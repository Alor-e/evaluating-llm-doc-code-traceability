{
  "dataset": "crawl4ai",
  "run_id": 3,
  "timestamp": "2025-02-12T14:28:15.214652",
  "results": [
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine different selection methods:\n\n```python\nasync def extract_article_content(url: str):\n    # Define structured extraction\n    article_schema = {\n        \"name\": \"Article\",\n        \"baseSelector\": \"article.main\",\n        \"fields\": [\n            {\"name\": \"title\", \"selector\": \"h1\", \"type\": \"text\"},\n            {\"name\": \"content\", \"selector\": \".content\", \"type\": \"text\"}\n        ]\n    }\n    \n    # Define LLM extraction\n    class ArticleAnalysis(BaseModel):\n        key_points: List[str]\n        sentiment: str\n        category: str\n\n    async with AsyncWebCrawler() as crawler:\n        # Get structured content\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(article_schema),\n            word_count_threshold=10,\n            excluded_tags=['nav', 'footer'],\n            exclude_external_links=True\n        )\n        \n        # Get semantic analysis\n        analysis_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=ArticleAnalysis.schema(),\n                instruction=\"Analyze the article content\"\n            )\n        )\n        \n        # Combine results\n        return {\n            \"article\": json.loads(pattern_result.extracted_content),\n            \"analysis\": json.loads(analysis_result.extracted_content),\n            \"media\": pattern_result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "usage",
      "relationship_explanation": "The documentation snippet uses AsyncWebCrawler by instantiating it within an async context manager (async with AsyncWebCrawler() as crawler:), demonstrating its direct application for web crawling.",
      "predicted_trace_chain": "docs/md_v2/basic/content-selection.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain starts with the document 'docs/md_v2/basic/content-selection.md' and directly leads to AsyncWebCrawler, as it is explicitly instantiated in the example.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the core functionality shown in the documentation's comprehensive example by providing async context management and extraction methods that support both structured (JsonCssExtractionStrategy) and LLM-based content extraction through its arun method.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine different selection methods:\n\n```python\nasync def extract_article_content(url: str):\n    # Define structured extraction\n    article_schema = {\n        \"name\": \"Article\",\n        \"baseSelector\": \"article.main\",\n        \"fields\": [\n            {\"name\": \"title\", \"selector\": \"h1\", \"type\": \"text\"},\n            {\"name\": \"content\", \"selector\": \".content\", \"type\": \"text\"}\n        ]\n    }\n    \n    # Define LLM extraction\n    class ArticleAnalysis(BaseModel):\n        key_points: List[str]\n        sentiment: str\n        category: str\n\n    async with AsyncWebCrawler() as crawler:\n        # Get structured content\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(article_schema),\n            word_count_threshold=10,\n            excluded_tags=['nav', 'footer'],\n            exclude_external_links=True\n        )\n        \n        # Get semantic analysis\n        analysis_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=ArticleAnalysis.schema(),\n                instruction=\"Analyze the article content\"\n            )\n        )\n        \n        # Combine results\n        return {\n            \"article\": json.loads(pattern_result.extracted_content),\n            \"analysis\": json.loads(analysis_result.extracted_content),\n            \"media\": pattern_result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method usage",
      "relationship_explanation": "The snippet calls the 'arun' method on the AsyncWebCrawler instance twice to retrieve structured and semantic analysis content, making its invocation explicit.",
      "predicted_trace_chain": "docs/md_v2/basic/content-selection.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the document, the chain moves to AsyncWebCrawler which is then used to call its 'arun' method for content extraction.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method executes the core crawling functionality shown in the documentation example by accepting extraction strategies, processing URLs, and returning structured results that can be used for both pattern-based and LLM-based content extraction.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine different selection methods:\n\n```python\nasync def extract_article_content(url: str):\n    # Define structured extraction\n    article_schema = {\n        \"name\": \"Article\",\n        \"baseSelector\": \"article.main\",\n        \"fields\": [\n            {\"name\": \"title\", \"selector\": \"h1\", \"type\": \"text\"},\n            {\"name\": \"content\", \"selector\": \".content\", \"type\": \"text\"}\n        ]\n    }\n    \n    # Define LLM extraction\n    class ArticleAnalysis(BaseModel):\n        key_points: List[str]\n        sentiment: str\n        category: str\n\n    async with AsyncWebCrawler() as crawler:\n        # Get structured content\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(article_schema),\n            word_count_threshold=10,\n            excluded_tags=['nav', 'footer'],\n            exclude_external_links=True\n        )\n        \n        # Get semantic analysis\n        analysis_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=ArticleAnalysis.schema(),\n                instruction=\"Analyze the article content\"\n            )\n        )\n        \n        # Combine results\n        return {\n            \"article\": json.loads(pattern_result.extracted_content),\n            \"analysis\": json.loads(analysis_result.extracted_content),\n            \"media\": pattern_result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "object instantiation",
      "relationship_explanation": "The example creates an instance of JsonCssExtractionStrategy by passing an 'article_schema' dictionary. This indicates its direct use as the extraction strategy for structured content.",
      "predicted_trace_chain": "docs/md_v2/basic/content-selection.md -> AsyncWebCrawler.arun() -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain indicates that the document calls AsyncWebCrawler.arun() with JsonCssExtractionStrategy as a parameter, linking the documentation example to this extraction strategy.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class implements the structured extraction pattern shown in the documentation's comprehensive example by using CSS selectors to extract data according to a predefined schema structure with baseSelector and fields properties.",
      "ground_truth_trace_chain": "content-selection.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine different selection methods:\n\n```python\nasync def extract_article_content(url: str):\n    # Define structured extraction\n    article_schema = {\n        \"name\": \"Article\",\n        \"baseSelector\": \"article.main\",\n        \"fields\": [\n            {\"name\": \"title\", \"selector\": \"h1\", \"type\": \"text\"},\n            {\"name\": \"content\", \"selector\": \".content\", \"type\": \"text\"}\n        ]\n    }\n    \n    # Define LLM extraction\n    class ArticleAnalysis(BaseModel):\n        key_points: List[str]\n        sentiment: str\n        category: str\n\n    async with AsyncWebCrawler() as crawler:\n        # Get structured content\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(article_schema),\n            word_count_threshold=10,\n            excluded_tags=['nav', 'footer'],\n            exclude_external_links=True\n        )\n        \n        # Get semantic analysis\n        analysis_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=ArticleAnalysis.schema(),\n                instruction=\"Analyze the article content\"\n            )\n        )\n        \n        # Combine results\n        return {\n            \"article\": json.loads(pattern_result.extracted_content),\n            \"analysis\": json.loads(analysis_result.extracted_content),\n            \"media\": pattern_result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "object instantiation",
      "relationship_explanation": "In the snippet, an instance of LLMExtractionStrategy is explicitly constructed with parameters such as provider, schema, and instruction, to perform semantic analysis on the article content.",
      "predicted_trace_chain": "docs/md_v2/basic/content-selection.md -> AsyncWebCrawler.arun() -> LLMExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain shows that AsyncWebCrawler.arun() is invoked with LLMExtractionStrategy as part of its extraction strategy parameter, mapping the documentation\u2019s semantic extraction process.",
      "ground_truth_relationship": "The LLMExtractionStrategy class implements the semantic analysis functionality shown in the documentation example, specifically handling the ArticleAnalysis extraction with custom providers, schemas, and instructions as demonstrated in the crawler.arun() call.",
      "ground_truth_trace_chain": "content-selection.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine different selection methods:\n\n```python\nasync def extract_article_content(url: str):\n    # Define structured extraction\n    article_schema = {\n        \"name\": \"Article\",\n        \"baseSelector\": \"article.main\",\n        \"fields\": [\n            {\"name\": \"title\", \"selector\": \"h1\", \"type\": \"text\"},\n            {\"name\": \"content\", \"selector\": \".content\", \"type\": \"text\"}\n        ]\n    }\n    \n    # Define LLM extraction\n    class ArticleAnalysis(BaseModel):\n        key_points: List[str]\n        sentiment: str\n        category: str\n\n    async with AsyncWebCrawler() as crawler:\n        # Get structured content\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(article_schema),\n            word_count_threshold=10,\n            excluded_tags=['nav', 'footer'],\n            exclude_external_links=True\n        )\n        \n        # Get semantic analysis\n        analysis_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=ArticleAnalysis.schema(),\n                instruction=\"Analyze the article content\"\n            )\n        )\n        \n        # Combine results\n        return {\n            \"article\": json.loads(pattern_result.extracted_content),\n            \"analysis\": json.loads(analysis_result.extracted_content),\n            \"media\": pattern_result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "Both JsonCssExtractionStrategy and LLMExtractionStrategy extend the abstract base class ExtractionStrategy. Although not directly instantiated in the snippet, it is part of the underlying framework that supports the extraction functionalities used in the example.",
      "predicted_trace_chain": "docs/md_v2/basic/content-selection.md -> AsyncWebCrawler.arun() -> [JsonCssExtractionStrategy | LLMExtractionStrategy] -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain starts from the document and proceeds through the extraction strategies used in AsyncWebCrawler.arun(), which in turn inherit from ExtractionStrategy, highlighting the base class dependency.",
      "ground_truth_relationship": "The ExtractionStrategy abstract base class defines the core interface and parallel processing functionality that enables both the JsonCssExtractionStrategy and LLMExtractionStrategy implementations shown in the documentation example.",
      "ground_truth_trace_chain": "content-selection.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine different selection methods:\n\n```python\nasync def extract_article_content(url: str):\n    # Define structured extraction\n    article_schema = {\n        \"name\": \"Article\",\n        \"baseSelector\": \"article.main\",\n        \"fields\": [\n            {\"name\": \"title\", \"selector\": \"h1\", \"type\": \"text\"},\n            {\"name\": \"content\", \"selector\": \".content\", \"type\": \"text\"}\n        ]\n    }\n    \n    # Define LLM extraction\n    class ArticleAnalysis(BaseModel):\n        key_points: List[str]\n        sentiment: str\n        category: str\n\n    async with AsyncWebCrawler() as crawler:\n        # Get structured content\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(article_schema),\n            word_count_threshold=10,\n            excluded_tags=['nav', 'footer'],\n            exclude_external_links=True\n        )\n        \n        # Get semantic analysis\n        analysis_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=ArticleAnalysis.schema(),\n                instruction=\"Analyze the article content\"\n            )\n        )\n        \n        # Combine results\n        return {\n            \"article\": json.loads(pattern_result.extracted_content),\n            \"analysis\": json.loads(analysis_result.extracted_content),\n            \"media\": pattern_result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class serves as the structured output container for the extract_article_content function, storing both the pattern-based extraction results (extracted_content) and media assets referenced in the documentation example.",
      "ground_truth_trace_chain": "content-selection.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine different selection methods:\n\n```python\nasync def extract_article_content(url: str):\n    # Define structured extraction\n    article_schema = {\n        \"name\": \"Article\",\n        \"baseSelector\": \"article.main\",\n        \"fields\": [\n            {\"name\": \"title\", \"selector\": \"h1\", \"type\": \"text\"},\n            {\"name\": \"content\", \"selector\": \".content\", \"type\": \"text\"}\n        ]\n    }\n    \n    # Define LLM extraction\n    class ArticleAnalysis(BaseModel):\n        key_points: List[str]\n        sentiment: str\n        category: str\n\n    async with AsyncWebCrawler() as crawler:\n        # Get structured content\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(article_schema),\n            word_count_threshold=10,\n            excluded_tags=['nav', 'footer'],\n            exclude_external_links=True\n        )\n        \n        # Get semantic analysis\n        analysis_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=ArticleAnalysis.schema(),\n                instruction=\"Analyze the article content\"\n            )\n        )\n        \n        # Combine results\n        return {\n            \"article\": json.loads(pattern_result.extracted_content),\n            \"analysis\": json.loads(analysis_result.extracted_content),\n            \"media\": pattern_result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "CrawlResult.extracted_content",
      "ground_truth_relationship": "The CrawlResult.extracted_content field stores serialized JSON content from both pattern-based and LLM-based extraction strategies as demonstrated in the comprehensive example where it's accessed via pattern_result.extracted_content and analysis_result.extracted_content.",
      "ground_truth_trace_chain": "content-selection.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine different selection methods:\n\n```python\nasync def extract_article_content(url: str):\n    # Define structured extraction\n    article_schema = {\n        \"name\": \"Article\",\n        \"baseSelector\": \"article.main\",\n        \"fields\": [\n            {\"name\": \"title\", \"selector\": \"h1\", \"type\": \"text\"},\n            {\"name\": \"content\", \"selector\": \".content\", \"type\": \"text\"}\n        ]\n    }\n    \n    # Define LLM extraction\n    class ArticleAnalysis(BaseModel):\n        key_points: List[str]\n        sentiment: str\n        category: str\n\n    async with AsyncWebCrawler() as crawler:\n        # Get structured content\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(article_schema),\n            word_count_threshold=10,\n            excluded_tags=['nav', 'footer'],\n            exclude_external_links=True\n        )\n        \n        # Get semantic analysis\n        analysis_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=ArticleAnalysis.schema(),\n                instruction=\"Analyze the article content\"\n            )\n        )\n        \n        # Combine results\n        return {\n            \"article\": json.loads(pattern_result.extracted_content),\n            \"analysis\": json.loads(analysis_result.extracted_content),\n            \"media\": pattern_result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the asynchronous web crawling functionality that enables the comprehensive example's pattern-based and LLM-based content extraction by providing browser automation capabilities and page manipulation methods.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine different selection methods:\n\n```python\nasync def extract_article_content(url: str):\n    # Define structured extraction\n    article_schema = {\n        \"name\": \"Article\",\n        \"baseSelector\": \"article.main\",\n        \"fields\": [\n            {\"name\": \"title\", \"selector\": \"h1\", \"type\": \"text\"},\n            {\"name\": \"content\", \"selector\": \".content\", \"type\": \"text\"}\n        ]\n    }\n    \n    # Define LLM extraction\n    class ArticleAnalysis(BaseModel):\n        key_points: List[str]\n        sentiment: str\n        category: str\n\n    async with AsyncWebCrawler() as crawler:\n        # Get structured content\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(article_schema),\n            word_count_threshold=10,\n            excluded_tags=['nav', 'footer'],\n            exclude_external_links=True\n        )\n        \n        # Get semantic analysis\n        analysis_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=ArticleAnalysis.schema(),\n                instruction=\"Analyze the article content\"\n            )\n        )\n        \n        # Combine results\n        return {\n            \"article\": json.loads(pattern_result.extracted_content),\n            \"analysis\": json.loads(analysis_result.extracted_content),\n            \"media\": pattern_result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "CrawlResult.media",
      "ground_truth_relationship": "The CrawlResult.media property is used to store media assets collected during crawling, which is shown being returned as part of the combined results in the comprehensive example's extract_article_content function.",
      "ground_truth_trace_chain": "content-selection.md -> CrawlResult.media",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine different selection methods:\n\n```python\nasync def extract_article_content(url: str):\n    # Define structured extraction\n    article_schema = {\n        \"name\": \"Article\",\n        \"baseSelector\": \"article.main\",\n        \"fields\": [\n            {\"name\": \"title\", \"selector\": \"h1\", \"type\": \"text\"},\n            {\"name\": \"content\", \"selector\": \".content\", \"type\": \"text\"}\n        ]\n    }\n    \n    # Define LLM extraction\n    class ArticleAnalysis(BaseModel):\n        key_points: List[str]\n        sentiment: str\n        category: str\n\n    async with AsyncWebCrawler() as crawler:\n        # Get structured content\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(article_schema),\n            word_count_threshold=10,\n            excluded_tags=['nav', 'footer'],\n            exclude_external_links=True\n        )\n        \n        # Get semantic analysis\n        analysis_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=ArticleAnalysis.schema(),\n                instruction=\"Analyze the article content\"\n            )\n        )\n        \n        # Combine results\n        return {\n            \"article\": json.loads(pattern_result.extracted_content),\n            \"analysis\": json.loads(analysis_result.extracted_content),\n            \"media\": pattern_result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the core methods that enable the comprehensive example's combined extraction functionality, including crawl() and crawl_many() which are used by the extract_article_content() function to perform both structured and LLM-based extractions.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Identity Management\n\nControl how your crawler appears to websites:\n\n```python\n# Custom user agent\nasync with AsyncWebCrawler(\n    user_agent=\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Custom headers\nheaders = {\n    \"Accept-Language\": \"en-US,en;q=0.9\",\n    \"Cache-Control\": \"no-cache\"\n}\nasync with AsyncWebCrawler(headers=headers) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation and usage",
      "relationship_explanation": "The documentation snippet directly instantiates AsyncWebCrawler with custom parameters (user_agent and headers) to control how the crawler identifies itself to websites. This shows explicit usage of the AsyncWebCrawler class for identity management.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The snippet, from the document 'docs/md_v2/basic/browser-config.md', explicitly creates an AsyncWebCrawler instance, making this the starting point of the trace.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements identity management through its arun method which accepts user_agent and **kwargs parameters that allow customization of crawler headers and user agent strings as demonstrated in the documentation examples.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Identity Management\n\nControl how your crawler appears to websites:\n\n```python\n# Custom user agent\nasync with AsyncWebCrawler(\n    user_agent=\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Custom headers\nheaders = {\n    \"Accept-Language\": \"en-US,en;q=0.9\",\n    \"Cache-Control\": \"no-cache\"\n}\nasync with AsyncWebCrawler(headers=headers) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The snippet calls the arun() method on the AsyncWebCrawler instance (e.g., 'result = await crawler.arun(url=\"https://example.com\")'), demonstrating the use of this method to perform crawling after configuring the crawler's identity.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain begins with the documentation file and then moves to AsyncWebCrawler, which is used to invoke the arun() method as shown in the usage example.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method implements custom identity management by accepting user_agent and **kwargs parameters which allow modification of crawler headers as shown in the documentation examples.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Identity Management\n\nControl how your crawler appears to websites:\n\n```python\n# Custom user agent\nasync with AsyncWebCrawler(\n    user_agent=\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Custom headers\nheaders = {\n    \"Accept-Language\": \"en-US,en;q=0.9\",\n    \"Cache-Control\": \"no-cache\"\n}\nasync with AsyncWebCrawler(headers=headers) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "dependency and implementation",
      "relationship_explanation": "Although not directly mentioned in the snippet, AsyncWebCrawler defaults to instantiating AsyncPlaywrightCrawlerStrategy when no alternate strategy is provided. This internal dependency handles the actual crawling operations and applies custom identity parameters (like user_agent and headers), thus supporting the documented identity management functionality.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "Starting from the documentation file, AsyncWebCrawler is instantiated in the snippet. Internally, it creates an AsyncPlaywrightCrawlerStrategy instance to perform crawling, which forms the implicit link in the traceability chain.",
      "ground_truth_relationship": "The code implements identity management by allowing custom user agents and headers to be passed through the AsyncPlaywrightCrawlerStrategy class constructor and applied to browser contexts using set_custom_headers() and update_user_agent() methods.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Identity Management\n\nControl how your crawler appears to websites:\n\n```python\n# Custom user agent\nasync with AsyncWebCrawler(\n    user_agent=\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Custom headers\nheaders = {\n    \"Accept-Language\": \"en-US,en;q=0.9\",\n    \"Cache-Control\": \"no-cache\"\n}\nasync with AsyncWebCrawler(headers=headers) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores crawled webpage data including response_headers and metadata fields that directly receive the custom identity information (user agents and headers) described in the documentation.",
      "ground_truth_trace_chain": "browser-config.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Identity Management\n\nControl how your crawler appears to websites:\n\n```python\n# Custom user agent\nasync with AsyncWebCrawler(\n    user_agent=\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Custom headers\nheaders = {\n    \"Accept-Language\": \"en-US,en;q=0.9\",\n    \"Cache-Control\": \"no-cache\"\n}\nasync with AsyncWebCrawler(headers=headers) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the interface for implementing crawler identity management through methods like update_user_agent() which enables the documented functionality of customizing how the crawler appears to websites.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Features\n\n### Custom Clustering\n```python\nstrategy = CosineStrategy(\n    linkage_method='complete',  # Alternative clustering method\n    max_dist=0.4,              # Larger clusters\n    model_name='sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2'  # Multilingual support\n)\n```\n\n### Content Filtering Pipeline\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"pricing plans features\",\n    word_count_threshold=15,\n    sim_threshold=0.5,\n    top_k=3\n)\n\nasync def extract_pricing_features(url: str):\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(\n            url=url,\n            extraction_strategy=strategy\n        )\n        \n        if result.success:\n            content = json.loads(result.extracted_content)\n            return {\n                'pricing_features': content,\n                'clusters': len(content),\n                'similarity_scores': [item['score'] for item in content]\n            }\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 7,
      "artifact_title": "CosineStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation/configuration",
      "relationship_explanation": "The documentation snippet explicitly instantiates a CosineStrategy with parameters (linkage_method, max_dist, model_name) to configure custom clustering functionality.",
      "predicted_trace_chain": "cosine.md -> CosineStrategy",
      "predicted_trace_chain_explanation": "The snippet from docs/md_v2/extraction/cosine.md directly demonstrates the creation of a CosineStrategy instance, forming the starting point of the trace.",
      "ground_truth_relationship": "The CosineStrategy class implements advanced text clustering by combining semantic filtering, word count thresholds, and hierarchical clustering using cosine similarity, exactly matching the documented custom clustering and content filtering pipeline features.",
      "ground_truth_trace_chain": "cosine.md -> ExtractionStrategy -> CosineStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Features\n\n### Custom Clustering\n```python\nstrategy = CosineStrategy(\n    linkage_method='complete',  # Alternative clustering method\n    max_dist=0.4,              # Larger clusters\n    model_name='sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2'  # Multilingual support\n)\n```\n\n### Content Filtering Pipeline\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"pricing plans features\",\n    word_count_threshold=15,\n    sim_threshold=0.5,\n    top_k=3\n)\n\nasync def extract_pricing_features(url: str):\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(\n            url=url,\n            extraction_strategy=strategy\n        )\n        \n        if result.success:\n            content = json.loads(result.extracted_content)\n            return {\n                'pricing_features': content,\n                'clusters': len(content),\n                'similarity_scores': [item['score'] for item in content]\n            }\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "CosineStrategy is implemented as a subclass of ExtractionStrategy. Although not directly mentioned in the snippet, this inheritance is inherent in its design and is essential for its extraction functionality.",
      "predicted_trace_chain": "cosine.md -> CosineStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "Starting from the documentation file, the trace passes through CosineStrategy and reaches its base class ExtractionStrategy, indicating the underlying extension mechanism.",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the core infrastructure for implementing specialized content extraction strategies like the CosineStrategy shown in the documentation, enabling features such as custom clustering and content filtering through its abstract extract() method.",
      "ground_truth_trace_chain": "cosine.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Features\n\n### Custom Clustering\n```python\nstrategy = CosineStrategy(\n    linkage_method='complete',  # Alternative clustering method\n    max_dist=0.4,              # Larger clusters\n    model_name='sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2'  # Multilingual support\n)\n```\n\n### Content Filtering Pipeline\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"pricing plans features\",\n    word_count_threshold=15,\n    sim_threshold=0.5,\n    top_k=3\n)\n\nasync def extract_pricing_features(url: str):\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(\n            url=url,\n            extraction_strategy=strategy\n        )\n        \n        if result.success:\n            content = json.loads(result.extracted_content)\n            return {\n                'pricing_features': content,\n                'clusters': len(content),\n                'similarity_scores': [item['score'] for item in content]\n            }\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation and context management",
      "relationship_explanation": "The snippet uses 'async with AsyncWebCrawler() as crawler:' which clearly demonstrates the instantiation and use of the AsyncWebCrawler class for initiating a crawling operation.",
      "predicted_trace_chain": "cosine.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain starts at the documentation file and directly leads to AsyncWebCrawler, aligning with its explicit usage in the provided code example.",
      "ground_truth_relationship": "The AsyncWebCrawler class provides the core functionality for the documented content filtering pipeline by implementing an asynchronous web crawling mechanism with customizable extraction strategies, caching, and support for clustering through its arun method.",
      "ground_truth_trace_chain": "cosine.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Features\n\n### Custom Clustering\n```python\nstrategy = CosineStrategy(\n    linkage_method='complete',  # Alternative clustering method\n    max_dist=0.4,              # Larger clusters\n    model_name='sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2'  # Multilingual support\n)\n```\n\n### Content Filtering Pipeline\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"pricing plans features\",\n    word_count_threshold=15,\n    sim_threshold=0.5,\n    top_k=3\n)\n\nasync def extract_pricing_features(url: str):\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(\n            url=url,\n            extraction_strategy=strategy\n        )\n        \n        if result.success:\n            content = json.loads(result.extracted_content)\n            return {\n                'pricing_features': content,\n                'clusters': len(content),\n                'similarity_scores': [item['score'] for item in content]\n            }\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The code snippet explicitly calls the 'arun' method of AsyncWebCrawler (i.e., crawler.arun(...)) to perform crawling and extraction based on the provided strategy.",
      "predicted_trace_chain": "cosine.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The documentation file leads to the instantiation of AsyncWebCrawler and then to the invocation of its arun() method, which is necessary to execute the web crawling process.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method provides the asynchronous execution engine that processes both custom clustering configurations and content filtering parameters defined in the CosineStrategy documentation, handling the extraction pipeline while managing caching, HTML processing, and error handling.",
      "ground_truth_trace_chain": "cosine.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Features\n\n### Custom Clustering\n```python\nstrategy = CosineStrategy(\n    linkage_method='complete',  # Alternative clustering method\n    max_dist=0.4,              # Larger clusters\n    model_name='sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2'  # Multilingual support\n)\n```\n\n### Content Filtering Pipeline\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"pricing plans features\",\n    word_count_threshold=15,\n    sim_threshold=0.5,\n    top_k=3\n)\n\nasync def extract_pricing_features(url: str):\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(\n            url=url,\n            extraction_strategy=strategy\n        )\n        \n        if result.success:\n            content = json.loads(result.extracted_content)\n            return {\n                'pricing_features': content,\n                'clusters': len(content),\n                'similarity_scores': [item['score'] for item in content]\n            }\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 11,
      "artifact_title": "CrawlResult.extracted_content",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "After crawling, the snippet accesses 'result.extracted_content' to retrieve the processed clustering output, demonstrating the use of this public attribute from the CrawlResult object.",
      "predicted_trace_chain": "cosine.md -> AsyncWebCrawler -> AsyncWebCrawler.arun() -> CrawlResult.extracted_content",
      "predicted_trace_chain_explanation": "The trace begins from the documentation file, continues through the AsyncWebCrawler instantiation and its arun() method call, and finally reaches the extracted_content attribute within the returned CrawlResult, showing the full pathway of the extraction pipeline.",
      "ground_truth_relationship": "The CrawlResult.extracted_content field stores the JSON-serialized clustering and filtering results that contain pricing features, similarity scores, and cluster information from the web crawler's execution.",
      "ground_truth_trace_chain": "cosine.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Features\n\n### Custom Clustering\n```python\nstrategy = CosineStrategy(\n    linkage_method='complete',  # Alternative clustering method\n    max_dist=0.4,              # Larger clusters\n    model_name='sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2'  # Multilingual support\n)\n```\n\n### Content Filtering Pipeline\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"pricing plans features\",\n    word_count_threshold=15,\n    sim_threshold=0.5,\n    top_k=3\n)\n\nasync def extract_pricing_features(url: str):\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(\n            url=url,\n            extraction_strategy=strategy\n        )\n        \n        if result.success:\n            content = json.loads(result.extracted_content)\n            return {\n                'pricing_features': content,\n                'clusters': len(content),\n                'similarity_scores': [item['score'] for item in content]\n            }\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class serves as the data model that captures and stores the extraction results shown in the documentation examples, with its extracted_content field holding the clustered and filtered content returned by the CosineStrategy.",
      "ground_truth_trace_chain": "cosine.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Features\n\n### Custom Clustering\n```python\nstrategy = CosineStrategy(\n    linkage_method='complete',  # Alternative clustering method\n    max_dist=0.4,              # Larger clusters\n    model_name='sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2'  # Multilingual support\n)\n```\n\n### Content Filtering Pipeline\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"pricing plans features\",\n    word_count_threshold=15,\n    sim_threshold=0.5,\n    top_k=3\n)\n\nasync def extract_pricing_features(url: str):\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(\n            url=url,\n            extraction_strategy=strategy\n        )\n        \n        if result.success:\n            content = json.loads(result.extracted_content)\n            return {\n                'pricing_features': content,\n                'clusters': len(content),\n                'similarity_scores': [item['score'] for item in content]\n            }\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_title": "CrawlResult.success",
      "ground_truth_relationship": "The CrawlResult.success boolean property is used in the documentation's extraction function to validate whether pricing features were successfully extracted before processing the results.",
      "ground_truth_trace_chain": "cosine.md -> CrawlResult.success",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Features\n\n### Custom Clustering\n```python\nstrategy = CosineStrategy(\n    linkage_method='complete',  # Alternative clustering method\n    max_dist=0.4,              # Larger clusters\n    model_name='sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2'  # Multilingual support\n)\n```\n\n### Content Filtering Pipeline\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"pricing plans features\",\n    word_count_threshold=15,\n    sim_threshold=0.5,\n    top_k=3\n)\n\nasync def extract_pricing_features(url: str):\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(\n            url=url,\n            extraction_strategy=strategy\n        )\n        \n        if result.success:\n            content = json.loads(result.extracted_content)\n            return {\n                'pricing_features': content,\n                'clusters': len(content),\n                'similarity_scores': [item['score'] for item in content]\n            }\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the core interface methods that enable the advanced features shown in the documentation, such as custom clustering and content filtering through its abstract crawl methods.",
      "ground_truth_trace_chain": "cosine.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Features\n\n### Custom Clustering\n```python\nstrategy = CosineStrategy(\n    linkage_method='complete',  # Alternative clustering method\n    max_dist=0.4,              # Larger clusters\n    model_name='sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2'  # Multilingual support\n)\n```\n\n### Content Filtering Pipeline\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"pricing plans features\",\n    word_count_threshold=15,\n    sim_threshold=0.5,\n    top_k=3\n)\n\nasync def extract_pricing_features(url: str):\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(\n            url=url,\n            extraction_strategy=strategy\n        )\n        \n        if result.success:\n            content = json.loads(result.extracted_content)\n            return {\n                'pricing_features': content,\n                'clusters': len(content),\n                'similarity_scores': [item['score'] for item in content]\n            }\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class enables advanced web content extraction by implementing browser automation features that support the documented custom clustering and content filtering pipelines through its sophisticated crawling capabilities and JavaScript execution support.",
      "ground_truth_trace_chain": "cosine.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "Now, let's create a schema to extract this complex structure:\n\n```python\nschema = {\n    \"name\": \"E-commerce Product Catalog\",\n    \"baseSelector\": \"div.category\",\n    \"fields\": [\n        {\n            \"name\": \"category_name\",\n            \"selector\": \"h2.category-name\",\n            \"type\": \"text\"\n        },\n        {\n            \"name\": \"products\",\n            \"selector\": \"div.product\",\n            \"type\": \"nested_list\",\n            \"fields\": [\n                {\n                    \"name\": \"name\",\n                    \"selector\": \"h3.product-name\",\n                    \"type\": \"text\"\n                },\n                {\n                    \"name\": \"price\",\n                    \"selector\": \"p.product-price\",\n                    \"type\": \"text\"\n                },\n                {\n                    \"name\": \"details\",\n                    \"selector\": \"div.product-details\",\n                    \"type\": \"nested\",\n                    \"fields\": [\n                        {\n                            \"name\": \"brand\",\n                            \"selector\": \"span.brand\",\n                            \"type\": \"text\"\n                        },\n                        {\n                            \"name\": \"model\",\n                            \"selector\": \"span.model\",\n                            \"type\": \"text\"\n                        }\n                    ]\n                },\n                {\n                    \"name\": \"features\",\n                    \"selector\": \"ul.product-features li\",\n                    \"type\": \"list\",\n                    \"fields\": [\n                        {\n                            \"name\": \"feature\",\n                            \"type\": \"text\"\n                        }\n                    ]\n                },\n                {\n                    \"name\": \"reviews\",\n                    \"selector\": \"div.review\",\n                    \"type\": \"nested_list\",\n                    \"fields\": [\n                        {\n                            \"name\": \"reviewer\",\n                            \"selector\": \"span.reviewer\",\n                            \"type\": \"text\"\n                        },\n                        {\n                            \"name\": \"rating\",\n                            \"selector\": \"span.rating\",\n                            \"type\": \"text\"\n                        },\n                        {\n                            \"name\": \"comment\",\n                            \"selector\": \"p.review-text\",\n                            \"type\": \"text\"\n                        }\n                    ]\n                },\n                {\n                    \"name\": \"related_products\",\n                    \"selector\": \"ul.related-products li\",\n                    \"type\": \"list\",\n                    \"fields\": [\n                        {\n                            \"name\": \"name\",\n                            \"selector\": \"span.related-name\",\n                            \"type\": \"text\"\n                        },\n                        {\n                            \"name\": \"price\",\n                            \"selector\": \"span.related-price\",\n                            \"type\": \"text\"\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}\n```\n\nThis schema demonstrates several advanced features:\n\n1. **Nested Objects**: The `details` field is a nested object within each product.\n2. **Simple Lists**: The `features` field is a simple list of text items.\n3. **Nested Lists**: The `products` field is a nested list, where each item is a complex object.\n4. **Lists of Objects**: The `reviews` and `related_products` fields are lists of objects.",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "implements schema-based extraction",
      "relationship_explanation": "The documentation snippet provides a complex schema with keys like 'baseSelector' and 'fields' that mirrors the input expected by JsonCssExtractionStrategy. Although the class name is not mentioned explicitly in the snippet, the schema structure demonstrated is designed to be used by this strategy to extract nested objects and lists.",
      "predicted_trace_chain": "css-advanced.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The documentation from 'css-advanced.md' outlines an advanced schema format, which aligns with the extraction interface declared in ExtractionStrategy and concretely implemented by JsonCssExtractionStrategy.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class implements the schema-based extraction by recursively parsing HTML elements using BeautifulSoup's select() method to match the CSS selectors defined in the documented schema structure.",
      "ground_truth_trace_chain": "css-advanced.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "Now, let's create a schema to extract this complex structure:\n\n```python\nschema = {\n    \"name\": \"E-commerce Product Catalog\",\n    \"baseSelector\": \"div.category\",\n    \"fields\": [\n        {\n            \"name\": \"category_name\",\n            \"selector\": \"h2.category-name\",\n            \"type\": \"text\"\n        },\n        {\n            \"name\": \"products\",\n            \"selector\": \"div.product\",\n            \"type\": \"nested_list\",\n            \"fields\": [\n                {\n                    \"name\": \"name\",\n                    \"selector\": \"h3.product-name\",\n                    \"type\": \"text\"\n                },\n                {\n                    \"name\": \"price\",\n                    \"selector\": \"p.product-price\",\n                    \"type\": \"text\"\n                },\n                {\n                    \"name\": \"details\",\n                    \"selector\": \"div.product-details\",\n                    \"type\": \"nested\",\n                    \"fields\": [\n                        {\n                            \"name\": \"brand\",\n                            \"selector\": \"span.brand\",\n                            \"type\": \"text\"\n                        },\n                        {\n                            \"name\": \"model\",\n                            \"selector\": \"span.model\",\n                            \"type\": \"text\"\n                        }\n                    ]\n                },\n                {\n                    \"name\": \"features\",\n                    \"selector\": \"ul.product-features li\",\n                    \"type\": \"list\",\n                    \"fields\": [\n                        {\n                            \"name\": \"feature\",\n                            \"type\": \"text\"\n                        }\n                    ]\n                },\n                {\n                    \"name\": \"reviews\",\n                    \"selector\": \"div.review\",\n                    \"type\": \"nested_list\",\n                    \"fields\": [\n                        {\n                            \"name\": \"reviewer\",\n                            \"selector\": \"span.reviewer\",\n                            \"type\": \"text\"\n                        },\n                        {\n                            \"name\": \"rating\",\n                            \"selector\": \"span.rating\",\n                            \"type\": \"text\"\n                        },\n                        {\n                            \"name\": \"comment\",\n                            \"selector\": \"p.review-text\",\n                            \"type\": \"text\"\n                        }\n                    ]\n                },\n                {\n                    \"name\": \"related_products\",\n                    \"selector\": \"ul.related-products li\",\n                    \"type\": \"list\",\n                    \"fields\": [\n                        {\n                            \"name\": \"name\",\n                            \"selector\": \"span.related-name\",\n                            \"type\": \"text\"\n                        },\n                        {\n                            \"name\": \"price\",\n                            \"selector\": \"span.related-price\",\n                            \"type\": \"text\"\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}\n```\n\nThis schema demonstrates several advanced features:\n\n1. **Nested Objects**: The `details` field is a nested object within each product.\n2. **Simple Lists**: The `features` field is a simple list of text items.\n3. **Nested Lists**: The `products` field is a nested list, where each item is a complex object.\n4. **Lists of Objects**: The `reviews` and `related_products` fields are lists of objects.",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "abstract base class for extraction strategies",
      "relationship_explanation": "ExtractionStrategy defines the abstract interface for all extraction methods. The provided schema example is intended for use with extraction strategies that implement this interface, thereby indirectly linking the schema design to ExtractionStrategy.",
      "predicted_trace_chain": "css-advanced.md -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The advanced extraction schema detailed in the documentation is based on the contract established by ExtractionStrategy, making this base class an essential component in the traceability pathway.",
      "ground_truth_relationship": "The ExtractionStrategy class provides the core functionality for implementing the schema-based extraction pattern shown in the documentation by defining abstract methods that process HTML content into structured data following the nested object and list patterns defined in the schema.",
      "ground_truth_trace_chain": "css-advanced.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Advanced Usage of JsonCssExtractionStrategy\n\nWhile the basic usage of JsonCssExtractionStrategy is powerful for simple structures, its true potential shines when dealing with complex, nested HTML structures. This section will explore advanced usage scenarios, demonstrating how to extract nested objects, lists, and nested lists.",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "implements",
      "relationship_explanation": "The documentation snippet explicitly mentions 'JsonCssExtractionStrategy' in its title and discussion. It highlights advanced usage scenarios for this strategy to handle complex nested HTML structures, directly linking the documentation to this artifact.",
      "predicted_trace_chain": "css-advanced.md -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The documentation (located in 'css-advanced.md') explicitly refers to JsonCssExtractionStrategy, making it a direct target in the traceability chain.",
      "ground_truth_relationship": "The code implements JsonCssExtractionStrategy class that recursively processes HTML data using BeautifulSoup and schema-based selectors, enabling the advanced nested extraction capabilities described in the documentation.",
      "ground_truth_trace_chain": "css-advanced.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Advanced Usage of JsonCssExtractionStrategy\n\nWhile the basic usage of JsonCssExtractionStrategy is powerful for simple structures, its true potential shines when dealing with complex, nested HTML structures. This section will explore advanced usage scenarios, demonstrating how to extract nested objects, lists, and nested lists.",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "extends",
      "relationship_explanation": "JsonCssExtractionStrategy is a subclass of ExtractionStrategy. Although the base class is not mentioned explicitly in the documentation snippet, its role is inherent in the advanced functionality of JsonCssExtractionStrategy.",
      "predicted_trace_chain": "css-advanced.md -> JsonCssExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "Starting from the documentation in 'css-advanced.md', the trace flows to JsonCssExtractionStrategy which, by inheritance, extends ExtractionStrategy, forming an implicit chain.",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the foundational architecture for implementing the JsonCssExtractionStrategy mentioned in the documentation by defining abstract methods and parallel processing capabilities that enable extraction of complex nested structures.",
      "ground_truth_trace_chain": "css-advanced.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Use Cases\n\n### 1. Article Content Extraction\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"main article content\",\n    word_count_threshold=100,  # Longer blocks for articles\n    top_k=1                   # Usually want single main content\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/blog/post\",\n    extraction_strategy=strategy\n)\n```\n\n### 2. Product Review Analysis\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"customer reviews and ratings\",\n    word_count_threshold=20,   # Reviews can be shorter\n    top_k=10,                 # Get multiple reviews\n    sim_threshold=0.4         # Allow variety in review content\n)\n```\n\n### 3. Technical Documentation\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"technical specifications documentation\",\n    word_count_threshold=30,\n    sim_threshold=0.6,        # Stricter matching for technical content\n    max_dist=0.3             # Allow related technical sections\n)\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 7,
      "artifact_title": "CosineStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "class instantiation and usage",
      "relationship_explanation": "The documentation snippet explicitly instantiates CosineStrategy with parameters (e.g., semantic_filter, word_count_threshold, top_k, sim_threshold, max_dist) to handle different extraction use cases. This directly demonstrates the creation and configuration of the CosineStrategy object.",
      "predicted_trace_chain": "docs/md_v2/extraction/cosine.md -> CosineStrategy",
      "predicted_trace_chain_explanation": "The use case documentation found in docs/md_v2/extraction/cosine.md directly creates an instance of CosineStrategy, establishing an explicit trace from the documentation to this artifact.",
      "ground_truth_relationship": "The CosineStrategy class implements configurable text extraction through cosine similarity matching, where different use cases (article content, product reviews, technical documentation) are achieved by adjusting the semantic_filter, word_count_threshold, top_k, and sim_threshold parameters as shown in the documentation examples.",
      "ground_truth_trace_chain": "cosine.md -> ExtractionStrategy -> CosineStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Use Cases\n\n### 1. Article Content Extraction\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"main article content\",\n    word_count_threshold=100,  # Longer blocks for articles\n    top_k=1                   # Usually want single main content\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/blog/post\",\n    extraction_strategy=strategy\n)\n```\n\n### 2. Product Review Analysis\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"customer reviews and ratings\",\n    word_count_threshold=20,   # Reviews can be shorter\n    top_k=10,                 # Get multiple reviews\n    sim_threshold=0.4         # Allow variety in review content\n)\n```\n\n### 3. Technical Documentation\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"technical specifications documentation\",\n    word_count_threshold=30,\n    sim_threshold=0.6,        # Stricter matching for technical content\n    max_dist=0.3             # Allow related technical sections\n)\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "implicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "In the example, the result is obtained by calling 'crawler.arun(...)' with the extraction_strategy parameter set to the instantiated CosineStrategy. This implicitly refers to AsyncWebCrawler.arun(), which handles the crawling and extraction process where the extraction strategy is applied.",
      "predicted_trace_chain": "docs/md_v2/extraction/cosine.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The documentation demonstrates the use of a crawler's arun method to process the extraction strategy; hence, the chain starts at the documentation and leads to the AsyncWebCrawler.arun() method responsible for executing the extraction workflow.",
      "ground_truth_relationship": "The arun() method implements the documented use cases by accepting flexible extraction_strategy parameters that control content filtering, word count thresholds, and similarity settings as shown in the three example configurations.",
      "ground_truth_trace_chain": "cosine.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Use Cases\n\n### 1. Article Content Extraction\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"main article content\",\n    word_count_threshold=100,  # Longer blocks for articles\n    top_k=1                   # Usually want single main content\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/blog/post\",\n    extraction_strategy=strategy\n)\n```\n\n### 2. Product Review Analysis\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"customer reviews and ratings\",\n    word_count_threshold=20,   # Reviews can be shorter\n    top_k=10,                 # Get multiple reviews\n    sim_threshold=0.4         # Allow variety in review content\n)\n```\n\n### 3. Technical Documentation\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"technical specifications documentation\",\n    word_count_threshold=30,\n    sim_threshold=0.6,        # Stricter matching for technical content\n    max_dist=0.3             # Allow related technical sections\n)\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance (base class)",
      "relationship_explanation": "CosineStrategy extends ExtractionStrategy, meaning that the abstraction defined by ExtractionStrategy underpins the extraction functionality. Although ExtractionStrategy is not directly instantiated, its role as the base class is essential for understanding the design and use of CosineStrategy.",
      "predicted_trace_chain": "docs/md_v2/extraction/cosine.md -> CosineStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain starts with the documentation that instantiates CosineStrategy, which in turn is a subclass of ExtractionStrategy. This explains that the extraction process relies on the contract and abstraction provided by ExtractionStrategy.",
      "ground_truth_relationship": "The ExtractionStrategy abstract base class provides the foundational structure for implementing the various content extraction strategies shown in the documentation's use cases, including article content, product reviews, and technical documentation extraction through its abstract extract() method and parallel processing run() method.",
      "ground_truth_trace_chain": "cosine.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Use Cases\n\n### 1. Article Content Extraction\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"main article content\",\n    word_count_threshold=100,  # Longer blocks for articles\n    top_k=1                   # Usually want single main content\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/blog/post\",\n    extraction_strategy=strategy\n)\n```\n\n### 2. Product Review Analysis\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"customer reviews and ratings\",\n    word_count_threshold=20,   # Reviews can be shorter\n    top_k=10,                 # Get multiple reviews\n    sim_threshold=0.4         # Allow variety in review content\n)\n```\n\n### 3. Technical Documentation\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"technical specifications documentation\",\n    word_count_threshold=30,\n    sim_threshold=0.6,        # Stricter matching for technical content\n    max_dist=0.3             # Allow related technical sections\n)\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class serves as the data structure for storing various extracted content types shown in the use cases, including the extracted_content field for article content, metadata for reviews, and technical documentation content along with associated metadata like URLs and success status.",
      "ground_truth_trace_chain": "cosine.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Use Cases\n\n### 1. Article Content Extraction\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"main article content\",\n    word_count_threshold=100,  # Longer blocks for articles\n    top_k=1                   # Usually want single main content\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/blog/post\",\n    extraction_strategy=strategy\n)\n```\n\n### 2. Product Review Analysis\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"customer reviews and ratings\",\n    word_count_threshold=20,   # Reviews can be shorter\n    top_k=10,                 # Get multiple reviews\n    sim_threshold=0.4         # Allow variety in review content\n)\n```\n\n### 3. Technical Documentation\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"technical specifications documentation\",\n    word_count_threshold=30,\n    sim_threshold=0.6,        # Stricter matching for technical content\n    max_dist=0.3             # Allow related technical sections\n)\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the core interface methods that the documented CosineStrategy implementations use to perform specialized content extraction tasks like article crawling, review analysis, and technical documentation parsing.",
      "ground_truth_trace_chain": "cosine.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Use Cases\n\n### 1. Article Content Extraction\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"main article content\",\n    word_count_threshold=100,  # Longer blocks for articles\n    top_k=1                   # Usually want single main content\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/blog/post\",\n    extraction_strategy=strategy\n)\n```\n\n### 2. Product Review Analysis\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"customer reviews and ratings\",\n    word_count_threshold=20,   # Reviews can be shorter\n    top_k=10,                 # Get multiple reviews\n    sim_threshold=0.4         # Allow variety in review content\n)\n```\n\n### 3. Technical Documentation\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"technical specifications documentation\",\n    word_count_threshold=30,\n    sim_threshold=0.6,        # Stricter matching for technical content\n    max_dist=0.3             # Allow related technical sections\n)\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the crawling functionality needed to support the three documented use cases (article extraction, product review analysis, and technical documentation) by providing configurable browser automation with customizable waiting conditions, content processing, and error handling.",
      "ground_truth_trace_chain": "cosine.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Use Cases\n\n### 1. Article Content Extraction\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"main article content\",\n    word_count_threshold=100,  # Longer blocks for articles\n    top_k=1                   # Usually want single main content\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/blog/post\",\n    extraction_strategy=strategy\n)\n```\n\n### 2. Product Review Analysis\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"customer reviews and ratings\",\n    word_count_threshold=20,   # Reviews can be shorter\n    top_k=10,                 # Get multiple reviews\n    sim_threshold=0.4         # Allow variety in review content\n)\n```\n\n### 3. Technical Documentation\n```python\nstrategy = CosineStrategy(\n    semantic_filter=\"technical specifications documentation\",\n    word_count_threshold=30,\n    sim_threshold=0.6,        # Stricter matching for technical content\n    max_dist=0.3             # Allow related technical sections\n)\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the documented use cases through its arun() method, which accepts an extraction_strategy parameter that can be configured with different CosineStrategy settings for article content, product reviews, or technical documentation extraction as shown in the examples.",
      "ground_truth_trace_chain": "cosine.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Content Filters\n\nControl what content is included:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    word_count_threshold=10,        # Minimum words per block\n    exclude_external_links=True,    # Remove external links\n    exclude_external_images=True,   # Remove external images\n    excluded_tags=['form', 'nav']   # Remove specific HTML tags\n)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The documentation snippet clearly shows a call to 'crawler.arun(...)' with parameters such as 'word_count_threshold', 'exclude_external_links', 'exclude_external_images', and 'excluded_tags'. This directly demonstrates usage of the 'AsyncWebCrawler.arun()' method, making the trace explicit.",
      "predicted_trace_chain": "output-formats.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the document 'output-formats.md' (extracted from the location provided), the chain immediately leads to the 'AsyncWebCrawler.arun()' method, which is explicitly invoked in the example. This method is responsible for initiating the web crawling process with content filtering options.",
      "ground_truth_relationship": "The arun() method implements content filtering by accepting parameters like word_count_threshold, extraction_strategy, and chunking_strategy which are used to process and filter the crawled HTML content according to user-specified criteria.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Content Filters\n\nControl what content is included:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    word_count_threshold=10,        # Minimum words per block\n    exclude_external_links=True,    # Remove external links\n    exclude_external_images=True,   # Remove external images\n    excluded_tags=['form', 'nav']   # Remove specific HTML tags\n)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores filtered content outputs from the crawler, with properties like cleaned_html and extracted_content that reflect the content filtering options documented in the configuration parameters.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Content Filters\n\nControl what content is included:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    word_count_threshold=10,        # Minimum words per block\n    exclude_external_links=True,    # Remove external links\n    exclude_external_images=True,   # Remove external images\n    excluded_tags=['form', 'nav']   # Remove specific HTML tags\n)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the interface that enables content filtering capabilities through its crawl method's kwargs parameter, which allows passing filtering options like word_count_threshold and excluded_tags as documented.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Content Filters\n\nControl what content is included:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    word_count_threshold=10,        # Minimum words per block\n    exclude_external_links=True,    # Remove external links\n    exclude_external_images=True,   # Remove external images\n    excluded_tags=['form', 'nav']   # Remove specific HTML tags\n)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements content filtering through its crawl method by accepting parameters like word_count_threshold and excluded_tags which are used to control what content is included in the final HTML output.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Content Filters\n\nControl what content is included:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    word_count_threshold=10,        # Minimum words per block\n    exclude_external_links=True,    # Remove external links\n    exclude_external_images=True,   # Remove external images\n    excluded_tags=['form', 'nav']   # Remove specific HTML tags\n)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The documentation describes filtering options that are directly implemented as parameters in the AsyncWebCrawler.arun() method, where word_count_threshold controls minimum block size and kwargs handles exclude_external_links, exclude_external_images, and excluded_tags options.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Technique 2: Integrated JavaScript Execution and Waiting Instead of using separate hooks, you can integrate the waiting logic directly into your JavaScript execution. This approach can be more concise and easier to manage for some scenarios. Here's an example: ```python async def integrated_js_and_wait_crawl(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/example/repo/commits/main\" session_id = \"integrated_session\" all_commits = [] js_next_page_and_wait = \"\"\" (async () => { const getCurrentCommit = () => { const commits = document.querySelectorAll('li.commit-item h4'); return commits.length > 0 ? commits[0].textContent.trim() : null; }; const initialCommit = getCurrentCommit(); const button = document.querySelector('a.pagination-next'); if (button) button.click(); while (true) { await new Promise(resolve => setTimeout(resolve, 100)); const newCommit = getCurrentCommit(); if (newCommit && newCommit !== initialCommit) { break; } } })(); \"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.commit-item\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.commit-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3): result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.commit-item\", extraction_strategy=extraction_strategy, js_code=js_next_page_and_wait if page > 0 else None, js_only=page > 0, bypass_cache=True ) commits = json.loads(result.extracted_content) all_commits.extend(commits) print(f\"Page {page + 1}: Found {len(commits)} commits\") await crawler.crawler_strategy.kill_session(session_id) print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\") asyncio.run(integrated_js_and_wait_crawl()) ``` This approach combines the JavaScript for clicking the \"next\" button and waiting for new content to load into a single script.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation and usage",
      "relationship_explanation": "The documentation explicitly instantiates and uses AsyncWebCrawler in the context manager (using 'async with AsyncWebCrawler(verbose=True) as crawler:'). This shows its direct usage to manage the crawling workflow.",
      "predicted_trace_chain": "docs/md_v2/advanced/session-management-advanced.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The trace chain starts from the documentation (located in docs/md_v2/advanced/session-management-advanced.md) where AsyncWebCrawler is directly instantiated.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the integrated JavaScript execution described in the documentation through its arun method, which accepts js_code and extracts content using the specified extraction_strategy while managing browser sessions.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Technique 2: Integrated JavaScript Execution and Waiting Instead of using separate hooks, you can integrate the waiting logic directly into your JavaScript execution. This approach can be more concise and easier to manage for some scenarios. Here's an example: ```python async def integrated_js_and_wait_crawl(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/example/repo/commits/main\" session_id = \"integrated_session\" all_commits = [] js_next_page_and_wait = \"\"\" (async () => { const getCurrentCommit = () => { const commits = document.querySelectorAll('li.commit-item h4'); return commits.length > 0 ? commits[0].textContent.trim() : null; }; const initialCommit = getCurrentCommit(); const button = document.querySelector('a.pagination-next'); if (button) button.click(); while (true) { await new Promise(resolve => setTimeout(resolve, 100)); const newCommit = getCurrentCommit(); if (newCommit && newCommit !== initialCommit) { break; } } })(); \"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.commit-item\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.commit-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3): result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.commit-item\", extraction_strategy=extraction_strategy, js_code=js_next_page_and_wait if page > 0 else None, js_only=page > 0, bypass_cache=True ) commits = json.loads(result.extracted_content) all_commits.extend(commits) print(f\"Page {page + 1}: Found {len(commits)} commits\") await crawler.crawler_strategy.kill_session(session_id) print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\") asyncio.run(integrated_js_and_wait_crawl()) ``` This approach combines the JavaScript for clicking the \"next\" button and waiting for new content to load into a single script.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "Within the provided code example, the 'arun()' method is called on the AsyncWebCrawler instance to perform the crawl with integrated JavaScript execution and waiting logic.",
      "predicted_trace_chain": "docs/md_v2/advanced/session-management-advanced.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the documentation, the AsyncWebCrawler instance is used to invoke its arun() method, which is essential for executing the crawl with integrated JS.",
      "ground_truth_relationship": "The arun() method implements the integrated JavaScript execution and waiting functionality by accepting js_code as a parameter through **kwargs which allows it to execute the documented JavaScript that handles pagination and content loading.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Technique 2: Integrated JavaScript Execution and Waiting Instead of using separate hooks, you can integrate the waiting logic directly into your JavaScript execution. This approach can be more concise and easier to manage for some scenarios. Here's an example: ```python async def integrated_js_and_wait_crawl(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/example/repo/commits/main\" session_id = \"integrated_session\" all_commits = [] js_next_page_and_wait = \"\"\" (async () => { const getCurrentCommit = () => { const commits = document.querySelectorAll('li.commit-item h4'); return commits.length > 0 ? commits[0].textContent.trim() : null; }; const initialCommit = getCurrentCommit(); const button = document.querySelector('a.pagination-next'); if (button) button.click(); while (true) { await new Promise(resolve => setTimeout(resolve, 100)); const newCommit = getCurrentCommit(); if (newCommit && newCommit !== initialCommit) { break; } } })(); \"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.commit-item\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.commit-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3): result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.commit-item\", extraction_strategy=extraction_strategy, js_code=js_next_page_and_wait if page > 0 else None, js_only=page > 0, bypass_cache=True ) commits = json.loads(result.extracted_content) all_commits.extend(commits) print(f\"Page {page + 1}: Found {len(commits)} commits\") await crawler.crawler_strategy.kill_session(session_id) print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\") asyncio.run(integrated_js_and_wait_crawl()) ``` This approach combines the JavaScript for clicking the \"next\" button and waiting for new content to load into a single script.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "class instantiation and usage",
      "relationship_explanation": "The code example explicitly creates an instance of JsonCssExtractionStrategy with a defined schema to extract commit elements from the page.",
      "predicted_trace_chain": "docs/md_v2/advanced/session-management-advanced.md -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The extraction strategy is directly instantiated in the documentation example to process the HTML content.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class implements the structured data extraction logic that processes the HTML content according to the schema defined in the documentation's example, where it extracts commit information using the specified baseSelector and field selectors.",
      "ground_truth_trace_chain": "session-management-advanced.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Technique 2: Integrated JavaScript Execution and Waiting Instead of using separate hooks, you can integrate the waiting logic directly into your JavaScript execution. This approach can be more concise and easier to manage for some scenarios. Here's an example: ```python async def integrated_js_and_wait_crawl(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/example/repo/commits/main\" session_id = \"integrated_session\" all_commits = [] js_next_page_and_wait = \"\"\" (async () => { const getCurrentCommit = () => { const commits = document.querySelectorAll('li.commit-item h4'); return commits.length > 0 ? commits[0].textContent.trim() : null; }; const initialCommit = getCurrentCommit(); const button = document.querySelector('a.pagination-next'); if (button) button.click(); while (true) { await new Promise(resolve => setTimeout(resolve, 100)); const newCommit = getCurrentCommit(); if (newCommit && newCommit !== initialCommit) { break; } } })(); \"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.commit-item\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.commit-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3): result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.commit-item\", extraction_strategy=extraction_strategy, js_code=js_next_page_and_wait if page > 0 else None, js_only=page > 0, bypass_cache=True ) commits = json.loads(result.extracted_content) all_commits.extend(commits) print(f\"Page {page + 1}: Found {len(commits)} commits\") await crawler.crawler_strategy.kill_session(session_id) print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\") asyncio.run(integrated_js_and_wait_crawl()) ``` This approach combines the JavaScript for clicking the \"next\" button and waiting for new content to load into a single script.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 2,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "After processing the pages, the example explicitly calls 'kill_session()' on the crawler's underlying strategy to clean up the session.",
      "predicted_trace_chain": "docs/md_v2/advanced/session-management-advanced.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_trace_chain_explanation": "The trace chain shows that the kill_session() method is reached through the AsyncWebCrawler instance, which delegates session termination to its crawler strategy.",
      "ground_truth_relationship": "The kill_session method is used at the end of the integrated crawling process to clean up browser resources by closing the page and context objects associated with the crawling session.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Technique 2: Integrated JavaScript Execution and Waiting Instead of using separate hooks, you can integrate the waiting logic directly into your JavaScript execution. This approach can be more concise and easier to manage for some scenarios. Here's an example: ```python async def integrated_js_and_wait_crawl(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/example/repo/commits/main\" session_id = \"integrated_session\" all_commits = [] js_next_page_and_wait = \"\"\" (async () => { const getCurrentCommit = () => { const commits = document.querySelectorAll('li.commit-item h4'); return commits.length > 0 ? commits[0].textContent.trim() : null; }; const initialCommit = getCurrentCommit(); const button = document.querySelector('a.pagination-next'); if (button) button.click(); while (true) { await new Promise(resolve => setTimeout(resolve, 100)); const newCommit = getCurrentCommit(); if (newCommit && newCommit !== initialCommit) { break; } } })(); \"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.commit-item\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.commit-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3): result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.commit-item\", extraction_strategy=extraction_strategy, js_code=js_next_page_and_wait if page > 0 else None, js_only=page > 0, bypass_cache=True ) commits = json.loads(result.extracted_content) all_commits.extend(commits) print(f\"Page {page + 1}: Found {len(commits)} commits\") await crawler.crawler_strategy.kill_session(session_id) print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\") asyncio.run(integrated_js_and_wait_crawl()) ``` This approach combines the JavaScript for clicking the \"next\" button and waiting for new content to load into a single script.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "default implementation usage",
      "relationship_explanation": "Although not directly named in the code snippet, AsyncWebCrawler uses AsyncPlaywrightCrawlerStrategy as its default crawling engine. Its methods (like kill_session) are implicitly used in the example.",
      "predicted_trace_chain": "docs/md_v2/advanced/session-management-advanced.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain indicates that AsyncWebCrawler instantiates and uses AsyncPlaywrightCrawlerStrategy by default, which underpins the crawler's functionality.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the integrated JavaScript execution and waiting functionality through its csp_compliant_wait method, which wraps user-provided JavaScript in a polling loop that checks for conditions while respecting timeouts.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Technique 2: Integrated JavaScript Execution and Waiting Instead of using separate hooks, you can integrate the waiting logic directly into your JavaScript execution. This approach can be more concise and easier to manage for some scenarios. Here's an example: ```python async def integrated_js_and_wait_crawl(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/example/repo/commits/main\" session_id = \"integrated_session\" all_commits = [] js_next_page_and_wait = \"\"\" (async () => { const getCurrentCommit = () => { const commits = document.querySelectorAll('li.commit-item h4'); return commits.length > 0 ? commits[0].textContent.trim() : null; }; const initialCommit = getCurrentCommit(); const button = document.querySelector('a.pagination-next'); if (button) button.click(); while (true) { await new Promise(resolve => setTimeout(resolve, 100)); const newCommit = getCurrentCommit(); if (newCommit && newCommit !== initialCommit) { break; } } })(); \"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.commit-item\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.commit-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3): result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.commit-item\", extraction_strategy=extraction_strategy, js_code=js_next_page_and_wait if page > 0 else None, js_only=page > 0, bypass_cache=True ) commits = json.loads(result.extracted_content) all_commits.extend(commits) print(f\"Page {page + 1}: Found {len(commits)} commits\") await crawler.crawler_strategy.kill_session(session_id) print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\") asyncio.run(integrated_js_and_wait_crawl()) ``` This approach combines the JavaScript for clicking the \"next\" button and waiting for new content to load into a single script.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance/base class",
      "relationship_explanation": "AsyncPlaywrightCrawlerStrategy extends AsyncCrawlerStrategy, making AsyncCrawlerStrategy the abstract base class that defines the contract for asynchronous crawling. This relationship is implicit in the inheritance hierarchy.",
      "predicted_trace_chain": "docs/md_v2/advanced/session-management-advanced.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "Starting from the documentation example, the default crawler strategy (AsyncPlaywrightCrawlerStrategy) inherits from AsyncCrawlerStrategy, establishing the base contract for its operations.",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class provides the foundational methods like set_hook() that enable the integrated JavaScript execution and waiting functionality described in the documentation's advanced technique.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Technique 2: Integrated JavaScript Execution and Waiting Instead of using separate hooks, you can integrate the waiting logic directly into your JavaScript execution. This approach can be more concise and easier to manage for some scenarios. Here's an example: ```python async def integrated_js_and_wait_crawl(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/example/repo/commits/main\" session_id = \"integrated_session\" all_commits = [] js_next_page_and_wait = \"\"\" (async () => { const getCurrentCommit = () => { const commits = document.querySelectorAll('li.commit-item h4'); return commits.length > 0 ? commits[0].textContent.trim() : null; }; const initialCommit = getCurrentCommit(); const button = document.querySelector('a.pagination-next'); if (button) button.click(); while (true) { await new Promise(resolve => setTimeout(resolve, 100)); const newCommit = getCurrentCommit(); if (newCommit && newCommit !== initialCommit) { break; } } })(); \"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.commit-item\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.commit-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3): result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.commit-item\", extraction_strategy=extraction_strategy, js_code=js_next_page_and_wait if page > 0 else None, js_only=page > 0, bypass_cache=True ) commits = json.loads(result.extracted_content) all_commits.extend(commits) print(f\"Page {page + 1}: Found {len(commits)} commits\") await crawler.crawler_strategy.kill_session(session_id) print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\") asyncio.run(integrated_js_and_wait_crawl()) ``` This approach combines the JavaScript for clicking the \"next\" button and waiting for new content to load into a single script.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance/base class",
      "relationship_explanation": "JsonCssExtractionStrategy is a concrete implementation that extends the abstract base class ExtractionStrategy. This inheritance link defines the standard interface for extraction strategies used in the crawling process.",
      "predicted_trace_chain": "docs/md_v2/advanced/session-management-advanced.md -> JsonCssExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The trace chain reflects that JsonCssExtractionStrategy, instantiated in the documentation, is built upon the ExtractionStrategy base class, ensuring consistency in extraction behavior.",
      "ground_truth_relationship": "The ExtractionStrategy abstract base class provides the foundation for implementing the commit extraction functionality shown in the documentation through its extract method, which processes HTML content into structured data as demonstrated in the documentation's schema-based extraction example.",
      "ground_truth_trace_chain": "session-management-advanced.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Technique 2: Integrated JavaScript Execution and Waiting Instead of using separate hooks, you can integrate the waiting logic directly into your JavaScript execution. This approach can be more concise and easier to manage for some scenarios. Here's an example: ```python async def integrated_js_and_wait_crawl(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/example/repo/commits/main\" session_id = \"integrated_session\" all_commits = [] js_next_page_and_wait = \"\"\" (async () => { const getCurrentCommit = () => { const commits = document.querySelectorAll('li.commit-item h4'); return commits.length > 0 ? commits[0].textContent.trim() : null; }; const initialCommit = getCurrentCommit(); const button = document.querySelector('a.pagination-next'); if (button) button.click(); while (true) { await new Promise(resolve => setTimeout(resolve, 100)); const newCommit = getCurrentCommit(); if (newCommit && newCommit !== initialCommit) { break; } } })(); \"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.commit-item\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.commit-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3): result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.commit-item\", extraction_strategy=extraction_strategy, js_code=js_next_page_and_wait if page > 0 else None, js_only=page > 0, bypass_cache=True ) commits = json.loads(result.extracted_content) all_commits.extend(commits) print(f\"Page {page + 1}: Found {len(commits)} commits\") await crawler.crawler_strategy.kill_session(session_id) print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\") asyncio.run(integrated_js_and_wait_crawl()) ``` This approach combines the JavaScript for clicking the \"next\" button and waiting for new content to load into a single script.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class serves as a structured container for storing the extracted commits and related metadata from the integrated JavaScript execution process described in the documentation.",
      "ground_truth_trace_chain": "session-management-advanced.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Technique 2: Integrated JavaScript Execution and Waiting Instead of using separate hooks, you can integrate the waiting logic directly into your JavaScript execution. This approach can be more concise and easier to manage for some scenarios. Here's an example: ```python async def integrated_js_and_wait_crawl(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/example/repo/commits/main\" session_id = \"integrated_session\" all_commits = [] js_next_page_and_wait = \"\"\" (async () => { const getCurrentCommit = () => { const commits = document.querySelectorAll('li.commit-item h4'); return commits.length > 0 ? commits[0].textContent.trim() : null; }; const initialCommit = getCurrentCommit(); const button = document.querySelector('a.pagination-next'); if (button) button.click(); while (true) { await new Promise(resolve => setTimeout(resolve, 100)); const newCommit = getCurrentCommit(); if (newCommit && newCommit !== initialCommit) { break; } } })(); \"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.commit-item\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.commit-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3): result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.commit-item\", extraction_strategy=extraction_strategy, js_code=js_next_page_and_wait if page > 0 else None, js_only=page > 0, bypass_cache=True ) commits = json.loads(result.extracted_content) all_commits.extend(commits) print(f\"Page {page + 1}: Found {len(commits)} commits\") await crawler.crawler_strategy.kill_session(session_id) print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\") asyncio.run(integrated_js_and_wait_crawl()) ``` This approach combines the JavaScript for clicking the \"next\" button and waiting for new content to load into a single script.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_title": "CrawlResult.extracted_content",
      "ground_truth_relationship": "The CrawlResult.extracted_content property stores the JSON-formatted commit data that was extracted from the webpage using the JsonCssExtractionStrategy schema.",
      "ground_truth_trace_chain": "session-management-advanced.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### [CSS-Based Extraction](css.md)\n\n`JsonCssExtractionStrategy` extracts data using CSS selectors. This is fast, reliable, and perfect for consistently structured pages.\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"Product Listing\",\n    \"baseSelector\": \".product-card\",\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"},\n        {\"name\": \"image\", \"selector\": \"img\", \"type\": \"attribute\", \"attribute\": \"src\"}\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\n\nresult = await crawler.arun(\n    url=\"https://example.com/products\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- E-commerce product listings\n- News article collections\n- Structured content pages\n- High-performance needs",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "implements",
      "relationship_explanation": "The documentation snippet explicitly names 'JsonCssExtractionStrategy' and shows its instantiation with a provided schema that uses CSS selectors. This directly demonstrates its purpose to extract data using CSS selectors.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain begins at the documentation file (docs/md_v2/extraction/overview.md) and directly references the 'JsonCssExtractionStrategy' class, which is the subject of the snippet.",
      "ground_truth_relationship": "The code implements the documented CSS-based extraction by using BeautifulSoup's select() method to find elements matching the schema's baseSelector and extract specified fields from each matched element.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### [CSS-Based Extraction](css.md)\n\n`JsonCssExtractionStrategy` extracts data using CSS selectors. This is fast, reliable, and perfect for consistently structured pages.\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"Product Listing\",\n    \"baseSelector\": \".product-card\",\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"},\n        {\"name\": \"image\", \"selector\": \"img\", \"type\": \"attribute\", \"attribute\": \"src\"}\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\n\nresult = await crawler.arun(\n    url=\"https://example.com/products\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- E-commerce product listings\n- News article collections\n- Structured content pages\n- High-performance needs",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "extends",
      "relationship_explanation": "'JsonCssExtractionStrategy' extends the abstract base class 'ExtractionStrategy'. Although not mentioned explicitly in the snippet, this inheritance relationship ensures that the CSS-based extraction strategy adheres to the required extraction interface.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> JsonCssExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "Starting from the documentation reference to 'JsonCssExtractionStrategy', the chain extends to its base class 'ExtractionStrategy', highlighting the dependency needed for the extraction functionality.",
      "ground_truth_relationship": "The ExtractionStrategy abstract base class provides the core interface and parallel processing capabilities that JsonCssExtractionStrategy extends to implement the CSS-based extraction functionality described in the documentation.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### [CSS-Based Extraction](css.md)\n\n`JsonCssExtractionStrategy` extracts data using CSS selectors. This is fast, reliable, and perfect for consistently structured pages.\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"Product Listing\",\n    \"baseSelector\": \".product-card\",\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"},\n        {\"name\": \"image\", \"selector\": \"img\", \"type\": \"attribute\", \"attribute\": \"src\"}\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\n\nresult = await crawler.arun(\n    url=\"https://example.com/products\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- E-commerce product listings\n- News article collections\n- Structured content pages\n- High-performance needs",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "implicit",
      "relationship_type": "uses",
      "relationship_explanation": "The usage example in the snippet calls 'crawler.arun(...)' with 'extraction_strategy' as a parameter. This implies that the asynchronous web crawler\u2019s 'arun()' method is used to execute the extraction strategy, although it is not directly named in the documentation text.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The documentation snippet demonstrates the use of a crawler's 'arun()' method, establishing an implicit link to 'AsyncWebCrawler.arun()' which handles the crawling and extraction process.",
      "ground_truth_relationship": "The arun() method in AsyncWebCrawler implements the core execution logic that enables the JsonCssExtractionStrategy to process web pages using CSS selectors by accepting an extraction_strategy parameter and integrating it into the crawling workflow.",
      "ground_truth_trace_chain": "overview.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### [CSS-Based Extraction](css.md)\n\n`JsonCssExtractionStrategy` extracts data using CSS selectors. This is fast, reliable, and perfect for consistently structured pages.\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"Product Listing\",\n    \"baseSelector\": \".product-card\",\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"},\n        {\"name\": \"image\", \"selector\": \"img\", \"type\": \"attribute\", \"attribute\": \"src\"}\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\n\nresult = await crawler.arun(\n    url=\"https://example.com/products\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- E-commerce product listings\n- News article collections\n- Structured content pages\n- High-performance needs",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the extracted content from CSS-based extraction in its 'extracted_content' field, allowing the JsonCssExtractionStrategy to save structured data parsed from HTML elements matching the specified CSS selectors.",
      "ground_truth_trace_chain": "overview.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### [CSS-Based Extraction](css.md)\n\n`JsonCssExtractionStrategy` extracts data using CSS selectors. This is fast, reliable, and perfect for consistently structured pages.\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"Product Listing\",\n    \"baseSelector\": \".product-card\",\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"},\n        {\"name\": \"image\", \"selector\": \"img\", \"type\": \"attribute\", \"attribute\": \"src\"}\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\n\nresult = await crawler.arun(\n    url=\"https://example.com/products\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- E-commerce product listings\n- News article collections\n- Structured content pages\n- High-performance needs",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy class provides the abstract interface that enables the documented JsonCssExtractionStrategy to execute its CSS-based data extraction through the crawl method which returns AsyncCrawlResponse objects.",
      "ground_truth_trace_chain": "overview.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### [CSS-Based Extraction](css.md)\n\n`JsonCssExtractionStrategy` extracts data using CSS selectors. This is fast, reliable, and perfect for consistently structured pages.\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"Product Listing\",\n    \"baseSelector\": \".product-card\",\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"},\n        {\"name\": \"image\", \"selector\": \"img\", \"type\": \"attribute\", \"attribute\": \"src\"}\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\n\nresult = await crawler.arun(\n    url=\"https://example.com/products\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- E-commerce product listings\n- News article collections\n- Structured content pages\n- High-performance needs",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy implements the underlying page navigation and browser automation functionality needed to support JsonCssExtractionStrategy's CSS selector-based data extraction from web pages.",
      "ground_truth_trace_chain": "overview.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### [CSS-Based Extraction](css.md)\n\n`JsonCssExtractionStrategy` extracts data using CSS selectors. This is fast, reliable, and perfect for consistently structured pages.\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"Product Listing\",\n    \"baseSelector\": \".product-card\",\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"},\n        {\"name\": \"image\", \"selector\": \"img\", \"type\": \"attribute\", \"attribute\": \"src\"}\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\n\nresult = await crawler.arun(\n    url=\"https://example.com/products\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- E-commerce product listings\n- News article collections\n- Structured content pages\n- High-performance needs",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements CSS-based extraction through its aprocess_html method, which specifically checks for JsonCssExtractionStrategy instances and processes them using the documented schema format to extract structured data from HTML elements.",
      "ground_truth_trace_chain": "overview.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Session Best Practices\n\n1. **Session Naming**:\n```python\n# Use descriptive session IDs\nsession_id = \"login_flow_session\"\nsession_id = \"product_catalog_session\"\n```\n\n2. **Resource Management**:\n```python\ntry:\n    # Your crawling code\n    pass\nfinally:\n    # Always clean up sessions\n    await crawler.crawler_strategy.kill_session(session_id)\n```\n\n3. **State Management**:\n```python\n# First page: login\nresult = await crawler.arun(\n    url=\"https://example.com/login\",\n    session_id=session_id,\n    js_code=\"document.querySelector('form').submit();\"\n)\n\n# Second page: verify login success\nresult = await crawler.arun(\n    url=\"https://example.com/dashboard\",\n    session_id=session_id,\n    wait_for=\"css:.user-profile\"  # Wait for authenticated content\n)\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_id": 2,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_relationship": "explicit",
      "relationship_type": "calls",
      "relationship_explanation": "The documentation snippet shows a direct invocation of kill_session on the crawler\u2019s strategy within a try-finally block for resource cleanup. This explicitly demonstrates that sessions should be terminated using the kill_session() method.",
      "predicted_trace_chain": "docs/md_v2/advanced/session-management.md -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_trace_chain_explanation": "Starting from the session management document, the code example directly calls kill_session(), mapping the documentation to the kill_session() method in AsyncPlaywrightCrawlerStrategy.",
      "ground_truth_relationship": "The kill_session() method implements the documented resource management best practice by closing browser contexts and pages to prevent memory leaks when sessions are no longer needed.",
      "ground_truth_trace_chain": "session-management.md -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Session Best Practices\n\n1. **Session Naming**:\n```python\n# Use descriptive session IDs\nsession_id = \"login_flow_session\"\nsession_id = \"product_catalog_session\"\n```\n\n2. **Resource Management**:\n```python\ntry:\n    # Your crawling code\n    pass\nfinally:\n    # Always clean up sessions\n    await crawler.crawler_strategy.kill_session(session_id)\n```\n\n3. **State Management**:\n```python\n# First page: login\nresult = await crawler.arun(\n    url=\"https://example.com/login\",\n    session_id=session_id,\n    js_code=\"document.querySelector('form').submit();\"\n)\n\n# Second page: verify login success\nresult = await crawler.arun(\n    url=\"https://example.com/dashboard\",\n    session_id=session_id,\n    wait_for=\"css:.user-profile\"  # Wait for authenticated content\n)\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "calls",
      "relationship_explanation": "The documentation includes examples of using the arun() method to perform crawling actions with specific parameters such as session_id, js_code, and wait_for. This clearly demonstrates how state management (such as login and dashboard verification) is implemented via the arun() method.",
      "predicted_trace_chain": "docs/md_v2/advanced/session-management.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The state management examples in the document lead directly to the use of the arun() method of AsyncWebCrawler, establishing a clear trace from the documentation to the corresponding code artifact.",
      "ground_truth_relationship": "The arun() method stores session_id from kwargs which enables stateful crawling across multiple requests as shown in the documentation's state management examples.",
      "ground_truth_trace_chain": "session-management.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Session Best Practices\n\n1. **Session Naming**:\n```python\n# Use descriptive session IDs\nsession_id = \"login_flow_session\"\nsession_id = \"product_catalog_session\"\n```\n\n2. **Resource Management**:\n```python\ntry:\n    # Your crawling code\n    pass\nfinally:\n    # Always clean up sessions\n    await crawler.crawler_strategy.kill_session(session_id)\n```\n\n3. **State Management**:\n```python\n# First page: login\nresult = await crawler.arun(\n    url=\"https://example.com/login\",\n    session_id=session_id,\n    js_code=\"document.querySelector('form').submit();\"\n)\n\n# Second page: verify login success\nresult = await crawler.arun(\n    url=\"https://example.com/dashboard\",\n    session_id=session_id,\n    wait_for=\"css:.user-profile\"  # Wait for authenticated content\n)\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class captures and stores session-specific data like session_id and status_code that are essential for implementing the documented session management practices including state tracking across page navigations.",
      "ground_truth_trace_chain": "session-management.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Session Best Practices\n\n1. **Session Naming**:\n```python\n# Use descriptive session IDs\nsession_id = \"login_flow_session\"\nsession_id = \"product_catalog_session\"\n```\n\n2. **Resource Management**:\n```python\ntry:\n    # Your crawling code\n    pass\nfinally:\n    # Always clean up sessions\n    await crawler.crawler_strategy.kill_session(session_id)\n```\n\n3. **State Management**:\n```python\n# First page: login\nresult = await crawler.arun(\n    url=\"https://example.com/login\",\n    session_id=session_id,\n    js_code=\"document.querySelector('form').submit();\"\n)\n\n# Second page: verify login success\nresult = await crawler.arun(\n    url=\"https://example.com/dashboard\",\n    session_id=session_id,\n    wait_for=\"css:.user-profile\"  # Wait for authenticated content\n)\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class serves as the foundation for implementing the session management patterns shown in the documentation by defining core methods like crawl() and crawl_many() that handle the session-based navigation and resource cleanup.",
      "ground_truth_trace_chain": "session-management.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Session Best Practices\n\n1. **Session Naming**:\n```python\n# Use descriptive session IDs\nsession_id = \"login_flow_session\"\nsession_id = \"product_catalog_session\"\n```\n\n2. **Resource Management**:\n```python\ntry:\n    # Your crawling code\n    pass\nfinally:\n    # Always clean up sessions\n    await crawler.crawler_strategy.kill_session(session_id)\n```\n\n3. **State Management**:\n```python\n# First page: login\nresult = await crawler.arun(\n    url=\"https://example.com/login\",\n    session_id=session_id,\n    js_code=\"document.querySelector('form').submit();\"\n)\n\n# Second page: verify login success\nresult = await crawler.arun(\n    url=\"https://example.com/dashboard\",\n    session_id=session_id,\n    wait_for=\"css:.user-profile\"  # Wait for authenticated content\n)\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements session management through its sessions dictionary and kill_session method, directly supporting the documented session best practices for naming, resource cleanup, and state management across multiple page requests.",
      "ground_truth_trace_chain": "session-management.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Session Best Practices\n\n1. **Session Naming**:\n```python\n# Use descriptive session IDs\nsession_id = \"login_flow_session\"\nsession_id = \"product_catalog_session\"\n```\n\n2. **Resource Management**:\n```python\ntry:\n    # Your crawling code\n    pass\nfinally:\n    # Always clean up sessions\n    await crawler.crawler_strategy.kill_session(session_id)\n```\n\n3. **State Management**:\n```python\n# First page: login\nresult = await crawler.arun(\n    url=\"https://example.com/login\",\n    session_id=session_id,\n    js_code=\"document.querySelector('form').submit();\"\n)\n\n# Second page: verify login success\nresult = await crawler.arun(\n    url=\"https://example.com/dashboard\",\n    session_id=session_id,\n    wait_for=\"css:.user-profile\"  # Wait for authenticated content\n)\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements session management through its 'arun' method, which accepts a 'session_id' parameter that enables maintaining state across multiple page visits as demonstrated in the documentation's state management example.",
      "ground_truth_trace_chain": "session-management.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### NlpSentenceChunking\n\n`NlpSentenceChunking` uses NLP models to split text into sentences, ensuring accurate sentence boundaries.\n\n#### When to Use\n- Ideal for texts where sentence boundaries are crucial.\n- Useful for creating chunks that preserve grammatical structures.\n\n#### Parameters\n- None.\n\n#### Example\n```python\nfrom crawl4ai.chunking_strategy import NlpSentenceChunking\n\nchunker = NlpSentenceChunking()\n\n# Sample text\ntext = \"This is a sample text. It will be split into sentences. Here's another sentence.\"\n\n# Chunk the text\nchunks = chunker.chunk(text)\nprint(chunks)\n```",
      "document_location": "docs/md_v2/extraction/chunking.md",
      "artifact_id": 25,
      "artifact_title": "NlpSentenceChunking",
      "predicted_relationship": "explicit",
      "relationship_type": "usage/instantiation",
      "relationship_explanation": "The documentation snippet explicitly mentions and demonstrates the usage of 'NlpSentenceChunking' by importing it and invoking its 'chunk' method. The provided example code shows how to instantiate NlpSentenceChunking and use it to split text into sentences.",
      "predicted_trace_chain": "docs/md_v2/extraction/chunking.md -> NlpSentenceChunking",
      "predicted_trace_chain_explanation": "The trace starts at the documentation file 'docs/md_v2/extraction/chunking.md', where 'NlpSentenceChunking' is explicitly referenced and used in a code example, leading directly to the NlpSentenceChunking class implementation.",
      "ground_truth_relationship": "The code implements sentence chunking by using NLTK's sent_tokenize function to split text into sentences, which directly fulfills the documentation's promise of using NLP models for accurate sentence boundary detection.",
      "ground_truth_trace_chain": "chunking.md -> ChunkingStrategy -> NlpSentenceChunking",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### NlpSentenceChunking\n\n`NlpSentenceChunking` uses NLP models to split text into sentences, ensuring accurate sentence boundaries.\n\n#### When to Use\n- Ideal for texts where sentence boundaries are crucial.\n- Useful for creating chunks that preserve grammatical structures.\n\n#### Parameters\n- None.\n\n#### Example\n```python\nfrom crawl4ai.chunking_strategy import NlpSentenceChunking\n\nchunker = NlpSentenceChunking()\n\n# Sample text\ntext = \"This is a sample text. It will be split into sentences. Here's another sentence.\"\n\n# Chunk the text\nchunks = chunker.chunk(text)\nprint(chunks)\n```",
      "document_location": "docs/md_v2/extraction/chunking.md",
      "artifact_id": 6,
      "artifact_title": "ChunkingStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "Although not directly mentioned in the documentation, NlpSentenceChunking extends ChunkingStrategy. This inheritance establishes an implicit relationship that defines the contract for chunking text, ensuring that NlpSentenceChunking conforms to the expected public interface for text chunking.",
      "predicted_trace_chain": "docs/md_v2/extraction/chunking.md -> NlpSentenceChunking -> ChunkingStrategy",
      "predicted_trace_chain_explanation": "Starting from the documentation reference to NlpSentenceChunking, the chain continues to its base class ChunkingStrategy. This chain highlights the inheritance relationship that underlies the implementation of the chunk method, linking the documentation to the abstract base class.",
      "ground_truth_relationship": "The abstract ChunkingStrategy class defines the base chunking interface that NlpSentenceChunking must implement through its required chunk() method, which takes text input and returns a list of sentence chunks.",
      "ground_truth_trace_chain": "chunking.md -> ChunkingStrategy -> ChunkingStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Using with Extraction Strategies\n\nCombine page interaction with structured extraction:\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy, LLMExtractionStrategy\n\n# Pattern-based extraction after interaction\nschema = {\n    \"name\": \"Dynamic Items\",\n    \"baseSelector\": \".item\",\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"description\", \"selector\": \".desc\", \"type\": \"text\"}\n    ]\n}\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\",\n    wait_for=\"css:.item:nth-child(10)\",  # Wait for 10 items\n    extraction_strategy=JsonCssExtractionStrategy(schema)\n)\n\n# Or use LLM to analyze dynamic content\nclass ContentAnalysis(BaseModel):\n    topics: List[str]\n    summary: str\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"document.querySelector('.show-more').click();\",\n    wait_for=\"css:.full-content\",\n    extraction_strategy=LLMExtractionStrategy(\n        provider=\"ollama/nemotron\",\n        schema=ContentAnalysis.schema(),\n        instruction=\"Analyze the full content\"\n    )\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "implements",
      "relationship_explanation": "The documentation explicitly imports JsonCssExtractionStrategy and uses it for pattern\u2010based extraction by passing a schema that defines the selectors for dynamic items. This shows that the extraction strategy implementation is directly used to extract structured content from the page.",
      "predicted_trace_chain": "page-interaction.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain starts from the documentation file 'page-interaction.md'. The snippet imports JsonCssExtractionStrategy, which as a subclass of ExtractionStrategy (artifact id 21) is used to implement the extraction behavior, ending at JsonCssExtractionStrategy.",
      "ground_truth_relationship": "JsonCssExtractionStrategy class implements pattern-based extraction by parsing HTML with BeautifulSoup and applying the schema's CSS selectors to extract structured data from matched elements.",
      "ground_truth_trace_chain": "page-interaction.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Using with Extraction Strategies\n\nCombine page interaction with structured extraction:\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy, LLMExtractionStrategy\n\n# Pattern-based extraction after interaction\nschema = {\n    \"name\": \"Dynamic Items\",\n    \"baseSelector\": \".item\",\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"description\", \"selector\": \".desc\", \"type\": \"text\"}\n    ]\n}\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\",\n    wait_for=\"css:.item:nth-child(10)\",  # Wait for 10 items\n    extraction_strategy=JsonCssExtractionStrategy(schema)\n)\n\n# Or use LLM to analyze dynamic content\nclass ContentAnalysis(BaseModel):\n    topics: List[str]\n    summary: str\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"document.querySelector('.show-more').click();\",\n    wait_for=\"css:.full-content\",\n    extraction_strategy=LLMExtractionStrategy(\n        provider=\"ollama/nemotron\",\n        schema=ContentAnalysis.schema(),\n        instruction=\"Analyze the full content\"\n    )\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "implements",
      "relationship_explanation": "The documentation explicitly imports LLMExtractionStrategy and demonstrates its usage by passing parameters such as provider, schema (derived from a Pydantic model), and an instruction to analyze the content. This indicates that the strategy is intended for LLM-based extraction.",
      "predicted_trace_chain": "page-interaction.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "predicted_trace_chain_explanation": "Starting from 'page-interaction.md', the extraction mechanism relies on the base class ExtractionStrategy. LLMExtractionStrategy, which extends ExtractionStrategy, is used in the snippet to analyze dynamic content, thus the chain completes at LLMExtractionStrategy.",
      "ground_truth_relationship": "The LLMExtractionStrategy code directly implements the documented functionality of analyzing dynamic content by processing HTML content through LLM models with configurable providers, schemas, and instructions as shown in the example where it processes content after waiting for '.full-content' elements.",
      "ground_truth_trace_chain": "page-interaction.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Using with Extraction Strategies\n\nCombine page interaction with structured extraction:\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy, LLMExtractionStrategy\n\n# Pattern-based extraction after interaction\nschema = {\n    \"name\": \"Dynamic Items\",\n    \"baseSelector\": \".item\",\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"description\", \"selector\": \".desc\", \"type\": \"text\"}\n    ]\n}\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\",\n    wait_for=\"css:.item:nth-child(10)\",  # Wait for 10 items\n    extraction_strategy=JsonCssExtractionStrategy(schema)\n)\n\n# Or use LLM to analyze dynamic content\nclass ContentAnalysis(BaseModel):\n    topics: List[str]\n    summary: str\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"document.querySelector('.show-more').click();\",\n    wait_for=\"css:.full-content\",\n    extraction_strategy=LLMExtractionStrategy(\n        provider=\"ollama/nemotron\",\n        schema=ContentAnalysis.schema(),\n        instruction=\"Analyze the full content\"\n    )\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "implicit",
      "relationship_type": "uses",
      "relationship_explanation": "Although not imported explicitly in the snippet, the code sample calls 'crawler.arun(...)' indicating that the crawling functionality provided by AsyncWebCrawler.arun() is used to combine page interaction (JavaScript execution, waiting for elements) with the extraction strategies. This method orchestrates the overall crawling process.",
      "predicted_trace_chain": "page-interaction.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The documentation snippet shows the invocation of the crawl process via 'crawler.arun(...)', which implicitly links the extraction strategy usage with the underlying crawling implementation provided by AsyncWebCrawler.arun().",
      "ground_truth_relationship": "The arun() method implements the documented functionality by accepting extraction_strategy objects like JsonCssExtractionStrategy and LLMExtractionStrategy, along with JavaScript code and wait conditions, to perform web crawling with structured data extraction.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Using with Extraction Strategies\n\nCombine page interaction with structured extraction:\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy, LLMExtractionStrategy\n\n# Pattern-based extraction after interaction\nschema = {\n    \"name\": \"Dynamic Items\",\n    \"baseSelector\": \".item\",\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"description\", \"selector\": \".desc\", \"type\": \"text\"}\n    ]\n}\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\",\n    wait_for=\"css:.item:nth-child(10)\",  # Wait for 10 items\n    extraction_strategy=JsonCssExtractionStrategy(schema)\n)\n\n# Or use LLM to analyze dynamic content\nclass ContentAnalysis(BaseModel):\n    topics: List[str]\n    summary: str\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"document.querySelector('.show-more').click();\",\n    wait_for=\"css:.full-content\",\n    extraction_strategy=LLMExtractionStrategy(\n        provider=\"ollama/nemotron\",\n        schema=ContentAnalysis.schema(),\n        instruction=\"Analyze the full content\"\n    )\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the data structure that holds the extraction results shown in the documentation examples, with the extracted_content field specifically storing the output from both JsonCssExtractionStrategy and LLMExtractionStrategy operations.",
      "ground_truth_trace_chain": "page-interaction.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Using with Extraction Strategies\n\nCombine page interaction with structured extraction:\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy, LLMExtractionStrategy\n\n# Pattern-based extraction after interaction\nschema = {\n    \"name\": \"Dynamic Items\",\n    \"baseSelector\": \".item\",\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"description\", \"selector\": \".desc\", \"type\": \"text\"}\n    ]\n}\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\",\n    wait_for=\"css:.item:nth-child(10)\",  # Wait for 10 items\n    extraction_strategy=JsonCssExtractionStrategy(schema)\n)\n\n# Or use LLM to analyze dynamic content\nclass ContentAnalysis(BaseModel):\n    topics: List[str]\n    summary: str\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"document.querySelector('.show-more').click();\",\n    wait_for=\"css:.full-content\",\n    extraction_strategy=LLMExtractionStrategy(\n        provider=\"ollama/nemotron\",\n        schema=ContentAnalysis.schema(),\n        instruction=\"Analyze the full content\"\n    )\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements browser automation for executing JavaScript code and waiting for elements, which directly enables the documented extraction strategies by providing the underlying mechanism to run js_code and handle wait_for conditions during page crawling.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Using with Extraction Strategies\n\nCombine page interaction with structured extraction:\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy, LLMExtractionStrategy\n\n# Pattern-based extraction after interaction\nschema = {\n    \"name\": \"Dynamic Items\",\n    \"baseSelector\": \".item\",\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"description\", \"selector\": \".desc\", \"type\": \"text\"}\n    ]\n}\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\",\n    wait_for=\"css:.item:nth-child(10)\",  # Wait for 10 items\n    extraction_strategy=JsonCssExtractionStrategy(schema)\n)\n\n# Or use LLM to analyze dynamic content\nclass ContentAnalysis(BaseModel):\n    topics: List[str]\n    summary: str\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"document.querySelector('.show-more').click();\",\n    wait_for=\"css:.full-content\",\n    extraction_strategy=LLMExtractionStrategy(\n        provider=\"ollama/nemotron\",\n        schema=ContentAnalysis.schema(),\n        instruction=\"Analyze the full content\"\n    )\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the documented functionality by providing an arun() method that accepts extraction strategies (JsonCssExtractionStrategy or LLMExtractionStrategy) and JavaScript execution parameters to handle dynamic content extraction, as shown in the documentation examples.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Using with Extraction Strategies\n\nCombine page interaction with structured extraction:\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy, LLMExtractionStrategy\n\n# Pattern-based extraction after interaction\nschema = {\n    \"name\": \"Dynamic Items\",\n    \"baseSelector\": \".item\",\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"description\", \"selector\": \".desc\", \"type\": \"text\"}\n    ]\n}\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\",\n    wait_for=\"css:.item:nth-child(10)\",  # Wait for 10 items\n    extraction_strategy=JsonCssExtractionStrategy(schema)\n)\n\n# Or use LLM to analyze dynamic content\nclass ContentAnalysis(BaseModel):\n    topics: List[str]\n    summary: str\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"document.querySelector('.show-more').click();\",\n    wait_for=\"css:.full-content\",\n    extraction_strategy=LLMExtractionStrategy(\n        provider=\"ollama/nemotron\",\n        schema=ContentAnalysis.schema(),\n        instruction=\"Analyze the full content\"\n    )\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_title": "ExtractionStrategy",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the foundational structure for the JsonCssExtractionStrategy and LLMExtractionStrategy implementations shown in the documentation through its abstract extract() method and parallel processing run() method.",
      "ground_truth_trace_chain": "page-interaction.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Using with Extraction Strategies\n\nCombine page interaction with structured extraction:\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy, LLMExtractionStrategy\n\n# Pattern-based extraction after interaction\nschema = {\n    \"name\": \"Dynamic Items\",\n    \"baseSelector\": \".item\",\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"description\", \"selector\": \".desc\", \"type\": \"text\"}\n    ]\n}\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\",\n    wait_for=\"css:.item:nth-child(10)\",  # Wait for 10 items\n    extraction_strategy=JsonCssExtractionStrategy(schema)\n)\n\n# Or use LLM to analyze dynamic content\nclass ContentAnalysis(BaseModel):\n    topics: List[str]\n    summary: str\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"document.querySelector('.show-more').click();\",\n    wait_for=\"css:.full-content\",\n    extraction_strategy=LLMExtractionStrategy(\n        provider=\"ollama/nemotron\",\n        schema=ContentAnalysis.schema(),\n        instruction=\"Analyze the full content\"\n    )\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface methods that enable the documented extraction strategies to perform crawling operations with custom behaviors like waiting for elements and executing JavaScript code.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Quick Start\n\nHere's a quick example to show you how easy it is to use Crawl4AI with its asynchronous capabilities:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    # Create an instance of AsyncWebCrawler\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        # Run the crawler on a URL\n        result = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n\n        # Print the extracted content\n        print(result.markdown)\n\n# Run the async main function\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/index.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "class instantiation and usage",
      "relationship_explanation": "The documentation snippet explicitly imports AsyncWebCrawler and uses it within an async context (using 'async with AsyncWebCrawler(verbose=True)') to create an instance. This shows that AsyncWebCrawler is the main class users interact with for asynchronous crawling in Crawl4AI.",
      "predicted_trace_chain": "docs/md_v2/index.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain starts from the documentation file (docs/md_v2/index.md) and directly points to the AsyncWebCrawler class as it is explicitly instantiated in the example.",
      "ground_truth_relationship": "The code implements the AsyncWebCrawler class with async context manager methods (__aenter__ and __aexit__) that directly enable the 'async with' syntax shown in the quickstart documentation example.",
      "ground_truth_trace_chain": "index.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Quick Start\n\nHere's a quick example to show you how easy it is to use Crawl4AI with its asynchronous capabilities:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    # Create an instance of AsyncWebCrawler\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        # Run the crawler on a URL\n        result = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n\n        # Print the extracted content\n        print(result.markdown)\n\n# Run the async main function\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/index.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "Within the async context provided by AsyncWebCrawler, the 'arun()' method is explicitly called to crawl a URL (using 'await crawler.arun(url=\"https://www.nbcnews.com/business\")'). This demonstrates that the method is the designated function for performing the crawl operation.",
      "predicted_trace_chain": "docs/md_v2/index.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain reflects that the documentation from docs/md_v2/index.md instantiates AsyncWebCrawler and then immediately calls its arun() method, marking the method as the next step in the usage pathway.",
      "ground_truth_relationship": "The code implements AsyncWebCrawler's arun() method which enables the asynchronous web crawling functionality shown in the quickstart documentation by handling URL fetching, content extraction, and error handling using async/await patterns.",
      "ground_truth_trace_chain": "index.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Quick Start\n\nHere's a quick example to show you how easy it is to use Crawl4AI with its asynchronous capabilities:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    # Create an instance of AsyncWebCrawler\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        # Run the crawler on a URL\n        result = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n\n        # Print the extracted content\n        print(result.markdown)\n\n# Run the async main function\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/index.md",
      "artifact_id": 15,
      "artifact_title": "CrawlResult.markdown",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "After invoking the arun() method, the example accesses the 'markdown' attribute of the resulting CrawlResult object (via 'print(result.markdown)'). This indicates that the extracted content is stored in the 'markdown' attribute.",
      "predicted_trace_chain": "docs/md_v2/index.md -> AsyncWebCrawler.arun() -> CrawlResult.markdown",
      "predicted_trace_chain_explanation": "The chain shows the progression from the documentation file to the arun() method invocation and finally to accessing the CrawlResult.markdown attribute, which represents the extracted result content.",
      "ground_truth_relationship": "The CrawlResult.markdown property stores the extracted content as a formatted string, which is displayed in the Quick Start example when printing result.markdown.",
      "ground_truth_trace_chain": "index.md -> CrawlResult.markdown",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Quick Start\n\nHere's a quick example to show you how easy it is to use Crawl4AI with its asynchronous capabilities:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    # Create an instance of AsyncWebCrawler\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        # Run the crawler on a URL\n        result = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n\n        # Print the extracted content\n        print(result.markdown)\n\n# Run the async main function\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/index.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the structured data model that stores the crawled webpage content, including the markdown field shown being printed in the documentation's example code.",
      "ground_truth_trace_chain": "index.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Quick Start\n\nHere's a quick example to show you how easy it is to use Crawl4AI with its asynchronous capabilities:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    # Create an instance of AsyncWebCrawler\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        # Run the crawler on a URL\n        result = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n\n        # Print the extracted content\n        print(result.markdown)\n\n# Run the async main function\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/index.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the core asynchronous web crawling functionality demonstrated in the quick start documentation, providing the underlying browser automation and content extraction capabilities used by AsyncWebCrawler's arun method.",
      "ground_truth_trace_chain": "index.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Quick Start\n\nHere's a quick example to show you how easy it is to use Crawl4AI with its asynchronous capabilities:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    # Create an instance of AsyncWebCrawler\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        # Run the crawler on a URL\n        result = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n\n        # Print the extracted content\n        print(result.markdown)\n\n# Run the async main function\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/index.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface methods that enable the asynchronous web crawling functionality shown in the Quick Start documentation example.",
      "ground_truth_trace_chain": "index.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Fit Markdown\n\nMost relevant content extracted and converted to markdown. Ideal for:\n- Article extraction\n- Main content focus\n- Removing boilerplate\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nprint(result.fit_markdown)  # Only the main content\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method call",
      "relationship_explanation": "The documentation code snippet directly calls 'crawler.arun(url=\"https://example.com\")', which corresponds to the AsyncWebCrawler.arun() method. This method is responsible for crawling the given URL and returning a CrawlResult object.",
      "predicted_trace_chain": "docs/md_v2/basic/output-formats.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the documentation file 'output-formats.md', the chain identifies the use of the 'arun' method as the entry point for processing the URL. This method call is the first step in the chain that produces a CrawlResult from which specific properties are later accessed.",
      "ground_truth_relationship": "The code implements an async crawling method that processes HTML content and extracts markdown-formatted text through an extraction strategy, which directly supports the documented fit_markdown feature for retrieving main content from web pages.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Fit Markdown\n\nMost relevant content extracted and converted to markdown. Ideal for:\n- Article extraction\n- Main content focus\n- Removing boilerplate\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nprint(result.fit_markdown)  # Only the main content\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 12,
      "artifact_title": "CrawlResult.fit_markdown",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The code in the snippet prints 'result.fit_markdown', explicitly accessing the 'fit_markdown' attribute of the CrawlResult class. This attribute holds the main content in markdown format, which is the focus of the documentation regarding 'Fit Markdown'.",
      "predicted_trace_chain": "docs/md_v2/basic/output-formats.md -> CrawlResult.fit_markdown",
      "predicted_trace_chain_explanation": "The chain begins at the documentation file 'output-formats.md' and directly accesses the 'fit_markdown' attribute from the CrawlResult object. This highlights the intended output (main content in markdown) as described in the documentation.",
      "ground_truth_relationship": "The fit_markdown property holds a string containing the cleaned and extracted main content from crawled web pages as markdown format, with boilerplate removed.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult.fit_markdown",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Fit Markdown\n\nMost relevant content extracted and converted to markdown. Ideal for:\n- Article extraction\n- Main content focus\n- Removing boilerplate\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nprint(result.fit_markdown)  # Only the main content\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class implements the fit_markdown property documented in the markdown section by storing the extracted and cleaned main content as an Optional[str] field that removes boilerplate content.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Fit Markdown\n\nMost relevant content extracted and converted to markdown. Ideal for:\n- Article extraction\n- Main content focus\n- Removing boilerplate\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nprint(result.fit_markdown)  # Only the main content\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface for web crawling operations, including the crawl() method that enables the markdown extraction functionality described in the documentation.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Fit Markdown\n\nMost relevant content extracted and converted to markdown. Ideal for:\n- Article extraction\n- Main content focus\n- Removing boilerplate\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nprint(result.fit_markdown)  # Only the main content\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements web crawling functionality that enables content extraction and markdown conversion by using Playwright to navigate web pages and retrieve their HTML content, which can then be processed to extract relevant content as described in the documentation.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Fit Markdown\n\nMost relevant content extracted and converted to markdown. Ideal for:\n- Article extraction\n- Main content focus\n- Removing boilerplate\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nprint(result.fit_markdown)  # Only the main content\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The .fit_markdown property mentioned in the documentation is implemented through the aprocess_html method which extracts and processes the result['fit_markdown'] field during web content crawling to provide cleaned, main content-focused markdown output.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Basic Proxy Setup\n\nSimple proxy configuration:\n\n```python\n# Using proxy URL\nasync with AsyncWebCrawler(\n    proxy=\"http://proxy.example.com:8080\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Using SOCKS proxy\nasync with AsyncWebCrawler(\n    proxy=\"socks5://proxy.example.com:1080\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation",
      "relationship_explanation": "The documentation snippet explicitly instantiates AsyncWebCrawler with a proxy parameter. The code example 'async with AsyncWebCrawler(proxy=...) as crawler:' directly references this class.",
      "predicted_trace_chain": "docs/md_v2/advanced/proxy-security.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The proxy configuration example originates from the proxy-security.md document and directly uses the AsyncWebCrawler class for setting up the crawl process.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements proxy support through its crawler_strategy parameter, which accepts proxy configurations as shown in the documentation's HTTP and SOCKS5 proxy examples during initialization.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Basic Proxy Setup\n\nSimple proxy configuration:\n\n```python\n# Using proxy URL\nasync with AsyncWebCrawler(\n    proxy=\"http://proxy.example.com:8080\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Using SOCKS proxy\nasync with AsyncWebCrawler(\n    proxy=\"socks5://proxy.example.com:1080\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "Within the snippet, the method 'arun' is explicitly called on the AsyncWebCrawler instance to perform the page crawl (e.g., 'result = await crawler.arun(url=\"https://example.com\")').",
      "predicted_trace_chain": "docs/md_v2/advanced/proxy-security.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "This chain shows the proxy configuration flows from instantiation of AsyncWebCrawler and is utilized when invoking its arun() method to execute the crawling operation.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method implements the core crawling functionality referenced in the proxy setup documentation by accepting and utilizing proxy configurations through its crawler_strategy component.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Basic Proxy Setup\n\nSimple proxy configuration:\n\n```python\n# Using proxy URL\nasync with AsyncWebCrawler(\n    proxy=\"http://proxy.example.com:8080\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Using SOCKS proxy\nasync with AsyncWebCrawler(\n    proxy=\"socks5://proxy.example.com:1080\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "default implementation dependency",
      "relationship_explanation": "AsyncWebCrawler, when not provided with an alternative, defaults to instantiating AsyncPlaywrightCrawlerStrategy with the provided keyword arguments (including the proxy parameter). Although not directly mentioned in the snippet, it is crucial for handling the proxy configuration under the hood.",
      "predicted_trace_chain": "docs/md_v2/advanced/proxy-security.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain indicates that the proxy parameter passed to AsyncWebCrawler is forwarded to its default crawling strategy, AsyncPlaywrightCrawlerStrategy, which ultimately implements the proxy support during crawling.",
      "ground_truth_relationship": "The code implements proxy support by accepting proxy URLs in both HTTP and SOCKS formats through the 'proxy' parameter in the AsyncPlaywrightCrawlerStrategy class, which is then configured in the browser launch arguments using Playwright's ProxySettings.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Basic Proxy Setup\n\nSimple proxy configuration:\n\n```python\n# Using proxy URL\nasync with AsyncWebCrawler(\n    proxy=\"http://proxy.example.com:8080\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Using SOCKS proxy\nasync with AsyncWebCrawler(\n    proxy=\"socks5://proxy.example.com:1080\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the data structure that stores the results of proxy-enabled web crawling operations shown in the documentation, including the crawled URL, HTML content, and various optional fields for metadata and error handling.",
      "ground_truth_trace_chain": "proxy-security.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Basic Proxy Setup\n\nSimple proxy configuration:\n\n```python\n# Using proxy URL\nasync with AsyncWebCrawler(\n    proxy=\"http://proxy.example.com:8080\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Using SOCKS proxy\nasync with AsyncWebCrawler(\n    proxy=\"socks5://proxy.example.com:1080\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface methods needed to implement proxy-based web crawling, which the documentation shows how to configure through the proxy parameter.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Example: Extracting Cryptocurrency Prices from Coinbase\n\nLet's look at an example that extracts cryptocurrency prices from the Coinbase explore page.\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_structured_data_using_css_extractor():\n    print(\"\\n--- Using JsonCssExtractionStrategy for Fast Structured Output ---\")\n    \n    # Define the extraction schema\n    schema = {\n        \"name\": \"Coinbase Crypto Prices\",\n        \"baseSelector\": \".cds-tableRow-t45thuk\",\n        \"fields\": [\n            {\n                \"name\": \"crypto\",\n                \"selector\": \"td:nth-child(1) h2\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"symbol\",\n                \"selector\": \"td:nth-child(1) p\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"price\",\n                \"selector\": \"td:nth-child(2)\",\n                \"type\": \"text\",\n            }\n        ],\n    }\n\n    # Create the extraction strategy\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    # Use the AsyncWebCrawler with the extraction strategy\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.coinbase.com/explore\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        # Parse the extracted content\n        crypto_prices = json.loads(result.extracted_content)\n        print(f\"Successfully extracted {len(crypto_prices)} cryptocurrency prices\")\n        print(json.dumps(crypto_prices[0], indent=2))\n\n    return crypto_prices\n\n# Run the async function\nasyncio.run(extract_structured_data_using_css_extractor())",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation",
      "relationship_explanation": "The documentation explicitly imports JsonCssExtractionStrategy and instantiates it with a defined extraction schema to extract cryptocurrency prices from Coinbase.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "Starting at the document 'docs/md_v2/extraction/css.md', the code snippet directly imports and creates an instance of JsonCssExtractionStrategy, which is used to process the structured extraction based on the provided schema.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class processes a schema-defined structure to extract cryptocurrency data from Coinbase's HTML using CSS selectors, where the example code demonstrates creating a schema with baseSelector for table rows and field selectors for crypto name, symbol, and price.",
      "ground_truth_trace_chain": "css.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example: Extracting Cryptocurrency Prices from Coinbase\n\nLet's look at an example that extracts cryptocurrency prices from the Coinbase explore page.\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_structured_data_using_css_extractor():\n    print(\"\\n--- Using JsonCssExtractionStrategy for Fast Structured Output ---\")\n    \n    # Define the extraction schema\n    schema = {\n        \"name\": \"Coinbase Crypto Prices\",\n        \"baseSelector\": \".cds-tableRow-t45thuk\",\n        \"fields\": [\n            {\n                \"name\": \"crypto\",\n                \"selector\": \"td:nth-child(1) h2\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"symbol\",\n                \"selector\": \"td:nth-child(1) p\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"price\",\n                \"selector\": \"td:nth-child(2)\",\n                \"type\": \"text\",\n            }\n        ],\n    }\n\n    # Create the extraction strategy\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    # Use the AsyncWebCrawler with the extraction strategy\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.coinbase.com/explore\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        # Parse the extracted content\n        crypto_prices = json.loads(result.extracted_content)\n        print(f\"Successfully extracted {len(crypto_prices)} cryptocurrency prices\")\n        print(json.dumps(crypto_prices[0], indent=2))\n\n    return crypto_prices\n\n# Run the async function\nasyncio.run(extract_structured_data_using_css_extractor())",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation",
      "relationship_explanation": "The documentation explicitly imports AsyncWebCrawler and uses it as an asynchronous context manager to initiate the crawling process.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "From the document 'docs/md_v2/extraction/css.md', AsyncWebCrawler is directly imported and instantiated to drive the crawling operation for extracting the data.",
      "ground_truth_relationship": "The AsyncWebCrawler code implements the cryptocurrency price extraction example by providing the core crawling functionality used in the arun() method to fetch and process the Coinbase webpage according to the specified JsonCssExtractionStrategy schema.",
      "ground_truth_trace_chain": "css.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example: Extracting Cryptocurrency Prices from Coinbase\n\nLet's look at an example that extracts cryptocurrency prices from the Coinbase explore page.\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_structured_data_using_css_extractor():\n    print(\"\\n--- Using JsonCssExtractionStrategy for Fast Structured Output ---\")\n    \n    # Define the extraction schema\n    schema = {\n        \"name\": \"Coinbase Crypto Prices\",\n        \"baseSelector\": \".cds-tableRow-t45thuk\",\n        \"fields\": [\n            {\n                \"name\": \"crypto\",\n                \"selector\": \"td:nth-child(1) h2\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"symbol\",\n                \"selector\": \"td:nth-child(1) p\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"price\",\n                \"selector\": \"td:nth-child(2)\",\n                \"type\": \"text\",\n            }\n        ],\n    }\n\n    # Create the extraction strategy\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    # Use the AsyncWebCrawler with the extraction strategy\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.coinbase.com/explore\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        # Parse the extracted content\n        crypto_prices = json.loads(result.extracted_content)\n        print(f\"Successfully extracted {len(crypto_prices)} cryptocurrency prices\")\n        print(json.dumps(crypto_prices[0], indent=2))\n\n    return crypto_prices\n\n# Run the async function\nasyncio.run(extract_structured_data_using_css_extractor())",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The code snippet calls the arun() method on the AsyncWebCrawler instance to perform the crawl, which triggers the extraction process.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The document first creates an AsyncWebCrawler instance then explicitly calls its arun() method; this chain is necessary because the crawl method returns a CrawlResult used later in data extraction.",
      "ground_truth_relationship": "The arun() method implements the core crawling functionality demonstrated in the documentation example by handling the URL request to Coinbase, applying the specified JsonCssExtractionStrategy, and returning structured cryptocurrency price data through CrawlResult.",
      "ground_truth_trace_chain": "css.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example: Extracting Cryptocurrency Prices from Coinbase\n\nLet's look at an example that extracts cryptocurrency prices from the Coinbase explore page.\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_structured_data_using_css_extractor():\n    print(\"\\n--- Using JsonCssExtractionStrategy for Fast Structured Output ---\")\n    \n    # Define the extraction schema\n    schema = {\n        \"name\": \"Coinbase Crypto Prices\",\n        \"baseSelector\": \".cds-tableRow-t45thuk\",\n        \"fields\": [\n            {\n                \"name\": \"crypto\",\n                \"selector\": \"td:nth-child(1) h2\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"symbol\",\n                \"selector\": \"td:nth-child(1) p\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"price\",\n                \"selector\": \"td:nth-child(2)\",\n                \"type\": \"text\",\n            }\n        ],\n    }\n\n    # Create the extraction strategy\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    # Use the AsyncWebCrawler with the extraction strategy\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.coinbase.com/explore\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        # Parse the extracted content\n        crypto_prices = json.loads(result.extracted_content)\n        print(f\"Successfully extracted {len(crypto_prices)} cryptocurrency prices\")\n        print(json.dumps(crypto_prices[0], indent=2))\n\n    return crypto_prices\n\n# Run the async function\nasyncio.run(extract_structured_data_using_css_extractor())",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 11,
      "artifact_title": "CrawlResult.extracted_content",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The extracted_content attribute is accessed from the CrawlResult object to retrieve the structured JSON output of the extraction.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> AsyncWebCrawler.arun() -> CrawlResult.extracted_content",
      "predicted_trace_chain_explanation": "After invoking AsyncWebCrawler.arun(), the document accesses the extracted_content attribute from the resulting CrawlResult; this step is essential for parsing the structured extraction data.",
      "ground_truth_relationship": "The extracted_content property stores the scraped cryptocurrency data in string format that gets parsed into JSON containing name, symbol, and price fields from Coinbase's webpage.",
      "ground_truth_trace_chain": "css.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example: Extracting Cryptocurrency Prices from Coinbase\n\nLet's look at an example that extracts cryptocurrency prices from the Coinbase explore page.\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_structured_data_using_css_extractor():\n    print(\"\\n--- Using JsonCssExtractionStrategy for Fast Structured Output ---\")\n    \n    # Define the extraction schema\n    schema = {\n        \"name\": \"Coinbase Crypto Prices\",\n        \"baseSelector\": \".cds-tableRow-t45thuk\",\n        \"fields\": [\n            {\n                \"name\": \"crypto\",\n                \"selector\": \"td:nth-child(1) h2\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"symbol\",\n                \"selector\": \"td:nth-child(1) p\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"price\",\n                \"selector\": \"td:nth-child(2)\",\n                \"type\": \"text\",\n            }\n        ],\n    }\n\n    # Create the extraction strategy\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    # Use the AsyncWebCrawler with the extraction strategy\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.coinbase.com/explore\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        # Parse the extracted content\n        crypto_prices = json.loads(result.extracted_content)\n        print(f\"Successfully extracted {len(crypto_prices)} cryptocurrency prices\")\n        print(json.dumps(crypto_prices[0], indent=2))\n\n    return crypto_prices\n\n# Run the async function\nasyncio.run(extract_structured_data_using_css_extractor())",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 20,
      "artifact_title": "CrawlResult.success",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute check",
      "relationship_explanation": "The code asserts the success attribute of the CrawlResult object to confirm that the crawling operation was successful.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> AsyncWebCrawler.arun() -> CrawlResult.success",
      "predicted_trace_chain_explanation": "Following the crawl process via AsyncWebCrawler.arun(), the document checks the CrawlResult.success attribute; this verifies the proper execution of the crawl before processing the extracted content.",
      "ground_truth_relationship": "The CrawlResult.success boolean property is used in the example code to verify that the cryptocurrency price crawl operation completed successfully before proceeding with data extraction.",
      "ground_truth_trace_chain": "css.md -> CrawlResult.success",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example: Extracting Cryptocurrency Prices from Coinbase\n\nLet's look at an example that extracts cryptocurrency prices from the Coinbase explore page.\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_structured_data_using_css_extractor():\n    print(\"\\n--- Using JsonCssExtractionStrategy for Fast Structured Output ---\")\n    \n    # Define the extraction schema\n    schema = {\n        \"name\": \"Coinbase Crypto Prices\",\n        \"baseSelector\": \".cds-tableRow-t45thuk\",\n        \"fields\": [\n            {\n                \"name\": \"crypto\",\n                \"selector\": \"td:nth-child(1) h2\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"symbol\",\n                \"selector\": \"td:nth-child(1) p\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"price\",\n                \"selector\": \"td:nth-child(2)\",\n                \"type\": \"text\",\n            }\n        ],\n    }\n\n    # Create the extraction strategy\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    # Use the AsyncWebCrawler with the extraction strategy\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.coinbase.com/explore\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        # Parse the extracted content\n        crypto_prices = json.loads(result.extracted_content)\n        print(f\"Successfully extracted {len(crypto_prices)} cryptocurrency prices\")\n        print(json.dumps(crypto_prices[0], indent=2))\n\n    return crypto_prices\n\n# Run the async function\nasyncio.run(extract_structured_data_using_css_extractor())",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the extracted cryptocurrency data from Coinbase in its extracted_content field, which is used in the example code to verify successful extraction and parse the crypto prices into a structured format.",
      "ground_truth_trace_chain": "css.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Example: Extracting Cryptocurrency Prices from Coinbase\n\nLet's look at an example that extracts cryptocurrency prices from the Coinbase explore page.\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_structured_data_using_css_extractor():\n    print(\"\\n--- Using JsonCssExtractionStrategy for Fast Structured Output ---\")\n    \n    # Define the extraction schema\n    schema = {\n        \"name\": \"Coinbase Crypto Prices\",\n        \"baseSelector\": \".cds-tableRow-t45thuk\",\n        \"fields\": [\n            {\n                \"name\": \"crypto\",\n                \"selector\": \"td:nth-child(1) h2\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"symbol\",\n                \"selector\": \"td:nth-child(1) p\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"price\",\n                \"selector\": \"td:nth-child(2)\",\n                \"type\": \"text\",\n            }\n        ],\n    }\n\n    # Create the extraction strategy\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    # Use the AsyncWebCrawler with the extraction strategy\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.coinbase.com/explore\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        # Parse the extracted content\n        crypto_prices = json.loads(result.extracted_content)\n        print(f\"Successfully extracted {len(crypto_prices)} cryptocurrency prices\")\n        print(json.dumps(crypto_prices[0], indent=2))\n\n    return crypto_prices\n\n# Run the async function\nasyncio.run(extract_structured_data_using_css_extractor())",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy implements the browser automation logic needed to extract cryptocurrency prices from Coinbase's explore page as shown in the documentation example, handling page navigation, DOM manipulation, and data extraction through Playwright's API.",
      "ground_truth_trace_chain": "css.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Example: Extracting Cryptocurrency Prices from Coinbase\n\nLet's look at an example that extracts cryptocurrency prices from the Coinbase explore page.\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_structured_data_using_css_extractor():\n    print(\"\\n--- Using JsonCssExtractionStrategy for Fast Structured Output ---\")\n    \n    # Define the extraction schema\n    schema = {\n        \"name\": \"Coinbase Crypto Prices\",\n        \"baseSelector\": \".cds-tableRow-t45thuk\",\n        \"fields\": [\n            {\n                \"name\": \"crypto\",\n                \"selector\": \"td:nth-child(1) h2\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"symbol\",\n                \"selector\": \"td:nth-child(1) p\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"price\",\n                \"selector\": \"td:nth-child(2)\",\n                \"type\": \"text\",\n            }\n        ],\n    }\n\n    # Create the extraction strategy\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    # Use the AsyncWebCrawler with the extraction strategy\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.coinbase.com/explore\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        # Parse the extracted content\n        crypto_prices = json.loads(result.extracted_content)\n        print(f\"Successfully extracted {len(crypto_prices)} cryptocurrency prices\")\n        print(json.dumps(crypto_prices[0], indent=2))\n\n    return crypto_prices\n\n# Run the async function\nasyncio.run(extract_structured_data_using_css_extractor())",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the core interface methods that enable the cryptocurrency price extraction example by providing essential crawling operations like crawl(), crawl_many(), and screenshot capabilities.",
      "ground_truth_trace_chain": "css.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Example: Extracting Cryptocurrency Prices from Coinbase\n\nLet's look at an example that extracts cryptocurrency prices from the Coinbase explore page.\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_structured_data_using_css_extractor():\n    print(\"\\n--- Using JsonCssExtractionStrategy for Fast Structured Output ---\")\n    \n    # Define the extraction schema\n    schema = {\n        \"name\": \"Coinbase Crypto Prices\",\n        \"baseSelector\": \".cds-tableRow-t45thuk\",\n        \"fields\": [\n            {\n                \"name\": \"crypto\",\n                \"selector\": \"td:nth-child(1) h2\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"symbol\",\n                \"selector\": \"td:nth-child(1) p\",\n                \"type\": \"text\",\n            },\n            {\n                \"name\": \"price\",\n                \"selector\": \"td:nth-child(2)\",\n                \"type\": \"text\",\n            }\n        ],\n    }\n\n    # Create the extraction strategy\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    # Use the AsyncWebCrawler with the extraction strategy\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.coinbase.com/explore\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        # Parse the extracted content\n        crypto_prices = json.loads(result.extracted_content)\n        print(f\"Successfully extracted {len(crypto_prices)} cryptocurrency prices\")\n        print(json.dumps(crypto_prices[0], indent=2))\n\n    return crypto_prices\n\n# Run the async function\nasyncio.run(extract_structured_data_using_css_extractor())",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_title": "ExtractionStrategy",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the core functionality shown in the Coinbase example by defining abstract extract() and run() methods that concrete strategies like JsonCssExtractionStrategy inherit to implement specific data extraction patterns.",
      "ground_truth_trace_chain": "css.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Combining with Magic Mode\n\nFor maximum protection, combine proxy with Magic Mode:\n\n```python\nasync with AsyncWebCrawler(\n    proxy=\"http://proxy.example.com:8080\",\n    headers={\"Accept-Language\": \"en-US\"}\n) as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        magic=True  # Enable all anti-detection features\n    )\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation/usage",
      "relationship_explanation": "The documentation snippet directly instantiates AsyncWebCrawler with proxy and headers parameters. This shows the intended use of AsyncWebCrawler to configure network settings and enable anti-detection features.",
      "predicted_trace_chain": "docs/md_v2/advanced/proxy-security.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain starts at the documentation file and immediately calls out AsyncWebCrawler as the primary class used for combining proxy settings with Magic Mode.",
      "ground_truth_relationship": "The AsyncWebCrawler class constructor accepts proxy and headers parameters shown in the documentation through its **kwargs argument, which are then passed to the AsyncPlaywrightCrawlerStrategy for implementing the proxy and magic mode features.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Combining with Magic Mode\n\nFor maximum protection, combine proxy with Magic Mode:\n\n```python\nasync with AsyncWebCrawler(\n    proxy=\"http://proxy.example.com:8080\",\n    headers={\"Accept-Language\": \"en-US\"}\n) as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        magic=True  # Enable all anti-detection features\n    )\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The usage example calls the 'arun' method on the AsyncWebCrawler instance with 'magic=True'. This explicitly triggers the crawling process with anti-detection features enabled.",
      "predicted_trace_chain": "docs/md_v2/advanced/proxy-security.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "This chain shows that after instantiating AsyncWebCrawler, the 'arun' method is invoked to perform the crawl with the 'magic' parameter, making it an essential step in the documented process.",
      "ground_truth_relationship": "The arun() method implements the documented proxy and magic mode functionality by accepting kwargs parameters that configure crawler settings like proxies and enabling anti-detection features through the crawler_strategy object.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Combining with Magic Mode\n\nFor maximum protection, combine proxy with Magic Mode:\n\n```python\nasync with AsyncWebCrawler(\n    proxy=\"http://proxy.example.com:8080\",\n    headers={\"Accept-Language\": \"en-US\"}\n) as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        magic=True  # Enable all anti-detection features\n    )\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "underlying implementation usage",
      "relationship_explanation": "AsyncWebCrawler defaults to using AsyncPlaywrightCrawlerStrategy when no custom crawler strategy is provided. Inside its 'crawl' method, it checks for flags like 'magic' (or 'simulate_user') to enable anti-detection features, making it a hidden but critical component for Magic Mode.",
      "predicted_trace_chain": "docs/md_v2/advanced/proxy-security.md -> AsyncWebCrawler -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain extends from the documentation through AsyncWebCrawler and its 'arun' method, showing that the actual crawling and magic mode behavior is implemented in AsyncPlaywrightCrawlerStrategy.",
      "ground_truth_relationship": "The code implements proxy configuration in the AsyncPlaywrightCrawlerStrategy class by setting up proxy settings during browser launch, which directly corresponds to the documentation's example of combining proxy settings with magic mode for enhanced protection.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Combining with Magic Mode\n\nFor maximum protection, combine proxy with Magic Mode:\n\n```python\nasync with AsyncWebCrawler(\n    proxy=\"http://proxy.example.com:8080\",\n    headers={\"Accept-Language\": \"en-US\"}\n) as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        magic=True  # Enable all anti-detection features\n    )\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance (base class)",
      "relationship_explanation": "AsyncPlaywrightCrawlerStrategy inherits from AsyncCrawlerStrategy. This base class establishes the interface for crawling strategies, of which the magic mode anti-detection feature is an implementation detail provided by its subclass.",
      "predicted_trace_chain": "docs/md_v2/advanced/proxy-security.md -> AsyncWebCrawler -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "This chain indicates that the magic mode functionality, while managed by AsyncPlaywrightCrawlerStrategy, is anchored in the interface specified by AsyncCrawlerStrategy, showing the design dependency.",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class provides the foundational methods that enable advanced crawling features like Magic Mode and proxy support shown in the documentation through its abstract crawl and configuration methods.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Combining with Magic Mode\n\nFor maximum protection, combine proxy with Magic Mode:\n\n```python\nasync with AsyncWebCrawler(\n    proxy=\"http://proxy.example.com:8080\",\n    headers={\"Accept-Language\": \"en-US\"}\n) as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        magic=True  # Enable all anti-detection features\n    )\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the structured output fields that store the results of a web crawl performed with AsyncWebCrawler, including fields like 'success' and 'cleaned_html' that are particularly relevant when magic mode is enabled for enhanced anti-detection.",
      "ground_truth_trace_chain": "proxy-security.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Hypothetical Website Example\n\nLet's consider a hypothetical e-commerce website that displays product categories, each containing multiple products. Each product has details, reviews, and related items. This complex structure will allow us to demonstrate various advanced features of JsonCssExtractionStrategy.\n\nAssume the HTML structure looks something like this:\n\n```html\n<div class=\"category\">\n  <h2 class=\"category-name\">Electronics</h2>\n  <div class=\"product\">\n    <h3 class=\"product-name\">Smartphone X</h3>\n    <p class=\"product-price\">$999</p>\n    <div class=\"product-details\">\n      <span class=\"brand\">TechCorp</span>\n      <span class=\"model\">X-2000</span>\n    </div>\n    <ul class=\"product-features\">\n      <li>5G capable</li>\n      <li>6.5\" OLED screen</li>\n      <li>128GB storage</li>\n    </ul>\n    <div class=\"product-reviews\">\n      <div class=\"review\">\n        <span class=\"reviewer\">John D.</span>\n        <span class=\"rating\">4.5</span>\n        <p class=\"review-text\">Great phone, love the camera!</p>\n      </div>\n      <div class=\"review\">\n        <span class=\"reviewer\">Jane S.</span>\n        <span class=\"rating\">5</span>\n        <p class=\"review-text\">Best smartphone I've ever owned.</p>\n      </div>\n    </div>\n    <ul class=\"related-products\">\n      <li>\n        <span class=\"related-name\">Phone Case</span>\n        <span class=\"related-price\">$29.99</span>\n      </li>\n      <li>\n        <span class=\"related-name\">Screen Protector</span>\n        <span class=\"related-price\">$9.99</span>\n      </li>\n    </ul>\n  </div>\n  <!-- More products... -->\n</div>\n```",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "extends",
      "relationship_explanation": "The documentation explicitly refers to 'advanced features of JsonCssExtractionStrategy' as a means to demonstrate how a complex HTML structure (such as one for an e-commerce website with categories, products, reviews, and related items) can be processed. This indicates that the JsonCssExtractionStrategy is intended for parsing such structured data using CSS selectors and JSON extraction.",
      "predicted_trace_chain": "css-advanced.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The document 'css-advanced.md' introduces advanced extraction methods. JsonCssExtractionStrategy is directly mentioned and is implemented by extending ExtractionStrategy. Thus, the chain begins at the document, references its abstract base (ExtractionStrategy), and culminates in the derived class.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class uses BeautifulSoup to parse and extract structured data from HTML elements like the documented e-commerce product listings by mapping CSS selectors to desired fields in a schema.",
      "ground_truth_trace_chain": "css-advanced.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Hypothetical Website Example\n\nLet's consider a hypothetical e-commerce website that displays product categories, each containing multiple products. Each product has details, reviews, and related items. This complex structure will allow us to demonstrate various advanced features of JsonCssExtractionStrategy.\n\nAssume the HTML structure looks something like this:\n\n```html\n<div class=\"category\">\n  <h2 class=\"category-name\">Electronics</h2>\n  <div class=\"product\">\n    <h3 class=\"product-name\">Smartphone X</h3>\n    <p class=\"product-price\">$999</p>\n    <div class=\"product-details\">\n      <span class=\"brand\">TechCorp</span>\n      <span class=\"model\">X-2000</span>\n    </div>\n    <ul class=\"product-features\">\n      <li>5G capable</li>\n      <li>6.5\" OLED screen</li>\n      <li>128GB storage</li>\n    </ul>\n    <div class=\"product-reviews\">\n      <div class=\"review\">\n        <span class=\"reviewer\">John D.</span>\n        <span class=\"rating\">4.5</span>\n        <p class=\"review-text\">Great phone, love the camera!</p>\n      </div>\n      <div class=\"review\">\n        <span class=\"reviewer\">Jane S.</span>\n        <span class=\"rating\">5</span>\n        <p class=\"review-text\">Best smartphone I've ever owned.</p>\n      </div>\n    </div>\n    <ul class=\"related-products\">\n      <li>\n        <span class=\"related-name\">Phone Case</span>\n        <span class=\"related-price\">$29.99</span>\n      </li>\n      <li>\n        <span class=\"related-name\">Screen Protector</span>\n        <span class=\"related-price\">$9.99</span>\n      </li>\n    </ul>\n  </div>\n  <!-- More products... -->\n</div>\n```",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "While ExtractionStrategy is not directly mentioned in the documentation snippet, it is the foundational abstract base class for extraction strategies. Since JsonCssExtractionStrategy extends ExtractionStrategy, it is implicitly part of the demonstrated extraction approach.",
      "predicted_trace_chain": "css-advanced.md -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The extraction approach showcased in the document derives from the abstract behavior defined in ExtractionStrategy. This relationship is implicit because the document centers on advanced extraction features, which necessitate the use of a base extraction framework.",
      "ground_truth_relationship": "The ExtractionStrategy class serves as an abstract base class with methods to extract and process structured data from HTML content like the documented e-commerce website example, where complex nested elements (products, reviews, features) need to be parsed systematically.",
      "ground_truth_trace_chain": "css-advanced.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example 1: Basic Session-Based Crawling\n\nLet's start with a basic example of session-based crawling:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def basic_session_crawl():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        session_id = \"my_session\"\n        url = \"https://example.com/dynamic-content\"\n\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                js_code=\"document.querySelector('.load-more-button').click();\" if page > 0 else None,\n                css_selector=\".content-item\",\n                bypass_cache=True\n            )\n            \n            print(f\"Page {page + 1}: Found {result.extracted_content.count('.content-item')} items\")\n\n        await crawler.crawler_strategy.kill_session(session_id)\n\nasyncio.run(basic_session_crawl())\n```\n\nThis example demonstrates:\n1. Using a consistent `session_id` across multiple `arun` calls\n2. Executing JavaScript to load more content after the first page\n3. Using a CSS selector to extract specific content\n4. Properly closing the session after crawling",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "class instantiation & usage",
      "relationship_explanation": "The documentation snippet explicitly imports and instantiates AsyncWebCrawler using an 'async with' statement. This shows that the example relies on AsyncWebCrawler as the primary entry point for session-based crawling.",
      "predicted_trace_chain": "session-management-advanced.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The trace starts from the documentation file where AsyncWebCrawler is directly instantiated, emphasizing its role in managing crawling sessions.",
      "ground_truth_relationship": "The documented session-based crawling example demonstrates the usage of the AsyncWebCrawler class's core methods like __aenter__, arun, and crawler_strategy.kill_session for handling persistent browser sessions with specific user interactions.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example 1: Basic Session-Based Crawling\n\nLet's start with a basic example of session-based crawling:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def basic_session_crawl():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        session_id = \"my_session\"\n        url = \"https://example.com/dynamic-content\"\n\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                js_code=\"document.querySelector('.load-more-button').click();\" if page > 0 else None,\n                css_selector=\".content-item\",\n                bypass_cache=True\n            )\n            \n            print(f\"Page {page + 1}: Found {result.extracted_content.count('.content-item')} items\")\n\n        await crawler.crawler_strategy.kill_session(session_id)\n\nasyncio.run(basic_session_crawl())\n```\n\nThis example demonstrates:\n1. Using a consistent `session_id` across multiple `arun` calls\n2. Executing JavaScript to load more content after the first page\n3. Using a CSS selector to extract specific content\n4. Properly closing the session after crawling",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The example code explicitly calls the arun() method on the AsyncWebCrawler instance to perform the crawling task for each page, including dynamic content loading and content extraction.",
      "predicted_trace_chain": "session-management-advanced.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain follows from the documentation file to the instantiation of AsyncWebCrawler and then to the explicit invocation of its arun() method, demonstrating basic session-based crawling.",
      "ground_truth_relationship": "The code implements session-based crawling through the arun() method by accepting a session_id parameter which maintains state across multiple crawl requests, exactly as demonstrated in the documentation example where a consistent session_id is used across multiple crawl operations.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example 1: Basic Session-Based Crawling\n\nLet's start with a basic example of session-based crawling:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def basic_session_crawl():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        session_id = \"my_session\"\n        url = \"https://example.com/dynamic-content\"\n\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                js_code=\"document.querySelector('.load-more-button').click();\" if page > 0 else None,\n                css_selector=\".content-item\",\n                bypass_cache=True\n            )\n            \n            print(f\"Page {page + 1}: Found {result.extracted_content.count('.content-item')} items\")\n\n        await crawler.crawler_strategy.kill_session(session_id)\n\nasyncio.run(basic_session_crawl())\n```\n\nThis example demonstrates:\n1. Using a consistent `session_id` across multiple `arun` calls\n2. Executing JavaScript to load more content after the first page\n3. Using a CSS selector to extract specific content\n4. Properly closing the session after crawling",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 2,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The snippet calls kill_session() via the crawler_strategy attribute of AsyncWebCrawler to properly close the session. This direct call ensures that session management is properly handled after crawling.",
      "predicted_trace_chain": "session-management-advanced.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_trace_chain_explanation": "Since AsyncWebCrawler uses AsyncPlaywrightCrawlerStrategy as its default crawler_strategy, the invocation of kill_session() forms the final step in the session management chain as illustrated in the documentation.",
      "ground_truth_relationship": "The kill_session method directly implements the session cleanup mentioned in the documentation's step 4 by closing both the page and context objects and removing the session from memory when crawling is complete.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example 1: Basic Session-Based Crawling\n\nLet's start with a basic example of session-based crawling:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def basic_session_crawl():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        session_id = \"my_session\"\n        url = \"https://example.com/dynamic-content\"\n\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                js_code=\"document.querySelector('.load-more-button').click();\" if page > 0 else None,\n                css_selector=\".content-item\",\n                bypass_cache=True\n            )\n            \n            print(f\"Page {page + 1}: Found {result.extracted_content.count('.content-item')} items\")\n\n        await crawler.crawler_strategy.kill_session(session_id)\n\nasyncio.run(basic_session_crawl())\n```\n\nThis example demonstrates:\n1. Using a consistent `session_id` across multiple `arun` calls\n2. Executing JavaScript to load more content after the first page\n3. Using a CSS selector to extract specific content\n4. Properly closing the session after crawling",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the structure for storing crawling results that are referenced in the example code, particularly through the 'result' variable which captures extracted content, session IDs, and other crawl-related data.",
      "ground_truth_trace_chain": "session-management-advanced.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Example 1: Basic Session-Based Crawling\n\nLet's start with a basic example of session-based crawling:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def basic_session_crawl():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        session_id = \"my_session\"\n        url = \"https://example.com/dynamic-content\"\n\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                js_code=\"document.querySelector('.load-more-button').click();\" if page > 0 else None,\n                css_selector=\".content-item\",\n                bypass_cache=True\n            )\n            \n            print(f\"Page {page + 1}: Found {result.extracted_content.count('.content-item')} items\")\n\n        await crawler.crawler_strategy.kill_session(session_id)\n\nasyncio.run(basic_session_crawl())\n```\n\nThis example demonstrates:\n1. Using a consistent `session_id` across multiple `arun` calls\n2. Executing JavaScript to load more content after the first page\n3. Using a CSS selector to extract specific content\n4. Properly closing the session after crawling",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_title": "CrawlResult.extracted_content",
      "ground_truth_relationship": "The extracted_content property stores the HTML content matching the '.content-item' CSS selector as shown in the example where it's used to count found items after each crawl.",
      "ground_truth_trace_chain": "session-management-advanced.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Example 1: Basic Session-Based Crawling\n\nLet's start with a basic example of session-based crawling:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def basic_session_crawl():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        session_id = \"my_session\"\n        url = \"https://example.com/dynamic-content\"\n\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                js_code=\"document.querySelector('.load-more-button').click();\" if page > 0 else None,\n                css_selector=\".content-item\",\n                bypass_cache=True\n            )\n            \n            print(f\"Page {page + 1}: Found {result.extracted_content.count('.content-item')} items\")\n\n        await crawler.crawler_strategy.kill_session(session_id)\n\nasyncio.run(basic_session_crawl())\n```\n\nThis example demonstrates:\n1. Using a consistent `session_id` across multiple `arun` calls\n2. Executing JavaScript to load more content after the first page\n3. Using a CSS selector to extract specific content\n4. Properly closing the session after crawling",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements session-based crawling by maintaining a sessions dictionary that maps session_ids to browser contexts and pages, allowing for stateful interactions across multiple requests as shown in the documentation example.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Example 1: Basic Session-Based Crawling\n\nLet's start with a basic example of session-based crawling:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def basic_session_crawl():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        session_id = \"my_session\"\n        url = \"https://example.com/dynamic-content\"\n\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                js_code=\"document.querySelector('.load-more-button').click();\" if page > 0 else None,\n                css_selector=\".content-item\",\n                bypass_cache=True\n            )\n            \n            print(f\"Page {page + 1}: Found {result.extracted_content.count('.content-item')} items\")\n\n        await crawler.crawler_strategy.kill_session(session_id)\n\nasyncio.run(basic_session_crawl())\n```\n\nThis example demonstrates:\n1. Using a consistent `session_id` across multiple `arun` calls\n2. Executing JavaScript to load more content after the first page\n3. Using a CSS selector to extract specific content\n4. Properly closing the session after crawling",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the core methods that enable session-based crawling functionality shown in the documentation example, with crawl() and crawl_many() methods being essential for handling both single and batch URL processing.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Technique 3: Using the `wait_for` Parameter Crawl4AI provides a `wait_for` parameter that allows you to specify a condition to wait for before considering the page fully loaded. This can be particularly useful for dynamic content. Here's an example: ```python async def wait_for_parameter_crawl(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/example/repo/commits/main\" session_id = \"wait_for_session\" all_commits = [] js_next_page = \"\"\" const commits = document.querySelectorAll('li.commit-item h4'); if (commits.length > 0) { window.lastCommit = commits[0].textContent.trim(); } const button = document.querySelector('a.pagination-next'); if (button) button.click(); \"\"\" wait_for = \"\"\"() => { const commits = document.querySelectorAll('li.commit-item h4'); if (commits.length === 0) return false; const firstCommit = commits[0].textContent.trim(); return firstCommit !== window.lastCommit; }\"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.commit-item\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.commit-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3): result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.commit-item\", extraction_strategy=extraction_strategy, js_code=js_next_page if page > 0 else None, wait_for=wait_for if page > 0 else None, js_only=page > 0, bypass_cache=True ) commits = json.loads(result.extracted_content) all_commits.extend(commits) print(f\"Page {page + 1}: Found {len(commits)} commits\") await crawler.crawler_strategy.kill_session(session_id) print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\") asyncio.run(wait_for_parameter_crawl()) ``` This technique separates the JavaScript execution (clicking the \"next\" button) from the waiting condition, providing more flexibility and clarity in some scenarios.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation/usage",
      "relationship_explanation": "The documentation snippet explicitly uses AsyncWebCrawler within an async context (async with AsyncWebCrawler(verbose=True)) to initiate a crawl session. This shows that AsyncWebCrawler is the entry point for the crawling operation.",
      "predicted_trace_chain": "session-management-advanced.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain begins with the document (session-management-advanced.md) and then directly invokes AsyncWebCrawler, as seen in the example's instantiation.",
      "ground_truth_relationship": "The AsyncWebCrawler class supports the wait_for parameter through its arun method's **kwargs parameter, which gets passed to the crawler_strategy's crawl method for handling page load conditions.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Technique 3: Using the `wait_for` Parameter Crawl4AI provides a `wait_for` parameter that allows you to specify a condition to wait for before considering the page fully loaded. This can be particularly useful for dynamic content. Here's an example: ```python async def wait_for_parameter_crawl(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/example/repo/commits/main\" session_id = \"wait_for_session\" all_commits = [] js_next_page = \"\"\" const commits = document.querySelectorAll('li.commit-item h4'); if (commits.length > 0) { window.lastCommit = commits[0].textContent.trim(); } const button = document.querySelector('a.pagination-next'); if (button) button.click(); \"\"\" wait_for = \"\"\"() => { const commits = document.querySelectorAll('li.commit-item h4'); if (commits.length === 0) return false; const firstCommit = commits[0].textContent.trim(); return firstCommit !== window.lastCommit; }\"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.commit-item\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.commit-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3): result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.commit-item\", extraction_strategy=extraction_strategy, js_code=js_next_page if page > 0 else None, wait_for=wait_for if page > 0 else None, js_only=page > 0, bypass_cache=True ) commits = json.loads(result.extracted_content) all_commits.extend(commits) print(f\"Page {page + 1}: Found {len(commits)} commits\") await crawler.crawler_strategy.kill_session(session_id) print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\") asyncio.run(wait_for_parameter_crawl()) ``` This technique separates the JavaScript execution (clicking the \"next\" button) from the waiting condition, providing more flexibility and clarity in some scenarios.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method usage",
      "relationship_explanation": "The code snippet explicitly calls the arun() method (e.g., result = await crawler.arun(...)) to execute the crawling operation with parameters such as wait_for, js_code, and extraction_strategy.",
      "predicted_trace_chain": "session-management-advanced.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the document, AsyncWebCrawler is used and its arun() method is subsequently called to process the crawl, demonstrating the operational flow.",
      "ground_truth_relationship": "The `arun()` method implements the documented `wait_for` parameter functionality by accepting it through its `**kwargs` argument and passing it to the crawler_strategy.crawl() method, where it's used to control page loading conditions.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Technique 3: Using the `wait_for` Parameter Crawl4AI provides a `wait_for` parameter that allows you to specify a condition to wait for before considering the page fully loaded. This can be particularly useful for dynamic content. Here's an example: ```python async def wait_for_parameter_crawl(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/example/repo/commits/main\" session_id = \"wait_for_session\" all_commits = [] js_next_page = \"\"\" const commits = document.querySelectorAll('li.commit-item h4'); if (commits.length > 0) { window.lastCommit = commits[0].textContent.trim(); } const button = document.querySelector('a.pagination-next'); if (button) button.click(); \"\"\" wait_for = \"\"\"() => { const commits = document.querySelectorAll('li.commit-item h4'); if (commits.length === 0) return false; const firstCommit = commits[0].textContent.trim(); return firstCommit !== window.lastCommit; }\"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.commit-item\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.commit-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3): result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.commit-item\", extraction_strategy=extraction_strategy, js_code=js_next_page if page > 0 else None, wait_for=wait_for if page > 0 else None, js_only=page > 0, bypass_cache=True ) commits = json.loads(result.extracted_content) all_commits.extend(commits) print(f\"Page {page + 1}: Found {len(commits)} commits\") await crawler.crawler_strategy.kill_session(session_id) print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\") asyncio.run(wait_for_parameter_crawl()) ``` This technique separates the JavaScript execution (clicking the \"next\" button) from the waiting condition, providing more flexibility and clarity in some scenarios.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "class instantiation",
      "relationship_explanation": "In the example, a new instance of JsonCssExtractionStrategy is explicitly created with a schema for commit extraction. This shows its role as the extraction strategy in the crawling process.",
      "predicted_trace_chain": "session-management-advanced.md -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain directly traces from the document to the instantiation of JsonCssExtractionStrategy, emphasizing its dedicated extraction functionality.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class implements the schema-based data extraction functionality used in the documentation's example by parsing HTML elements with BeautifulSoup according to the specified baseSelector and field selectors defined in the schema.",
      "ground_truth_trace_chain": "session-management-advanced.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Technique 3: Using the `wait_for` Parameter Crawl4AI provides a `wait_for` parameter that allows you to specify a condition to wait for before considering the page fully loaded. This can be particularly useful for dynamic content. Here's an example: ```python async def wait_for_parameter_crawl(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/example/repo/commits/main\" session_id = \"wait_for_session\" all_commits = [] js_next_page = \"\"\" const commits = document.querySelectorAll('li.commit-item h4'); if (commits.length > 0) { window.lastCommit = commits[0].textContent.trim(); } const button = document.querySelector('a.pagination-next'); if (button) button.click(); \"\"\" wait_for = \"\"\"() => { const commits = document.querySelectorAll('li.commit-item h4'); if (commits.length === 0) return false; const firstCommit = commits[0].textContent.trim(); return firstCommit !== window.lastCommit; }\"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.commit-item\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.commit-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3): result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.commit-item\", extraction_strategy=extraction_strategy, js_code=js_next_page if page > 0 else None, wait_for=wait_for if page > 0 else None, js_only=page > 0, bypass_cache=True ) commits = json.loads(result.extracted_content) all_commits.extend(commits) print(f\"Page {page + 1}: Found {len(commits)} commits\") await crawler.crawler_strategy.kill_session(session_id) print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\") asyncio.run(wait_for_parameter_crawl()) ``` This technique separates the JavaScript execution (clicking the \"next\" button) from the waiting condition, providing more flexibility and clarity in some scenarios.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 2,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_relationship": "explicit",
      "relationship_type": "method call",
      "relationship_explanation": "The snippet explicitly calls kill_session() (via crawler.crawler_strategy.kill_session(session_id)) to terminate the session after crawling. This confirms that session management is integrated into the process.",
      "predicted_trace_chain": "session-management-advanced.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_trace_chain_explanation": "The chain reflects that after using AsyncWebCrawler and its underlying strategy, the kill_session() method is invoked to clean up the session.",
      "ground_truth_relationship": "The kill_session method cleans up browser resources by closing the page and context objects after the wait_for-based crawling is complete, as shown in the documentation's final step where crawler.crawler_strategy.kill_session(session_id) is called.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Technique 3: Using the `wait_for` Parameter Crawl4AI provides a `wait_for` parameter that allows you to specify a condition to wait for before considering the page fully loaded. This can be particularly useful for dynamic content. Here's an example: ```python async def wait_for_parameter_crawl(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/example/repo/commits/main\" session_id = \"wait_for_session\" all_commits = [] js_next_page = \"\"\" const commits = document.querySelectorAll('li.commit-item h4'); if (commits.length > 0) { window.lastCommit = commits[0].textContent.trim(); } const button = document.querySelector('a.pagination-next'); if (button) button.click(); \"\"\" wait_for = \"\"\"() => { const commits = document.querySelectorAll('li.commit-item h4'); if (commits.length === 0) return false; const firstCommit = commits[0].textContent.trim(); return firstCommit !== window.lastCommit; }\"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.commit-item\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.commit-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3): result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.commit-item\", extraction_strategy=extraction_strategy, js_code=js_next_page if page > 0 else None, wait_for=wait_for if page > 0 else None, js_only=page > 0, bypass_cache=True ) commits = json.loads(result.extracted_content) all_commits.extend(commits) print(f\"Page {page + 1}: Found {len(commits)} commits\") await crawler.crawler_strategy.kill_session(session_id) print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\") asyncio.run(wait_for_parameter_crawl()) ``` This technique separates the JavaScript execution (clicking the \"next\" button) from the waiting condition, providing more flexibility and clarity in some scenarios.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "default instantiation (extension)",
      "relationship_explanation": "Although the snippet does not directly name AsyncPlaywrightCrawlerStrategy, AsyncWebCrawler defaults to this strategy for handling crawling operations. This indirectly provides the wait_for functionality and other dynamic content-handling capabilities.",
      "predicted_trace_chain": "session-management-advanced.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The document's use of AsyncWebCrawler implies that its default crawler strategy, AsyncPlaywrightCrawlerStrategy, is instantiated and used to enable the advanced waiting (wait_for) behavior.",
      "ground_truth_relationship": "The code implements the documented wait_for functionality through the smart_wait method in AsyncPlaywrightCrawlerStrategy, which evaluates either CSS selectors or JavaScript functions to determine when a page has finished loading dynamic content.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Technique 3: Using the `wait_for` Parameter Crawl4AI provides a `wait_for` parameter that allows you to specify a condition to wait for before considering the page fully loaded. This can be particularly useful for dynamic content. Here's an example: ```python async def wait_for_parameter_crawl(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/example/repo/commits/main\" session_id = \"wait_for_session\" all_commits = [] js_next_page = \"\"\" const commits = document.querySelectorAll('li.commit-item h4'); if (commits.length > 0) { window.lastCommit = commits[0].textContent.trim(); } const button = document.querySelector('a.pagination-next'); if (button) button.click(); \"\"\" wait_for = \"\"\"() => { const commits = document.querySelectorAll('li.commit-item h4'); if (commits.length === 0) return false; const firstCommit = commits[0].textContent.trim(); return firstCommit !== window.lastCommit; }\"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.commit-item\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.commit-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3): result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.commit-item\", extraction_strategy=extraction_strategy, js_code=js_next_page if page > 0 else None, wait_for=wait_for if page > 0 else None, js_only=page > 0, bypass_cache=True ) commits = json.loads(result.extracted_content) all_commits.extend(commits) print(f\"Page {page + 1}: Found {len(commits)} commits\") await crawler.crawler_strategy.kill_session(session_id) print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\") asyncio.run(wait_for_parameter_crawl()) ``` This technique separates the JavaScript execution (clicking the \"next\" button) from the waiting condition, providing more flexibility and clarity in some scenarios.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_title": "CrawlResult.extracted_content",
      "ground_truth_relationship": "The extracted_content field in CrawlResult stores the JSON-formatted commit data obtained from the page after waiting for the specified condition to be met using the wait_for parameter.",
      "ground_truth_trace_chain": "session-management-advanced.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Technique 3: Using the `wait_for` Parameter Crawl4AI provides a `wait_for` parameter that allows you to specify a condition to wait for before considering the page fully loaded. This can be particularly useful for dynamic content. Here's an example: ```python async def wait_for_parameter_crawl(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/example/repo/commits/main\" session_id = \"wait_for_session\" all_commits = [] js_next_page = \"\"\" const commits = document.querySelectorAll('li.commit-item h4'); if (commits.length > 0) { window.lastCommit = commits[0].textContent.trim(); } const button = document.querySelector('a.pagination-next'); if (button) button.click(); \"\"\" wait_for = \"\"\"() => { const commits = document.querySelectorAll('li.commit-item h4'); if (commits.length === 0) return false; const firstCommit = commits[0].textContent.trim(); return firstCommit !== window.lastCommit; }\"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.commit-item\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.commit-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3): result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.commit-item\", extraction_strategy=extraction_strategy, js_code=js_next_page if page > 0 else None, wait_for=wait_for if page > 0 else None, js_only=page > 0, bypass_cache=True ) commits = json.loads(result.extracted_content) all_commits.extend(commits) print(f\"Page {page + 1}: Found {len(commits)} commits\") await crawler.crawler_strategy.kill_session(session_id) print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\") asyncio.run(wait_for_parameter_crawl()) ``` This technique separates the JavaScript execution (clicking the \"next\" button) from the waiting condition, providing more flexibility and clarity in some scenarios.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class provides the foundational structure for implementing waiting behaviors through its crawl method, which the documentation's wait_for parameter utilizes to control page load completion conditions.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Technique 3: Using the `wait_for` Parameter Crawl4AI provides a `wait_for` parameter that allows you to specify a condition to wait for before considering the page fully loaded. This can be particularly useful for dynamic content. Here's an example: ```python async def wait_for_parameter_crawl(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/example/repo/commits/main\" session_id = \"wait_for_session\" all_commits = [] js_next_page = \"\"\" const commits = document.querySelectorAll('li.commit-item h4'); if (commits.length > 0) { window.lastCommit = commits[0].textContent.trim(); } const button = document.querySelector('a.pagination-next'); if (button) button.click(); \"\"\" wait_for = \"\"\"() => { const commits = document.querySelectorAll('li.commit-item h4'); if (commits.length === 0) return false; const firstCommit = commits[0].textContent.trim(); return firstCommit !== window.lastCommit; }\"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.commit-item\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.commit-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3): result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.commit-item\", extraction_strategy=extraction_strategy, js_code=js_next_page if page > 0 else None, wait_for=wait_for if page > 0 else None, js_only=page > 0, bypass_cache=True ) commits = json.loads(result.extracted_content) all_commits.extend(commits) print(f\"Page {page + 1}: Found {len(commits)} commits\") await crawler.crawler_strategy.kill_session(session_id) print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\") asyncio.run(wait_for_parameter_crawl()) ``` This technique separates the JavaScript execution (clicking the \"next\" button) from the waiting condition, providing more flexibility and clarity in some scenarios.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_title": "ExtractionStrategy",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the foundation for handling the extraction_strategy parameter shown in the documentation's example code, defining the abstract interface for parsing HTML content that concrete implementations like JsonCssExtractionStrategy use to extract commit information.",
      "ground_truth_trace_chain": "session-management-advanced.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Metadata Extraction\n\nCrawl4AI automatically extracts and processes page metadata, providing valuable information about the content:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\nmetadata = result.metadata\nprint(f\"Title: {metadata['title']}\")\nprint(f\"Description: {metadata['description']}\")\nprint(f\"Keywords: {metadata['keywords']}\")\nprint(f\"Author: {metadata['author']}\")\nprint(f\"Published Date: {metadata['published_date']}\")\nprint(f\"Modified Date: {metadata['modified_date']}\")\nprint(f\"Language: {metadata['language']}\")\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The documentation snippet shows a call to 'crawler.arun(url=\"https://example.com\")'. This directly maps to the AsyncWebCrawler.arun() method, which is responsible for initiating the crawl process and returning a CrawlResult instance that holds metadata among other information.",
      "predicted_trace_chain": "docs/md_v2/advanced/content-processing.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain starts from the documentation file (docs/md_v2/advanced/content-processing.md) where the crawl function is demonstrated and links directly to the AsyncWebCrawler.arun() method, which is explicitly invoked in the provided code sample.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method processes webpage content and returns a CrawlResult object containing metadata fields like title, description, and language that can be accessed through the .metadata property as shown in the documentation example.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Metadata Extraction\n\nCrawl4AI automatically extracts and processes page metadata, providing valuable information about the content:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\nmetadata = result.metadata\nprint(f\"Title: {metadata['title']}\")\nprint(f\"Description: {metadata['description']}\")\nprint(f\"Keywords: {metadata['keywords']}\")\nprint(f\"Author: {metadata['author']}\")\nprint(f\"Published Date: {metadata['published_date']}\")\nprint(f\"Modified Date: {metadata['modified_date']}\")\nprint(f\"Language: {metadata['language']}\")\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 17,
      "artifact_title": "CrawlResult.metadata",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "After obtaining the result from the crawler.arun() call, the snippet accesses 'result.metadata' to print metadata such as title, description, keywords, and others. This attribute is implemented as the 'metadata' field in the CrawlResult class, making it the point of extraction for page metadata.",
      "predicted_trace_chain": "docs/md_v2/advanced/content-processing.md -> AsyncWebCrawler.arun() -> CrawlResult.metadata",
      "predicted_trace_chain_explanation": "The chain demonstrates the flow from the documentation file to the AsyncWebCrawler.arun() method (which returns a CrawlResult), and finally to the metadata attribute of CrawlResult, which supplies the metadata details used in the example.",
      "ground_truth_relationship": "The metadata property of CrawlResult stores extracted page metadata as an optional dictionary containing fields like title, description, keywords, author, and dates as documented in the usage example.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult.metadata",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Metadata Extraction\n\nCrawl4AI automatically extracts and processes page metadata, providing valuable information about the content:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\nmetadata = result.metadata\nprint(f\"Title: {metadata['title']}\")\nprint(f\"Description: {metadata['description']}\")\nprint(f\"Keywords: {metadata['keywords']}\")\nprint(f\"Author: {metadata['author']}\")\nprint(f\"Published Date: {metadata['published_date']}\")\nprint(f\"Modified Date: {metadata['modified_date']}\")\nprint(f\"Language: {metadata['language']}\")\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The metadata extraction documented in the example is implemented through the metadata field in the CrawlResult class which stores the extracted page metadata as an optional dictionary.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Metadata Extraction\n\nCrawl4AI automatically extracts and processes page metadata, providing valuable information about the content:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\nmetadata = result.metadata\nprint(f\"Title: {metadata['title']}\")\nprint(f\"Description: {metadata['description']}\")\nprint(f\"Keywords: {metadata['keywords']}\")\nprint(f\"Author: {metadata['author']}\")\nprint(f\"Published Date: {metadata['published_date']}\")\nprint(f\"Modified Date: {metadata['modified_date']}\")\nprint(f\"Language: {metadata['language']}\")\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface for implementing metadata extraction through its crawl method, which returns AsyncCrawlResponse objects containing the metadata fields shown in the documentation example.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Metadata Extraction\n\nCrawl4AI automatically extracts and processes page metadata, providing valuable information about the content:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\nmetadata = result.metadata\nprint(f\"Title: {metadata['title']}\")\nprint(f\"Description: {metadata['description']}\")\nprint(f\"Keywords: {metadata['keywords']}\")\nprint(f\"Author: {metadata['author']}\")\nprint(f\"Published Date: {metadata['published_date']}\")\nprint(f\"Modified Date: {metadata['modified_date']}\")\nprint(f\"Language: {metadata['language']}\")\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class extracts metadata from web pages by navigating to URLs and accessing page content through Playwright's browser automation, which enables the metadata extraction functionality documented in the example code snippet.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Metadata Extraction\n\nCrawl4AI automatically extracts and processes page metadata, providing valuable information about the content:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\nmetadata = result.metadata\nprint(f\"Title: {metadata['title']}\")\nprint(f\"Description: {metadata['description']}\")\nprint(f\"Keywords: {metadata['keywords']}\")\nprint(f\"Author: {metadata['author']}\")\nprint(f\"Published Date: {metadata['published_date']}\")\nprint(f\"Modified Date: {metadata['modified_date']}\")\nprint(f\"Language: {metadata['language']}\")\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class processes webpage metadata through its aprocess_html method which extracts metadata into a dictionary stored in the CrawlResult object, exactly matching the documented metadata fields like title, description, and language that can be accessed as shown in the example.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### FixedLengthWordChunking\n\n`FixedLengthWordChunking` splits text into chunks based on a fixed number of words. This ensures each chunk has approximately the same length.\n\n#### When to Use\n- Suitable for processing large texts where uniform chunk size is important.\n- Useful when the number of words per chunk needs to be controlled.\n\n#### Parameters\n- `chunk_size` (int, optional): Number of words per chunk. Default is `100`.\n\n#### Example\n```python\nfrom crawl4ai.chunking_strategy import FixedLengthWordChunking\n\nchunker = FixedLengthWordChunking(chunk_size=10)\n\n# Sample text\ntext = \"This is a sample text. It will be split into chunks of fixed length.\"\n\n# Chunk the text\nchunks = chunker.chunk(text)\nprint(chunks)\n```",
      "document_location": "docs/md_v2/extraction/chunking.md",
      "artifact_id": 22,
      "artifact_title": "FixedLengthWordChunking",
      "predicted_relationship": "explicit",
      "relationship_type": "implements",
      "relationship_explanation": "The documentation explicitly names 'FixedLengthWordChunking' and shows its usage in the example code, indicating that this class splits text into fixed-length word chunks. The usage example demonstrates creating an instance with a 'chunk_size' parameter and calling the 'chunk' method.",
      "predicted_trace_chain": "docs/md_v2/extraction/chunking.md -> FixedLengthWordChunking",
      "predicted_trace_chain_explanation": "The chain starts at the documentation file 'docs/md_v2/extraction/chunking.md' and directly references the FixedLengthWordChunking class, as it is explicitly mentioned in the snippet and used in the example.",
      "ground_truth_relationship": "The code implements the documented chunking strategy by splitting input text into word tokens and using list slicing with the chunk_size parameter to create fixed-length segments joined back into strings.",
      "ground_truth_trace_chain": "chunking.md -> ChunkingStrategy -> FixedLengthWordChunking",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### FixedLengthWordChunking\n\n`FixedLengthWordChunking` splits text into chunks based on a fixed number of words. This ensures each chunk has approximately the same length.\n\n#### When to Use\n- Suitable for processing large texts where uniform chunk size is important.\n- Useful when the number of words per chunk needs to be controlled.\n\n#### Parameters\n- `chunk_size` (int, optional): Number of words per chunk. Default is `100`.\n\n#### Example\n```python\nfrom crawl4ai.chunking_strategy import FixedLengthWordChunking\n\nchunker = FixedLengthWordChunking(chunk_size=10)\n\n# Sample text\ntext = \"This is a sample text. It will be split into chunks of fixed length.\"\n\n# Chunk the text\nchunks = chunker.chunk(text)\nprint(chunks)\n```",
      "document_location": "docs/md_v2/extraction/chunking.md",
      "artifact_id": 6,
      "artifact_title": "ChunkingStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "extends",
      "relationship_explanation": "FixedLengthWordChunking is implemented as a subclass of ChunkingStrategy. Although the documentation does not mention ChunkingStrategy explicitly, its inclusion is implicit because FixedLengthWordChunking inherits the defined interface and behavior from ChunkingStrategy.",
      "predicted_trace_chain": "docs/md_v2/extraction/chunking.md -> FixedLengthWordChunking -> ChunkingStrategy",
      "predicted_trace_chain_explanation": "The chain begins with the documentation file, then moves to the FixedLengthWordChunking class (directly mentioned), and further extends to its base class ChunkingStrategy, demonstrating the inheritance relationship that supports the implemented functionality.",
      "ground_truth_relationship": "The abstract ChunkingStrategy class serves as the base interface that FixedLengthWordChunking implements to provide word-based text chunking functionality.",
      "ground_truth_trace_chain": "chunking.md -> ChunkingStrategy -> ChunkingStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Strategy Selection Guide\n\nChoose your strategy based on these factors:\n\n1. **Content Structure**\n   - Well-structured HTML \u2192 Use CSS Strategy\n   - Natural language text \u2192 Use LLM Strategy\n   - Mixed/Complex content \u2192 Use Cosine Strategy\n\n2. **Performance Requirements**\n   - Fastest: CSS Strategy\n   - Moderate: Cosine Strategy\n   - Variable: LLM Strategy (depends on provider)\n\n3. **Accuracy Needs**\n   - Highest structure accuracy: CSS Strategy\n   - Best semantic understanding: LLM Strategy\n   - Best content relevance: Cosine Strategy",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "implements (subclass of ExtractionStrategy)",
      "relationship_explanation": "The documentation text explicitly recommends a 'CSS Strategy' for well-structured HTML and highest structure accuracy. JsonCssExtractionStrategy implements a CSS\u2010based extraction approach and is thus aligned with this recommendation.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> JsonCssExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain starts with the documentation file (docs/md_v2/extraction/overview.md) which advises using a CSS Strategy. This recommendation maps directly to the JsonCssExtractionStrategy artifact. Since JsonCssExtractionStrategy inherits from ExtractionStrategy, the chain continues to include ExtractionStrategy, showing the hierarchical relationship.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class directly implements the CSS Strategy mentioned in the documentation by using CSS selectors to efficiently parse well-structured HTML content as recommended in the strategy selection guide.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Strategy Selection Guide\n\nChoose your strategy based on these factors:\n\n1. **Content Structure**\n   - Well-structured HTML \u2192 Use CSS Strategy\n   - Natural language text \u2192 Use LLM Strategy\n   - Mixed/Complex content \u2192 Use Cosine Strategy\n\n2. **Performance Requirements**\n   - Fastest: CSS Strategy\n   - Moderate: Cosine Strategy\n   - Variable: LLM Strategy (depends on provider)\n\n3. **Accuracy Needs**\n   - Highest structure accuracy: CSS Strategy\n   - Best semantic understanding: LLM Strategy\n   - Best content relevance: Cosine Strategy",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "implements (subclass of ExtractionStrategy)",
      "relationship_explanation": "The documentation explicitly advises using an 'LLM Strategy' for processing natural language text and for best semantic understanding. LLMExtractionStrategy is designed to use language models (LLM) for extraction, matching this guidance.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> LLMExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The trace begins at the documentation where the LLM Strategy is recommended and maps directly to the LLMExtractionStrategy artifact. Its inheritance from ExtractionStrategy is then shown in the chain, linking the recommendation to its implementation.",
      "ground_truth_relationship": "The LLMExtractionStrategy class implements the LLM Strategy option described in the documentation, specifically handling natural language text processing with configurable performance based on the provider and offering semantic understanding through its extract() method.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Strategy Selection Guide\n\nChoose your strategy based on these factors:\n\n1. **Content Structure**\n   - Well-structured HTML \u2192 Use CSS Strategy\n   - Natural language text \u2192 Use LLM Strategy\n   - Mixed/Complex content \u2192 Use Cosine Strategy\n\n2. **Performance Requirements**\n   - Fastest: CSS Strategy\n   - Moderate: Cosine Strategy\n   - Variable: LLM Strategy (depends on provider)\n\n3. **Accuracy Needs**\n   - Highest structure accuracy: CSS Strategy\n   - Best semantic understanding: LLM Strategy\n   - Best content relevance: Cosine Strategy",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 7,
      "artifact_title": "CosineStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "implements (subclass of ExtractionStrategy)",
      "relationship_explanation": "The documentation clearly indicates that for mixed or complex content and for achieving best content relevance, a 'Cosine Strategy' should be used. CosineStrategy computes similarity based on cosine measures, fitting this requirement.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> CosineStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "Starting from the documentation file, the chain maps the recommendation for a Cosine Strategy directly to the CosineStrategy artifact, and further links to ExtractionStrategy to reflect its base class relationship, thereby completing the traceability pathway.",
      "ground_truth_relationship": "The CosineStrategy class directly implements the document's 'Mixed/Complex content' recommendation by using cosine similarity and hierarchical clustering to process and analyze text content with moderate performance characteristics.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> CosineStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Strategy Selection Guide\n\nChoose your strategy based on these factors:\n\n1. **Content Structure**\n   - Well-structured HTML \u2192 Use CSS Strategy\n   - Natural language text \u2192 Use LLM Strategy\n   - Mixed/Complex content \u2192 Use Cosine Strategy\n\n2. **Performance Requirements**\n   - Fastest: CSS Strategy\n   - Moderate: Cosine Strategy\n   - Variable: LLM Strategy (depends on provider)\n\n3. **Accuracy Needs**\n   - Highest structure accuracy: CSS Strategy\n   - Best semantic understanding: LLM Strategy\n   - Best content relevance: Cosine Strategy",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "ExtractionStrategy",
      "ground_truth_relationship": "The ExtractionStrategy abstract class provides the technical foundation for implementing the three distinct strategies (CSS, LLM, and Cosine) outlined in the strategy selection guide through its abstract extract method and parallel processing capabilities.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Parameter Details\n\n1. **semantic_filter**\n   - Sets the target topic or content type\n   - Use keywords relevant to your desired content\n   - Example: \"technical specifications\", \"user reviews\", \"pricing information\"\n\n2. **sim_threshold**\n   - Controls how similar content must be to be grouped together\n   - Higher values (e.g., 0.8) mean stricter matching\n   - Lower values (e.g., 0.3) allow more variation\n   ```python\n   # Strict matching\n   strategy = CosineStrategy(sim_threshold=0.8)\n   \n   # Loose matching\n   strategy = CosineStrategy(sim_threshold=0.3)\n   ```\n\n3. **word_count_threshold**\n   - Filters out short content blocks\n   - Helps eliminate noise and irrelevant content\n   ```python\n   # Only consider substantial paragraphs\n   strategy = CosineStrategy(word_count_threshold=50)\n   ```\n\n4. **top_k**\n   - Number of top content clusters to return\n   - Higher values return more diverse content\n   ```python\n   # Get top 5 most relevant content clusters\n   strategy = CosineStrategy(top_k=5)\n   ```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 7,
      "artifact_title": "CosineStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation/usage",
      "relationship_explanation": "The documentation snippet explicitly demonstrates how to instantiate CosineStrategy with specific parameters (sim_threshold, word_count_threshold, top_k). The provided code examples (e.g., 'strategy = CosineStrategy(sim_threshold=0.8)') directly reference the CosineStrategy class and illustrate configuring its constructor parameters.",
      "predicted_trace_chain": "cosine.md -> CosineStrategy",
      "predicted_trace_chain_explanation": "Starting from the document 'cosine.md', the examples clearly show the use of CosineStrategy, establishing a direct trace to this artifact.",
      "ground_truth_relationship": "The documentation's parameter details section directly maps to the CosineStrategy class's __init__ method parameters, where semantic_filter, sim_threshold, word_count_threshold, and top_k are initialized with their described functionalities implemented in the corresponding class methods like filter_documents_embeddings() and filter_clusters_by_word_count().",
      "ground_truth_trace_chain": "cosine.md -> ExtractionStrategy -> CosineStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Parameter Details\n\n1. **semantic_filter**\n   - Sets the target topic or content type\n   - Use keywords relevant to your desired content\n   - Example: \"technical specifications\", \"user reviews\", \"pricing information\"\n\n2. **sim_threshold**\n   - Controls how similar content must be to be grouped together\n   - Higher values (e.g., 0.8) mean stricter matching\n   - Lower values (e.g., 0.3) allow more variation\n   ```python\n   # Strict matching\n   strategy = CosineStrategy(sim_threshold=0.8)\n   \n   # Loose matching\n   strategy = CosineStrategy(sim_threshold=0.3)\n   ```\n\n3. **word_count_threshold**\n   - Filters out short content blocks\n   - Helps eliminate noise and irrelevant content\n   ```python\n   # Only consider substantial paragraphs\n   strategy = CosineStrategy(word_count_threshold=50)\n   ```\n\n4. **top_k**\n   - Number of top content clusters to return\n   - Higher values return more diverse content\n   ```python\n   # Get top 5 most relevant content clusters\n   strategy = CosineStrategy(top_k=5)\n   ```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "CosineStrategy extends ExtractionStrategy, meaning that while ExtractionStrategy is not directly mentioned in the snippet, it is implicitly part of the trace. This base class defines the extraction interface that CosineStrategy implements.",
      "predicted_trace_chain": "cosine.md -> CosineStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The trace starts from 'cosine.md' which explicitly mentions CosineStrategy, and since CosineStrategy inherits from ExtractionStrategy, the pathway extends to ExtractionStrategy, establishing the implicit relationship.",
      "ground_truth_relationship": "The ExtractionStrategy class serves as a base template for implementing various content extraction configurations described in the parameter documentation, with specific settings for semantic_filter, sim_threshold, word_count_threshold, and top_k being defined in child classes.",
      "ground_truth_trace_chain": "cosine.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Configuration Options\n\n### Core Parameters\n\n```python\nCosineStrategy(\n    # Content Filtering\n    semantic_filter: str = None,       # Keywords/topic for content filtering\n    word_count_threshold: int = 10,    # Minimum words per cluster\n    sim_threshold: float = 0.3,        # Similarity threshold (0.0 to 1.0)\n    \n    # Clustering Parameters\n    max_dist: float = 0.2,            # Maximum distance for clustering\n    linkage_method: str = 'ward',      # Clustering linkage method\n    top_k: int = 3,                   # Number of top categories to extract\n    \n    # Model Configuration\n    model_name: str = 'sentence-transformers/all-MiniLM-L6-v2',  # Embedding model\n    \n    verbose: bool = False             # Enable logging\n)\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 7,
      "artifact_title": "CosineStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "constructor usage",
      "relationship_explanation": "The documentation snippet shows a direct invocation of CosineStrategy with parameters such as semantic_filter, word_count_threshold, sim_threshold, max_dist, linkage_method, top_k, model_name, and verbose. These match the __init__ signature of the CosineStrategy class, providing explicit evidence of its usage in configuration.",
      "predicted_trace_chain": "docs/md_v2/extraction/cosine.md -> CosineStrategy",
      "predicted_trace_chain_explanation": "The trace begins from the documentation file 'cosine.md' and directly points to the CosineStrategy class, as the configuration options in the snippet exactly mirror the constructor parameters defined in CosineStrategy.",
      "ground_truth_relationship": "The code implements a CosineStrategy class that exactly matches the documented configuration parameters, including semantic_filter, word_count_threshold, max_dist, linkage_method, top_k, model_name, and sim_threshold, which are all initialized in the constructor with the same default values shown in the documentation.",
      "ground_truth_trace_chain": "cosine.md -> ExtractionStrategy -> CosineStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Configuration Options\n\n### Core Parameters\n\n```python\nCosineStrategy(\n    # Content Filtering\n    semantic_filter: str = None,       # Keywords/topic for content filtering\n    word_count_threshold: int = 10,    # Minimum words per cluster\n    sim_threshold: float = 0.3,        # Similarity threshold (0.0 to 1.0)\n    \n    # Clustering Parameters\n    max_dist: float = 0.2,            # Maximum distance for clustering\n    linkage_method: str = 'ward',      # Clustering linkage method\n    top_k: int = 3,                   # Number of top categories to extract\n    \n    # Model Configuration\n    model_name: str = 'sentence-transformers/all-MiniLM-L6-v2',  # Embedding model\n    \n    verbose: bool = False             # Enable logging\n)\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "CosineStrategy extends ExtractionStrategy. Although the base class is not directly mentioned in the snippet, the configuration options imply it is part of the extraction framework provided by the ExtractionStrategy. This inheritance relationship is fundamental to the overall design of the extraction strategies.",
      "predicted_trace_chain": "docs/md_v2/extraction/cosine.md -> CosineStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "This chain illustrates that the documentation for CosineStrategy inherently involves its base class ExtractionStrategy, linking the documented configuration parameters to the broader extraction strategy interface.",
      "ground_truth_relationship": "The ExtractionStrategy abstract base class serves as a foundation for implementing configurable extraction strategies like CosineStrategy, where the documented parameters would be passed through the kwargs argument in the constructor.",
      "ground_truth_trace_chain": "cosine.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Link Analysis\n\nCrawl4AI provides sophisticated link analysis capabilities, helping you understand the relationship between pages and identify important navigation patterns.\n\n### Link Classification\nThe library automatically categorizes links into:\n- Internal links (same domain)\n- External links (different domains)\n- Social media links\n- Navigation links\n- Content links\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Analyze internal links\nfor link in result.links[\"internal\"]:\n    print(f\"Internal: {link['href']}\")\n    print(f\"Link text: {link['text']}\")\n    print(f\"Context: {link['context']}\")  # Surrounding text\n    print(f\"Type: {link['type']}\")  # nav, content, etc.\n\n# Analyze external links\nfor link in result.links[\"external\"]:\n    print(f\"External: {link['href']}\")\n    print(f\"Domain: {link['domain']}\")\n    print(f\"Type: {link['type']}\")\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method usage",
      "relationship_explanation": "The documentation snippet explicitly calls 'crawler.arun(url=\"https://example.com\")', demonstrating the use of the 'AsyncWebCrawler.arun()' method as the entry point for link analysis.",
      "predicted_trace_chain": "docs/md_v2/advanced/content-processing.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the documentation file, the usage example directly invokes AsyncWebCrawler.arun(), which initiates the crawling process and returns a CrawlResult containing link information.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method implements the core crawling functionality that powers the link analysis features by asynchronously fetching and processing web pages, returning a CrawlResult object that contains the categorized internal and external links described in the documentation.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Link Analysis\n\nCrawl4AI provides sophisticated link analysis capabilities, helping you understand the relationship between pages and identify important navigation patterns.\n\n### Link Classification\nThe library automatically categorizes links into:\n- Internal links (same domain)\n- External links (different domains)\n- Social media links\n- Navigation links\n- Content links\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Analyze internal links\nfor link in result.links[\"internal\"]:\n    print(f\"Internal: {link['href']}\")\n    print(f\"Link text: {link['text']}\")\n    print(f\"Context: {link['context']}\")  # Surrounding text\n    print(f\"Type: {link['type']}\")  # nav, content, etc.\n\n# Analyze external links\nfor link in result.links[\"external\"]:\n    print(f\"External: {link['href']}\")\n    print(f\"Domain: {link['domain']}\")\n    print(f\"Type: {link['type']}\")\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 8,
      "artifact_title": "CrawlResult",
      "predicted_relationship": "implicit",
      "relationship_type": "return type",
      "relationship_explanation": "The variable 'result' assigned from the call to arun() is an instance of CrawlResult. Although not named explicitly in the documentation snippet, it is implied by the usage as it holds the output data including links.",
      "predicted_trace_chain": "docs/md_v2/advanced/content-processing.md -> AsyncWebCrawler.arun() -> CrawlResult",
      "predicted_trace_chain_explanation": "The chain shows that AsyncWebCrawler.arun() returns a CrawlResult object, which is then used to access various attributes such as link classifications.",
      "ground_truth_relationship": "The CrawlResult class implements the documented link analysis functionality by storing categorized links in its 'links' dictionary field, where each link category (internal, external, social, etc.) contains a list of dictionaries with link metadata like href, text, context, and type.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Link Analysis\n\nCrawl4AI provides sophisticated link analysis capabilities, helping you understand the relationship between pages and identify important navigation patterns.\n\n### Link Classification\nThe library automatically categorizes links into:\n- Internal links (same domain)\n- External links (different domains)\n- Social media links\n- Navigation links\n- Content links\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Analyze internal links\nfor link in result.links[\"internal\"]:\n    print(f\"Internal: {link['href']}\")\n    print(f\"Link text: {link['text']}\")\n    print(f\"Context: {link['context']}\")  # Surrounding text\n    print(f\"Type: {link['type']}\")  # nav, content, etc.\n\n# Analyze external links\nfor link in result.links[\"external\"]:\n    print(f\"External: {link['href']}\")\n    print(f\"Domain: {link['domain']}\")\n    print(f\"Type: {link['type']}\")\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 14,
      "artifact_title": "CrawlResult.links",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet directly references 'result.links' to iterate over categorized link data (internal and external). This confirms that the CrawlResult.links attribute is used to store the link analysis details.",
      "predicted_trace_chain": "docs/md_v2/advanced/content-processing.md -> AsyncWebCrawler.arun() -> CrawlResult -> CrawlResult.links",
      "predicted_trace_chain_explanation": "The documentation chain begins with the advanced content processing file, calls AsyncWebCrawler.arun() to obtain a CrawlResult, and then explicitly accesses the 'links' attribute for link classification.",
      "ground_truth_relationship": "The links property of CrawlResult stores categorized link data as a dictionary where keys indicate link types (internal, external, social, etc.) and values are lists of link details like href, text, and context.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult.links",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Link Analysis\n\nCrawl4AI provides sophisticated link analysis capabilities, helping you understand the relationship between pages and identify important navigation patterns.\n\n### Link Classification\nThe library automatically categorizes links into:\n- Internal links (same domain)\n- External links (different domains)\n- Social media links\n- Navigation links\n- Content links\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Analyze internal links\nfor link in result.links[\"internal\"]:\n    print(f\"Internal: {link['href']}\")\n    print(f\"Link text: {link['text']}\")\n    print(f\"Context: {link['context']}\")  # Surrounding text\n    print(f\"Type: {link['type']}\")  # nav, content, etc.\n\n# Analyze external links\nfor link in result.links[\"external\"]:\n    print(f\"External: {link['href']}\")\n    print(f\"Domain: {link['domain']}\")\n    print(f\"Type: {link['type']}\")\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class provides the foundational interface methods needed to implement the link analysis capabilities described in the documentation, including the crawl method that returns AsyncCrawlResponse objects containing categorized link data.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Link Analysis\n\nCrawl4AI provides sophisticated link analysis capabilities, helping you understand the relationship between pages and identify important navigation patterns.\n\n### Link Classification\nThe library automatically categorizes links into:\n- Internal links (same domain)\n- External links (different domains)\n- Social media links\n- Navigation links\n- Content links\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Analyze internal links\nfor link in result.links[\"internal\"]:\n    print(f\"Internal: {link['href']}\")\n    print(f\"Link text: {link['text']}\")\n    print(f\"Context: {link['context']}\")  # Surrounding text\n    print(f\"Type: {link['type']}\")  # nav, content, etc.\n\n# Analyze external links\nfor link in result.links[\"external\"]:\n    print(f\"External: {link['href']}\")\n    print(f\"Domain: {link['domain']}\")\n    print(f\"Type: {link['type']}\")\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements link analysis by crawling pages asynchronously and providing methods to extract and categorize internal, external, and social media links through Playwright's DOM manipulation capabilities.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Link Analysis\n\nCrawl4AI provides sophisticated link analysis capabilities, helping you understand the relationship between pages and identify important navigation patterns.\n\n### Link Classification\nThe library automatically categorizes links into:\n- Internal links (same domain)\n- External links (different domains)\n- Social media links\n- Navigation links\n- Content links\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Analyze internal links\nfor link in result.links[\"internal\"]:\n    print(f\"Internal: {link['href']}\")\n    print(f\"Link text: {link['text']}\")\n    print(f\"Context: {link['context']}\")  # Surrounding text\n    print(f\"Type: {link['type']}\")  # nav, content, etc.\n\n# Analyze external links\nfor link in result.links[\"external\"]:\n    print(f\"External: {link['href']}\")\n    print(f\"Domain: {link['domain']}\")\n    print(f\"Type: {link['type']}\")\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler code implements the documented link analysis by processing HTML content in the aprocess_html method, which extracts and classifies links into a structured format stored in the links dictionary, as shown in the documentation's code example.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Usage: Combining JS Execution with LLM Extraction\n\nThis example demonstrates how to combine JavaScript execution with LLM extraction to handle dynamic content:\n\n```python\nasync def extract_dynamic_content():\n    js_code = \"\"\"\n    const loadMoreButton = Array.from(document.querySelectorAll('button')).find(button => button.textContent.includes('Load More'));\n    if (loadMoreButton) {\n        loadMoreButton.click();\n        await new Promise(resolve => setTimeout(resolve, 2000));\n    }\n    \"\"\"\n\n    wait_for = \"\"\"\n    () => {\n        const articles = document.querySelectorAll('article.tease-card');\n        return articles.length > 10;\n    }\n    \"\"\"\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            js_code=js_code,\n            wait_for=wait_for,\n            css_selector=\"article.tease-card\",\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\",\n                api_token=os.getenv('OPENAI_API_KEY'),\n                instruction=\"Summarize each article, focusing on technology-related content\"\n            ),\n            bypass_cache=True,\n        )\n\n    summaries = json.loads(result.extracted_content)\n    print(f\"Number of summarized articles: {len(summaries)}\")\n\n    with open(\".data/tech_summaries.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(summaries, f, indent=2)\n\nasyncio.run(extract_dynamic_content())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "usage/instantiation",
      "relationship_explanation": "The documentation snippet directly instantiates AsyncWebCrawler using an async context manager (evidenced by 'async with AsyncWebCrawler(verbose=True) as crawler:'), indicating its crucial role as the starting point for the crawling process.",
      "predicted_trace_chain": "docs/md_v2/extraction/llm.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The trace begins at the documentation file and immediately shows the creation of an AsyncWebCrawler instance, which is explicitly used to manage the crawling workflow.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the documented dynamic content extraction functionality through its arun method, which accepts js_code and wait_for parameters to execute JavaScript on web pages and coordinates with extraction strategies for content processing.",
      "ground_truth_trace_chain": "llm.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Usage: Combining JS Execution with LLM Extraction\n\nThis example demonstrates how to combine JavaScript execution with LLM extraction to handle dynamic content:\n\n```python\nasync def extract_dynamic_content():\n    js_code = \"\"\"\n    const loadMoreButton = Array.from(document.querySelectorAll('button')).find(button => button.textContent.includes('Load More'));\n    if (loadMoreButton) {\n        loadMoreButton.click();\n        await new Promise(resolve => setTimeout(resolve, 2000));\n    }\n    \"\"\"\n\n    wait_for = \"\"\"\n    () => {\n        const articles = document.querySelectorAll('article.tease-card');\n        return articles.length > 10;\n    }\n    \"\"\"\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            js_code=js_code,\n            wait_for=wait_for,\n            css_selector=\"article.tease-card\",\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\",\n                api_token=os.getenv('OPENAI_API_KEY'),\n                instruction=\"Summarize each article, focusing on technology-related content\"\n            ),\n            bypass_cache=True,\n        )\n\n    summaries = json.loads(result.extracted_content)\n    print(f\"Number of summarized articles: {len(summaries)}\")\n\n    with open(\".data/tech_summaries.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(summaries, f, indent=2)\n\nasyncio.run(extract_dynamic_content())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The 'arun()' method is explicitly called on the AsyncWebCrawler instance to perform the crawling operation with parameters such as js_code, wait_for conditions, css_selector and an extraction strategy.",
      "predicted_trace_chain": "docs/md_v2/extraction/llm.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "After initializing the AsyncWebCrawler, the 'arun()' method is invoked to start the crawl process, establishing a clear, sequential chain from the documentation to the method call.",
      "ground_truth_relationship": "The documented example showcases how the AsyncWebCrawler.arun() method handles dynamic web content by accepting optional parameters like js_code, wait_for, and css_selector that allow JavaScript execution and selective content extraction through the LLMExtractionStrategy.",
      "ground_truth_trace_chain": "llm.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Usage: Combining JS Execution with LLM Extraction\n\nThis example demonstrates how to combine JavaScript execution with LLM extraction to handle dynamic content:\n\n```python\nasync def extract_dynamic_content():\n    js_code = \"\"\"\n    const loadMoreButton = Array.from(document.querySelectorAll('button')).find(button => button.textContent.includes('Load More'));\n    if (loadMoreButton) {\n        loadMoreButton.click();\n        await new Promise(resolve => setTimeout(resolve, 2000));\n    }\n    \"\"\"\n\n    wait_for = \"\"\"\n    () => {\n        const articles = document.querySelectorAll('article.tease-card');\n        return articles.length > 10;\n    }\n    \"\"\"\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            js_code=js_code,\n            wait_for=wait_for,\n            css_selector=\"article.tease-card\",\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\",\n                api_token=os.getenv('OPENAI_API_KEY'),\n                instruction=\"Summarize each article, focusing on technology-related content\"\n            ),\n            bypass_cache=True,\n        )\n\n    summaries = json.loads(result.extracted_content)\n    print(f\"Number of summarized articles: {len(summaries)}\")\n\n    with open(\".data/tech_summaries.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(summaries, f, indent=2)\n\nasyncio.run(extract_dynamic_content())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation and parameter usage",
      "relationship_explanation": "LLMExtractionStrategy is explicitly instantiated as the value for the 'extraction_strategy' parameter in the 'arun()' method call, providing LLM-based extraction capabilities by specifying provider, api_token, and instruction.",
      "predicted_trace_chain": "docs/md_v2/extraction/llm.md -> AsyncWebCrawler.arun() -> LLMExtractionStrategy",
      "predicted_trace_chain_explanation": "The extraction strategy is integrated into the crawling process via the arun() method, linking the document\u2019s description to the LLMExtractionStrategy instantiation which governs how content is processed.",
      "ground_truth_relationship": "The code implements the LLMExtractionStrategy class that enables the functionality shown in the documentation's example of extracting dynamic content from web pages using LLM-based extraction with customizable providers, API tokens, and instructions.",
      "ground_truth_trace_chain": "llm.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Usage: Combining JS Execution with LLM Extraction\n\nThis example demonstrates how to combine JavaScript execution with LLM extraction to handle dynamic content:\n\n```python\nasync def extract_dynamic_content():\n    js_code = \"\"\"\n    const loadMoreButton = Array.from(document.querySelectorAll('button')).find(button => button.textContent.includes('Load More'));\n    if (loadMoreButton) {\n        loadMoreButton.click();\n        await new Promise(resolve => setTimeout(resolve, 2000));\n    }\n    \"\"\"\n\n    wait_for = \"\"\"\n    () => {\n        const articles = document.querySelectorAll('article.tease-card');\n        return articles.length > 10;\n    }\n    \"\"\"\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            js_code=js_code,\n            wait_for=wait_for,\n            css_selector=\"article.tease-card\",\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\",\n                api_token=os.getenv('OPENAI_API_KEY'),\n                instruction=\"Summarize each article, focusing on technology-related content\"\n            ),\n            bypass_cache=True,\n        )\n\n    summaries = json.loads(result.extracted_content)\n    print(f\"Number of summarized articles: {len(summaries)}\")\n\n    with open(\".data/tech_summaries.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(summaries, f, indent=2)\n\nasyncio.run(extract_dynamic_content())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "LLMExtractionStrategy extends the abstract base class ExtractionStrategy. Although not directly mentioned in the snippet, this inheritance relationship is fundamental to ensuring that LLMExtractionStrategy adheres to the common extraction interface.",
      "predicted_trace_chain": "docs/md_v2/extraction/llm.md -> LLMExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "This chain shows that the LLMExtractionStrategy used in the snippet is built upon the foundational ExtractionStrategy abstraction, ensuring consistency in extraction functionalities.",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the foundation for implementing different content extraction methods, including the LLMExtractionStrategy shown in the documentation example that uses GPT-4 to summarize articles.",
      "ground_truth_trace_chain": "llm.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Usage: Combining JS Execution with LLM Extraction\n\nThis example demonstrates how to combine JavaScript execution with LLM extraction to handle dynamic content:\n\n```python\nasync def extract_dynamic_content():\n    js_code = \"\"\"\n    const loadMoreButton = Array.from(document.querySelectorAll('button')).find(button => button.textContent.includes('Load More'));\n    if (loadMoreButton) {\n        loadMoreButton.click();\n        await new Promise(resolve => setTimeout(resolve, 2000));\n    }\n    \"\"\"\n\n    wait_for = \"\"\"\n    () => {\n        const articles = document.querySelectorAll('article.tease-card');\n        return articles.length > 10;\n    }\n    \"\"\"\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            js_code=js_code,\n            wait_for=wait_for,\n            css_selector=\"article.tease-card\",\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\",\n                api_token=os.getenv('OPENAI_API_KEY'),\n                instruction=\"Summarize each article, focusing on technology-related content\"\n            ),\n            bypass_cache=True,\n        )\n\n    summaries = json.loads(result.extracted_content)\n    print(f\"Number of summarized articles: {len(summaries)}\")\n\n    with open(\".data/tech_summaries.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(summaries, f, indent=2)\n\nasyncio.run(extract_dynamic_content())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 11,
      "artifact_title": "CrawlResult.extracted_content",
      "predicted_relationship": "explicit",
      "relationship_type": "property access",
      "relationship_explanation": "The code snippet accesses the 'extracted_content' attribute of the crawl result (i.e., result.extracted_content) to retrieve the summarized articles, demonstrating its role in conveying the extraction output.",
      "predicted_trace_chain": "docs/md_v2/extraction/llm.md -> AsyncWebCrawler.arun() -> CrawlResult.extracted_content",
      "predicted_trace_chain_explanation": "This chain connects the crawling process (via AsyncWebCrawler.arun()) to the final output by retrieving the 'extracted_content' property from the CrawlResult, thus completing the extraction workflow.",
      "ground_truth_relationship": "The extracted_content field stores the LLM-processed article summaries that are later parsed as JSON in the example documentation, serving as the bridge between raw crawled data and structured output.",
      "ground_truth_trace_chain": "llm.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Usage: Combining JS Execution with LLM Extraction\n\nThis example demonstrates how to combine JavaScript execution with LLM extraction to handle dynamic content:\n\n```python\nasync def extract_dynamic_content():\n    js_code = \"\"\"\n    const loadMoreButton = Array.from(document.querySelectorAll('button')).find(button => button.textContent.includes('Load More'));\n    if (loadMoreButton) {\n        loadMoreButton.click();\n        await new Promise(resolve => setTimeout(resolve, 2000));\n    }\n    \"\"\"\n\n    wait_for = \"\"\"\n    () => {\n        const articles = document.querySelectorAll('article.tease-card');\n        return articles.length > 10;\n    }\n    \"\"\"\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            js_code=js_code,\n            wait_for=wait_for,\n            css_selector=\"article.tease-card\",\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\",\n                api_token=os.getenv('OPENAI_API_KEY'),\n                instruction=\"Summarize each article, focusing on technology-related content\"\n            ),\n            bypass_cache=True,\n        )\n\n    summaries = json.loads(result.extracted_content)\n    print(f\"Number of summarized articles: {len(summaries)}\")\n\n    with open(\".data/tech_summaries.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(summaries, f, indent=2)\n\nasyncio.run(extract_dynamic_content())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the extracted_content field which holds the LLM-processed article summaries demonstrated in the documentation example where technology-focused content is extracted from NBC News articles.",
      "ground_truth_trace_chain": "llm.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Usage: Combining JS Execution with LLM Extraction\n\nThis example demonstrates how to combine JavaScript execution with LLM extraction to handle dynamic content:\n\n```python\nasync def extract_dynamic_content():\n    js_code = \"\"\"\n    const loadMoreButton = Array.from(document.querySelectorAll('button')).find(button => button.textContent.includes('Load More'));\n    if (loadMoreButton) {\n        loadMoreButton.click();\n        await new Promise(resolve => setTimeout(resolve, 2000));\n    }\n    \"\"\"\n\n    wait_for = \"\"\"\n    () => {\n        const articles = document.querySelectorAll('article.tease-card');\n        return articles.length > 10;\n    }\n    \"\"\"\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            js_code=js_code,\n            wait_for=wait_for,\n            css_selector=\"article.tease-card\",\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\",\n                api_token=os.getenv('OPENAI_API_KEY'),\n                instruction=\"Summarize each article, focusing on technology-related content\"\n            ),\n            bypass_cache=True,\n        )\n\n    summaries = json.loads(result.extracted_content)\n    print(f\"Number of summarized articles: {len(summaries)}\")\n\n    with open(\".data/tech_summaries.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(summaries, f, indent=2)\n\nasyncio.run(extract_dynamic_content())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the dynamic content extraction capabilities described in the documentation through its js_code execution and smart_wait methods, which handle JavaScript interaction and waiting for elements to load on the page.",
      "ground_truth_trace_chain": "llm.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Usage: Combining JS Execution with LLM Extraction\n\nThis example demonstrates how to combine JavaScript execution with LLM extraction to handle dynamic content:\n\n```python\nasync def extract_dynamic_content():\n    js_code = \"\"\"\n    const loadMoreButton = Array.from(document.querySelectorAll('button')).find(button => button.textContent.includes('Load More'));\n    if (loadMoreButton) {\n        loadMoreButton.click();\n        await new Promise(resolve => setTimeout(resolve, 2000));\n    }\n    \"\"\"\n\n    wait_for = \"\"\"\n    () => {\n        const articles = document.querySelectorAll('article.tease-card');\n        return articles.length > 10;\n    }\n    \"\"\"\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            js_code=js_code,\n            wait_for=wait_for,\n            css_selector=\"article.tease-card\",\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\",\n                api_token=os.getenv('OPENAI_API_KEY'),\n                instruction=\"Summarize each article, focusing on technology-related content\"\n            ),\n            bypass_cache=True,\n        )\n\n    summaries = json.loads(result.extracted_content)\n    print(f\"Number of summarized articles: {len(summaries)}\")\n\n    with open(\".data/tech_summaries.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(summaries, f, indent=2)\n\nasyncio.run(extract_dynamic_content())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the core interface methods that enable the advanced dynamic content extraction capabilities demonstrated in the documentation, particularly the crawl method that's essential for executing JavaScript and handling LLM extraction.",
      "ground_truth_trace_chain": "llm.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Choose the Right Strategy**\n   - Start with CSS for structured data\n   - Use LLM for complex interpretation\n   - Try Cosine for content relevance\n\n2. **Optimize Performance**\n   - Cache LLM results\n   - Keep CSS selectors specific\n   - Tune similarity thresholds\n\n3. **Handle Errors**\n   ```python\n   result = await crawler.arun(\n       url=\"https://example.com\",\n       extraction_strategy=strategy\n   )\n   \n   if not result.success:\n       print(f\"Extraction failed: {result.error_message}\")\n   else:\n       data = json.loads(result.extracted_content)\n   ```\n\nEach strategy has its strengths and optimal use cases. Explore the detailed documentation for each strategy to learn more about their specific features and configurations.",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "usage",
      "relationship_explanation": "The documentation code example directly calls the 'arun' method on a crawler instance (e.g., await crawler.arun(...)), demonstrating how to initiate a crawl with a specific extraction strategy.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The document from 'docs/md_v2/extraction/overview.md' explicitly shows usage of the AsyncWebCrawler.arun() method as part of the example code.",
      "ground_truth_relationship": "The code implements error handling patterns shown in the documentation through try-catch blocks that return CrawlResult objects with error messages, while also incorporating the documented best practices of caching and strategy selection.",
      "ground_truth_trace_chain": "overview.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Choose the Right Strategy**\n   - Start with CSS for structured data\n   - Use LLM for complex interpretation\n   - Try Cosine for content relevance\n\n2. **Optimize Performance**\n   - Cache LLM results\n   - Keep CSS selectors specific\n   - Tune similarity thresholds\n\n3. **Handle Errors**\n   ```python\n   result = await crawler.arun(\n       url=\"https://example.com\",\n       extraction_strategy=strategy\n   )\n   \n   if not result.success:\n       print(f\"Extraction failed: {result.error_message}\")\n   else:\n       data = json.loads(result.extracted_content)\n   ```\n\nEach strategy has its strengths and optimal use cases. Explore the detailed documentation for each strategy to learn more about their specific features and configurations.",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 10,
      "artifact_title": "CrawlResult.error_message",
      "predicted_relationship": "explicit",
      "relationship_type": "property usage",
      "relationship_explanation": "Within the example, the error_message attribute is accessed (print(f\"Extraction failed: {result.error_message}\")) to display error details when extraction does not succeed.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> CrawlResult.error_message",
      "predicted_trace_chain_explanation": "The error handling in the provided code snippet directly references the error_message property, linking it to the CrawlResult definition.",
      "ground_truth_relationship": "The error_message field in CrawlResult directly enables the error handling best practice shown in the documentation by providing a string description of what went wrong when result.success is False.",
      "ground_truth_trace_chain": "overview.md -> CrawlResult.error_message",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Choose the Right Strategy**\n   - Start with CSS for structured data\n   - Use LLM for complex interpretation\n   - Try Cosine for content relevance\n\n2. **Optimize Performance**\n   - Cache LLM results\n   - Keep CSS selectors specific\n   - Tune similarity thresholds\n\n3. **Handle Errors**\n   ```python\n   result = await crawler.arun(\n       url=\"https://example.com\",\n       extraction_strategy=strategy\n   )\n   \n   if not result.success:\n       print(f\"Extraction failed: {result.error_message}\")\n   else:\n       data = json.loads(result.extracted_content)\n   ```\n\nEach strategy has its strengths and optimal use cases. Explore the detailed documentation for each strategy to learn more about their specific features and configurations.",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 20,
      "artifact_title": "CrawlResult.success",
      "predicted_relationship": "explicit",
      "relationship_type": "property usage",
      "relationship_explanation": "The example explicitly checks the 'success' property (if not result.success) to determine if the crawl and data extraction were successful.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> CrawlResult.success",
      "predicted_trace_chain_explanation": "This property is directly used in the conditional logic of the example, establishing a clear usage relationship from the documentation.",
      "ground_truth_relationship": "The CrawlResult.success boolean property directly supports the error handling best practices shown in the documentation by enabling conditional verification of successful extraction operations.",
      "ground_truth_trace_chain": "overview.md -> CrawlResult.success",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Choose the Right Strategy**\n   - Start with CSS for structured data\n   - Use LLM for complex interpretation\n   - Try Cosine for content relevance\n\n2. **Optimize Performance**\n   - Cache LLM results\n   - Keep CSS selectors specific\n   - Tune similarity thresholds\n\n3. **Handle Errors**\n   ```python\n   result = await crawler.arun(\n       url=\"https://example.com\",\n       extraction_strategy=strategy\n   )\n   \n   if not result.success:\n       print(f\"Extraction failed: {result.error_message}\")\n   else:\n       data = json.loads(result.extracted_content)\n   ```\n\nEach strategy has its strengths and optimal use cases. Explore the detailed documentation for each strategy to learn more about their specific features and configurations.",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 11,
      "artifact_title": "CrawlResult.extracted_content",
      "predicted_relationship": "explicit",
      "relationship_type": "property usage",
      "relationship_explanation": "After confirming success, the code snippet proceeds to parse the extracted data by accessing the 'extracted_content' attribute (data = json.loads(result.extracted_content)).",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> CrawlResult.extracted_content",
      "predicted_trace_chain_explanation": "The attribute is directly used in the example to retrieve and process extracted content, linking back to its definition in CrawlResult.",
      "ground_truth_relationship": "The CrawlResult.extracted_content field stores the successfully crawled data as demonstrated in the documentation's error handling code sample where it's parsed as JSON after a successful extraction.",
      "ground_truth_trace_chain": "overview.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Choose the Right Strategy**\n   - Start with CSS for structured data\n   - Use LLM for complex interpretation\n   - Try Cosine for content relevance\n\n2. **Optimize Performance**\n   - Cache LLM results\n   - Keep CSS selectors specific\n   - Tune similarity thresholds\n\n3. **Handle Errors**\n   ```python\n   result = await crawler.arun(\n       url=\"https://example.com\",\n       extraction_strategy=strategy\n   )\n   \n   if not result.success:\n       print(f\"Extraction failed: {result.error_message}\")\n   else:\n       data = json.loads(result.extracted_content)\n   ```\n\nEach strategy has its strengths and optimal use cases. Explore the detailed documentation for each strategy to learn more about their specific features and configurations.",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "strategy recommendation",
      "relationship_explanation": "The documentation recommends starting with CSS for structured data extraction. Although not directly mentioned by name, this guidance implicitly suggests using the JsonCssExtractionStrategy, which leverages CSS selectors to extract data.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The recommendation for a CSS-based approach in the document maps to the functionality provided by JsonCssExtractionStrategy as an extraction strategy.",
      "ground_truth_relationship": "The code implements the CSS strategy mentioned in the documentation's best practices by using BeautifulSoup selectors to extract structured data according to a predefined schema.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Choose the Right Strategy**\n   - Start with CSS for structured data\n   - Use LLM for complex interpretation\n   - Try Cosine for content relevance\n\n2. **Optimize Performance**\n   - Cache LLM results\n   - Keep CSS selectors specific\n   - Tune similarity thresholds\n\n3. **Handle Errors**\n   ```python\n   result = await crawler.arun(\n       url=\"https://example.com\",\n       extraction_strategy=strategy\n   )\n   \n   if not result.success:\n       print(f\"Extraction failed: {result.error_message}\")\n   else:\n       data = json.loads(result.extracted_content)\n   ```\n\nEach strategy has its strengths and optimal use cases. Explore the detailed documentation for each strategy to learn more about their specific features and configurations.",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "strategy recommendation",
      "relationship_explanation": "The snippet advises using LLM for complex interpretation. This recommendation implicitly refers to the LLMExtractionStrategy, which is designed to extract content using LLM-based methods.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> LLMExtractionStrategy",
      "predicted_trace_chain_explanation": "The advice within the documentation about leveraging LLM for nuanced content extraction aligns with what LLMExtractionStrategy offers.",
      "ground_truth_relationship": "The code implements error handling and retry logic through ThreadPoolExecutor and try-catch blocks, directly aligning with the documentation's 'Handle Errors' section which shows error checking patterns.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Choose the Right Strategy**\n   - Start with CSS for structured data\n   - Use LLM for complex interpretation\n   - Try Cosine for content relevance\n\n2. **Optimize Performance**\n   - Cache LLM results\n   - Keep CSS selectors specific\n   - Tune similarity thresholds\n\n3. **Handle Errors**\n   ```python\n   result = await crawler.arun(\n       url=\"https://example.com\",\n       extraction_strategy=strategy\n   )\n   \n   if not result.success:\n       print(f\"Extraction failed: {result.error_message}\")\n   else:\n       data = json.loads(result.extracted_content)\n   ```\n\nEach strategy has its strengths and optimal use cases. Explore the detailed documentation for each strategy to learn more about their specific features and configurations.",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 7,
      "artifact_title": "CosineStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "strategy recommendation",
      "relationship_explanation": "By suggesting the use of Cosine for content relevance, the documentation implicitly points to the CosineStrategy, which utilizes cosine similarity to evaluate and filter content relevance.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> CosineStrategy",
      "predicted_trace_chain_explanation": "The mention of 'Cosine' for assessing content relevance in the best practices indirectly correlates to the CosineStrategy as a viable strategy for this purpose.",
      "ground_truth_relationship": "The CosineStrategy class implements the documented 'Cosine for content relevance' best practice by using cosine similarity metrics in the filter_documents_embeddings method to evaluate and filter content based on semantic relevance scores.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> CosineStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Choose the Right Strategy**\n   - Start with CSS for structured data\n   - Use LLM for complex interpretation\n   - Try Cosine for content relevance\n\n2. **Optimize Performance**\n   - Cache LLM results\n   - Keep CSS selectors specific\n   - Tune similarity thresholds\n\n3. **Handle Errors**\n   ```python\n   result = await crawler.arun(\n       url=\"https://example.com\",\n       extraction_strategy=strategy\n   )\n   \n   if not result.success:\n       print(f\"Extraction failed: {result.error_message}\")\n   else:\n       data = json.loads(result.extracted_content)\n   ```\n\nEach strategy has its strengths and optimal use cases. Explore the detailed documentation for each strategy to learn more about their specific features and configurations.",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class captures the success/error states described in the error handling documentation through its success, error_message, and extracted_content fields that enable the demonstrated error checking pattern.",
      "ground_truth_trace_chain": "overview.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Choose the Right Strategy**\n   - Start with CSS for structured data\n   - Use LLM for complex interpretation\n   - Try Cosine for content relevance\n\n2. **Optimize Performance**\n   - Cache LLM results\n   - Keep CSS selectors specific\n   - Tune similarity thresholds\n\n3. **Handle Errors**\n   ```python\n   result = await crawler.arun(\n       url=\"https://example.com\",\n       extraction_strategy=strategy\n   )\n   \n   if not result.success:\n       print(f\"Extraction failed: {result.error_message}\")\n   else:\n       data = json.loads(result.extracted_content)\n   ```\n\nEach strategy has its strengths and optimal use cases. Explore the detailed documentation for each strategy to learn more about their specific features and configurations.",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the documented error handling pattern through its crawl method, which returns an AsyncCrawlResponse containing success/failure information and extracted content exactly as shown in the documentation example.",
      "ground_truth_trace_chain": "overview.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Choose the Right Strategy**\n   - Start with CSS for structured data\n   - Use LLM for complex interpretation\n   - Try Cosine for content relevance\n\n2. **Optimize Performance**\n   - Cache LLM results\n   - Keep CSS selectors specific\n   - Tune similarity thresholds\n\n3. **Handle Errors**\n   ```python\n   result = await crawler.arun(\n       url=\"https://example.com\",\n       extraction_strategy=strategy\n   )\n   \n   if not result.success:\n       print(f\"Extraction failed: {result.error_message}\")\n   else:\n       data = json.loads(result.extracted_content)\n   ```\n\nEach strategy has its strengths and optimal use cases. Explore the detailed documentation for each strategy to learn more about their specific features and configurations.",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the documented best practices by incorporating caching mechanisms (through async_db_manager), configurable extraction strategies, and error handling with detailed success/failure reporting in its arun() method.",
      "ground_truth_trace_chain": "overview.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Choose the Right Strategy**\n   - Start with CSS for structured data\n   - Use LLM for complex interpretation\n   - Try Cosine for content relevance\n\n2. **Optimize Performance**\n   - Cache LLM results\n   - Keep CSS selectors specific\n   - Tune similarity thresholds\n\n3. **Handle Errors**\n   ```python\n   result = await crawler.arun(\n       url=\"https://example.com\",\n       extraction_strategy=strategy\n   )\n   \n   if not result.success:\n       print(f\"Extraction failed: {result.error_message}\")\n   else:\n       data = json.loads(result.extracted_content)\n   ```\n\nEach strategy has its strengths and optimal use cases. Explore the detailed documentation for each strategy to learn more about their specific features and configurations.",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "ExtractionStrategy",
      "ground_truth_relationship": "The ExtractionStrategy abstract base class implements the documented 'Choose the Right Strategy' section by providing a flexible framework where different extraction methods (CSS, LLM, Cosine) can be implemented through the abstract extract() method while sharing common parallel processing functionality in run().",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Choose the Right Strategy**\n   - Start with CSS for structured data\n   - Use LLM for complex interpretation\n   - Try Cosine for content relevance\n\n2. **Optimize Performance**\n   - Cache LLM results\n   - Keep CSS selectors specific\n   - Tune similarity thresholds\n\n3. **Handle Errors**\n   ```python\n   result = await crawler.arun(\n       url=\"https://example.com\",\n       extraction_strategy=strategy\n   )\n   \n   if not result.success:\n       print(f\"Extraction failed: {result.error_message}\")\n   else:\n       data = json.loads(result.extracted_content)\n   ```\n\nEach strategy has its strengths and optimal use cases. Explore the detailed documentation for each strategy to learn more about their specific features and configurations.",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class implements the 'Choose the Right Strategy' section of the documentation by defining core methods that each concrete strategy (CSS, LLM, Cosine) must implement for web crawling.",
      "ground_truth_trace_chain": "overview.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "# JSON CSS Extraction Strategy with AsyncWebCrawler\n\nThe `JsonCssExtractionStrategy` is a powerful feature of Crawl4AI that allows you to extract structured data from web pages using CSS selectors. This method is particularly useful when you need to extract specific data points from a consistent HTML structure, such as tables or repeated elements. Here's how to use it with the AsyncWebCrawler.\n\n## Overview\n\nThe `JsonCssExtractionStrategy` works by defining a schema that specifies:\n1. A base CSS selector for the repeating elements\n2. Fields to extract from each element, each with its own CSS selector\n\nThis strategy is fast and efficient, as it doesn't rely on external services like LLMs for extraction.",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "implements",
      "relationship_explanation": "The documentation explicitly mentions 'JsonCssExtractionStrategy' as a feature to extract structured data using CSS selectors with a defined schema. This directly maps to the JsonCssExtractionStrategy class found in the code, which implements extraction using CSS selectors.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The documentation originates from docs/md_v2/extraction/css.md and directly references the JsonCssExtractionStrategy class, establishing a clear trace to this artifact.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class implements the documented functionality by using BeautifulSoup to process HTML and extract data through CSS selectors defined in a schema, where baseSelector finds repeating elements and fields specify what to extract from each element.",
      "ground_truth_trace_chain": "css.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# JSON CSS Extraction Strategy with AsyncWebCrawler\n\nThe `JsonCssExtractionStrategy` is a powerful feature of Crawl4AI that allows you to extract structured data from web pages using CSS selectors. This method is particularly useful when you need to extract specific data points from a consistent HTML structure, such as tables or repeated elements. Here's how to use it with the AsyncWebCrawler.\n\n## Overview\n\nThe `JsonCssExtractionStrategy` works by defining a schema that specifies:\n1. A base CSS selector for the repeating elements\n2. Fields to extract from each element, each with its own CSS selector\n\nThis strategy is fast and efficient, as it doesn't rely on external services like LLMs for extraction.",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "uses",
      "relationship_explanation": "The snippet indicates how to use the JSON CSS Extraction Strategy in conjunction with the AsyncWebCrawler. This implies that AsyncWebCrawler is designed to integrate with various extraction strategies including JsonCssExtractionStrategy.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The documentation instructs the user to employ AsyncWebCrawler with the JSON CSS Extraction Strategy, directly tying the documentation to the AsyncWebCrawler class.",
      "ground_truth_relationship": "The AsyncWebCrawler code implements JsonCssExtractionStrategy by checking for this strategy type in the aprocess_html method and executing its run() method to extract structured data using CSS selectors from the crawled HTML content.",
      "ground_truth_trace_chain": "css.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# JSON CSS Extraction Strategy with AsyncWebCrawler\n\nThe `JsonCssExtractionStrategy` is a powerful feature of Crawl4AI that allows you to extract structured data from web pages using CSS selectors. This method is particularly useful when you need to extract specific data points from a consistent HTML structure, such as tables or repeated elements. Here's how to use it with the AsyncWebCrawler.\n\n## Overview\n\nThe `JsonCssExtractionStrategy` works by defining a schema that specifies:\n1. A base CSS selector for the repeating elements\n2. Fields to extract from each element, each with its own CSS selector\n\nThis strategy is fast and efficient, as it doesn't rely on external services like LLMs for extraction.",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "Although ExtractionStrategy is not explicitly mentioned in the text, JsonCssExtractionStrategy extends it. This makes ExtractionStrategy an implicit part of the extraction functionality described in the documentation.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> JsonCssExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain starts with the documentation that directly references JsonCssExtractionStrategy, which in turn extends ExtractionStrategy. This inheritance connection embeds ExtractionStrategy into the overall design.",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the foundational structure for implementing JSON CSS extraction through its abstract extract method and parallel processing run method, which aligns with the documentation's description of structured data extraction from web pages.",
      "ground_truth_trace_chain": "css.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## JavaScript Execution\n\nExecute custom JavaScript before crawling:\n\n```python\n# Single JavaScript command\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\"\n)\n\n# Multiple commands\njs_commands = [\n    \"window.scrollTo(0, document.body.scrollHeight);\",\n    \"document.querySelector('.load-more').click();\"\n]\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=js_commands\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The documentation snippet directly demonstrates a call to the 'arun()' method by using 'crawler.arun(..., js_code=...)'. This clearly shows that users can pass custom JavaScript commands via the 'js_code' parameter, making this method an explicit interface for JS execution.",
      "predicted_trace_chain": "browser-config.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The documentation file 'browser-config.md' (from the docs/md_v2/basic folder) directly invokes AsyncWebCrawler.arun(), establishing a trace from the documentation to this code element.",
      "ground_truth_relationship": "The arun() method implements the documented JavaScript execution functionality by accepting custom JavaScript commands through its **kwargs parameter, which are then passed to the crawler_strategy.crawl() method for execution during the page crawl.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## JavaScript Execution\n\nExecute custom JavaScript before crawling:\n\n```python\n# Single JavaScript command\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\"\n)\n\n# Multiple commands\njs_commands = [\n    \"window.scrollTo(0, document.body.scrollHeight);\",\n    \"document.querySelector('.load-more').click();\"\n]\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=js_commands\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "method implementation",
      "relationship_explanation": "While not directly referenced in the snippet, AsyncPlaywrightCrawlerStrategy is the default crawler strategy used by AsyncWebCrawler. Its 'crawl' method retrieves the 'js_code' parameter and executes it via page.evaluate(), thereby implementing the custom JavaScript execution functionality.",
      "predicted_trace_chain": "browser-config.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain indicates that the call in AsyncWebCrawler.arun() forwards the js_code parameter to AsyncPlaywrightCrawlerStrategy, which handles the actual JavaScript execution. This intermediate step is necessary as AsyncWebCrawler delegates the crawling work to this implementing class.",
      "ground_truth_relationship": "The code implements JavaScript execution functionality through the crawl() method, which accepts js_code parameter that can handle both single commands and arrays of commands, evaluating them on the page using page.evaluate().",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## JavaScript Execution\n\nExecute custom JavaScript before crawling:\n\n```python\n# Single JavaScript command\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\"\n)\n\n# Multiple commands\njs_commands = [\n    \"window.scrollTo(0, document.body.scrollHeight);\",\n    \"document.querySelector('.load-more').click();\"\n]\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=js_commands\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the outcomes of JavaScript execution during crawling, including the modified HTML content, success status, and any errors that occurred during script execution.",
      "ground_truth_trace_chain": "browser-config.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## JavaScript Execution\n\nExecute custom JavaScript before crawling:\n\n```python\n# Single JavaScript command\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\"\n)\n\n# Multiple commands\njs_commands = [\n    \"window.scrollTo(0, document.body.scrollHeight);\",\n    \"document.querySelector('.load-more').click();\"\n]\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=js_commands\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class provides the foundational crawl() method that enables JavaScript execution during web scraping as shown in the documentation's arun() examples.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## JavaScript Execution\n\nExecute custom JavaScript before crawling:\n\n```python\n# Single JavaScript command\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\"\n)\n\n# Multiple commands\njs_commands = [\n    \"window.scrollTo(0, document.body.scrollHeight);\",\n    \"document.querySelector('.load-more').click();\"\n]\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=js_commands\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the documented JavaScript execution functionality through its arun method, which accepts a 'js_code' parameter and passes it to the underlying crawler_strategy for execution before webpage scraping.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Using the Advanced Schema\n\nTo use this advanced schema with AsyncWebCrawler:\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_complex_product_data():\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://gist.githubusercontent.com/githubusercontent/2d7b8ba3cd8ab6cf3c8da771ddb36878/raw/1ae2f90c6861ce7dd84cc50d3df9920dee5e1fd2/sample_ecommerce.html\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        product_data = json.loads(result.extracted_content)\n        print(json.dumps(product_data, indent=2))\n\nasyncio.run(extract_complex_product_data())\n```\n\nThis will produce a structured JSON output that captures the complex hierarchy of the product catalog, including nested objects, lists, and nested lists.",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation/usage",
      "relationship_explanation": "The documentation snippet explicitly imports and instantiates JsonCssExtractionStrategy with an advanced schema for data extraction.",
      "predicted_trace_chain": "css-advanced.md -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The snippet from 'css-advanced.md' directly uses JsonCssExtractionStrategy to configure extraction, establishing this trace.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class processes HTML content using a schema-based approach where it selects elements with BeautifulSoup and extracts structured data according to the field definitions shown in the documentation example.",
      "ground_truth_trace_chain": "css-advanced.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Using the Advanced Schema\n\nTo use this advanced schema with AsyncWebCrawler:\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_complex_product_data():\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://gist.githubusercontent.com/githubusercontent/2d7b8ba3cd8ab6cf3c8da771ddb36878/raw/1ae2f90c6861ce7dd84cc50d3df9920dee5e1fd2/sample_ecommerce.html\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        product_data = json.loads(result.extracted_content)\n        print(json.dumps(product_data, indent=2))\n\nasyncio.run(extract_complex_product_data())\n```\n\nThis will produce a structured JSON output that captures the complex hierarchy of the product catalog, including nested objects, lists, and nested lists.",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "JsonCssExtractionStrategy extends the abstract base class ExtractionStrategy, linking the advanced extraction functionality to the overall extraction framework.",
      "predicted_trace_chain": "css-advanced.md -> JsonCssExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "Since JsonCssExtractionStrategy inherits from ExtractionStrategy, the advanced extraction usage implicitly relies on ExtractionStrategy's interface.",
      "ground_truth_relationship": "The ExtractionStrategy abstract base class provides the foundation for specialized extraction strategies like JsonCssExtractionStrategy shown in the documentation, enabling structured data extraction from HTML content through its extract() and run() methods.",
      "ground_truth_trace_chain": "css-advanced.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Using the Advanced Schema\n\nTo use this advanced schema with AsyncWebCrawler:\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_complex_product_data():\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://gist.githubusercontent.com/githubusercontent/2d7b8ba3cd8ab6cf3c8da771ddb36878/raw/1ae2f90c6861ce7dd84cc50d3df9920dee5e1fd2/sample_ecommerce.html\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        product_data = json.loads(result.extracted_content)\n        print(json.dumps(product_data, indent=2))\n\nasyncio.run(extract_complex_product_data())\n```\n\nThis will produce a structured JSON output that captures the complex hierarchy of the product catalog, including nested objects, lists, and nested lists.",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation/usage",
      "relationship_explanation": "The snippet explicitly imports AsyncWebCrawler and uses it as an asynchronous context manager to perform crawling.",
      "predicted_trace_chain": "css-advanced.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The documentation starts in 'css-advanced.md' and directly instantiates AsyncWebCrawler, forming the basis for the crawl operation.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements asynchronous web crawling functionality shown in the documentation through its arun() method, which processes URLs, handles caching, and supports the JsonCssExtractionStrategy for advanced schema extraction.",
      "ground_truth_trace_chain": "css-advanced.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Using the Advanced Schema\n\nTo use this advanced schema with AsyncWebCrawler:\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_complex_product_data():\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://gist.githubusercontent.com/githubusercontent/2d7b8ba3cd8ab6cf3c8da771ddb36878/raw/1ae2f90c6861ce7dd84cc50d3df9920dee5e1fd2/sample_ecommerce.html\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        product_data = json.loads(result.extracted_content)\n        print(json.dumps(product_data, indent=2))\n\nasyncio.run(extract_complex_product_data())\n```\n\nThis will produce a structured JSON output that captures the complex hierarchy of the product catalog, including nested objects, lists, and nested lists.",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The code directly calls the arun() method of an AsyncWebCrawler instance to execute the crawl and retrieve results.",
      "predicted_trace_chain": "css-advanced.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "After instantiating AsyncWebCrawler, the snippet invokes its arun() method to start the crawling process, establishing this chain.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method implements the asynchronous web crawling functionality showcased in the documentation by accepting extraction strategies, handling caching, and returning structured results that enable the documented JSON data extraction workflow.",
      "ground_truth_trace_chain": "css-advanced.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Using the Advanced Schema\n\nTo use this advanced schema with AsyncWebCrawler:\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_complex_product_data():\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://gist.githubusercontent.com/githubusercontent/2d7b8ba3cd8ab6cf3c8da771ddb36878/raw/1ae2f90c6861ce7dd84cc50d3df9920dee5e1fd2/sample_ecommerce.html\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        product_data = json.loads(result.extracted_content)\n        print(json.dumps(product_data, indent=2))\n\nasyncio.run(extract_complex_product_data())\n```\n\nThis will produce a structured JSON output that captures the complex hierarchy of the product catalog, including nested objects, lists, and nested lists.",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_id": 20,
      "artifact_title": "CrawlResult.success",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet asserts on the 'success' attribute of the crawl result to ensure the crawl was successful.",
      "predicted_trace_chain": "css-advanced.md -> AsyncWebCrawler.arun() -> CrawlResult.success",
      "predicted_trace_chain_explanation": "The result of arun() is a CrawlResult object, from which the 'success' attribute is explicitly checked in the documentation.",
      "ground_truth_relationship": "The CrawlResult.success boolean property is used in the documentation example to validate that the crawling operation completed successfully before processing the extracted product data.",
      "ground_truth_trace_chain": "css-advanced.md -> CrawlResult.success",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Using the Advanced Schema\n\nTo use this advanced schema with AsyncWebCrawler:\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_complex_product_data():\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://gist.githubusercontent.com/githubusercontent/2d7b8ba3cd8ab6cf3c8da771ddb36878/raw/1ae2f90c6861ce7dd84cc50d3df9920dee5e1fd2/sample_ecommerce.html\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        product_data = json.loads(result.extracted_content)\n        print(json.dumps(product_data, indent=2))\n\nasyncio.run(extract_complex_product_data())\n```\n\nThis will produce a structured JSON output that captures the complex hierarchy of the product catalog, including nested objects, lists, and nested lists.",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_id": 11,
      "artifact_title": "CrawlResult.extracted_content",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The code accesses the 'extracted_content' attribute of the crawl result to obtain the structured JSON output of the product data.",
      "predicted_trace_chain": "css-advanced.md -> AsyncWebCrawler.arun() -> CrawlResult.extracted_content",
      "predicted_trace_chain_explanation": "After the crawl operation via arun(), the documentation retrieves structured data via the 'extracted_content' attribute of the resulting CrawlResult.",
      "ground_truth_relationship": "The CrawlResult.extracted_content field stores the raw extracted data as a string that must be JSON-parsed to access the structured product information shown in the documentation example.",
      "ground_truth_trace_chain": "css-advanced.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Using the Advanced Schema\n\nTo use this advanced schema with AsyncWebCrawler:\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_complex_product_data():\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://gist.githubusercontent.com/githubusercontent/2d7b8ba3cd8ab6cf3c8da771ddb36878/raw/1ae2f90c6861ce7dd84cc50d3df9920dee5e1fd2/sample_ecommerce.html\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        product_data = json.loads(result.extracted_content)\n        print(json.dumps(product_data, indent=2))\n\nasyncio.run(extract_complex_product_data())\n```\n\nThis will produce a structured JSON output that captures the complex hierarchy of the product catalog, including nested objects, lists, and nested lists.",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the structure that stores the extracted_content field used in the documentation example to validate successful crawling and store the parsed JSON product data.",
      "ground_truth_trace_chain": "css-advanced.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Using the Advanced Schema\n\nTo use this advanced schema with AsyncWebCrawler:\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_complex_product_data():\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://gist.githubusercontent.com/githubusercontent/2d7b8ba3cd8ab6cf3c8da771ddb36878/raw/1ae2f90c6861ce7dd84cc50d3df9920dee5e1fd2/sample_ecommerce.html\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        product_data = json.loads(result.extracted_content)\n        print(json.dumps(product_data, indent=2))\n\nasyncio.run(extract_complex_product_data())\n```\n\nThis will produce a structured JSON output that captures the complex hierarchy of the product catalog, including nested objects, lists, and nested lists.",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the core functionality needed to execute the documented AsyncWebCrawler example by providing a Playwright-based web scraping engine that handles browser automation, JavaScript execution, and HTML extraction for complex web scraping tasks.",
      "ground_truth_trace_chain": "css-advanced.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Using the Advanced Schema\n\nTo use this advanced schema with AsyncWebCrawler:\n\n```python\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nasync def extract_complex_product_data():\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://gist.githubusercontent.com/githubusercontent/2d7b8ba3cd8ab6cf3c8da771ddb36878/raw/1ae2f90c6861ce7dd84cc50d3df9920dee5e1fd2/sample_ecommerce.html\",\n            extraction_strategy=extraction_strategy,\n            bypass_cache=True,\n        )\n\n        assert result.success, \"Failed to crawl the page\"\n\n        product_data = json.loads(result.extracted_content)\n        print(json.dumps(product_data, indent=2))\n\nasyncio.run(extract_complex_product_data())\n```\n\nThis will produce a structured JSON output that captures the complex hierarchy of the product catalog, including nested objects, lists, and nested lists.",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the core interface methods that enable the documented AsyncWebCrawler to perform web scraping operations with customizable extraction strategies.",
      "ground_truth_trace_chain": "css-advanced.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Example: Handling Protected Sites\n\n```python\nasync def crawl_protected_site(url: str):\n    async with AsyncWebCrawler(headless=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            magic=True,\n            remove_overlay_elements=True,  # Remove popups/modals\n            page_timeout=60000            # Increased timeout for protection checks\n        )\n        \n        return result.markdown if result.success else None\n```\n",
      "document_location": "docs/md_v2/advanced/magic-mode.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation/usage",
      "relationship_explanation": "The documentation snippet explicitly instantiates AsyncWebCrawler with headless=True in an async context manager, indicating it is the primary class handling the crawl process.",
      "predicted_trace_chain": "magic-mode.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The snippet from magic-mode.md begins with the direct creation of an AsyncWebCrawler instance, establishing the starting point of the traceability chain.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the documented protected site crawling functionality through its arun method, which supports the parameters shown in the example like headless mode, magic mode, overlay removal, and custom timeouts for handling protected sites.",
      "ground_truth_trace_chain": "magic-mode.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example: Handling Protected Sites\n\n```python\nasync def crawl_protected_site(url: str):\n    async with AsyncWebCrawler(headless=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            magic=True,\n            remove_overlay_elements=True,  # Remove popups/modals\n            page_timeout=60000            # Increased timeout for protection checks\n        )\n        \n        return result.markdown if result.success else None\n```\n",
      "document_location": "docs/md_v2/advanced/magic-mode.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The code snippet explicitly calls the 'arun' method on the AsyncWebCrawler instance with parameters such as magic=True, remove_overlay_elements=True, and page_timeout=60000, which are essential for handling protected sites.",
      "predicted_trace_chain": "magic-mode.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "After instantiating AsyncWebCrawler, the snippet invokes its arun() method to perform crawling, forming a clear chain from the document to the method.",
      "ground_truth_relationship": "The code implements arun() with extensive error handling, caching, and customizable parameters that enable protected site crawling features shown in the documentation example like magic mode, overlay removal, and configurable timeouts.",
      "ground_truth_trace_chain": "magic-mode.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example: Handling Protected Sites\n\n```python\nasync def crawl_protected_site(url: str):\n    async with AsyncWebCrawler(headless=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            magic=True,\n            remove_overlay_elements=True,  # Remove popups/modals\n            page_timeout=60000            # Increased timeout for protection checks\n        )\n        \n        return result.markdown if result.success else None\n```\n",
      "document_location": "docs/md_v2/advanced/magic-mode.md",
      "artifact_id": 15,
      "artifact_title": "CrawlResult.markdown",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet returns 'result.markdown' if the crawl is successful, explicitly accessing the 'markdown' attribute from the CrawlResult object returned by arun().",
      "predicted_trace_chain": "magic-mode.md -> AsyncWebCrawler -> AsyncWebCrawler.arun() -> CrawlResult.markdown",
      "predicted_trace_chain_explanation": "This chain traces the output of the arun() method to the CrawlResult instance, specifically accessing its 'markdown' attribute to obtain the final processed content.",
      "ground_truth_relationship": "The CrawlResult.markdown property stores the extracted text output from crawling protected sites as shown in the example where it's returned upon successful crawls.",
      "ground_truth_trace_chain": "magic-mode.md -> CrawlResult.markdown",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example: Handling Protected Sites\n\n```python\nasync def crawl_protected_site(url: str):\n    async with AsyncWebCrawler(headless=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            magic=True,\n            remove_overlay_elements=True,  # Remove popups/modals\n            page_timeout=60000            # Increased timeout for protection checks\n        )\n        \n        return result.markdown if result.success else None\n```\n",
      "document_location": "docs/md_v2/advanced/magic-mode.md",
      "artifact_id": 20,
      "artifact_title": "CrawlResult.success",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute check",
      "relationship_explanation": "The documentation snippet uses 'result.success' in a conditional expression to determine whether the crawl was successful.",
      "predicted_trace_chain": "magic-mode.md -> AsyncWebCrawler -> AsyncWebCrawler.arun() -> CrawlResult.success",
      "predicted_trace_chain_explanation": "The chain shows that after calling arun(), the resulting CrawlResult object is evaluated for its 'success' attribute, which is critical for determining the outcome of the crawl.",
      "ground_truth_relationship": "The success flag directly determines whether protected site content should be returned as markdown or None in the crawling example.",
      "ground_truth_trace_chain": "magic-mode.md -> CrawlResult.success",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example: Handling Protected Sites\n\n```python\nasync def crawl_protected_site(url: str):\n    async with AsyncWebCrawler(headless=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            magic=True,\n            remove_overlay_elements=True,  # Remove popups/modals\n            page_timeout=60000            # Increased timeout for protection checks\n        )\n        \n        return result.markdown if result.success else None\n```\n",
      "document_location": "docs/md_v2/advanced/magic-mode.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "default strategy implementation",
      "relationship_explanation": "Although not explicitly mentioned in the snippet, AsyncWebCrawler internally defaults to using AsyncPlaywrightCrawlerStrategy for its crawling operations. Parameters like magic and remove_overlay_elements influence its behavior.",
      "predicted_trace_chain": "magic-mode.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The trace chain extends from AsyncWebCrawler to its default crawler strategy, AsyncPlaywrightCrawlerStrategy, indicating an implicit dependency that handles the low-level crawling logic.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the protected site crawling functionality by using headless browser automation with features like popup removal and extended timeouts as shown in the documentation example.",
      "ground_truth_trace_chain": "magic-mode.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example: Handling Protected Sites\n\n```python\nasync def crawl_protected_site(url: str):\n    async with AsyncWebCrawler(headless=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            magic=True,\n            remove_overlay_elements=True,  # Remove popups/modals\n            page_timeout=60000            # Increased timeout for protection checks\n        )\n        \n        return result.markdown if result.success else None\n```\n",
      "document_location": "docs/md_v2/advanced/magic-mode.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the structure for storing crawl outcomes, with fields like markdown and success that are accessed in the crawl_protected_site function's return statement.",
      "ground_truth_trace_chain": "magic-mode.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Example: Handling Protected Sites\n\n```python\nasync def crawl_protected_site(url: str):\n    async with AsyncWebCrawler(headless=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            magic=True,\n            remove_overlay_elements=True,  # Remove popups/modals\n            page_timeout=60000            # Increased timeout for protection checks\n        )\n        \n        return result.markdown if result.success else None\n```\n",
      "document_location": "docs/md_v2/advanced/magic-mode.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the interface that enables implementations like the documented crawl_protected_site function to perform automated web crawling with customizable behavior for handling protected sites through methods like crawl() and set_hook().",
      "ground_truth_trace_chain": "magic-mode.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### RegexChunking\n\n`RegexChunking` splits text using regular expressions. This is ideal for creating chunks based on specific patterns like paragraphs or sentences.\n\n#### When to Use\n- Great for structured text with consistent delimiters.\n- Suitable for documents where specific patterns (e.g., double newlines, periods) indicate logical chunks.\n\n#### Parameters\n- `patterns` (list, optional): Regular expressions used to split the text. Default is to split by double newlines (`['\\n\\n']`).\n\n#### Example\n```python\nfrom crawl4ai.chunking_strategy import RegexChunking\n\n# Define patterns for splitting text\npatterns = [r'\\n\\n', r'\\. ']\nchunker = RegexChunking(patterns=patterns)\n\n# Sample text\ntext = \"This is a sample text. It will be split into chunks.\\n\\nThis is another paragraph.\"\n\n# Chunk the text\nchunks = chunker.chunk(text)\nprint(chunks)\n```",
      "document_location": "docs/md_v2/extraction/chunking.md",
      "artifact_id": 26,
      "artifact_title": "RegexChunking",
      "predicted_relationship": "explicit",
      "relationship_type": "usage",
      "relationship_explanation": "The documentation snippet explicitly mentions the 'RegexChunking' class and shows its instantiation and usage in the provided example code. The example demonstrates initializing the class with a 'patterns' parameter and calling its 'chunk' method to split text. This direct reference establishes an explicit trace to the RegexChunking artifact.",
      "predicted_trace_chain": "docs/md_v2/extraction/chunking.md -> RegexChunking",
      "predicted_trace_chain_explanation": "The chain starts at the documentation file 'docs/md_v2/extraction/chunking.md' which directly shows the usage and purpose of the RegexChunking class, forming an explicit link from the documentation to the RegexChunking artifact.",
      "ground_truth_relationship": "The RegexChunking code implements text splitting using the re.split() function iteratively over each pattern in self.patterns, which directly corresponds to the documentation's description of using regular expressions to split text based on specified patterns like paragraphs or sentences.",
      "ground_truth_trace_chain": "chunking.md -> ChunkingStrategy -> RegexChunking",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### RegexChunking\n\n`RegexChunking` splits text using regular expressions. This is ideal for creating chunks based on specific patterns like paragraphs or sentences.\n\n#### When to Use\n- Great for structured text with consistent delimiters.\n- Suitable for documents where specific patterns (e.g., double newlines, periods) indicate logical chunks.\n\n#### Parameters\n- `patterns` (list, optional): Regular expressions used to split the text. Default is to split by double newlines (`['\\n\\n']`).\n\n#### Example\n```python\nfrom crawl4ai.chunking_strategy import RegexChunking\n\n# Define patterns for splitting text\npatterns = [r'\\n\\n', r'\\. ']\nchunker = RegexChunking(patterns=patterns)\n\n# Sample text\ntext = \"This is a sample text. It will be split into chunks.\\n\\nThis is another paragraph.\"\n\n# Chunk the text\nchunks = chunker.chunk(text)\nprint(chunks)\n```",
      "document_location": "docs/md_v2/extraction/chunking.md",
      "artifact_id": 6,
      "artifact_title": "ChunkingStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "extends",
      "relationship_explanation": "Although not explicitly mentioned in the documentation snippet, RegexChunking extends ChunkingStrategy. This implicit relationship is critical because RegexChunking implements the abstract 'chunk' method defined in ChunkingStrategy, linking it to the overall chunking framework.",
      "predicted_trace_chain": "docs/md_v2/extraction/chunking.md -> RegexChunking -> ChunkingStrategy",
      "predicted_trace_chain_explanation": "The chain begins with the documentation that explicitly references RegexChunking. Since RegexChunking inherits from ChunkingStrategy, the linkage extends implicitly to its base class, providing the necessary context for the implementation of chunking functionality.",
      "ground_truth_relationship": "The ChunkingStrategy abstract base class defines the foundational interface that RegexChunking must implement to perform text splitting using regular expressions through the required chunk() method.",
      "ground_truth_trace_chain": "chunking.md -> ChunkingStrategy -> ChunkingStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Content Customization\n\n### HTML to Text Options\n\nConfigure markdown conversion:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    html2text={\n        \"escape_dot\": False,\n        \"body_width\": 0,\n        \"protect_links\": True,\n        \"unicode_snob\": True\n    }\n)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "implicit",
      "relationship_type": "class instantiation/usage",
      "relationship_explanation": "The documentation snippet shows an invocation 'crawler.arun(...)', which implies that 'crawler' is an instance of the AsyncWebCrawler class. This class is responsible for managing the overall crawling process, including handling content customization options such as HTML to text conversion via passed keyword arguments.",
      "predicted_trace_chain": "docs/md_v2/basic/output-formats.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "Starting from the documentation file, the chain leads to the AsyncWebCrawler class, which provides the context for method invocations and overall crawler configuration.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements HTML-to-text customization through its arun() method which accepts HTML conversion parameters as keyword arguments (**kwargs) that are passed to the underlying crawler strategy.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Content Customization\n\n### HTML to Text Options\n\nConfigure markdown conversion:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    html2text={\n        \"escape_dot\": False,\n        \"body_width\": 0,\n        \"protect_links\": True,\n        \"unicode_snob\": True\n    }\n)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The usage example explicitly calls the 'arun' method on a crawler instance with a configuration dictionary provided to the 'html2text' parameter. This indicates that AsyncWebCrawler.arun() is the method responsible for processing these conversion options and returning a CrawlResult containing the markdown conversion of HTML.",
      "predicted_trace_chain": "docs/md_v2/basic/output-formats.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The trace chain shows the progression from the documentation file, through the AsyncWebCrawler class (which is instantiated as 'crawler'), to its 'arun()' method where the HTML to text conversion customization is applied.",
      "ground_truth_relationship": "The documentation shows the html2text customization options that can be passed as kwargs to the arun() method, which processes these options when crawling and converting webpage content as shown in the code's **kwargs parameter.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Content Customization\n\n### HTML to Text Options\n\nConfigure markdown conversion:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    html2text={\n        \"escape_dot\": False,\n        \"body_width\": 0,\n        \"protect_links\": True,\n        \"unicode_snob\": True\n    }\n)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class includes markdown and fit_markdown fields to store the text output from HTML conversion using the documented html2text configuration options.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Content Customization\n\n### HTML to Text Options\n\nConfigure markdown conversion:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    html2text={\n        \"escape_dot\": False,\n        \"body_width\": 0,\n        \"protect_links\": True,\n        \"unicode_snob\": True\n    }\n)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements HTML to text customization by accepting configuration options through its crawl method's kwargs parameter, which can be passed down from the crawler.arun() method documented in the example.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Content Customization\n\n### HTML to Text Options\n\nConfigure markdown conversion:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    html2text={\n        \"escape_dot\": False,\n        \"body_width\": 0,\n        \"protect_links\": True,\n        \"unicode_snob\": True\n    }\n)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface used to implement HTML-to-text customization options through its crawl method, which accepts kwargs to pass configuration parameters like the html2text options shown in the documentation.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "# LLM Extraction with AsyncWebCrawler\n\nCrawl4AI's AsyncWebCrawler allows you to use Language Models (LLMs) to extract structured data or relevant content from web pages asynchronously. Below are two examples demonstrating how to use `LLMExtractionStrategy` for different purposes with the AsyncWebCrawler.",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "extends/implements",
      "relationship_explanation": "The documentation explicitly mentions the use of `LLMExtractionStrategy` for LLM extraction. This artifact provides the logic for extracting structured data using language models and directly implements the extraction functionality as described in the snippet.",
      "predicted_trace_chain": "llm.md -> LLMExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The document (llm.md) directly refers to LLMExtractionStrategy. Since LLMExtractionStrategy extends the ExtractionStrategy base class, the full chain shows how the extraction behavior is structured.",
      "ground_truth_relationship": "The code implements an asynchronous web content extraction strategy that uses LLMs to process and structure web data, directly fulfilling the documentation's description of using Language Models for structured data extraction from web pages.",
      "ground_truth_trace_chain": "llm.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# LLM Extraction with AsyncWebCrawler\n\nCrawl4AI's AsyncWebCrawler allows you to use Language Models (LLMs) to extract structured data or relevant content from web pages asynchronously. Below are two examples demonstrating how to use `LLMExtractionStrategy` for different purposes with the AsyncWebCrawler.",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "uses/orchestrates",
      "relationship_explanation": "The documentation states that AsyncWebCrawler is used to perform asynchronous web crawling with integrated LLM extraction. This makes AsyncWebCrawler directly relevant as the main component coordinating the extraction tasks.",
      "predicted_trace_chain": "llm.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "Starting from llm.md, the documentation demonstrates the usage of AsyncWebCrawler as the driver for asynchronous crawling that supports LLM extraction.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements asynchronous web crawling functionality with built-in LLM extraction support through its arun method, which accepts an extraction_strategy parameter for processing crawled content with language models.",
      "ground_truth_trace_chain": "llm.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# LLM Extraction with AsyncWebCrawler\n\nCrawl4AI's AsyncWebCrawler allows you to use Language Models (LLMs) to extract structured data or relevant content from web pages asynchronously. Below are two examples demonstrating how to use `LLMExtractionStrategy` for different purposes with the AsyncWebCrawler.",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "While not mentioned explicitly in the text snippet, ExtractionStrategy is the base class for LLMExtractionStrategy. Its inclusion in the chain is necessary to understand the inheritance and design of the extraction functionality that enables LLM-based extraction.",
      "predicted_trace_chain": "llm.md -> LLMExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain shows that from the documented use of LLMExtractionStrategy, the extraction capabilities are built upon the common interface provided by ExtractionStrategy, which is a fundamental part of the extraction mechanism.",
      "ground_truth_relationship": "The ExtractionStrategy abstract base class defines a foundation for using LLMs to extract structured data from web pages by implementing a parallel processing system through its extract() and run() methods",
      "ground_truth_trace_chain": "llm.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Anti-Detection Features\n\nEnable stealth features to avoid bot detection:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    simulate_user=True,        # Simulate human behavior\n    override_navigator=True,   # Mask automation signals\n    magic=True               # Enable all anti-detection features\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "calls/usage",
      "relationship_explanation": "The documentation snippet shows an explicit call to 'crawler.arun()' with parameters such as simulate_user, override_navigator, and magic set to True. This directly maps to the 'AsyncWebCrawler.arun()' method, which is responsible for initiating the crawl and passing along these anti-detection flags.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the documentation file, the usage example directly indicates the 'arun()' method of 'AsyncWebCrawler' as the entry point for crawling with anti-detection features.",
      "ground_truth_relationship": "The arun() method accepts various stealth-related keyword arguments (like simulate_user, override_navigator, magic) which are passed through **kwargs to the crawler_strategy.crawl() function to implement the documented anti-detection features.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Anti-Detection Features\n\nEnable stealth features to avoid bot detection:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    simulate_user=True,        # Simulate human behavior\n    override_navigator=True,   # Mask automation signals\n    magic=True               # Enable all anti-detection features\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "implementation of anti-detection features",
      "relationship_explanation": "Inside the crawl method of 'AsyncPlaywrightCrawlerStrategy', the code checks for the flags simulate_user, override_navigator, and magic. When any of these flags are enabled, it injects stealth scripts to override navigator properties. This is how the strategy implements the anti-detection features described in the documentation.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain begins with the explicit call to 'arun()', which delegates the crawling to its underlying strategy ('AsyncPlaywrightCrawlerStrategy'). This strategy handles the anti-detection behavior by processing the provided flags.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements anti-detection features through context.add_init_script() which injects JavaScript to override navigator properties, simulate plugins, and mask automation signals when override_navigator, simulate_user, or magic parameters are set to True.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Anti-Detection Features\n\nEnable stealth features to avoid bot detection:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    simulate_user=True,        # Simulate human behavior\n    override_navigator=True,   # Mask automation signals\n    magic=True               # Enable all anti-detection features\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "The 'AsyncPlaywrightCrawlerStrategy' class extends the abstract base class 'AsyncCrawlerStrategy'. This inheritance forms the backbone of the crawler's design, ensuring a consistent interface and supporting the implementation of anti-detection features.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "This chain illustrates the design hierarchy: starting from the documentation's usage of 'arun()', moving to its implementation in 'AsyncPlaywrightCrawlerStrategy' and finally recognizing the foundational role of the base class 'AsyncCrawlerStrategy' that defines the interface.",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the interface for implementing anti-detection features through methods like update_user_agent and set_hook, which enable the stealth capabilities described in the documentation.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Anti-Detection Features\n\nEnable stealth features to avoid bot detection:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    simulate_user=True,        # Simulate human behavior\n    override_navigator=True,   # Mask automation signals\n    magic=True               # Enable all anti-detection features\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class captures crawling outcomes including response_headers and status_code which are essential for verifying if anti-detection measures successfully masked the crawler's automated nature.",
      "ground_truth_trace_chain": "browser-config.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Anti-Detection Features\n\nEnable stealth features to avoid bot detection:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    simulate_user=True,        # Simulate human behavior\n    override_navigator=True,   # Mask automation signals\n    magic=True               # Enable all anti-detection features\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The documentation describes anti-detection features which are implemented through optional kwargs parameters passed to the AsyncWebCrawler's constructor and arun method, which are then forwarded to the crawler_strategy for handling stealth behaviors.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Taking Screenshots \ud83d\udcf8\n\nCapture screenshots of web pages easily:\n\n```python\nasync def capture_and_save_screenshot(url: str, output_path: str):\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            screenshot=True,\n            bypass_cache=True\n        )\n        \n        if result.success and result.screenshot:\n            import base64\n            screenshot_data = base64.b64decode(result.screenshot)\n            with open(output_path, 'wb') as f:\n                f.write(screenshot_data)\n            print(f\"Screenshot saved successfully to {output_path}\")\n        else:\n            print(\"Failed to capture screenshot\")\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "class instantiation",
      "relationship_explanation": "The documentation snippet explicitly instantiates AsyncWebCrawler using 'async with AsyncWebCrawler(verbose=True) as crawler:', demonstrating its use for taking screenshots.",
      "predicted_trace_chain": "quickstart.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The snippet originates from quickstart.md and directly shows the creation of an AsyncWebCrawler instance.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements screenshot functionality through its arun method, which accepts a 'screenshot' boolean parameter and returns the captured image data in base64 format, which is then decoded and saved in the documented capture_and_save_screenshot function.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Taking Screenshots \ud83d\udcf8\n\nCapture screenshots of web pages easily:\n\n```python\nasync def capture_and_save_screenshot(url: str, output_path: str):\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            screenshot=True,\n            bypass_cache=True\n        )\n        \n        if result.success and result.screenshot:\n            import base64\n            screenshot_data = base64.b64decode(result.screenshot)\n            with open(output_path, 'wb') as f:\n                f.write(screenshot_data)\n            print(f\"Screenshot saved successfully to {output_path}\")\n        else:\n            print(\"Failed to capture screenshot\")\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The example explicitly calls the arun() method on the AsyncWebCrawler instance to perform the crawl, with parameters including 'screenshot=True' and 'bypass_cache=True'.",
      "predicted_trace_chain": "quickstart.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from quickstart.md, after instantiating AsyncWebCrawler, its arun() method is directly invoked to fetch the page and capture the screenshot.",
      "ground_truth_relationship": "The arun() method implements screenshot capture functionality by accepting a screenshot boolean parameter and populating screenshot_data from either the cache or a new crawl which is then returned in the CrawlResult for base64 decoding and saving as shown in the documentation example.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Taking Screenshots \ud83d\udcf8\n\nCapture screenshots of web pages easily:\n\n```python\nasync def capture_and_save_screenshot(url: str, output_path: str):\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            screenshot=True,\n            bypass_cache=True\n        )\n        \n        if result.success and result.screenshot:\n            import base64\n            screenshot_data = base64.b64decode(result.screenshot)\n            with open(output_path, 'wb') as f:\n                f.write(screenshot_data)\n            print(f\"Screenshot saved successfully to {output_path}\")\n        else:\n            print(\"Failed to capture screenshot\")\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 18,
      "artifact_title": "CrawlResult.screenshot",
      "predicted_relationship": "implicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "In the snippet, after receiving the result from arun(), the code checks 'result.screenshot' to verify if a screenshot was captured. This implies the use of the CrawlResult.screenshot attribute in the public interface.",
      "predicted_trace_chain": "quickstart.md -> AsyncWebCrawler -> AsyncWebCrawler.arun() -> CrawlResult.screenshot",
      "predicted_trace_chain_explanation": "The crawl() method returns a CrawlResult object, whose screenshot attribute is then accessed, forming a chain from the documentation to this attribute.",
      "ground_truth_relationship": "The CrawlResult.screenshot field stores the base64-encoded screenshot data that is later decoded and saved to a file in the capture_and_save_screenshot function.",
      "ground_truth_trace_chain": "quickstart.md -> CrawlResult.screenshot",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Taking Screenshots \ud83d\udcf8\n\nCapture screenshots of web pages easily:\n\n```python\nasync def capture_and_save_screenshot(url: str, output_path: str):\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            screenshot=True,\n            bypass_cache=True\n        )\n        \n        if result.success and result.screenshot:\n            import base64\n            screenshot_data = base64.b64decode(result.screenshot)\n            with open(output_path, 'wb') as f:\n                f.write(screenshot_data)\n            print(f\"Screenshot saved successfully to {output_path}\")\n        else:\n            print(\"Failed to capture screenshot\")\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 20,
      "artifact_title": "CrawlResult.success",
      "predicted_relationship": "implicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet also checks 'result.success' to ascertain if the crawl succeeded, thus implicitly utilizing the CrawlResult.success attribute from the result object.",
      "predicted_trace_chain": "quickstart.md -> AsyncWebCrawler -> AsyncWebCrawler.arun() -> CrawlResult.success",
      "predicted_trace_chain_explanation": "After invoking the arun() method on AsyncWebCrawler, the CrawlResult object is returned and its success attribute is used to determine the outcome, linking back to the documentation snippet.",
      "ground_truth_relationship": "The CrawlResult.success boolean property is used to verify if the screenshot capture operation completed successfully before attempting to save the screenshot data to disk.",
      "ground_truth_trace_chain": "quickstart.md -> CrawlResult.success",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Taking Screenshots \ud83d\udcf8\n\nCapture screenshots of web pages easily:\n\n```python\nasync def capture_and_save_screenshot(url: str, output_path: str):\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            screenshot=True,\n            bypass_cache=True\n        )\n        \n        if result.success and result.screenshot:\n            import base64\n            screenshot_data = base64.b64decode(result.screenshot)\n            with open(output_path, 'wb') as f:\n                f.write(screenshot_data)\n            print(f\"Screenshot saved successfully to {output_path}\")\n        else:\n            print(\"Failed to capture screenshot\")\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class includes a 'screenshot' field that stores base64-encoded image data, which enables the documented screenshot capture functionality to store and return webpage snapshots.",
      "ground_truth_trace_chain": "quickstart.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Taking Screenshots \ud83d\udcf8\n\nCapture screenshots of web pages easily:\n\n```python\nasync def capture_and_save_screenshot(url: str, output_path: str):\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            screenshot=True,\n            bypass_cache=True\n        )\n        \n        if result.success and result.screenshot:\n            import base64\n            screenshot_data = base64.b64decode(result.screenshot)\n            with open(output_path, 'wb') as f:\n                f.write(screenshot_data)\n            print(f\"Screenshot saved successfully to {output_path}\")\n        else:\n            print(\"Failed to capture screenshot\")\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the screenshot functionality by using the take_screenshot method that captures a full-page screenshot of the webpage and returns it as a base64-encoded string, which directly corresponds to the documented screenshot capture and saving process.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Taking Screenshots \ud83d\udcf8\n\nCapture screenshots of web pages easily:\n\n```python\nasync def capture_and_save_screenshot(url: str, output_path: str):\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            screenshot=True,\n            bypass_cache=True\n        )\n        \n        if result.success and result.screenshot:\n            import base64\n            screenshot_data = base64.b64decode(result.screenshot)\n            with open(output_path, 'wb') as f:\n                f.write(screenshot_data)\n            print(f\"Screenshot saved successfully to {output_path}\")\n        else:\n            print(\"Failed to capture screenshot\")\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface methods, including take_screenshot(), that enable the screenshot capture functionality demonstrated in the documentation's capture_and_save_screenshot function.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "# Output Formats\n\nCrawl4AI provides multiple output formats to suit different needs, from raw HTML to structured data using LLM or pattern-based extraction.\n\n## Basic Formats\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Access different formats\nraw_html = result.html           # Original HTML\nclean_html = result.cleaned_html # Sanitized HTML\nmarkdown = result.markdown       # Standard markdown\nfit_md = result.fit_markdown    # Most relevant content in markdown\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method call",
      "relationship_explanation": "The documentation snippet explicitly demonstrates the use of the 'arun()' method by invoking 'crawler.arun(url=\"https://example.com\")'. This clearly shows that this method is responsible for initiating the crawl and returning output formats.",
      "predicted_trace_chain": "docs/md_v2/basic/output-formats.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain starts at the documentation file and directly references the 'AsyncWebCrawler.arun()' method, which is explicitly called in the code snippet.",
      "ground_truth_relationship": "The arun() method implements the core crawling functionality that populates the different output formats (html, cleaned_html, markdown, fit_markdown) mentioned in the documentation through its processing and sanitization of the crawled content.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Output Formats\n\nCrawl4AI provides multiple output formats to suit different needs, from raw HTML to structured data using LLM or pattern-based extraction.\n\n## Basic Formats\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Access different formats\nraw_html = result.html           # Original HTML\nclean_html = result.cleaned_html # Sanitized HTML\nmarkdown = result.markdown       # Standard markdown\nfit_md = result.fit_markdown    # Most relevant content in markdown\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 8,
      "artifact_title": "CrawlResult",
      "predicted_relationship": "implicit",
      "relationship_type": "return type",
      "relationship_explanation": "While the documentation snippet does not mention 'CrawlResult' by name, the returned object from 'arun()' is an instance of CrawlResult. This object encapsulates all the output formats (raw HTML, cleaned HTML, markdown, and fit markdown) that are accessed later in the snippet.",
      "predicted_trace_chain": "docs/md_v2/basic/output-formats.md -> AsyncWebCrawler.arun() -> CrawlResult",
      "predicted_trace_chain_explanation": "The chain illustrates that calling 'AsyncWebCrawler.arun()' returns a 'CrawlResult' object, which is the source of all output attributes used in the documentation.",
      "ground_truth_relationship": "The CrawlResult class directly implements the documented output formats through its properties html, cleaned_html, markdown, and fit_markdown, which store the different content representations described in the documentation.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Output Formats\n\nCrawl4AI provides multiple output formats to suit different needs, from raw HTML to structured data using LLM or pattern-based extraction.\n\n## Basic Formats\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Access different formats\nraw_html = result.html           # Original HTML\nclean_html = result.cleaned_html # Sanitized HTML\nmarkdown = result.markdown       # Standard markdown\nfit_md = result.fit_markdown    # Most relevant content in markdown\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 13,
      "artifact_title": "CrawlResult.html",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The code snippet directly accesses 'result.html' to retrieve the original (raw) HTML. This clearly maps to the 'html' attribute defined in the CrawlResult model.",
      "predicted_trace_chain": "docs/md_v2/basic/output-formats.md -> AsyncWebCrawler.arun() -> CrawlResult.html",
      "predicted_trace_chain_explanation": "Starting from the documentation, the 'arun()' method returns a CrawlResult whose 'html' attribute is then used to obtain the raw HTML as shown in the example.",
      "ground_truth_relationship": "The code defines the 'html' property as a string type to store the raw HTML content mentioned in the documentation's Basic Formats section.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult.html",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Output Formats\n\nCrawl4AI provides multiple output formats to suit different needs, from raw HTML to structured data using LLM or pattern-based extraction.\n\n## Basic Formats\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Access different formats\nraw_html = result.html           # Original HTML\nclean_html = result.cleaned_html # Sanitized HTML\nmarkdown = result.markdown       # Standard markdown\nfit_md = result.fit_markdown    # Most relevant content in markdown\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 9,
      "artifact_title": "CrawlResult.cleaned_html",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The example shows the use of 'result.cleaned_html' to obtain sanitized HTML, directly linking the documentation to the public attribute 'cleaned_html' in the CrawlResult class.",
      "predicted_trace_chain": "docs/md_v2/basic/output-formats.md -> AsyncWebCrawler.arun() -> CrawlResult.cleaned_html",
      "predicted_trace_chain_explanation": "The trace starts from the documentation snippet, goes through the 'arun()' method, and ends at the 'cleaned_html' attribute of the CrawlResult object that provides the sanitized HTML output.",
      "ground_truth_relationship": "The cleaned_html property in CrawlResult stores the sanitized HTML version of the crawled webpage as an optional string value, providing access to a cleaned version of the original HTML content.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult.cleaned_html",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Output Formats\n\nCrawl4AI provides multiple output formats to suit different needs, from raw HTML to structured data using LLM or pattern-based extraction.\n\n## Basic Formats\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Access different formats\nraw_html = result.html           # Original HTML\nclean_html = result.cleaned_html # Sanitized HTML\nmarkdown = result.markdown       # Standard markdown\nfit_md = result.fit_markdown    # Most relevant content in markdown\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 15,
      "artifact_title": "CrawlResult.markdown",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet explicitly retrieves 'result.markdown' for the standard markdown output, directly mapping to the 'markdown' attribute in CrawlResult.",
      "predicted_trace_chain": "docs/md_v2/basic/output-formats.md -> AsyncWebCrawler.arun() -> CrawlResult.markdown",
      "predicted_trace_chain_explanation": "The chain indicates that after calling the 'arun()' method, the returned CrawlResult's 'markdown' attribute is accessed as shown by the documentation.",
      "ground_truth_relationship": "The markdown field in CrawlResult stores the HTML content converted to standard markdown format as shown in the documentation example where it can be accessed via result.markdown.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult.markdown",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Output Formats\n\nCrawl4AI provides multiple output formats to suit different needs, from raw HTML to structured data using LLM or pattern-based extraction.\n\n## Basic Formats\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Access different formats\nraw_html = result.html           # Original HTML\nclean_html = result.cleaned_html # Sanitized HTML\nmarkdown = result.markdown       # Standard markdown\nfit_md = result.fit_markdown    # Most relevant content in markdown\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 12,
      "artifact_title": "CrawlResult.fit_markdown",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The documentation snippet shows accessing 'result.fit_markdown' to obtain the most relevant or concise markdown output. This directly corresponds to the 'fit_markdown' attribute defined in the CrawlResult model.",
      "predicted_trace_chain": "docs/md_v2/basic/output-formats.md -> AsyncWebCrawler.arun() -> CrawlResult.fit_markdown",
      "predicted_trace_chain_explanation": "This chain demonstrates that the output for the most relevant markdown is derived from the 'fit_markdown' attribute of the CrawlResult object, which is returned by the 'arun()' method as illustrated in the documentation.",
      "ground_truth_relationship": "The fit_markdown property stores the most relevant content extracted from a webpage in markdown format as documented in the Basic Formats section.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult.fit_markdown",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Output Formats\n\nCrawl4AI provides multiple output formats to suit different needs, from raw HTML to structured data using LLM or pattern-based extraction.\n\n## Basic Formats\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Access different formats\nraw_html = result.html           # Original HTML\nclean_html = result.cleaned_html # Sanitized HTML\nmarkdown = result.markdown       # Standard markdown\nfit_md = result.fit_markdown    # Most relevant content in markdown\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface that enables the crawler to fetch content in different output formats through its crawl method which returns an AsyncCrawlResponse containing the various formats mentioned in the documentation.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "# Output Formats\n\nCrawl4AI provides multiple output formats to suit different needs, from raw HTML to structured data using LLM or pattern-based extraction.\n\n## Basic Formats\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Access different formats\nraw_html = result.html           # Original HTML\nclean_html = result.cleaned_html # Sanitized HTML\nmarkdown = result.markdown       # Standard markdown\nfit_md = result.fit_markdown    # Most relevant content in markdown\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the core crawling functionality that enables the extraction of different output formats (raw HTML, cleaned HTML, markdown) by retrieving the page content through its crawl() method and returning an AsyncCrawlResponse object containing the raw HTML which can then be transformed into other formats.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "# Output Formats\n\nCrawl4AI provides multiple output formats to suit different needs, from raw HTML to structured data using LLM or pattern-based extraction.\n\n## Basic Formats\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Access different formats\nraw_html = result.html           # Original HTML\nclean_html = result.cleaned_html # Sanitized HTML\nmarkdown = result.markdown       # Standard markdown\nfit_md = result.fit_markdown    # Most relevant content in markdown\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The code implements the documented output formats through the CrawlResult class, which returns html, cleaned_html, markdown, and fit_markdown properties corresponding exactly to the formats shown in the documentation example.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Dynamic Content with Sessions\n\nHere's a real-world example of crawling GitHub commits across multiple pages:\n\n```python\nasync def crawl_dynamic_content():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        url = \"https://github.com/microsoft/TypeScript/commits/main\"\n        session_id = \"typescript_commits_session\"\n        all_commits = []\n\n        # Define navigation JavaScript\n        js_next_page = \"\"\"\n        const button = document.querySelector('a[data-testid=\"pagination-next-button\"]');\n        if (button) button.click();\n        \"\"\"\n\n        # Define wait condition\n        wait_for = \"\"\"() => {\n            const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4');\n            if (commits.length === 0) return false;\n            const firstCommit = commits[0].textContent.trim();\n            return firstCommit !== window.firstCommit;\n        }\"\"\"\n        \n        # Define extraction schema\n        schema = {\n            \"name\": \"Commit Extractor\",\n            \"baseSelector\": \"li.Box-sc-g0xbh4-0\",\n            \"fields\": [\n                {\n                    \"name\": \"title\",\n                    \"selector\": \"h4.markdown-title\",\n                    \"type\": \"text\",\n                    \"transform\": \"strip\",\n                },\n            ],\n        }\n        extraction_strategy = JsonCssExtractionStrategy(schema)\n\n        # Crawl multiple pages\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                extraction_strategy=extraction_strategy,\n                js_code=js_next_page if page > 0 else None,\n                wait_for=wait_for if page > 0 else None,\n                js_only=page > 0,\n                bypass_cache=True\n            )\n\n            if result.success:\n                commits = json.loads(result.extracted_content)\n                all_commits.extend(commits)\n                print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        # Clean up session\n        await crawler.crawler_strategy.kill_session(session_id)\n        return all_commits\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation and usage",
      "relationship_explanation": "The documentation snippet explicitly instantiates AsyncWebCrawler using an async context manager (using 'async with AsyncWebCrawler(verbose=True) as crawler'), indicating that this class provides the main crawling interface and session management functionality.",
      "predicted_trace_chain": "docs/md_v2/advanced/session-management.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain starts at the documentation file and directly calls out AsyncWebCrawler which is used to manage dynamic crawling sessions.",
      "ground_truth_relationship": "The AsyncWebCrawler class enables dynamic content crawling through its arun() method which supports session-based browsing, JavaScript execution, and custom extraction strategies as demonstrated in the documentation's GitHub commits crawling example.",
      "ground_truth_trace_chain": "session-management.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Dynamic Content with Sessions\n\nHere's a real-world example of crawling GitHub commits across multiple pages:\n\n```python\nasync def crawl_dynamic_content():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        url = \"https://github.com/microsoft/TypeScript/commits/main\"\n        session_id = \"typescript_commits_session\"\n        all_commits = []\n\n        # Define navigation JavaScript\n        js_next_page = \"\"\"\n        const button = document.querySelector('a[data-testid=\"pagination-next-button\"]');\n        if (button) button.click();\n        \"\"\"\n\n        # Define wait condition\n        wait_for = \"\"\"() => {\n            const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4');\n            if (commits.length === 0) return false;\n            const firstCommit = commits[0].textContent.trim();\n            return firstCommit !== window.firstCommit;\n        }\"\"\"\n        \n        # Define extraction schema\n        schema = {\n            \"name\": \"Commit Extractor\",\n            \"baseSelector\": \"li.Box-sc-g0xbh4-0\",\n            \"fields\": [\n                {\n                    \"name\": \"title\",\n                    \"selector\": \"h4.markdown-title\",\n                    \"type\": \"text\",\n                    \"transform\": \"strip\",\n                },\n            ],\n        }\n        extraction_strategy = JsonCssExtractionStrategy(schema)\n\n        # Crawl multiple pages\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                extraction_strategy=extraction_strategy,\n                js_code=js_next_page if page > 0 else None,\n                wait_for=wait_for if page > 0 else None,\n                js_only=page > 0,\n                bypass_cache=True\n            )\n\n            if result.success:\n                commits = json.loads(result.extracted_content)\n                all_commits.extend(commits)\n                print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        # Clean up session\n        await crawler.crawler_strategy.kill_session(session_id)\n        return all_commits\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "Within the example, the 'arun' method is explicitly called (e.g. 'result = await crawler.arun(...)') to perform the actual crawling and extraction of dynamic content from multiple pages.",
      "predicted_trace_chain": "docs/md_v2/advanced/session-management.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The documentation shows AsyncWebCrawler being used and then its 'arun' method is invoked to process each page, forming a clear chain from the document to the method.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method provides the core functionality for executing dynamic web crawling with session management, implementing features like bypass_cache and session_id parameters that are demonstrated in the document's GitHub commits crawling example.",
      "ground_truth_trace_chain": "session-management.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Dynamic Content with Sessions\n\nHere's a real-world example of crawling GitHub commits across multiple pages:\n\n```python\nasync def crawl_dynamic_content():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        url = \"https://github.com/microsoft/TypeScript/commits/main\"\n        session_id = \"typescript_commits_session\"\n        all_commits = []\n\n        # Define navigation JavaScript\n        js_next_page = \"\"\"\n        const button = document.querySelector('a[data-testid=\"pagination-next-button\"]');\n        if (button) button.click();\n        \"\"\"\n\n        # Define wait condition\n        wait_for = \"\"\"() => {\n            const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4');\n            if (commits.length === 0) return false;\n            const firstCommit = commits[0].textContent.trim();\n            return firstCommit !== window.firstCommit;\n        }\"\"\"\n        \n        # Define extraction schema\n        schema = {\n            \"name\": \"Commit Extractor\",\n            \"baseSelector\": \"li.Box-sc-g0xbh4-0\",\n            \"fields\": [\n                {\n                    \"name\": \"title\",\n                    \"selector\": \"h4.markdown-title\",\n                    \"type\": \"text\",\n                    \"transform\": \"strip\",\n                },\n            ],\n        }\n        extraction_strategy = JsonCssExtractionStrategy(schema)\n\n        # Crawl multiple pages\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                extraction_strategy=extraction_strategy,\n                js_code=js_next_page if page > 0 else None,\n                wait_for=wait_for if page > 0 else None,\n                js_only=page > 0,\n                bypass_cache=True\n            )\n\n            if result.success:\n                commits = json.loads(result.extracted_content)\n                all_commits.extend(commits)\n                print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        # Clean up session\n        await crawler.crawler_strategy.kill_session(session_id)\n        return all_commits\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation for extraction",
      "relationship_explanation": "The code snippet explicitly creates an instance of JsonCssExtractionStrategy by passing a schema to extract commit titles from the crawled page. This extraction strategy processes HTML content using defined CSS selectors.",
      "predicted_trace_chain": "docs/md_v2/advanced/session-management.md -> AsyncWebCrawler.arun() -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The extraction strategy is directly linked to the crawling process via the 'arun' method, demonstrating that the document\u2019s extraction requirement is satisfied through this strategy.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class implements the schema-based extraction logic shown in the documentation by parsing HTML elements using BeautifulSoup and applying the defined selectors to extract commit data from GitHub's pages.",
      "ground_truth_trace_chain": "session-management.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Dynamic Content with Sessions\n\nHere's a real-world example of crawling GitHub commits across multiple pages:\n\n```python\nasync def crawl_dynamic_content():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        url = \"https://github.com/microsoft/TypeScript/commits/main\"\n        session_id = \"typescript_commits_session\"\n        all_commits = []\n\n        # Define navigation JavaScript\n        js_next_page = \"\"\"\n        const button = document.querySelector('a[data-testid=\"pagination-next-button\"]');\n        if (button) button.click();\n        \"\"\"\n\n        # Define wait condition\n        wait_for = \"\"\"() => {\n            const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4');\n            if (commits.length === 0) return false;\n            const firstCommit = commits[0].textContent.trim();\n            return firstCommit !== window.firstCommit;\n        }\"\"\"\n        \n        # Define extraction schema\n        schema = {\n            \"name\": \"Commit Extractor\",\n            \"baseSelector\": \"li.Box-sc-g0xbh4-0\",\n            \"fields\": [\n                {\n                    \"name\": \"title\",\n                    \"selector\": \"h4.markdown-title\",\n                    \"type\": \"text\",\n                    \"transform\": \"strip\",\n                },\n            ],\n        }\n        extraction_strategy = JsonCssExtractionStrategy(schema)\n\n        # Crawl multiple pages\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                extraction_strategy=extraction_strategy,\n                js_code=js_next_page if page > 0 else None,\n                wait_for=wait_for if page > 0 else None,\n                js_only=page > 0,\n                bypass_cache=True\n            )\n\n            if result.success:\n                commits = json.loads(result.extracted_content)\n                all_commits.extend(commits)\n                print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        # Clean up session\n        await crawler.crawler_strategy.kill_session(session_id)\n        return all_commits\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_id": 2,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation for session cleanup",
      "relationship_explanation": "At the end of the example, the 'kill_session' method is explicitly called (via 'await crawler.crawler_strategy.kill_session(session_id)') to clean up the active session after crawling dynamic content.",
      "predicted_trace_chain": "docs/md_v2/advanced/session-management.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_trace_chain_explanation": "This chain demonstrates that session management is achieved by invoking the kill_session method on the crawler's strategy, ensuring proper session termination as described in the document.",
      "ground_truth_relationship": "The kill_session method cleans up browser resources by closing the page and context objects stored in the sessions dictionary, which is demonstrated in the documentation's final step of the GitHub commit crawling example.",
      "ground_truth_trace_chain": "session-management.md -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Dynamic Content with Sessions\n\nHere's a real-world example of crawling GitHub commits across multiple pages:\n\n```python\nasync def crawl_dynamic_content():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        url = \"https://github.com/microsoft/TypeScript/commits/main\"\n        session_id = \"typescript_commits_session\"\n        all_commits = []\n\n        # Define navigation JavaScript\n        js_next_page = \"\"\"\n        const button = document.querySelector('a[data-testid=\"pagination-next-button\"]');\n        if (button) button.click();\n        \"\"\"\n\n        # Define wait condition\n        wait_for = \"\"\"() => {\n            const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4');\n            if (commits.length === 0) return false;\n            const firstCommit = commits[0].textContent.trim();\n            return firstCommit !== window.firstCommit;\n        }\"\"\"\n        \n        # Define extraction schema\n        schema = {\n            \"name\": \"Commit Extractor\",\n            \"baseSelector\": \"li.Box-sc-g0xbh4-0\",\n            \"fields\": [\n                {\n                    \"name\": \"title\",\n                    \"selector\": \"h4.markdown-title\",\n                    \"type\": \"text\",\n                    \"transform\": \"strip\",\n                },\n            ],\n        }\n        extraction_strategy = JsonCssExtractionStrategy(schema)\n\n        # Crawl multiple pages\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                extraction_strategy=extraction_strategy,\n                js_code=js_next_page if page > 0 else None,\n                wait_for=wait_for if page > 0 else None,\n                js_only=page > 0,\n                bypass_cache=True\n            )\n\n            if result.success:\n                commits = json.loads(result.extracted_content)\n                all_commits.extend(commits)\n                print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        # Clean up session\n        await crawler.crawler_strategy.kill_session(session_id)\n        return all_commits\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "default implementation of crawler strategy",
      "relationship_explanation": "Although the documentation does not directly mention AsyncPlaywrightCrawlerStrategy by name, AsyncWebCrawler internally defaults to instantiating AsyncPlaywrightCrawlerStrategy when no custom strategy is provided. This strategy underlies the session management and dynamic content handling, including the kill_session functionality.",
      "predicted_trace_chain": "docs/md_v2/advanced/session-management.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The implicit chain shows that AsyncWebCrawler leverages AsyncPlaywrightCrawlerStrategy as its default implementation, linking the documented dynamic session handling to the actual underlying strategy.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the session management and page navigation logic required to support the dynamic content crawling example, including handling session_id persistence and executing JavaScript for next page navigation.",
      "ground_truth_trace_chain": "session-management.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Dynamic Content with Sessions\n\nHere's a real-world example of crawling GitHub commits across multiple pages:\n\n```python\nasync def crawl_dynamic_content():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        url = \"https://github.com/microsoft/TypeScript/commits/main\"\n        session_id = \"typescript_commits_session\"\n        all_commits = []\n\n        # Define navigation JavaScript\n        js_next_page = \"\"\"\n        const button = document.querySelector('a[data-testid=\"pagination-next-button\"]');\n        if (button) button.click();\n        \"\"\"\n\n        # Define wait condition\n        wait_for = \"\"\"() => {\n            const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4');\n            if (commits.length === 0) return false;\n            const firstCommit = commits[0].textContent.trim();\n            return firstCommit !== window.firstCommit;\n        }\"\"\"\n        \n        # Define extraction schema\n        schema = {\n            \"name\": \"Commit Extractor\",\n            \"baseSelector\": \"li.Box-sc-g0xbh4-0\",\n            \"fields\": [\n                {\n                    \"name\": \"title\",\n                    \"selector\": \"h4.markdown-title\",\n                    \"type\": \"text\",\n                    \"transform\": \"strip\",\n                },\n            ],\n        }\n        extraction_strategy = JsonCssExtractionStrategy(schema)\n\n        # Crawl multiple pages\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                extraction_strategy=extraction_strategy,\n                js_code=js_next_page if page > 0 else None,\n                wait_for=wait_for if page > 0 else None,\n                js_only=page > 0,\n                bypass_cache=True\n            )\n\n            if result.success:\n                commits = json.loads(result.extracted_content)\n                all_commits.extend(commits)\n                print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        # Clean up session\n        await crawler.crawler_strategy.kill_session(session_id)\n        return all_commits\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult model stores the extracted commits and session data from the GitHub crawling example by providing fields like 'extracted_content' for the commit data and 'session_id' for tracking the TypeScript commits session.",
      "ground_truth_trace_chain": "session-management.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Dynamic Content with Sessions\n\nHere's a real-world example of crawling GitHub commits across multiple pages:\n\n```python\nasync def crawl_dynamic_content():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        url = \"https://github.com/microsoft/TypeScript/commits/main\"\n        session_id = \"typescript_commits_session\"\n        all_commits = []\n\n        # Define navigation JavaScript\n        js_next_page = \"\"\"\n        const button = document.querySelector('a[data-testid=\"pagination-next-button\"]');\n        if (button) button.click();\n        \"\"\"\n\n        # Define wait condition\n        wait_for = \"\"\"() => {\n            const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4');\n            if (commits.length === 0) return false;\n            const firstCommit = commits[0].textContent.trim();\n            return firstCommit !== window.firstCommit;\n        }\"\"\"\n        \n        # Define extraction schema\n        schema = {\n            \"name\": \"Commit Extractor\",\n            \"baseSelector\": \"li.Box-sc-g0xbh4-0\",\n            \"fields\": [\n                {\n                    \"name\": \"title\",\n                    \"selector\": \"h4.markdown-title\",\n                    \"type\": \"text\",\n                    \"transform\": \"strip\",\n                },\n            ],\n        }\n        extraction_strategy = JsonCssExtractionStrategy(schema)\n\n        # Crawl multiple pages\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                extraction_strategy=extraction_strategy,\n                js_code=js_next_page if page > 0 else None,\n                wait_for=wait_for if page > 0 else None,\n                js_only=page > 0,\n                bypass_cache=True\n            )\n\n            if result.success:\n                commits = json.loads(result.extracted_content)\n                all_commits.extend(commits)\n                print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        # Clean up session\n        await crawler.crawler_strategy.kill_session(session_id)\n        return all_commits\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_title": "CrawlResult.extracted_content",
      "ground_truth_relationship": "The extracted_content field stores the scraped GitHub commit data as a JSON string, which is then parsed and accumulated into the all_commits list during the pagination process.",
      "ground_truth_trace_chain": "session-management.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Dynamic Content with Sessions\n\nHere's a real-world example of crawling GitHub commits across multiple pages:\n\n```python\nasync def crawl_dynamic_content():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        url = \"https://github.com/microsoft/TypeScript/commits/main\"\n        session_id = \"typescript_commits_session\"\n        all_commits = []\n\n        # Define navigation JavaScript\n        js_next_page = \"\"\"\n        const button = document.querySelector('a[data-testid=\"pagination-next-button\"]');\n        if (button) button.click();\n        \"\"\"\n\n        # Define wait condition\n        wait_for = \"\"\"() => {\n            const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4');\n            if (commits.length === 0) return false;\n            const firstCommit = commits[0].textContent.trim();\n            return firstCommit !== window.firstCommit;\n        }\"\"\"\n        \n        # Define extraction schema\n        schema = {\n            \"name\": \"Commit Extractor\",\n            \"baseSelector\": \"li.Box-sc-g0xbh4-0\",\n            \"fields\": [\n                {\n                    \"name\": \"title\",\n                    \"selector\": \"h4.markdown-title\",\n                    \"type\": \"text\",\n                    \"transform\": \"strip\",\n                },\n            ],\n        }\n        extraction_strategy = JsonCssExtractionStrategy(schema)\n\n        # Crawl multiple pages\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                extraction_strategy=extraction_strategy,\n                js_code=js_next_page if page > 0 else None,\n                wait_for=wait_for if page > 0 else None,\n                js_only=page > 0,\n                bypass_cache=True\n            )\n\n            if result.success:\n                commits = json.loads(result.extracted_content)\n                all_commits.extend(commits)\n                print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        # Clean up session\n        await crawler.crawler_strategy.kill_session(session_id)\n        return all_commits\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_title": "CrawlResult.success",
      "ground_truth_relationship": "The CrawlResult.success boolean property is used in the documentation example to verify if commit extraction was successful before appending the commits to all_commits list.",
      "ground_truth_trace_chain": "session-management.md -> CrawlResult.success",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Dynamic Content with Sessions\n\nHere's a real-world example of crawling GitHub commits across multiple pages:\n\n```python\nasync def crawl_dynamic_content():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        url = \"https://github.com/microsoft/TypeScript/commits/main\"\n        session_id = \"typescript_commits_session\"\n        all_commits = []\n\n        # Define navigation JavaScript\n        js_next_page = \"\"\"\n        const button = document.querySelector('a[data-testid=\"pagination-next-button\"]');\n        if (button) button.click();\n        \"\"\"\n\n        # Define wait condition\n        wait_for = \"\"\"() => {\n            const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4');\n            if (commits.length === 0) return false;\n            const firstCommit = commits[0].textContent.trim();\n            return firstCommit !== window.firstCommit;\n        }\"\"\"\n        \n        # Define extraction schema\n        schema = {\n            \"name\": \"Commit Extractor\",\n            \"baseSelector\": \"li.Box-sc-g0xbh4-0\",\n            \"fields\": [\n                {\n                    \"name\": \"title\",\n                    \"selector\": \"h4.markdown-title\",\n                    \"type\": \"text\",\n                    \"transform\": \"strip\",\n                },\n            ],\n        }\n        extraction_strategy = JsonCssExtractionStrategy(schema)\n\n        # Crawl multiple pages\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                extraction_strategy=extraction_strategy,\n                js_code=js_next_page if page > 0 else None,\n                wait_for=wait_for if page > 0 else None,\n                js_only=page > 0,\n                bypass_cache=True\n            )\n\n            if result.success:\n                commits = json.loads(result.extracted_content)\n                all_commits.extend(commits)\n                print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        # Clean up session\n        await crawler.crawler_strategy.kill_session(session_id)\n        return all_commits\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_title": "ExtractionStrategy",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the foundational structure that enables the JsonCssExtractionStrategy used in the documentation to extract commit information from GitHub pages through a unified interface.",
      "ground_truth_trace_chain": "session-management.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Dynamic Content with Sessions\n\nHere's a real-world example of crawling GitHub commits across multiple pages:\n\n```python\nasync def crawl_dynamic_content():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        url = \"https://github.com/microsoft/TypeScript/commits/main\"\n        session_id = \"typescript_commits_session\"\n        all_commits = []\n\n        # Define navigation JavaScript\n        js_next_page = \"\"\"\n        const button = document.querySelector('a[data-testid=\"pagination-next-button\"]');\n        if (button) button.click();\n        \"\"\"\n\n        # Define wait condition\n        wait_for = \"\"\"() => {\n            const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4');\n            if (commits.length === 0) return false;\n            const firstCommit = commits[0].textContent.trim();\n            return firstCommit !== window.firstCommit;\n        }\"\"\"\n        \n        # Define extraction schema\n        schema = {\n            \"name\": \"Commit Extractor\",\n            \"baseSelector\": \"li.Box-sc-g0xbh4-0\",\n            \"fields\": [\n                {\n                    \"name\": \"title\",\n                    \"selector\": \"h4.markdown-title\",\n                    \"type\": \"text\",\n                    \"transform\": \"strip\",\n                },\n            ],\n        }\n        extraction_strategy = JsonCssExtractionStrategy(schema)\n\n        # Crawl multiple pages\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                extraction_strategy=extraction_strategy,\n                js_code=js_next_page if page > 0 else None,\n                wait_for=wait_for if page > 0 else None,\n                js_only=page > 0,\n                bypass_cache=True\n            )\n\n            if result.success:\n                commits = json.loads(result.extracted_content)\n                all_commits.extend(commits)\n                print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        # Clean up session\n        await crawler.crawler_strategy.kill_session(session_id)\n        return all_commits\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface methods that enable dynamic session-based crawling operations demonstrated in the documentation example, particularly through its crawl method which is used to navigate through GitHub's paginated commit history.",
      "ground_truth_trace_chain": "session-management.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Handling Dynamic Content\n\n### Load More Content\n\nHandle infinite scroll or load more buttons:\n\n```python\n# Scroll and wait pattern\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=[\n        # Scroll to bottom\n        \"window.scrollTo(0, document.body.scrollHeight);\",\n        # Click load more if exists\n        \"const loadMore = document.querySelector('.load-more'); if(loadMore) loadMore.click();\"\n    ],\n    # Wait for new content\n    wait_for=\"js:() => document.querySelectorAll('.item').length > previousCount\"\n)\n```\n\n### Form Interaction\n\nHandle forms and inputs:\n\n```python\njs_form_interaction = \"\"\"\n    // Fill form fields\n    document.querySelector('#search').value = 'search term';\n    // Submit form\n    document.querySelector('form').submit();\n\"\"\"\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=js_form_interaction,\n    wait_for=\"css:.results\"  # Wait for results to load\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "uses",
      "relationship_explanation": "The documentation snippet explicitly calls 'crawler.arun()' with parameters such as 'js_code' and 'wait_for'. This direct invocation maps to the AsyncWebCrawler.arun() method, which is responsible for handling dynamic content such as infinite scroll and form interactions.",
      "predicted_trace_chain": "docs/md_v2/basic/page-interaction.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain starts with the documentation file and directly links to the 'AsyncWebCrawler.arun()' method because the sample code explicitly invokes this method to process dynamic page interactions.",
      "ground_truth_relationship": "The arun() method implements dynamic content handling and form interactions by accepting js_code and wait_for parameters that allow execution of JavaScript commands for scrolling, clicking, and form manipulation while waiting for specified selectors or conditions to be met.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Handling Dynamic Content\n\n### Load More Content\n\nHandle infinite scroll or load more buttons:\n\n```python\n# Scroll and wait pattern\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=[\n        # Scroll to bottom\n        \"window.scrollTo(0, document.body.scrollHeight);\",\n        # Click load more if exists\n        \"const loadMore = document.querySelector('.load-more'); if(loadMore) loadMore.click();\"\n    ],\n    # Wait for new content\n    wait_for=\"js:() => document.querySelectorAll('.item').length > previousCount\"\n)\n```\n\n### Form Interaction\n\nHandle forms and inputs:\n\n```python\njs_form_interaction = \"\"\"\n    // Fill form fields\n    document.querySelector('#search').value = 'search term';\n    // Submit form\n    document.querySelector('form').submit();\n\"\"\"\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=js_form_interaction,\n    wait_for=\"css:.results\"  # Wait for results to load\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "implicit",
      "relationship_type": "contains method",
      "relationship_explanation": "Although not directly mentioned in the snippet, the 'crawler' variable is understood to be an instance of AsyncWebCrawler. This class encapsulates the 'arun()' method, thereby providing the broader crawling framework used in the examples.",
      "predicted_trace_chain": "docs/md_v2/basic/page-interaction.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "Since 'arun()' is a method of AsyncWebCrawler, the documentation implicitly relies on this class to provide the complete dynamic content handling functionality.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements dynamic content handling through its arun method, which accepts js_code and wait_for parameters to execute JavaScript for scrolling, form interactions, and waiting for content loads as described in the documentation.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Handling Dynamic Content\n\n### Load More Content\n\nHandle infinite scroll or load more buttons:\n\n```python\n# Scroll and wait pattern\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=[\n        # Scroll to bottom\n        \"window.scrollTo(0, document.body.scrollHeight);\",\n        # Click load more if exists\n        \"const loadMore = document.querySelector('.load-more'); if(loadMore) loadMore.click();\"\n    ],\n    # Wait for new content\n    wait_for=\"js:() => document.querySelectorAll('.item').length > previousCount\"\n)\n```\n\n### Form Interaction\n\nHandle forms and inputs:\n\n```python\njs_form_interaction = \"\"\"\n    // Fill form fields\n    document.querySelector('#search').value = 'search term';\n    // Submit form\n    document.querySelector('form').submit();\n\"\"\"\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=js_form_interaction,\n    wait_for=\"css:.results\"  # Wait for results to load\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "implements",
      "relationship_explanation": "By default, AsyncWebCrawler instantiates AsyncPlaywrightCrawlerStrategy as its crawler strategy. This strategy implements the detailed crawling behavior\u2014including handling JavaScript actions\u2014needed for features like scrolling and form submission as illustrated in the snippet.",
      "predicted_trace_chain": "docs/md_v2/basic/page-interaction.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain indicates that the 'arun()' method of AsyncWebCrawler delegates the crawling operations to a strategy. Since AsyncPlaywrightCrawlerStrategy is the default implementation, it forms an essential part of the execution chain for the dynamic content handling demonstrated in the documentation.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements dynamic content loading through its smart_wait method which handles both scroll-to-bottom and form interaction patterns by executing JavaScript code and waiting for specified selectors or conditions as shown in the documentation examples.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Handling Dynamic Content\n\n### Load More Content\n\nHandle infinite scroll or load more buttons:\n\n```python\n# Scroll and wait pattern\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=[\n        # Scroll to bottom\n        \"window.scrollTo(0, document.body.scrollHeight);\",\n        # Click load more if exists\n        \"const loadMore = document.querySelector('.load-more'); if(loadMore) loadMore.click();\"\n    ],\n    # Wait for new content\n    wait_for=\"js:() => document.querySelectorAll('.item').length > previousCount\"\n)\n```\n\n### Form Interaction\n\nHandle forms and inputs:\n\n```python\njs_form_interaction = \"\"\"\n    // Fill form fields\n    document.querySelector('#search').value = 'search term';\n    // Submit form\n    document.querySelector('form').submit();\n\"\"\"\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=js_form_interaction,\n    wait_for=\"css:.results\"  # Wait for results to load\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "AsyncPlaywrightCrawlerStrategy extends the abstract base class AsyncCrawlerStrategy. This relationship ensures that the strategy conforms to a defined interface for crawling operations, including those needed for processing dynamic content.",
      "predicted_trace_chain": "docs/md_v2/basic/page-interaction.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "The complete chain shows that the functionality invoked by the documentation is built upon a hierarchy where AsyncWebCrawler.arun() utilizes AsyncPlaywrightCrawlerStrategy, which in turn is based on the abstract interface provided by AsyncCrawlerStrategy. This ensures a cohesive implementation of dynamic content handling.",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class provides the foundational methods like crawl() and set_hook() that enable the documented dynamic content handling and form interactions through its extensible interface.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Handling Dynamic Content\n\n### Load More Content\n\nHandle infinite scroll or load more buttons:\n\n```python\n# Scroll and wait pattern\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=[\n        # Scroll to bottom\n        \"window.scrollTo(0, document.body.scrollHeight);\",\n        # Click load more if exists\n        \"const loadMore = document.querySelector('.load-more'); if(loadMore) loadMore.click();\"\n    ],\n    # Wait for new content\n    wait_for=\"js:() => document.querySelectorAll('.item').length > previousCount\"\n)\n```\n\n### Form Interaction\n\nHandle forms and inputs:\n\n```python\njs_form_interaction = \"\"\"\n    // Fill form fields\n    document.querySelector('#search').value = 'search term';\n    // Submit form\n    document.querySelector('form').submit();\n\"\"\"\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=js_form_interaction,\n    wait_for=\"css:.results\"  # Wait for results to load\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the outputs of the documented crawling operations like form submissions and infinite scrolling by capturing HTML content, success status, and extracted data in structured fields.",
      "ground_truth_trace_chain": "page-interaction.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to use multiple output formats together:\n\n```python\nasync def crawl_content(url: str):\n    async with AsyncWebCrawler() as crawler:\n        # Extract main content with fit markdown\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=10,\n            exclude_external_links=True\n        )\n        \n        # Get structured data using LLM\n        llm_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=YourSchema.schema(),\n                instruction=\"Extract key information\"\n            )\n        )\n        \n        # Get repeated patterns (if any)\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(your_schema)\n        )\n        \n        return {\n            \"main_content\": result.fit_markdown,\n            \"structured_data\": json.loads(llm_result.extracted_content),\n            \"pattern_data\": json.loads(pattern_result.extracted_content),\n            \"media\": result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation",
      "relationship_explanation": "The documentation snippet explicitly creates an AsyncWebCrawler instance using the async context manager (async with AsyncWebCrawler() as crawler:).",
      "predicted_trace_chain": "output-formats.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "Starting from the document 'output-formats.md', the code directly instantiates the AsyncWebCrawler, establishing the first link in the trace chain.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the documented multi-format extraction by providing an arun() method that accepts different extraction strategies and processes HTML content to return structured data, markdown content, and media elements as shown in the comprehensive example.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to use multiple output formats together:\n\n```python\nasync def crawl_content(url: str):\n    async with AsyncWebCrawler() as crawler:\n        # Extract main content with fit markdown\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=10,\n            exclude_external_links=True\n        )\n        \n        # Get structured data using LLM\n        llm_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=YourSchema.schema(),\n                instruction=\"Extract key information\"\n            )\n        )\n        \n        # Get repeated patterns (if any)\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(your_schema)\n        )\n        \n        return {\n            \"main_content\": result.fit_markdown,\n            \"structured_data\": json.loads(llm_result.extracted_content),\n            \"pattern_data\": json.loads(pattern_result.extracted_content),\n            \"media\": result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "Within the snippet, the AsyncWebCrawler instance calls the 'arun' method to perform the crawling tasks. This method is explicitly invoked to retrieve the crawl results.",
      "predicted_trace_chain": "output-formats.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The instantiation of AsyncWebCrawler leads directly to the invocation of its 'arun()' method, forming a clear pathway from the document to the method call used for crawling.",
      "ground_truth_relationship": "The documentation demonstrates three different use cases of AsyncWebCrawler.arun() by showing how it can extract content using different extraction strategies (no strategy, LLM strategy, and JSON CSS strategy) while the code shows the underlying implementation that handles these different strategies through its extraction_strategy parameter.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to use multiple output formats together:\n\n```python\nasync def crawl_content(url: str):\n    async with AsyncWebCrawler() as crawler:\n        # Extract main content with fit markdown\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=10,\n            exclude_external_links=True\n        )\n        \n        # Get structured data using LLM\n        llm_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=YourSchema.schema(),\n                instruction=\"Extract key information\"\n            )\n        )\n        \n        # Get repeated patterns (if any)\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(your_schema)\n        )\n        \n        return {\n            \"main_content\": result.fit_markdown,\n            \"structured_data\": json.loads(llm_result.extracted_content),\n            \"pattern_data\": json.loads(pattern_result.extracted_content),\n            \"media\": result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation and parameter passing",
      "relationship_explanation": "The snippet explicitly instantiates LLMExtractionStrategy with parameters (provider, schema, instruction) and passes it as the extraction_strategy to the 'arun' method for structured data extraction.",
      "predicted_trace_chain": "output-formats.md -> AsyncWebCrawler.arun() -> LLMExtractionStrategy",
      "predicted_trace_chain_explanation": "After calling 'arun()', the code uses an instance of LLMExtractionStrategy as an extraction strategy, linking the crawl process to the structured extraction mechanism.",
      "ground_truth_relationship": "The LLMExtractionStrategy class implements the specific functionality shown in the documentation example where it processes URLs with custom providers, schemas, and instructions to extract structured data using language models as demonstrated in the 'crawler.arun' call with LLMExtractionStrategy parameters.",
      "ground_truth_trace_chain": "output-formats.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to use multiple output formats together:\n\n```python\nasync def crawl_content(url: str):\n    async with AsyncWebCrawler() as crawler:\n        # Extract main content with fit markdown\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=10,\n            exclude_external_links=True\n        )\n        \n        # Get structured data using LLM\n        llm_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=YourSchema.schema(),\n                instruction=\"Extract key information\"\n            )\n        )\n        \n        # Get repeated patterns (if any)\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(your_schema)\n        )\n        \n        return {\n            \"main_content\": result.fit_markdown,\n            \"structured_data\": json.loads(llm_result.extracted_content),\n            \"pattern_data\": json.loads(pattern_result.extracted_content),\n            \"media\": result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation and parameter passing",
      "relationship_explanation": "The documentation snippet creates an instance of JsonCssExtractionStrategy (with a provided schema) and passes it to the 'arun' method to extract repeated patterns.",
      "predicted_trace_chain": "output-formats.md -> AsyncWebCrawler.arun() -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The 'arun()' method is invoked with the JsonCssExtractionStrategy as its extraction_strategy parameter, thereby establishing a direct trace from the document to this extraction strategy.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class implements the pattern extraction functionality shown in the documentation's example by using CSS selectors to systematically extract structured data from repeated HTML elements.",
      "ground_truth_trace_chain": "output-formats.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to use multiple output formats together:\n\n```python\nasync def crawl_content(url: str):\n    async with AsyncWebCrawler() as crawler:\n        # Extract main content with fit markdown\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=10,\n            exclude_external_links=True\n        )\n        \n        # Get structured data using LLM\n        llm_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=YourSchema.schema(),\n                instruction=\"Extract key information\"\n            )\n        )\n        \n        # Get repeated patterns (if any)\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(your_schema)\n        )\n        \n        return {\n            \"main_content\": result.fit_markdown,\n            \"structured_data\": json.loads(llm_result.extracted_content),\n            \"pattern_data\": json.loads(pattern_result.extracted_content),\n            \"media\": result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 12,
      "artifact_title": "CrawlResult.fit_markdown",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet accesses the 'fit_markdown' attribute (result.fit_markdown) from the CrawlResult returned by the arun() method, using it to extract the main content in a formatted markdown output.",
      "predicted_trace_chain": "output-formats.md -> AsyncWebCrawler.arun() -> CrawlResult.fit_markdown",
      "predicted_trace_chain_explanation": "After the crawl operation is performed with 'arun()', the resulting CrawlResult provides the 'fit_markdown' attribute, which is then used directly in the code, forming an explicit attribute access pathway.",
      "ground_truth_relationship": "The fit_markdown property from CrawlResult is shown being used in the documentation example to store and access the main extracted content from a webpage within the returned dictionary's main_content field.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult.fit_markdown",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to use multiple output formats together:\n\n```python\nasync def crawl_content(url: str):\n    async with AsyncWebCrawler() as crawler:\n        # Extract main content with fit markdown\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=10,\n            exclude_external_links=True\n        )\n        \n        # Get structured data using LLM\n        llm_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=YourSchema.schema(),\n                instruction=\"Extract key information\"\n            )\n        )\n        \n        # Get repeated patterns (if any)\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(your_schema)\n        )\n        \n        return {\n            \"main_content\": result.fit_markdown,\n            \"structured_data\": json.loads(llm_result.extracted_content),\n            \"pattern_data\": json.loads(pattern_result.extracted_content),\n            \"media\": result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 11,
      "artifact_title": "CrawlResult.extracted_content",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet retrieves structured and pattern data by accessing 'extracted_content' on the results (llm_result.extracted_content and pattern_result.extracted_content) obtained from the arun() method.",
      "predicted_trace_chain": "output-formats.md -> AsyncWebCrawler.arun() -> CrawlResult.extracted_content",
      "predicted_trace_chain_explanation": "The extraction strategies applied in the 'arun()' method output their results into the CrawlResult's 'extracted_content' attribute, which is then used in the snippet, establishing a direct trace.",
      "ground_truth_relationship": "The extracted_content field is used to store the crawled data in string format, which the example shows being parsed as JSON for both LLM and pattern-based extraction strategies.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to use multiple output formats together:\n\n```python\nasync def crawl_content(url: str):\n    async with AsyncWebCrawler() as crawler:\n        # Extract main content with fit markdown\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=10,\n            exclude_external_links=True\n        )\n        \n        # Get structured data using LLM\n        llm_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=YourSchema.schema(),\n                instruction=\"Extract key information\"\n            )\n        )\n        \n        # Get repeated patterns (if any)\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(your_schema)\n        )\n        \n        return {\n            \"main_content\": result.fit_markdown,\n            \"structured_data\": json.loads(llm_result.extracted_content),\n            \"pattern_data\": json.loads(pattern_result.extracted_content),\n            \"media\": result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 16,
      "artifact_title": "CrawlResult.media",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet explicitly uses the 'media' attribute (result.media) of the CrawlResult to retrieve media information that was extracted during the crawl.",
      "predicted_trace_chain": "output-formats.md -> AsyncWebCrawler.arun() -> CrawlResult.media",
      "predicted_trace_chain_explanation": "Following the crawling process via 'arun()', the CrawlResult's 'media' attribute is accessed to obtain media data, forming the final link in the trace chain from the document to the media output.",
      "ground_truth_relationship": "The CrawlResult.media dictionary stores extracted media items which the documentation shows being returned as part of the final output in the \"media\" field of the crawl_content function's response.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult.media",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to use multiple output formats together:\n\n```python\nasync def crawl_content(url: str):\n    async with AsyncWebCrawler() as crawler:\n        # Extract main content with fit markdown\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=10,\n            exclude_external_links=True\n        )\n        \n        # Get structured data using LLM\n        llm_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=YourSchema.schema(),\n                instruction=\"Extract key information\"\n            )\n        )\n        \n        # Get repeated patterns (if any)\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(your_schema)\n        )\n        \n        return {\n            \"main_content\": result.fit_markdown,\n            \"structured_data\": json.loads(llm_result.extracted_content),\n            \"pattern_data\": json.loads(pattern_result.extracted_content),\n            \"media\": result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the structure for storing all possible outputs shown in the example code, including fit_markdown, extracted_content, and media which are used to capture the main content, structured data, and pattern data respectively.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to use multiple output formats together:\n\n```python\nasync def crawl_content(url: str):\n    async with AsyncWebCrawler() as crawler:\n        # Extract main content with fit markdown\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=10,\n            exclude_external_links=True\n        )\n        \n        # Get structured data using LLM\n        llm_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=YourSchema.schema(),\n                instruction=\"Extract key information\"\n            )\n        )\n        \n        # Get repeated patterns (if any)\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(your_schema)\n        )\n        \n        return {\n            \"main_content\": result.fit_markdown,\n            \"structured_data\": json.loads(llm_result.extracted_content),\n            \"pattern_data\": json.loads(pattern_result.extracted_content),\n            \"media\": result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the core functionality shown in the documentation example by providing methods for concurrent web crawling with multiple output formats through its crawl() method, which supports various extraction strategies and configurations like LLM and pattern-based extraction.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to use multiple output formats together:\n\n```python\nasync def crawl_content(url: str):\n    async with AsyncWebCrawler() as crawler:\n        # Extract main content with fit markdown\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=10,\n            exclude_external_links=True\n        )\n        \n        # Get structured data using LLM\n        llm_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=YourSchema.schema(),\n                instruction=\"Extract key information\"\n            )\n        )\n        \n        # Get repeated patterns (if any)\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(your_schema)\n        )\n        \n        return {\n            \"main_content\": result.fit_markdown,\n            \"structured_data\": json.loads(llm_result.extracted_content),\n            \"pattern_data\": json.loads(pattern_result.extracted_content),\n            \"media\": result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface methods that enable the multi-format extraction capabilities demonstrated in the documentation's comprehensive example.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to use multiple output formats together:\n\n```python\nasync def crawl_content(url: str):\n    async with AsyncWebCrawler() as crawler:\n        # Extract main content with fit markdown\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=10,\n            exclude_external_links=True\n        )\n        \n        # Get structured data using LLM\n        llm_result = await crawler.arun(\n            url=url,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"ollama/nemotron\",\n                schema=YourSchema.schema(),\n                instruction=\"Extract key information\"\n            )\n        )\n        \n        # Get repeated patterns (if any)\n        pattern_result = await crawler.arun(\n            url=url,\n            extraction_strategy=JsonCssExtractionStrategy(your_schema)\n        )\n        \n        return {\n            \"main_content\": result.fit_markdown,\n            \"structured_data\": json.loads(llm_result.extracted_content),\n            \"pattern_data\": json.loads(pattern_result.extracted_content),\n            \"media\": result.media\n        }\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "ExtractionStrategy",
      "ground_truth_relationship": "The ExtractionStrategy abstract base class provides the foundation for the different extraction methods (LLMExtractionStrategy, JsonCssExtractionStrategy) demonstrated in the documentation's comprehensive example.",
      "ground_truth_trace_chain": "output-formats.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Pattern-Based Selection\n\nFor repeated content patterns (like product listings, news feeds):\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"News Articles\",\n    \"baseSelector\": \"article.news-item\",  # Repeated element\n    \"fields\": [\n        {\"name\": \"headline\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"summary\", \"selector\": \".summary\", \"type\": \"text\"},\n        {\"name\": \"category\", \"selector\": \".category\", \"type\": \"text\"},\n        {\n            \"name\": \"metadata\",\n            \"type\": \"nested\",\n            \"fields\": [\n                {\"name\": \"author\", \"selector\": \".author\", \"type\": \"text\"},\n                {\"name\": \"date\", \"selector\": \".date\", \"type\": \"text\"}\n            ]\n        }\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\narticles = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation and import",
      "relationship_explanation": "The documentation snippet explicitly imports JsonCssExtractionStrategy from crawl4ai.extraction_strategy and instantiates it with a schema. This directly demonstrates its usage for pattern\u2010based extraction.",
      "predicted_trace_chain": "content-selection.md -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "Starting from the documentation file (docs/md_v2/basic/content-selection.md), the snippet directly creates an instance of JsonCssExtractionStrategy, forming the first link in the traceability chain.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class implements pattern-based content extraction by using a schema definition to recursively select and extract nested data from repeating HTML elements using CSS selectors.",
      "ground_truth_trace_chain": "content-selection.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Pattern-Based Selection\n\nFor repeated content patterns (like product listings, news feeds):\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"News Articles\",\n    \"baseSelector\": \"article.news-item\",  # Repeated element\n    \"fields\": [\n        {\"name\": \"headline\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"summary\", \"selector\": \".summary\", \"type\": \"text\"},\n        {\"name\": \"category\", \"selector\": \".category\", \"type\": \"text\"},\n        {\n            \"name\": \"metadata\",\n            \"type\": \"nested\",\n            \"fields\": [\n                {\"name\": \"author\", \"selector\": \".author\", \"type\": \"text\"},\n                {\"name\": \"date\", \"selector\": \".date\", \"type\": \"text\"}\n            ]\n        }\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\narticles = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "JsonCssExtractionStrategy is defined as a subclass of ExtractionStrategy. Although not directly mentioned in the snippet, this base class is part of the underlying design, providing the common interface for extraction strategies.",
      "predicted_trace_chain": "content-selection.md -> JsonCssExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain begins with the documentation usage of JsonCssExtractionStrategy, which inherently relies on its base class, ExtractionStrategy, to implement the extraction interface.",
      "ground_truth_relationship": "The ExtractionStrategy base class defines the core interface and parallel processing logic that enables pattern-based content extraction, which concrete implementations like JsonCssExtractionStrategy use to extract structured data from repeated HTML elements as shown in the documentation example.",
      "ground_truth_trace_chain": "content-selection.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Pattern-Based Selection\n\nFor repeated content patterns (like product listings, news feeds):\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"News Articles\",\n    \"baseSelector\": \"article.news-item\",  # Repeated element\n    \"fields\": [\n        {\"name\": \"headline\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"summary\", \"selector\": \".summary\", \"type\": \"text\"},\n        {\"name\": \"category\", \"selector\": \".category\", \"type\": \"text\"},\n        {\n            \"name\": \"metadata\",\n            \"type\": \"nested\",\n            \"fields\": [\n                {\"name\": \"author\", \"selector\": \".author\", \"type\": \"text\"},\n                {\"name\": \"date\", \"selector\": \".date\", \"type\": \"text\"}\n            ]\n        }\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\narticles = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "implicit",
      "relationship_type": "method call",
      "relationship_explanation": "The snippet calls 'crawler.arun' to perform the crawl operation with the given extraction strategy. This call maps to the AsyncWebCrawler.arun() method, which processes the URL and extraction strategy.",
      "predicted_trace_chain": "content-selection.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the documentation file, the snippet\u2019s invocation of 'crawler.arun' traces directly to the AsyncWebCrawler.arun() method responsible for executing the crawl and extraction.",
      "ground_truth_relationship": "The arun() method processes the JsonCssExtractionStrategy schema by accepting an extraction_strategy parameter and applying it to crawled HTML content to extract structured data according to the defined selectors and field patterns.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Pattern-Based Selection\n\nFor repeated content patterns (like product listings, news feeds):\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"News Articles\",\n    \"baseSelector\": \"article.news-item\",  # Repeated element\n    \"fields\": [\n        {\"name\": \"headline\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"summary\", \"selector\": \".summary\", \"type\": \"text\"},\n        {\"name\": \"category\", \"selector\": \".category\", \"type\": \"text\"},\n        {\n            \"name\": \"metadata\",\n            \"type\": \"nested\",\n            \"fields\": [\n                {\"name\": \"author\", \"selector\": \".author\", \"type\": \"text\"},\n                {\"name\": \"date\", \"selector\": \".date\", \"type\": \"text\"}\n            ]\n        }\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\narticles = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 11,
      "artifact_title": "CrawlResult.extracted_content",
      "predicted_relationship": "implicit",
      "relationship_type": "property access",
      "relationship_explanation": "After the crawl, the snippet accesses 'result.extracted_content' to retrieve the extracted articles. This accesses the public attribute of the CrawlResult model that holds the processed extraction output.",
      "predicted_trace_chain": "content-selection.md -> AsyncWebCrawler.arun() -> CrawlResult.extracted_content",
      "predicted_trace_chain_explanation": "The documented example shows that the result from AsyncWebCrawler.arun() (the crawl operation) returns a CrawlResult object whose 'extracted_content' property is used to obtain the final data.",
      "ground_truth_relationship": null,
      "ground_truth_trace_chain": null,
      "traceability_granularity": "Method",
      "confusion_metrics": "False Positive",
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Pattern-Based Selection\n\nFor repeated content patterns (like product listings, news feeds):\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"News Articles\",\n    \"baseSelector\": \"article.news-item\",  # Repeated element\n    \"fields\": [\n        {\"name\": \"headline\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"summary\", \"selector\": \".summary\", \"type\": \"text\"},\n        {\"name\": \"category\", \"selector\": \".category\", \"type\": \"text\"},\n        {\n            \"name\": \"metadata\",\n            \"type\": \"nested\",\n            \"fields\": [\n                {\"name\": \"author\", \"selector\": \".author\", \"type\": \"text\"},\n                {\"name\": \"date\", \"selector\": \".date\", \"type\": \"text\"}\n            ]\n        }\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\narticles = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class's extracted_content field stores the JSON output from pattern-based extraction strategies like JsonCssExtractionStrategy shown in the documentation.",
      "ground_truth_trace_chain": "content-selection.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Pattern-Based Selection\n\nFor repeated content patterns (like product listings, news feeds):\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"News Articles\",\n    \"baseSelector\": \"article.news-item\",  # Repeated element\n    \"fields\": [\n        {\"name\": \"headline\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"summary\", \"selector\": \".summary\", \"type\": \"text\"},\n        {\"name\": \"category\", \"selector\": \".category\", \"type\": \"text\"},\n        {\n            \"name\": \"metadata\",\n            \"type\": \"nested\",\n            \"fields\": [\n                {\"name\": \"author\", \"selector\": \".author\", \"type\": \"text\"},\n                {\"name\": \"date\", \"selector\": \".date\", \"type\": \"text\"}\n            ]\n        }\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\narticles = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class provides the core interface that enables pattern-based extraction by defining crawl methods that the JsonCssExtractionStrategy uses to fetch and process structured content like news articles.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Pattern-Based Selection\n\nFor repeated content patterns (like product listings, news feeds):\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"News Articles\",\n    \"baseSelector\": \"article.news-item\",  # Repeated element\n    \"fields\": [\n        {\"name\": \"headline\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"summary\", \"selector\": \".summary\", \"type\": \"text\"},\n        {\"name\": \"category\", \"selector\": \".category\", \"type\": \"text\"},\n        {\n            \"name\": \"metadata\",\n            \"type\": \"nested\",\n            \"fields\": [\n                {\"name\": \"author\", \"selector\": \".author\", \"type\": \"text\"},\n                {\"name\": \"date\", \"selector\": \".date\", \"type\": \"text\"}\n            ]\n        }\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\narticles = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the documented pattern-based selection by providing a flexible crawling engine that can navigate web pages and enable CSS-based extraction through its crawl method, allowing the JsonCssExtractionStrategy to perform the actual pattern matching and content extraction.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Pattern-Based Selection\n\nFor repeated content patterns (like product listings, news feeds):\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"News Articles\",\n    \"baseSelector\": \"article.news-item\",  # Repeated element\n    \"fields\": [\n        {\"name\": \"headline\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"summary\", \"selector\": \".summary\", \"type\": \"text\"},\n        {\"name\": \"category\", \"selector\": \".category\", \"type\": \"text\"},\n        {\n            \"name\": \"metadata\",\n            \"type\": \"nested\",\n            \"fields\": [\n                {\"name\": \"author\", \"selector\": \".author\", \"type\": \"text\"},\n                {\"name\": \"date\", \"selector\": \".date\", \"type\": \"text\"}\n            ]\n        }\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\narticles = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements pattern-based selection through its aprocess_html method, which uses JsonCssExtractionStrategy to extract structured data according to the schema defined in the documentation.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### User Simulation \ud83c\udfad\n\nSimulate real user behavior to avoid detection:\n\n```python\nasync with AsyncWebCrawler(verbose=True, headless=True) as crawler:\n    result = await crawler.arun(\n        url=\"YOUR-URL-HERE\",\n        bypass_cache=True,\n        simulate_user=True,  # Causes random mouse movements and clicks\n        override_navigator=True  # Makes the browser appear more like a real user\n    )\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation",
      "relationship_explanation": "The documentation snippet explicitly instantiates an AsyncWebCrawler instance with parameters (e.g., verbose=True, headless=True). This direct usage in the example confirms its explicit traceability.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain begins at the documentation file and proceeds directly to the instantiation of the AsyncWebCrawler class, which is explicitly referenced by the usage code.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements user simulation through the simulate_user and override_navigator parameters in its arun method, which are passed via **kwargs to the underlying crawler_strategy for executing realistic browser behaviors.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### User Simulation \ud83c\udfad\n\nSimulate real user behavior to avoid detection:\n\n```python\nasync with AsyncWebCrawler(verbose=True, headless=True) as crawler:\n    result = await crawler.arun(\n        url=\"YOUR-URL-HERE\",\n        bypass_cache=True,\n        simulate_user=True,  # Causes random mouse movements and clicks\n        override_navigator=True  # Makes the browser appear more like a real user\n    )\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "usage",
      "relationship_explanation": "The sample code calls the arun() method on the AsyncWebCrawler instance. This method initiates the crawling process and is directly invoked in the provided documentation example.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the documentation snippet, the chain moves from the AsyncWebCrawler instantiation to the explicit call of its arun() method, establishing a clear path of usage.",
      "ground_truth_relationship": "The documentation describes user simulation features while the arun() method implements these behaviors through the **kwargs parameter which can accept simulate_user and override_navigator flags to control browser automation behavior.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### User Simulation \ud83c\udfad\n\nSimulate real user behavior to avoid detection:\n\n```python\nasync with AsyncWebCrawler(verbose=True, headless=True) as crawler:\n    result = await crawler.arun(\n        url=\"YOUR-URL-HERE\",\n        bypass_cache=True,\n        simulate_user=True,  # Causes random mouse movements and clicks\n        override_navigator=True  # Makes the browser appear more like a real user\n    )\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "default implementation and feature extension",
      "relationship_explanation": "Although not directly mentioned in the snippet, AsyncWebCrawler uses AsyncPlaywrightCrawlerStrategy by default. This strategy\u2019s crawl() implementation checks for flags like 'simulate_user' and 'override_navigator' to simulate real user behavior, fulfilling the documented functionality.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain links the documentation through AsyncWebCrawler to its default crawler strategy (AsyncPlaywrightCrawlerStrategy), which is responsible for implementing behavior such as user simulation that the documentation describes.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements user simulation through mouse movements, clicks, and navigator property overrides when simulate_user=True or override_navigator=True are passed as parameters in the crawl method.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### User Simulation \ud83c\udfad\n\nSimulate real user behavior to avoid detection:\n\n```python\nasync with AsyncWebCrawler(verbose=True, headless=True) as crawler:\n    result = await crawler.arun(\n        url=\"YOUR-URL-HERE\",\n        bypass_cache=True,\n        simulate_user=True,  # Causes random mouse movements and clicks\n        override_navigator=True  # Makes the browser appear more like a real user\n    )\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance (base class)",
      "relationship_explanation": "AsyncPlaywrightCrawlerStrategy extends AsyncCrawlerStrategy. Although the abstract base class is not directly used in the snippet, it underpins the crawling interface used in the simulation of user behavior.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "This chain shows the inheritance hierarchy: starting from the documentation and AsyncWebCrawler, it moves to the default strategy (AsyncPlaywrightCrawlerStrategy) and then to its base class (AsyncCrawlerStrategy), illuminating the complete structure behind the user simulation functionality.",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface methods that enable user simulation features referenced in the documentation through abstract methods like set_hook and update_user_agent which are used to implement browser behavior customization.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### User Simulation \ud83c\udfad\n\nSimulate real user behavior to avoid detection:\n\n```python\nasync with AsyncWebCrawler(verbose=True, headless=True) as crawler:\n    result = await crawler.arun(\n        url=\"YOUR-URL-HERE\",\n        bypass_cache=True,\n        simulate_user=True,  # Causes random mouse movements and clicks\n        override_navigator=True  # Makes the browser appear more like a real user\n    )\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class captures and stores the results of simulated user browsing sessions, including metadata like session_id and status_code that help verify the authenticity of the simulated user interaction.",
      "ground_truth_trace_chain": "quickstart.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Adding Basic Options\n\nCustomize your crawl with these common options:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    word_count_threshold=10,        # Minimum words per content block\n    exclude_external_links=True,    # Remove external links\n    remove_overlay_elements=True,   # Remove popups/modals\n    process_iframes=True           # Process iframe content\n)\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method usage",
      "relationship_explanation": "The documentation snippet shows an explicit usage example by calling 'crawler.arun(...)'. This directly maps to the AsyncWebCrawler.arun() method (artifact id 5), which accepts parameters such as url, word_count_threshold, remove_overlay_elements, and process_iframes, thereby enabling basic crawl options.",
      "predicted_trace_chain": "simple-crawling.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The usage example from 'simple-crawling.md' directly invokes the arun() method on a crawler instance, which exactly corresponds to the AsyncWebCrawler.arun() artifact.",
      "ground_truth_relationship": "The code implements an asynchronous crawler method that accepts the documented options like word_count_threshold and handles various crawling parameters through its **kwargs argument system, allowing for flexible configuration as shown in the documentation examples.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Adding Basic Options\n\nCustomize your crawl with these common options:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    word_count_threshold=10,        # Minimum words per content block\n    exclude_external_links=True,    # Remove external links\n    remove_overlay_elements=True,   # Remove popups/modals\n    process_iframes=True           # Process iframe content\n)\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "class usage / method implementation",
      "relationship_explanation": "Within the implementation of AsyncWebCrawler.arun(), the crawler internally uses a crawler strategy. In this case, the AsyncPlaywrightCrawlerStrategy (artifact id 1) is used to execute the actual crawling. This strategy processes additional options like remove_overlay_elements (to remove popups/modals) and process_iframes (to handle iframe content) as passed in the documentation snippet.",
      "predicted_trace_chain": "simple-crawling.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain starts in the documentation example, which calls AsyncWebCrawler.arun(). That method, in turn, utilizes an instance of AsyncPlaywrightCrawlerStrategy to perform the crawl and handle extra options (remove_overlay_elements and process_iframes), thus forming the complete trace pathway.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the documented crawling options through its crawl method, which processes parameters like process_iframes=True for handling iframe content and remove_overlay_elements=True for removing popups/modals through dedicated helper methods.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Adding Basic Options\n\nCustomize your crawl with these common options:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    word_count_threshold=10,        # Minimum words per content block\n    exclude_external_links=True,    # Remove external links\n    remove_overlay_elements=True,   # Remove popups/modals\n    process_iframes=True           # Process iframe content\n)\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the data structure that stores all crawled outputs and processing flags shown in the documentation's basic options, including the cleaned content, extracted media, and success status.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Adding Basic Options\n\nCustomize your crawl with these common options:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    word_count_threshold=10,        # Minimum words per content block\n    exclude_external_links=True,    # Remove external links\n    remove_overlay_elements=True,   # Remove popups/modals\n    process_iframes=True           # Process iframe content\n)\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core methods that enable the crawler configuration options shown in the documentation through its crawl method's kwargs parameter.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Adding Basic Options\n\nCustomize your crawl with these common options:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    word_count_threshold=10,        # Minimum words per content block\n    exclude_external_links=True,    # Remove external links\n    remove_overlay_elements=True,   # Remove popups/modals\n    process_iframes=True           # Process iframe content\n)\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the documented configuration options through its arun method, which accepts parameters like word_count_threshold and other kwargs that directly correspond to the basic crawling options shown in the documentation example.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Screenshot Capabilities\n\nCapture page screenshots with enhanced error handling:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    screenshot=True,                # Enable screenshot\n    screenshot_wait_for=2.0        # Wait 2 seconds before capture\n)\n\nif result.screenshot:  # Base64 encoded image\n    import base64\n    with open(\"screenshot.png\", \"wb\") as f:\n        f.write(base64.b64decode(result.screenshot))\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "usage",
      "relationship_explanation": "The documentation snippet directly calls 'crawler.arun()' with parameters (screenshot=True and screenshot_wait_for=2.0). This explicitly demonstrates the usage of the arun() method to perform a crawl that includes screenshot capture.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain starts with the document from 'docs/md_v2/basic/browser-config.md' and directly invokes the 'AsyncWebCrawler.arun()' method, which is the API endpoint used for capturing screenshots.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method implements screenshot functionality by accepting a 'screenshot' boolean parameter and storing the captured screenshot data in the screenshot_data variable, which is later included in the CrawlResult object returned to the user.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Screenshot Capabilities\n\nCapture page screenshots with enhanced error handling:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    screenshot=True,                # Enable screenshot\n    screenshot_wait_for=2.0        # Wait 2 seconds before capture\n)\n\nif result.screenshot:  # Base64 encoded image\n    import base64\n    with open(\"screenshot.png\", \"wb\") as f:\n        f.write(base64.b64decode(result.screenshot))\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "implements",
      "relationship_explanation": "Although not directly mentioned in the snippet, AsyncPlaywrightCrawlerStrategy is the underlying strategy used by AsyncWebCrawler. Its implementation of the crawl() method contains the logic for handling the 'screenshot' and 'screenshot_wait_for' parameters, including invoking its 'take_screenshot' method for capturing page screenshots with enhanced error handling.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The crawl process starts with the 'AsyncWebCrawler.arun()' call, which then leverages 'AsyncPlaywrightCrawlerStrategy' to execute the actual crawling and screenshot capture logic. This intermediate step is necessary because the screenshot functionality is implemented within the AsyncPlaywrightCrawlerStrategy.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements screenshot functionality through its take_screenshot method, which captures a full-page base64-encoded image and includes error handling that generates a black error image if the screenshot fails.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Screenshot Capabilities\n\nCapture page screenshots with enhanced error handling:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    screenshot=True,                # Enable screenshot\n    screenshot_wait_for=2.0        # Wait 2 seconds before capture\n)\n\nif result.screenshot:  # Base64 encoded image\n    import base64\n    with open(\"screenshot.png\", \"wb\") as f:\n        f.write(base64.b64decode(result.screenshot))\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 18,
      "artifact_title": "CrawlResult.screenshot",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute usage",
      "relationship_explanation": "The snippet explicitly checks and uses the 'screenshot' attribute of the result object (i.e., 'result.screenshot'). This attribute is part of the public interface of CrawlResult and holds the Base64 encoded image obtained from the screenshot capture.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler.arun() -> CrawlResult.screenshot",
      "predicted_trace_chain_explanation": "The screenshot attribute is accessed on the result returned by the 'AsyncWebCrawler.arun()' method. This chain is necessary because the CrawlResult object, which carries the 'screenshot' property, is produced after the crawling process completes.",
      "ground_truth_relationship": "The screenshot property in CrawlResult stores the captured webpage screenshot as a base64-encoded string that can be decoded into a PNG image file.",
      "ground_truth_trace_chain": "browser-config.md -> CrawlResult.screenshot",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Screenshot Capabilities\n\nCapture page screenshots with enhanced error handling:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    screenshot=True,                # Enable screenshot\n    screenshot_wait_for=2.0        # Wait 2 seconds before capture\n)\n\nif result.screenshot:  # Base64 encoded image\n    import base64\n    with open(\"screenshot.png\", \"wb\") as f:\n        f.write(base64.b64decode(result.screenshot))\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class enables screenshot functionality through its screenshot field which stores the Base64-encoded image data as documented in the screenshot capabilities example.",
      "ground_truth_trace_chain": "browser-config.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Screenshot Capabilities\n\nCapture page screenshots with enhanced error handling:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    screenshot=True,                # Enable screenshot\n    screenshot_wait_for=2.0        # Wait 2 seconds before capture\n)\n\nif result.screenshot:  # Base64 encoded image\n    import base64\n    with open(\"screenshot.png\", \"wb\") as f:\n        f.write(base64.b64decode(result.screenshot))\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the take_screenshot() method that implements the documented screenshot capability, allowing derived crawler classes to capture page screenshots with customizable wait times.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Screenshot Capabilities\n\nCapture page screenshots with enhanced error handling:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    screenshot=True,                # Enable screenshot\n    screenshot_wait_for=2.0        # Wait 2 seconds before capture\n)\n\nif result.screenshot:  # Base64 encoded image\n    import base64\n    with open(\"screenshot.png\", \"wb\") as f:\n        f.write(base64.b64decode(result.screenshot))\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements screenshot capabilities through its arun() method, which accepts a screenshot boolean parameter and stores the captured image data in the screenshot_data variable, which is then included in the returned CrawlResult object.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### 2. Pattern-Based Extraction\n\nFor pages with repetitive patterns (e.g., product listings, article feeds), use JsonCssExtractionStrategy:\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"Product Listing\",\n    \"baseSelector\": \".product-card\",  # Repeated element\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"},\n        {\"name\": \"description\", \"selector\": \".desc\", \"type\": \"text\"}\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\nproducts = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "class instantiation and usage",
      "relationship_explanation": "The documentation snippet explicitly imports JsonCssExtractionStrategy and instantiates it with a schema object. This directly demonstrates its role for pattern-based extraction (e.g., extracting repeated product listings).",
      "predicted_trace_chain": "docs/md_v2/basic/output-formats.md -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain starts from the documentation file and leads directly to the usage of JsonCssExtractionStrategy in the code example.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class implements pattern-based web scraping by iterating through elements matching a base selector and extracting specified fields according to a schema defining CSS selectors and data types.",
      "ground_truth_trace_chain": "output-formats.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### 2. Pattern-Based Extraction\n\nFor pages with repetitive patterns (e.g., product listings, article feeds), use JsonCssExtractionStrategy:\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"Product Listing\",\n    \"baseSelector\": \".product-card\",  # Repeated element\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"},\n        {\"name\": \"description\", \"selector\": \".desc\", \"type\": \"text\"}\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\nproducts = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "JsonCssExtractionStrategy is a subclass of ExtractionStrategy. Although not mentioned by name in the snippet, this inheritance relationship is essential, as ExtractionStrategy defines the contract for extraction methods used in pattern-based extraction.",
      "predicted_trace_chain": "docs/md_v2/basic/output-formats.md -> JsonCssExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain shows how the explicit usage of JsonCssExtractionStrategy is part of a larger abstraction, extending the ExtractionStrategy base class.",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the core framework that enables pattern-based extraction through derived classes like JsonCssExtractionStrategy, which implements the schema-based extraction shown in the documentation.",
      "ground_truth_trace_chain": "output-formats.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### 2. Pattern-Based Extraction\n\nFor pages with repetitive patterns (e.g., product listings, article feeds), use JsonCssExtractionStrategy:\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"Product Listing\",\n    \"baseSelector\": \".product-card\",  # Repeated element\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"},\n        {\"name\": \"description\", \"selector\": \".desc\", \"type\": \"text\"}\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\nproducts = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 11,
      "artifact_title": "CrawlResult.extracted_content",
      "predicted_relationship": "implicit",
      "relationship_type": "attribute usage",
      "relationship_explanation": "After crawling, the example code uses 'result.extracted_content' to retrieve the extracted data. This attribute is a public interface of CrawlResult that holds the output of the extraction process.",
      "predicted_trace_chain": "docs/md_v2/basic/output-formats.md -> CrawlResult.extracted_content",
      "predicted_trace_chain_explanation": "The chain illustrates that the extraction result, provided in the 'extracted_content' attribute of the crawl result, is used to obtain the final JSON output of products.",
      "ground_truth_relationship": "The extracted_content field stores the JSON-formatted results of pattern-based scraping, where each match from the baseSelector is transformed into an array of objects with the specified fields from the schema.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### 2. Pattern-Based Extraction\n\nFor pages with repetitive patterns (e.g., product listings, article feeds), use JsonCssExtractionStrategy:\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"Product Listing\",\n    \"baseSelector\": \".product-card\",  # Repeated element\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"},\n        {\"name\": \"description\", \"selector\": \".desc\", \"type\": \"text\"}\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\nproducts = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "implicit",
      "relationship_type": "method call",
      "relationship_explanation": "The code snippet calls 'crawler.arun(...)' to execute the crawling process with the specified extraction strategy. This method (AsyncWebCrawler.arun()) orchestrates the crawl and extraction, even though its explicit class name is not mentioned in the snippet.",
      "predicted_trace_chain": "docs/md_v2/basic/output-formats.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain shows that the asynchronous crawl method is the entry point that processes the page, applies the extraction strategy, and returns a result containing the extracted content.",
      "ground_truth_relationship": "The arun() method processes web pages by accepting an extraction_strategy parameter which implements the JsonCssExtractionStrategy shown in the documentation to extract structured data using CSS selectors.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### 2. Pattern-Based Extraction\n\nFor pages with repetitive patterns (e.g., product listings, article feeds), use JsonCssExtractionStrategy:\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"Product Listing\",\n    \"baseSelector\": \".product-card\",  # Repeated element\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"},\n        {\"name\": \"description\", \"selector\": \".desc\", \"type\": \"text\"}\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\nproducts = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the pattern-based extraction results in its extracted_content field, which the documentation shows being accessed and parsed as JSON after running the JsonCssExtractionStrategy.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### 2. Pattern-Based Extraction\n\nFor pages with repetitive patterns (e.g., product listings, article feeds), use JsonCssExtractionStrategy:\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"Product Listing\",\n    \"baseSelector\": \".product-card\",  # Repeated element\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"},\n        {\"name\": \"description\", \"selector\": \".desc\", \"type\": \"text\"}\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\nproducts = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class provides the foundational interface methods that enable pattern-based extraction strategies like JsonCssExtractionStrategy to execute their crawling and content extraction operations through the crawl() method.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### 2. Pattern-Based Extraction\n\nFor pages with repetitive patterns (e.g., product listings, article feeds), use JsonCssExtractionStrategy:\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"Product Listing\",\n    \"baseSelector\": \".product-card\",  # Repeated element\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"},\n        {\"name\": \"description\", \"selector\": \".desc\", \"type\": \"text\"}\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\nproducts = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements browser automation capabilities that enable the pattern-based extraction described in the documentation by providing methods to navigate pages and interact with DOM elements using CSS selectors defined in JsonCssExtractionStrategy.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### 2. Pattern-Based Extraction\n\nFor pages with repetitive patterns (e.g., product listings, article feeds), use JsonCssExtractionStrategy:\n\n```python\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\n\nschema = {\n    \"name\": \"Product Listing\",\n    \"baseSelector\": \".product-card\",  # Repeated element\n    \"fields\": [\n        {\"name\": \"title\", \"selector\": \"h2\", \"type\": \"text\"},\n        {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"},\n        {\"name\": \"description\", \"selector\": \".desc\", \"type\": \"text\"}\n    ]\n}\n\nstrategy = JsonCssExtractionStrategy(schema)\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\nproducts = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements pattern-based extraction through its aprocess_html method, which specifically checks for JsonCssExtractionStrategy instances and processes them using the schema format shown in the documentation to extract structured data from repeating HTML elements.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Rotating Proxies\n\nExample using a proxy rotation service:\n\n```python\nasync def get_next_proxy():\n    # Your proxy rotation logic here\n    return {\"server\": \"http://next.proxy.com:8080\"}\n\nasync with AsyncWebCrawler() as crawler:\n    # Update proxy for each request\n    for url in urls:\n        proxy = await get_next_proxy()\n        crawler.update_proxy(proxy)\n        result = await crawler.arun(url=url)\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation/usage",
      "relationship_explanation": "The documentation snippet explicitly demonstrates instantiating an AsyncWebCrawler object with 'async with AsyncWebCrawler() as crawler:'. This clearly maps to the AsyncWebCrawler class in the codebase.",
      "predicted_trace_chain": "docs/md_v2/advanced/proxy-security.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain begins with the documentation file indicating proxy security examples and highlights the creation of an AsyncWebCrawler instance, which is the starting point for the proxy rotation functionality.",
      "ground_truth_relationship": "The AsyncWebCrawler class shown in the code provides the foundational structure referenced in the documentation example, with arun() and __aenter__ methods that enable the async context manager pattern and proxy updating functionality through its crawler_strategy attribute.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Rotating Proxies\n\nExample using a proxy rotation service:\n\n```python\nasync def get_next_proxy():\n    # Your proxy rotation logic here\n    return {\"server\": \"http://next.proxy.com:8080\"}\n\nasync with AsyncWebCrawler() as crawler:\n    # Update proxy for each request\n    for url in urls:\n        proxy = await get_next_proxy()\n        crawler.update_proxy(proxy)\n        result = await crawler.arun(url=url)\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method call",
      "relationship_explanation": "Within the provided example, after updating the proxy, the crawl is executed using 'result = await crawler.arun(url=url)'. This call directly maps to the AsyncWebCrawler.arun() method implementation.",
      "predicted_trace_chain": "docs/md_v2/advanced/proxy-security.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the documentation, the AsyncWebCrawler instance is created and subsequently its arun() method is called. This method is responsible for executing the crawling process, forming a clear chain from documentation to method usage.",
      "ground_truth_relationship": "The arun() method in AsyncWebCrawler implements the core crawling functionality referenced in the documentation, accepting a URL parameter and supporting proxy configuration through its crawler_strategy component.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Rotating Proxies\n\nExample using a proxy rotation service:\n\n```python\nasync def get_next_proxy():\n    # Your proxy rotation logic here\n    return {\"server\": \"http://next.proxy.com:8080\"}\n\nasync with AsyncWebCrawler() as crawler:\n    # Update proxy for each request\n    for url in urls:\n        proxy = await get_next_proxy()\n        crawler.update_proxy(proxy)\n        result = await crawler.arun(url=url)\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the response data from crawler requests made through rotating proxies, with fields like success and error_message to track proxy-related issues.",
      "ground_truth_trace_chain": "proxy-security.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Rotating Proxies\n\nExample using a proxy rotation service:\n\n```python\nasync def get_next_proxy():\n    # Your proxy rotation logic here\n    return {\"server\": \"http://next.proxy.com:8080\"}\n\nasync with AsyncWebCrawler() as crawler:\n    # Update proxy for each request\n    for url in urls:\n        proxy = await get_next_proxy()\n        crawler.update_proxy(proxy)\n        result = await crawler.arun(url=url)\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements proxy support through its proxy handling in the start() method, where it creates ProxySettings objects that align with the documentation's example of rotating proxies for web crawling.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Rotating Proxies\n\nExample using a proxy rotation service:\n\n```python\nasync def get_next_proxy():\n    # Your proxy rotation logic here\n    return {\"server\": \"http://next.proxy.com:8080\"}\n\nasync with AsyncWebCrawler() as crawler:\n    # Update proxy for each request\n    for url in urls:\n        proxy = await get_next_proxy()\n        crawler.update_proxy(proxy)\n        result = await crawler.arun(url=url)\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface methods that enable proxy rotation functionality shown in the documentation through its update_user_agent method and abstract crawl methods.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Media Selection\n\nSelect specific types of media:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Access different media types\nimages = result.media[\"images\"]  # List of image details\nvideos = result.media[\"videos\"]  # List of video details\naudios = result.media[\"audios\"]  # List of audio details\n\n# Image with metadata\nfor image in images:\n    print(f\"URL: {image['src']}\")\n    print(f\"Alt text: {image['alt']}\")\n    print(f\"Description: {image['desc']}\")\n    print(f\"Relevance score: {image['score']}\")\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method call",
      "relationship_explanation": "The documentation snippet explicitly shows the invocation of 'crawler.arun(url=\"https://example.com\")'. This directly maps to the 'AsyncWebCrawler.arun()' method which is responsible for crawling the provided URL and returning a result.",
      "predicted_trace_chain": "docs/md_v2/basic/content-selection.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The code snippet begins with a call to 'arun()', making it the starting point of the trace. The method is explicitly used to initiate crawling, hence directly linking the documentation to this artifact.",
      "ground_truth_relationship": "The documented media selection functionality is implemented through the arun() method which performs the web crawl and returns a CrawlResult object containing structured media data that can be accessed through the media dictionary with keys for images, videos, and audios.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Media Selection\n\nSelect specific types of media:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Access different media types\nimages = result.media[\"images\"]  # List of image details\nvideos = result.media[\"videos\"]  # List of video details\naudios = result.media[\"audios\"]  # List of audio details\n\n# Image with metadata\nfor image in images:\n    print(f\"URL: {image['src']}\")\n    print(f\"Alt text: {image['alt']}\")\n    print(f\"Description: {image['desc']}\")\n    print(f\"Relevance score: {image['score']}\")\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 8,
      "artifact_title": "CrawlResult",
      "predicted_relationship": "implicit",
      "relationship_type": "return type / attribute definition",
      "relationship_explanation": "Even though 'CrawlResult' is not explicitly named in the snippet, the variable 'result' is the output of 'AsyncWebCrawler.arun()' and is subsequently used to access its 'media' attribute. The 'CrawlResult' class defines the 'media' attribute where different media types (images, videos, audios) are stored.",
      "predicted_trace_chain": "docs/md_v2/basic/content-selection.md -> AsyncWebCrawler.arun() -> CrawlResult",
      "predicted_trace_chain_explanation": "After calling 'arun()', the result returned is an instance of 'CrawlResult'. The documentation\u2019s subsequent access of 'result.media' confirms that the media selection functionality is provided by the 'CrawlResult' object, thus completing the trace chain from the documentation snippet to the CrawlResult artifact.",
      "ground_truth_relationship": "The CrawlResult class implements media selection through its media dictionary field that stores different media types (images, videos, audios) as documented in the usage example.",
      "ground_truth_trace_chain": "content-selection.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Media Selection\n\nSelect specific types of media:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Access different media types\nimages = result.media[\"images\"]  # List of image details\nvideos = result.media[\"videos\"]  # List of video details\naudios = result.media[\"audios\"]  # List of audio details\n\n# Image with metadata\nfor image in images:\n    print(f\"URL: {image['src']}\")\n    print(f\"Alt text: {image['alt']}\")\n    print(f\"Description: {image['desc']}\")\n    print(f\"Relevance score: {image['score']}\")\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface that enables the media selection functionality shown in the documentation through its crawl method which returns an AsyncCrawlResponse containing the structured media data.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Media Selection\n\nSelect specific types of media:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Access different media types\nimages = result.media[\"images\"]  # List of image details\nvideos = result.media[\"videos\"]  # List of video details\naudios = result.media[\"audios\"]  # List of audio details\n\n# Image with metadata\nfor image in images:\n    print(f\"URL: {image['src']}\")\n    print(f\"Alt text: {image['alt']}\")\n    print(f\"Description: {image['desc']}\")\n    print(f\"Relevance score: {image['score']}\")\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class includes media processing capabilities that enable the documented functionality of extracting and organizing different media types (images, videos, audios) from crawled web pages, with methods to access their metadata and attributes.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Media Selection\n\nSelect specific types of media:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Access different media types\nimages = result.media[\"images\"]  # List of image details\nvideos = result.media[\"videos\"]  # List of video details\naudios = result.media[\"audios\"]  # List of audio details\n\n# Image with metadata\nfor image in images:\n    print(f\"URL: {image['src']}\")\n    print(f\"Alt text: {image['alt']}\")\n    print(f\"Description: {image['desc']}\")\n    print(f\"Relevance score: {image['score']}\")\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class processes media types through its aprocess_html method, where it scrapes and organizes images, videos, and audios into a structured media dictionary that matches the documented media selection interface.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Media Selection\n\nSelect specific types of media:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Access different media types\nimages = result.media[\"images\"]  # List of image details\nvideos = result.media[\"videos\"]  # List of video details\naudios = result.media[\"audios\"]  # List of audio details\n\n# Image with metadata\nfor image in images:\n    print(f\"URL: {image['src']}\")\n    print(f\"Alt text: {image['alt']}\")\n    print(f\"Description: {image['desc']}\")\n    print(f\"Relevance score: {image['score']}\")\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "CrawlResult.media",
      "ground_truth_relationship": "The CrawlResult.media dictionary property stores categorized lists of media elements (images, videos, audios) that are accessed by type keys in the documented example code.",
      "ground_truth_trace_chain": "content-selection.md -> CrawlResult.media",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Browser Selection \ud83c\udf10\n\nCrawl4AI supports multiple browser engines. Here's how to use different browsers:\n\n```python\n# Use Firefox\nasync with AsyncWebCrawler(browser_type=\"firefox\", verbose=True, headless=True) as crawler:\n    result = await crawler.arun(url=\"https://www.example.com\", bypass_cache=True)\n\n# Use WebKit\nasync with AsyncWebCrawler(browser_type=\"webkit\", verbose=True, headless=True) as crawler:\n    result = await crawler.arun(url=\"https://www.example.com\", bypass_cache=True)\n\n# Use Chromium (default)\nasync with AsyncWebCrawler(verbose=True, headless=True) as crawler:\n    result = await crawler.arun(url=\"https://www.example.com\", bypass_cache=True)\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation",
      "relationship_explanation": "The documentation snippet explicitly shows the instantiation of AsyncWebCrawler with browser_type arguments (e.g., 'firefox', 'webkit', and default Chromium). This demonstrates how the user can select different browser engines.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain starts at the documentation file, where AsyncWebCrawler is directly instantiated as shown in the provided code examples.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements browser selection through its crawler_strategy parameter, which accepts a PlaywrightCrawlerStrategy instance that can be configured with different browser_type values (firefox, webkit, or chromium) as shown in the documentation examples.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Browser Selection \ud83c\udf10\n\nCrawl4AI supports multiple browser engines. Here's how to use different browsers:\n\n```python\n# Use Firefox\nasync with AsyncWebCrawler(browser_type=\"firefox\", verbose=True, headless=True) as crawler:\n    result = await crawler.arun(url=\"https://www.example.com\", bypass_cache=True)\n\n# Use WebKit\nasync with AsyncWebCrawler(browser_type=\"webkit\", verbose=True, headless=True) as crawler:\n    result = await crawler.arun(url=\"https://www.example.com\", bypass_cache=True)\n\n# Use Chromium (default)\nasync with AsyncWebCrawler(verbose=True, headless=True) as crawler:\n    result = await crawler.arun(url=\"https://www.example.com\", bypass_cache=True)\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "Within the usage examples, the arun() method of the AsyncWebCrawler instance is explicitly called to perform the crawl. This demonstrates how crawling is executed after setting up the crawler instance.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain shows that after instantiating AsyncWebCrawler (from the documentation), the arun() method is invoked, directly linking documentation to method usage.",
      "ground_truth_relationship": "The arun() method enables browser selection through the crawler_strategy object which is initialized with the specified browser_type (firefox, webkit, or chromium) when creating the AsyncWebCrawler instance.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Browser Selection \ud83c\udf10\n\nCrawl4AI supports multiple browser engines. Here's how to use different browsers:\n\n```python\n# Use Firefox\nasync with AsyncWebCrawler(browser_type=\"firefox\", verbose=True, headless=True) as crawler:\n    result = await crawler.arun(url=\"https://www.example.com\", bypass_cache=True)\n\n# Use WebKit\nasync with AsyncWebCrawler(browser_type=\"webkit\", verbose=True, headless=True) as crawler:\n    result = await crawler.arun(url=\"https://www.example.com\", bypass_cache=True)\n\n# Use Chromium (default)\nasync with AsyncWebCrawler(verbose=True, headless=True) as crawler:\n    result = await crawler.arun(url=\"https://www.example.com\", bypass_cache=True)\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "default implementation dependency",
      "relationship_explanation": "Although not explicitly mentioned in the snippet, AsyncWebCrawler internally uses AsyncPlaywrightCrawlerStrategy as its default crawling strategy when no custom strategy is provided. This strategy supports browser selection based on the 'browser_type' parameter.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain indicates that the documentation's use of AsyncWebCrawler implicitly leads to the default instantiation of AsyncPlaywrightCrawlerStrategy, which manages browser engine selection.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements browser selection through its start() method, which uses the browser_type parameter to launch either Firefox, WebKit, or Chromium (default) browsers as documented in the browser selection examples.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Browser Selection \ud83c\udf10\n\nCrawl4AI supports multiple browser engines. Here's how to use different browsers:\n\n```python\n# Use Firefox\nasync with AsyncWebCrawler(browser_type=\"firefox\", verbose=True, headless=True) as crawler:\n    result = await crawler.arun(url=\"https://www.example.com\", bypass_cache=True)\n\n# Use WebKit\nasync with AsyncWebCrawler(browser_type=\"webkit\", verbose=True, headless=True) as crawler:\n    result = await crawler.arun(url=\"https://www.example.com\", bypass_cache=True)\n\n# Use Chromium (default)\nasync with AsyncWebCrawler(verbose=True, headless=True) as crawler:\n    result = await crawler.arun(url=\"https://www.example.com\", bypass_cache=True)\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance (base class)",
      "relationship_explanation": "AsyncPlaywrightCrawlerStrategy extends the abstract base class AsyncCrawlerStrategy. This inheritance ensures that the crawling strategies adhere to a common interface, which is fundamental to the design of the crawler framework.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "This chain articulates the inheritance hierarchy starting from the documented AsyncWebCrawler usage, flowing through its default strategy (AsyncPlaywrightCrawlerStrategy), and ultimately to its base class (AsyncCrawlerStrategy), which supports the overall functionality.",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the core interface methods that each browser type (Firefox, WebKit, Chromium) must implement to support the browser selection functionality documented.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Browser Selection \ud83c\udf10\n\nCrawl4AI supports multiple browser engines. Here's how to use different browsers:\n\n```python\n# Use Firefox\nasync with AsyncWebCrawler(browser_type=\"firefox\", verbose=True, headless=True) as crawler:\n    result = await crawler.arun(url=\"https://www.example.com\", bypass_cache=True)\n\n# Use WebKit\nasync with AsyncWebCrawler(browser_type=\"webkit\", verbose=True, headless=True) as crawler:\n    result = await crawler.arun(url=\"https://www.example.com\", bypass_cache=True)\n\n# Use Chromium (default)\nasync with AsyncWebCrawler(verbose=True, headless=True) as crawler:\n    result = await crawler.arun(url=\"https://www.example.com\", bypass_cache=True)\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class is used to store and structure the crawling output data regardless of which browser engine (Firefox, WebKit, or Chromium) is used to perform the crawl.",
      "ground_truth_trace_chain": "quickstart.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### [Cosine Strategy](cosine.md)\n\n`CosineStrategy` uses similarity-based clustering to identify and extract relevant content sections.\n\n```python\nfrom crawl4ai.extraction_strategy import CosineStrategy\n\nstrategy = CosineStrategy(\n    semantic_filter=\"product reviews\",    # Content focus\n    word_count_threshold=10,             # Minimum words per cluster\n    sim_threshold=0.3,                   # Similarity threshold\n    max_dist=0.2,                        # Maximum cluster distance\n    top_k=3                             # Number of top clusters to extract\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/reviews\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- Content similarity analysis\n- Topic clustering\n- Relevant content extraction\n- Pattern recognition in text",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 7,
      "artifact_title": "CosineStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "implements/usage",
      "relationship_explanation": "The documentation snippet explicitly imports and instantiates CosineStrategy, demonstrating its role in similarity\u2010based clustering for content extraction.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> CosineStrategy",
      "predicted_trace_chain_explanation": "The example starts with the documentation file and directly uses CosineStrategy, making it the primary artifact shown.",
      "ground_truth_relationship": "The code implements the CosineStrategy class with configurable parameters (semantic_filter, word_count_threshold, sim_threshold, max_dist, and top_k) exactly as documented in the example code snippet, using these values to control the similarity-based clustering and content extraction process.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> CosineStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### [Cosine Strategy](cosine.md)\n\n`CosineStrategy` uses similarity-based clustering to identify and extract relevant content sections.\n\n```python\nfrom crawl4ai.extraction_strategy import CosineStrategy\n\nstrategy = CosineStrategy(\n    semantic_filter=\"product reviews\",    # Content focus\n    word_count_threshold=10,             # Minimum words per cluster\n    sim_threshold=0.3,                   # Similarity threshold\n    max_dist=0.2,                        # Maximum cluster distance\n    top_k=3                             # Number of top clusters to extract\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/reviews\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- Content similarity analysis\n- Topic clustering\n- Relevant content extraction\n- Pattern recognition in text",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "CosineStrategy extends ExtractionStrategy, which defines the abstract interface for all extraction strategies. This relationship is implicit in the inheritance hierarchy.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> CosineStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "Since CosineStrategy inherits from ExtractionStrategy, the documentation implicitly points to the fundamental extraction interface provided by ExtractionStrategy.",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the foundational structure and parallel processing capabilities that enable derived strategies like CosineStrategy to implement specialized content extraction methods through the abstract extract() method.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### [Cosine Strategy](cosine.md)\n\n`CosineStrategy` uses similarity-based clustering to identify and extract relevant content sections.\n\n```python\nfrom crawl4ai.extraction_strategy import CosineStrategy\n\nstrategy = CosineStrategy(\n    semantic_filter=\"product reviews\",    # Content focus\n    word_count_threshold=10,             # Minimum words per cluster\n    sim_threshold=0.3,                   # Similarity threshold\n    max_dist=0.2,                        # Maximum cluster distance\n    top_k=3                             # Number of top clusters to extract\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/reviews\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- Content similarity analysis\n- Topic clustering\n- Relevant content extraction\n- Pattern recognition in text",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "implicit",
      "relationship_type": "method usage",
      "relationship_explanation": "The snippet shows the extraction strategy being passed to the crawler's arun() method. Although not explicitly named as AsyncWebCrawler, the usage implies that the arun() method (from AsyncWebCrawler.arun()) integrates the extraction functionality into the crawling process.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The documented example uses the arun() method on a crawler instance to perform the crawl with CosineStrategy, thereby linking the extraction strategy with the web crawling process.",
      "ground_truth_relationship": "The arun() method implements the main crawling logic that applies the documented CosineStrategy by accepting an extraction_strategy parameter which can be set to a CosineStrategy instance for similarity-based content clustering and extraction.",
      "ground_truth_trace_chain": "overview.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### [Cosine Strategy](cosine.md)\n\n`CosineStrategy` uses similarity-based clustering to identify and extract relevant content sections.\n\n```python\nfrom crawl4ai.extraction_strategy import CosineStrategy\n\nstrategy = CosineStrategy(\n    semantic_filter=\"product reviews\",    # Content focus\n    word_count_threshold=10,             # Minimum words per cluster\n    sim_threshold=0.3,                   # Similarity threshold\n    max_dist=0.2,                        # Maximum cluster distance\n    top_k=3                             # Number of top clusters to extract\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/reviews\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- Content similarity analysis\n- Topic clustering\n- Relevant content extraction\n- Pattern recognition in text",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the extracted content from the CosineStrategy in its extracted_content field along with metadata and source information needed for similarity-based clustering operations.",
      "ground_truth_trace_chain": "overview.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### [Cosine Strategy](cosine.md)\n\n`CosineStrategy` uses similarity-based clustering to identify and extract relevant content sections.\n\n```python\nfrom crawl4ai.extraction_strategy import CosineStrategy\n\nstrategy = CosineStrategy(\n    semantic_filter=\"product reviews\",    # Content focus\n    word_count_threshold=10,             # Minimum words per cluster\n    sim_threshold=0.3,                   # Similarity threshold\n    max_dist=0.2,                        # Maximum cluster distance\n    top_k=3                             # Number of top clusters to extract\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/reviews\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- Content similarity analysis\n- Topic clustering\n- Relevant content extraction\n- Pattern recognition in text",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the core interface methods needed to implement concrete strategies like CosineStrategy by requiring async crawl operations, screenshot capabilities, and hook management that extraction strategies build upon.",
      "ground_truth_trace_chain": "overview.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### [Cosine Strategy](cosine.md)\n\n`CosineStrategy` uses similarity-based clustering to identify and extract relevant content sections.\n\n```python\nfrom crawl4ai.extraction_strategy import CosineStrategy\n\nstrategy = CosineStrategy(\n    semantic_filter=\"product reviews\",    # Content focus\n    word_count_threshold=10,             # Minimum words per cluster\n    sim_threshold=0.3,                   # Similarity threshold\n    max_dist=0.2,                        # Maximum cluster distance\n    top_k=3                             # Number of top clusters to extract\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/reviews\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- Content similarity analysis\n- Topic clustering\n- Relevant content extraction\n- Pattern recognition in text",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class provides the underlying browser automation infrastructure needed to execute the cosine-based content extraction strategy by loading web pages and making their content available for analysis and clustering.",
      "ground_truth_trace_chain": "overview.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### [Cosine Strategy](cosine.md)\n\n`CosineStrategy` uses similarity-based clustering to identify and extract relevant content sections.\n\n```python\nfrom crawl4ai.extraction_strategy import CosineStrategy\n\nstrategy = CosineStrategy(\n    semantic_filter=\"product reviews\",    # Content focus\n    word_count_threshold=10,             # Minimum words per cluster\n    sim_threshold=0.3,                   # Similarity threshold\n    max_dist=0.2,                        # Maximum cluster distance\n    top_k=3                             # Number of top clusters to extract\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/reviews\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- Content similarity analysis\n- Topic clustering\n- Relevant content extraction\n- Pattern recognition in text",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the cosine strategy through its arun() method, which accepts an extraction_strategy parameter that can be configured with CosineStrategy to perform similarity-based content clustering as documented.",
      "ground_truth_trace_chain": "overview.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Use Fit Markdown for Articles**\n   ```python\n   # Perfect for blog posts, news articles, documentation\n   content = result.fit_markdown\n   ```\n\n2. **Handle Media Appropriately**\n   ```python\n   # Filter by relevance score\n   relevant_images = [\n       img for img in result.media[\"images\"]\n       if img['score'] > 5\n   ]\n   ```\n\n3. **Combine Link Analysis with Content**\n   ```python\n   # Get content links with context\n   content_links = [\n       link for link in result.links[\"internal\"]\n       if link['type'] == 'content'\n   ]\n   ```\n\n4. **Clean Content with Purpose**\n   ```python\n   # Customize cleaning based on your needs\n   result = await crawler.arun(\n       url=url,\n       word_count_threshold=20,      # Adjust based on content type\n       keep_data_attributes=False,   # Remove data attributes\n       process_iframes=True         # Include iframe content\n   )\n   ```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 12,
      "artifact_title": "CrawlResult.fit_markdown",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute usage",
      "relationship_explanation": "The documentation snippet directly demonstrates accessing the 'fit_markdown' attribute (content = result.fit_markdown) which is meant for representing formatted article content such as blog posts and news articles.",
      "predicted_trace_chain": "docs/md_v2/advanced/content-processing.md -> CrawlResult.fit_markdown",
      "predicted_trace_chain_explanation": "The chain starts from the documentation file and leads directly to the 'CrawlResult.fit_markdown' artifact, which is explicitly used in the code snippet.",
      "ground_truth_relationship": "The CrawlResult.fit_markdown property implements the documented Best Practice #1 by providing an optional string property that stores content formatted specifically for blog posts and articles.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult.fit_markdown",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Use Fit Markdown for Articles**\n   ```python\n   # Perfect for blog posts, news articles, documentation\n   content = result.fit_markdown\n   ```\n\n2. **Handle Media Appropriately**\n   ```python\n   # Filter by relevance score\n   relevant_images = [\n       img for img in result.media[\"images\"]\n       if img['score'] > 5\n   ]\n   ```\n\n3. **Combine Link Analysis with Content**\n   ```python\n   # Get content links with context\n   content_links = [\n       link for link in result.links[\"internal\"]\n       if link['type'] == 'content'\n   ]\n   ```\n\n4. **Clean Content with Purpose**\n   ```python\n   # Customize cleaning based on your needs\n   result = await crawler.arun(\n       url=url,\n       word_count_threshold=20,      # Adjust based on content type\n       keep_data_attributes=False,   # Remove data attributes\n       process_iframes=True         # Include iframe content\n   )\n   ```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 16,
      "artifact_title": "CrawlResult.media",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute usage",
      "relationship_explanation": "The snippet shows a usage example filtering images from 'result.media[\"images\"]' by relevance score. This clearly indicates that the 'media' attribute of the CrawlResult is used to store and process media assets.",
      "predicted_trace_chain": "docs/md_v2/advanced/content-processing.md -> CrawlResult.media",
      "predicted_trace_chain_explanation": "The documentation directly references the 'media' attribute, establishing a trace from the documentation file to the CrawlResult.media artifact.",
      "ground_truth_relationship": "The CrawlResult.media dictionary property enables filtering and organizing media elements like images based on relevance scores as shown in the documentation's Best Practices section.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult.media",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Use Fit Markdown for Articles**\n   ```python\n   # Perfect for blog posts, news articles, documentation\n   content = result.fit_markdown\n   ```\n\n2. **Handle Media Appropriately**\n   ```python\n   # Filter by relevance score\n   relevant_images = [\n       img for img in result.media[\"images\"]\n       if img['score'] > 5\n   ]\n   ```\n\n3. **Combine Link Analysis with Content**\n   ```python\n   # Get content links with context\n   content_links = [\n       link for link in result.links[\"internal\"]\n       if link['type'] == 'content'\n   ]\n   ```\n\n4. **Clean Content with Purpose**\n   ```python\n   # Customize cleaning based on your needs\n   result = await crawler.arun(\n       url=url,\n       word_count_threshold=20,      # Adjust based on content type\n       keep_data_attributes=False,   # Remove data attributes\n       process_iframes=True         # Include iframe content\n   )\n   ```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 14,
      "artifact_title": "CrawlResult.links",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute usage",
      "relationship_explanation": "The documentation includes a code example that filters internal links via 'result.links[\"internal\"]'. This explicitly shows the usage of the 'links' attribute from the CrawlResult model.",
      "predicted_trace_chain": "docs/md_v2/advanced/content-processing.md -> CrawlResult.links",
      "predicted_trace_chain_explanation": "By demonstrating the extraction of content links, the documentation links directly to the 'CrawlResult.links' artifact.",
      "ground_truth_relationship": "The CrawlResult.links dictionary structure enables the filtering of internal content links as shown in the best practices documentation where links are filtered by type.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult.links",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Use Fit Markdown for Articles**\n   ```python\n   # Perfect for blog posts, news articles, documentation\n   content = result.fit_markdown\n   ```\n\n2. **Handle Media Appropriately**\n   ```python\n   # Filter by relevance score\n   relevant_images = [\n       img for img in result.media[\"images\"]\n       if img['score'] > 5\n   ]\n   ```\n\n3. **Combine Link Analysis with Content**\n   ```python\n   # Get content links with context\n   content_links = [\n       link for link in result.links[\"internal\"]\n       if link['type'] == 'content'\n   ]\n   ```\n\n4. **Clean Content with Purpose**\n   ```python\n   # Customize cleaning based on your needs\n   result = await crawler.arun(\n       url=url,\n       word_count_threshold=20,      # Adjust based on content type\n       keep_data_attributes=False,   # Remove data attributes\n       process_iframes=True         # Include iframe content\n   )\n   ```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The provided example calls 'crawler.arun(...)' with several parameters such as 'word_count_threshold', 'keep_data_attributes', and 'process_iframes'. This usage clearly corresponds to the 'AsyncWebCrawler.arun()' method responsible for cleaning and processing content.",
      "predicted_trace_chain": "docs/md_v2/advanced/content-processing.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain follows from the documentation file through the example usage to the 'AsyncWebCrawler.arun()' method, highlighting its role in content cleaning as described in the documentation.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method implements the documented best practices by accepting parameters like word_count_threshold to clean content, supporting media processing through screenshot capture, and handling link extraction through its processing pipeline.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Use Fit Markdown for Articles**\n   ```python\n   # Perfect for blog posts, news articles, documentation\n   content = result.fit_markdown\n   ```\n\n2. **Handle Media Appropriately**\n   ```python\n   # Filter by relevance score\n   relevant_images = [\n       img for img in result.media[\"images\"]\n       if img['score'] > 5\n   ]\n   ```\n\n3. **Combine Link Analysis with Content**\n   ```python\n   # Get content links with context\n   content_links = [\n       link for link in result.links[\"internal\"]\n       if link['type'] == 'content'\n   ]\n   ```\n\n4. **Clean Content with Purpose**\n   ```python\n   # Customize cleaning based on your needs\n   result = await crawler.arun(\n       url=url,\n       word_count_threshold=20,      # Adjust based on content type\n       keep_data_attributes=False,   # Remove data attributes\n       process_iframes=True         # Include iframe content\n   )\n   ```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class implements all the key properties referenced in the best practices documentation, including fit_markdown for articles, media for image handling, links for content analysis, and cleaned_html for content processing.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Use Fit Markdown for Articles**\n   ```python\n   # Perfect for blog posts, news articles, documentation\n   content = result.fit_markdown\n   ```\n\n2. **Handle Media Appropriately**\n   ```python\n   # Filter by relevance score\n   relevant_images = [\n       img for img in result.media[\"images\"]\n       if img['score'] > 5\n   ]\n   ```\n\n3. **Combine Link Analysis with Content**\n   ```python\n   # Get content links with context\n   content_links = [\n       link for link in result.links[\"internal\"]\n       if link['type'] == 'content'\n   ]\n   ```\n\n4. **Clean Content with Purpose**\n   ```python\n   # Customize cleaning based on your needs\n   result = await crawler.arun(\n       url=url,\n       word_count_threshold=20,      # Adjust based on content type\n       keep_data_attributes=False,   # Remove data attributes\n       process_iframes=True         # Include iframe content\n   )\n   ```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface methods that enable the documented features like content filtering, markdown conversion, and media handling through its abstract crawl methods.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Use Fit Markdown for Articles**\n   ```python\n   # Perfect for blog posts, news articles, documentation\n   content = result.fit_markdown\n   ```\n\n2. **Handle Media Appropriately**\n   ```python\n   # Filter by relevance score\n   relevant_images = [\n       img for img in result.media[\"images\"]\n       if img['score'] > 5\n   ]\n   ```\n\n3. **Combine Link Analysis with Content**\n   ```python\n   # Get content links with context\n   content_links = [\n       link for link in result.links[\"internal\"]\n       if link['type'] == 'content'\n   ]\n   ```\n\n4. **Clean Content with Purpose**\n   ```python\n   # Customize cleaning based on your needs\n   result = await crawler.arun(\n       url=url,\n       word_count_threshold=20,      # Adjust based on content type\n       keep_data_attributes=False,   # Remove data attributes\n       process_iframes=True         # Include iframe content\n   )\n   ```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the documented best practices by providing methods for Markdown content processing, media handling with score filtering, link analysis, and customizable content cleaning through configuration parameters in its crawl method.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Use Fit Markdown for Articles**\n   ```python\n   # Perfect for blog posts, news articles, documentation\n   content = result.fit_markdown\n   ```\n\n2. **Handle Media Appropriately**\n   ```python\n   # Filter by relevance score\n   relevant_images = [\n       img for img in result.media[\"images\"]\n       if img['score'] > 5\n   ]\n   ```\n\n3. **Combine Link Analysis with Content**\n   ```python\n   # Get content links with context\n   content_links = [\n       link for link in result.links[\"internal\"]\n       if link['type'] == 'content'\n   ]\n   ```\n\n4. **Clean Content with Purpose**\n   ```python\n   # Customize cleaning based on your needs\n   result = await crawler.arun(\n       url=url,\n       word_count_threshold=20,      # Adjust based on content type\n       keep_data_attributes=False,   # Remove data attributes\n       process_iframes=True         # Include iframe content\n   )\n   ```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The documentation outlines best practices for using the AsyncWebCrawler class's features, specifically showing how to access fit_markdown for articles, filter media by relevance scores, process content links, and customize crawling parameters through the arun() method implementation.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Example 1: Extract Structured Data\n\nIn this example, we use the `LLMExtractionStrategy` to extract structured data (model names and their fees) from the OpenAI pricing page.\n\n```python\nimport os\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\nfrom pydantic import BaseModel, Field\n\nclass OpenAIModelFee(BaseModel):\n    model_name: str = Field(..., description=\"Name of the OpenAI model.\")\n    input_fee: str = Field(..., description=\"Fee for input token for the OpenAI model.\")\n    output_fee: str = Field(..., description=\"Fee for output token for the OpenAI model.\")\n\nasync def extract_openai_fees():\n    url = 'https://openai.com/api/pricing/'\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=1,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\", # Or use ollama like provider=\"ollama/nemotron\"\n                api_token=os.getenv('OPENAI_API_KEY'),\n                schema=OpenAIModelFee.model_json_schema(),\n                extraction_type=\"schema\",\n                instruction=\"From the crawled content, extract all mentioned model names along with their \"\n                            \"fees for input and output tokens. Make sure not to miss anything in the entire content. \"\n                            'One extracted model JSON format should look like this: '\n                            '{ \"model_name\": \"GPT-4\", \"input_fee\": \"US$10.00 / 1M tokens\", \"output_fee\": \"US$30.00 / 1M tokens\" }'\n            ),\n            bypass_cache=True,\n        )\n\n    model_fees = json.loads(result.extracted_content)\n    print(f\"Number of models extracted: {len(model_fees)}\")\n\n    with open(\".data/openai_fees.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(model_fees, f, indent=2)\n\nasyncio.run(extract_openai_fees())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "Instantiation and Usage",
      "relationship_explanation": "The documentation snippet explicitly imports AsyncWebCrawler and instantiates it within an async context manager. This demonstrates its role as the main crawler object that initiates the crawling process.",
      "predicted_trace_chain": "docs/md_v2/extraction/llm.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain starts from the documentation file ('llm.md') and directly reaches AsyncWebCrawler, highlighting the direct usage of this class in the extraction example.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the web crawling functionality demonstrated in the documentation by providing asynchronous methods to crawl URLs, process HTML content, and extract structured data using strategies like LLMExtractionStrategy.",
      "ground_truth_trace_chain": "llm.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example 1: Extract Structured Data\n\nIn this example, we use the `LLMExtractionStrategy` to extract structured data (model names and their fees) from the OpenAI pricing page.\n\n```python\nimport os\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\nfrom pydantic import BaseModel, Field\n\nclass OpenAIModelFee(BaseModel):\n    model_name: str = Field(..., description=\"Name of the OpenAI model.\")\n    input_fee: str = Field(..., description=\"Fee for input token for the OpenAI model.\")\n    output_fee: str = Field(..., description=\"Fee for output token for the OpenAI model.\")\n\nasync def extract_openai_fees():\n    url = 'https://openai.com/api/pricing/'\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=1,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\", # Or use ollama like provider=\"ollama/nemotron\"\n                api_token=os.getenv('OPENAI_API_KEY'),\n                schema=OpenAIModelFee.model_json_schema(),\n                extraction_type=\"schema\",\n                instruction=\"From the crawled content, extract all mentioned model names along with their \"\n                            \"fees for input and output tokens. Make sure not to miss anything in the entire content. \"\n                            'One extracted model JSON format should look like this: '\n                            '{ \"model_name\": \"GPT-4\", \"input_fee\": \"US$10.00 / 1M tokens\", \"output_fee\": \"US$30.00 / 1M tokens\" }'\n            ),\n            bypass_cache=True,\n        )\n\n    model_fees = json.loads(result.extracted_content)\n    print(f\"Number of models extracted: {len(model_fees)}\")\n\n    with open(\".data/openai_fees.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(model_fees, f, indent=2)\n\nasyncio.run(extract_openai_fees())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "Method Invocation",
      "relationship_explanation": "Within the provided example, the 'arun()' method is explicitly called on an AsyncWebCrawler instance. This method is responsible for performing the crawling and subsequently processing the extracted content.",
      "predicted_trace_chain": "docs/md_v2/extraction/llm.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The trace chain shows that after creating an AsyncWebCrawler instance (from the 'llm.md' document), its 'arun()' method is invoked to execute the extraction workflow.",
      "ground_truth_relationship": "The example documentation shows a specific usage of AsyncWebCrawler.arun() to extract OpenAI model pricing data, where the code processes the URL with an LLMExtractionStrategy instance and handles caching, HTML processing, and error management to return a CrawlResult.",
      "ground_truth_trace_chain": "llm.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example 1: Extract Structured Data\n\nIn this example, we use the `LLMExtractionStrategy` to extract structured data (model names and their fees) from the OpenAI pricing page.\n\n```python\nimport os\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\nfrom pydantic import BaseModel, Field\n\nclass OpenAIModelFee(BaseModel):\n    model_name: str = Field(..., description=\"Name of the OpenAI model.\")\n    input_fee: str = Field(..., description=\"Fee for input token for the OpenAI model.\")\n    output_fee: str = Field(..., description=\"Fee for output token for the OpenAI model.\")\n\nasync def extract_openai_fees():\n    url = 'https://openai.com/api/pricing/'\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=1,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\", # Or use ollama like provider=\"ollama/nemotron\"\n                api_token=os.getenv('OPENAI_API_KEY'),\n                schema=OpenAIModelFee.model_json_schema(),\n                extraction_type=\"schema\",\n                instruction=\"From the crawled content, extract all mentioned model names along with their \"\n                            \"fees for input and output tokens. Make sure not to miss anything in the entire content. \"\n                            'One extracted model JSON format should look like this: '\n                            '{ \"model_name\": \"GPT-4\", \"input_fee\": \"US$10.00 / 1M tokens\", \"output_fee\": \"US$30.00 / 1M tokens\" }'\n            ),\n            bypass_cache=True,\n        )\n\n    model_fees = json.loads(result.extracted_content)\n    print(f\"Number of models extracted: {len(model_fees)}\")\n\n    with open(\".data/openai_fees.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(model_fees, f, indent=2)\n\nasyncio.run(extract_openai_fees())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "Strategy Implementation",
      "relationship_explanation": "The code snippet explicitly instantiates LLMExtractionStrategy with detailed parameters (provider, api_token, schema, extraction_type, and instruction) to extract structured data from the pricing page. This demonstrates its role as the extraction strategy for processing the crawled content.",
      "predicted_trace_chain": "docs/md_v2/extraction/llm.md -> LLMExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "Starting from the documentation file, the chain moves to LLMExtractionStrategy, which is directly instantiated in the example, and then to its base class ExtractionStrategy, linking the concrete implementation with the abstract extraction interface.",
      "ground_truth_relationship": "The LLMExtractionStrategy class implements the structured data extraction functionality demonstrated in the documentation by using provider-based LLM models to parse HTML content according to a predefined Pydantic schema, as shown in the OpenAIModelFee example.",
      "ground_truth_trace_chain": "llm.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example 1: Extract Structured Data\n\nIn this example, we use the `LLMExtractionStrategy` to extract structured data (model names and their fees) from the OpenAI pricing page.\n\n```python\nimport os\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\nfrom pydantic import BaseModel, Field\n\nclass OpenAIModelFee(BaseModel):\n    model_name: str = Field(..., description=\"Name of the OpenAI model.\")\n    input_fee: str = Field(..., description=\"Fee for input token for the OpenAI model.\")\n    output_fee: str = Field(..., description=\"Fee for output token for the OpenAI model.\")\n\nasync def extract_openai_fees():\n    url = 'https://openai.com/api/pricing/'\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=1,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\", # Or use ollama like provider=\"ollama/nemotron\"\n                api_token=os.getenv('OPENAI_API_KEY'),\n                schema=OpenAIModelFee.model_json_schema(),\n                extraction_type=\"schema\",\n                instruction=\"From the crawled content, extract all mentioned model names along with their \"\n                            \"fees for input and output tokens. Make sure not to miss anything in the entire content. \"\n                            'One extracted model JSON format should look like this: '\n                            '{ \"model_name\": \"GPT-4\", \"input_fee\": \"US$10.00 / 1M tokens\", \"output_fee\": \"US$30.00 / 1M tokens\" }'\n            ),\n            bypass_cache=True,\n        )\n\n    model_fees = json.loads(result.extracted_content)\n    print(f\"Number of models extracted: {len(model_fees)}\")\n\n    with open(\".data/openai_fees.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(model_fees, f, indent=2)\n\nasyncio.run(extract_openai_fees())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the structure that holds the extraction results shown in the documentation example, particularly storing the extracted OpenAI model fees in the extracted_content field.",
      "ground_truth_trace_chain": "llm.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Example 1: Extract Structured Data\n\nIn this example, we use the `LLMExtractionStrategy` to extract structured data (model names and their fees) from the OpenAI pricing page.\n\n```python\nimport os\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\nfrom pydantic import BaseModel, Field\n\nclass OpenAIModelFee(BaseModel):\n    model_name: str = Field(..., description=\"Name of the OpenAI model.\")\n    input_fee: str = Field(..., description=\"Fee for input token for the OpenAI model.\")\n    output_fee: str = Field(..., description=\"Fee for output token for the OpenAI model.\")\n\nasync def extract_openai_fees():\n    url = 'https://openai.com/api/pricing/'\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=1,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\", # Or use ollama like provider=\"ollama/nemotron\"\n                api_token=os.getenv('OPENAI_API_KEY'),\n                schema=OpenAIModelFee.model_json_schema(),\n                extraction_type=\"schema\",\n                instruction=\"From the crawled content, extract all mentioned model names along with their \"\n                            \"fees for input and output tokens. Make sure not to miss anything in the entire content. \"\n                            'One extracted model JSON format should look like this: '\n                            '{ \"model_name\": \"GPT-4\", \"input_fee\": \"US$10.00 / 1M tokens\", \"output_fee\": \"US$30.00 / 1M tokens\" }'\n            ),\n            bypass_cache=True,\n        )\n\n    model_fees = json.loads(result.extracted_content)\n    print(f\"Number of models extracted: {len(model_fees)}\")\n\n    with open(\".data/openai_fees.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(model_fees, f, indent=2)\n\nasyncio.run(extract_openai_fees())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_title": "CrawlResult.extracted_content",
      "ground_truth_relationship": "The extracted_content property stores the LLM-extracted structured data (model fees) as a JSON string which is then parsed and saved to a file in the example documentation.",
      "ground_truth_trace_chain": "llm.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Example 1: Extract Structured Data\n\nIn this example, we use the `LLMExtractionStrategy` to extract structured data (model names and their fees) from the OpenAI pricing page.\n\n```python\nimport os\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\nfrom pydantic import BaseModel, Field\n\nclass OpenAIModelFee(BaseModel):\n    model_name: str = Field(..., description=\"Name of the OpenAI model.\")\n    input_fee: str = Field(..., description=\"Fee for input token for the OpenAI model.\")\n    output_fee: str = Field(..., description=\"Fee for output token for the OpenAI model.\")\n\nasync def extract_openai_fees():\n    url = 'https://openai.com/api/pricing/'\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=1,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\", # Or use ollama like provider=\"ollama/nemotron\"\n                api_token=os.getenv('OPENAI_API_KEY'),\n                schema=OpenAIModelFee.model_json_schema(),\n                extraction_type=\"schema\",\n                instruction=\"From the crawled content, extract all mentioned model names along with their \"\n                            \"fees for input and output tokens. Make sure not to miss anything in the entire content. \"\n                            'One extracted model JSON format should look like this: '\n                            '{ \"model_name\": \"GPT-4\", \"input_fee\": \"US$10.00 / 1M tokens\", \"output_fee\": \"US$30.00 / 1M tokens\" }'\n            ),\n            bypass_cache=True,\n        )\n\n    model_fees = json.loads(result.extracted_content)\n    print(f\"Number of models extracted: {len(model_fees)}\")\n\n    with open(\".data/openai_fees.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(model_fees, f, indent=2)\n\nasyncio.run(extract_openai_fees())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class provides the core web crawling functionality that enables the extraction example to fetch and process web content from the OpenAI pricing page before applying the LLMExtractionStrategy for data extraction.",
      "ground_truth_trace_chain": "llm.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Example 1: Extract Structured Data\n\nIn this example, we use the `LLMExtractionStrategy` to extract structured data (model names and their fees) from the OpenAI pricing page.\n\n```python\nimport os\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\nfrom pydantic import BaseModel, Field\n\nclass OpenAIModelFee(BaseModel):\n    model_name: str = Field(..., description=\"Name of the OpenAI model.\")\n    input_fee: str = Field(..., description=\"Fee for input token for the OpenAI model.\")\n    output_fee: str = Field(..., description=\"Fee for output token for the OpenAI model.\")\n\nasync def extract_openai_fees():\n    url = 'https://openai.com/api/pricing/'\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=1,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\", # Or use ollama like provider=\"ollama/nemotron\"\n                api_token=os.getenv('OPENAI_API_KEY'),\n                schema=OpenAIModelFee.model_json_schema(),\n                extraction_type=\"schema\",\n                instruction=\"From the crawled content, extract all mentioned model names along with their \"\n                            \"fees for input and output tokens. Make sure not to miss anything in the entire content. \"\n                            'One extracted model JSON format should look like this: '\n                            '{ \"model_name\": \"GPT-4\", \"input_fee\": \"US$10.00 / 1M tokens\", \"output_fee\": \"US$30.00 / 1M tokens\" }'\n            ),\n            bypass_cache=True,\n        )\n\n    model_fees = json.loads(result.extracted_content)\n    print(f\"Number of models extracted: {len(model_fees)}\")\n\n    with open(\".data/openai_fees.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(model_fees, f, indent=2)\n\nasyncio.run(extract_openai_fees())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_title": "ExtractionStrategy",
      "ground_truth_relationship": "The ExtractionStrategy base class defines the core interface and parallel processing logic that enables concrete implementations like LLMExtractionStrategy to extract structured data from web content, as demonstrated in the documentation example with OpenAI model fees.",
      "ground_truth_trace_chain": "llm.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Example 1: Extract Structured Data\n\nIn this example, we use the `LLMExtractionStrategy` to extract structured data (model names and their fees) from the OpenAI pricing page.\n\n```python\nimport os\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\nfrom pydantic import BaseModel, Field\n\nclass OpenAIModelFee(BaseModel):\n    model_name: str = Field(..., description=\"Name of the OpenAI model.\")\n    input_fee: str = Field(..., description=\"Fee for input token for the OpenAI model.\")\n    output_fee: str = Field(..., description=\"Fee for output token for the OpenAI model.\")\n\nasync def extract_openai_fees():\n    url = 'https://openai.com/api/pricing/'\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=url,\n            word_count_threshold=1,\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\", # Or use ollama like provider=\"ollama/nemotron\"\n                api_token=os.getenv('OPENAI_API_KEY'),\n                schema=OpenAIModelFee.model_json_schema(),\n                extraction_type=\"schema\",\n                instruction=\"From the crawled content, extract all mentioned model names along with their \"\n                            \"fees for input and output tokens. Make sure not to miss anything in the entire content. \"\n                            'One extracted model JSON format should look like this: '\n                            '{ \"model_name\": \"GPT-4\", \"input_fee\": \"US$10.00 / 1M tokens\", \"output_fee\": \"US$30.00 / 1M tokens\" }'\n            ),\n            bypass_cache=True,\n        )\n\n    model_fees = json.loads(result.extracted_content)\n    print(f\"Number of models extracted: {len(model_fees)}\")\n\n    with open(\".data/openai_fees.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(model_fees, f, indent=2)\n\nasyncio.run(extract_openai_fees())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy class defines the abstract interface that enables the asynchronous web crawling functionality shown in the documentation example, where AsyncWebCrawler uses this interface to fetch OpenAI pricing data.",
      "ground_truth_trace_chain": "llm.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Raw HTML\n\nOriginal, unmodified HTML from the webpage. Useful when you need to:\n- Preserve the exact page structure\n- Process HTML with your own tools\n- Debug page issues\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nprint(result.html)  # Complete HTML including headers, scripts, etc.\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The documentation snippet explicitly shows the usage of the 'arun' method on a crawler object (i.e. 'result = await crawler.arun(url=\"https://example.com\")'). This demonstrates that the method is responsible for initiating the crawl and returning a CrawlResult containing the raw HTML.",
      "predicted_trace_chain": "output-formats.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the documentation file 'output-formats.md', the snippet directly calls 'AsyncWebCrawler.arun()', establishing it as the first artifact in the chain.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method implements the raw HTML retrieval functionality by fetching unmodified webpage content and storing it in the CrawlResult.html property, which can be accessed as shown in the documentation example.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Raw HTML\n\nOriginal, unmodified HTML from the webpage. Useful when you need to:\n- Preserve the exact page structure\n- Process HTML with your own tools\n- Debug page issues\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nprint(result.html)  # Complete HTML including headers, scripts, etc.\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 13,
      "artifact_title": "CrawlResult.html",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet prints 'result.html', explicitly accessing the 'html' attribute of the CrawlResult. This attribute holds the complete raw HTML output (including headers and scripts), which is the documented functionality.",
      "predicted_trace_chain": "output-formats.md -> AsyncWebCrawler.arun() -> CrawlResult.html",
      "predicted_trace_chain_explanation": "The chain begins in 'output-formats.md' where 'AsyncWebCrawler.arun()' is invoked to obtain a CrawlResult, and then the 'html' attribute of that result is accessed to retrieve the raw HTML as described in the documentation.",
      "ground_truth_relationship": "The CrawlResult.html property stores the complete unmodified HTML content from a crawled webpage as a string, allowing access to the raw markup for custom processing or debugging.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult.html",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Raw HTML\n\nOriginal, unmodified HTML from the webpage. Useful when you need to:\n- Preserve the exact page structure\n- Process HTML with your own tools\n- Debug page issues\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nprint(result.html)  # Complete HTML including headers, scripts, etc.\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores raw HTML content in its 'html' field, matching the documentation's description of preserving unmodified webpage content for analysis and debugging purposes.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Raw HTML\n\nOriginal, unmodified HTML from the webpage. Useful when you need to:\n- Preserve the exact page structure\n- Process HTML with your own tools\n- Debug page issues\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nprint(result.html)  # Complete HTML including headers, scripts, etc.\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements raw HTML retrieval through its arun() method, which returns a CrawlResult object containing the unmodified HTML in the 'html' property as documented in the code example.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## JavaScript Execution\n\n### Basic Execution\n\n```python\n# Single JavaScript command\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\"\n)\n\n# Multiple commands\njs_commands = [\n    \"window.scrollTo(0, document.body.scrollHeight);\",\n    \"document.querySelector('.load-more').click();\",\n    \"document.querySelector('#consent-button').click();\"\n]\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=js_commands\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "usage",
      "relationship_explanation": "The documentation snippet directly demonstrates the use of the 'arun' method by calling 'crawler.arun' with the 'js_code' parameter. This explicitly maps to the 'AsyncWebCrawler.arun()' method which is part of the public interface for initiating crawling operations with JavaScript execution.",
      "predicted_trace_chain": "page-interaction.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The documentation (from 'docs/md_v2/basic/page-interaction.md') shows a direct call to 'crawler.arun()', which is implemented by AsyncWebCrawler.arun(), establishing a clear and direct trace.",
      "ground_truth_relationship": "The arun() method implements the documented JavaScript execution capability by accepting js_code as a parameter through **kwargs and forwarding it to the crawler_strategy.crawl() method for executing single or multiple JavaScript commands on the target webpage.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## JavaScript Execution\n\n### Basic Execution\n\n```python\n# Single JavaScript command\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\"\n)\n\n# Multiple commands\njs_commands = [\n    \"window.scrollTo(0, document.body.scrollHeight);\",\n    \"document.querySelector('.load-more').click();\",\n    \"document.querySelector('#consent-button').click();\"\n]\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=js_commands\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "implementation",
      "relationship_explanation": "While the snippet does not mention this class by name, the 'js_code' parameter passed to 'AsyncWebCrawler.arun()' is handled internally by the crawler strategy. The 'AsyncPlaywrightCrawlerStrategy' class processes the 'js_code' parameter within its 'crawl' method to execute JavaScript commands on the page, making it an essential but implicit part of the execution chain.",
      "predicted_trace_chain": "page-interaction.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The 'arun' method of AsyncWebCrawler (explicitly used in the documentation) delegates the crawling work to its strategy component, which by default is an instance of AsyncPlaywrightCrawlerStrategy. This intermediate step is necessary to handle the 'js_code' functionality, forming the complete trace.",
      "ground_truth_relationship": "The code implements JavaScript execution by allowing both single and multiple JS commands to be passed through the js_code parameter in the crawl method, which are then executed using Playwright's page.evaluate() function.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## JavaScript Execution\n\n### Basic Execution\n\n```python\n# Single JavaScript command\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\"\n)\n\n# Multiple commands\njs_commands = [\n    \"window.scrollTo(0, document.body.scrollHeight);\",\n    \"document.querySelector('.load-more').click();\",\n    \"document.querySelector('#consent-button').click();\"\n]\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=js_commands\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult model captures and stores the outcomes of JavaScript execution commands, including the resulting HTML, success status, and any errors that may occur during the execution of the documented JS commands.",
      "ground_truth_trace_chain": "page-interaction.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## JavaScript Execution\n\n### Basic Execution\n\n```python\n# Single JavaScript command\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\"\n)\n\n# Multiple commands\njs_commands = [\n    \"window.scrollTo(0, document.body.scrollHeight);\",\n    \"document.querySelector('.load-more').click();\",\n    \"document.querySelector('#consent-button').click();\"\n]\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=js_commands\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core methods that enable JavaScript execution through its crawl() method, which the documentation demonstrates using through examples of scrolling and clicking elements.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## JavaScript Execution\n\n### Basic Execution\n\n```python\n# Single JavaScript command\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\"\n)\n\n# Multiple commands\njs_commands = [\n    \"window.scrollTo(0, document.body.scrollHeight);\",\n    \"document.querySelector('.load-more').click();\",\n    \"document.querySelector('#consent-button').click();\"\n]\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=js_commands\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements JavaScript execution through its arun method, which accepts a js_code parameter that can be either a single command or list of commands as shown in the documentation examples.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Content Filtering\n\nControl what content is included or excluded:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    # Content thresholds\n    word_count_threshold=10,        # Minimum words per block\n    \n    # Tag exclusions\n    excluded_tags=['form', 'header', 'footer', 'nav'],\n    \n    # Link filtering\n    exclude_external_links=True,    # Remove external links\n    exclude_social_media_links=True,  # Remove social media links\n    \n    # Media filtering\n    exclude_external_images=True   # Remove external images\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method usage",
      "relationship_explanation": "The documentation snippet shows an explicit example of calling the 'arun' method on a crawler instance with parameters like 'word_count_threshold' and various exclusion flags. This directly correlates to the 'AsyncWebCrawler.arun()' method as implemented in the code artifact.",
      "predicted_trace_chain": "content-selection.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain starts from the documentation file 'content-selection.md' and links directly to the 'AsyncWebCrawler.arun()' method, which is responsible for processing these content filtering parameters.",
      "ground_truth_relationship": "The documented content filtering parameters like word_count_threshold, excluded_tags, and link filtering options are implemented as optional kwargs in the arun() method and processed during HTML extraction and processing stages of the crawler.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Content Filtering\n\nControl what content is included or excluded:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    # Content thresholds\n    word_count_threshold=10,        # Minimum words per block\n    \n    # Tag exclusions\n    excluded_tags=['form', 'header', 'footer', 'nav'],\n    \n    # Link filtering\n    exclude_external_links=True,    # Remove external links\n    exclude_social_media_links=True,  # Remove social media links\n    \n    # Media filtering\n    exclude_external_images=True   # Remove external images\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "implicit",
      "relationship_type": "class instantiation",
      "relationship_explanation": "Although the snippet does not explicitly mention the class name, the 'crawler' object used in the example is implicitly an instance of the 'AsyncWebCrawler' class. This class provides the framework within which the arun() method operates.",
      "predicted_trace_chain": "content-selection.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "Starting from the 'content-selection.md' documentation, the implied instantiation of a crawler maps to the 'AsyncWebCrawler' class, which underlies the method call demonstrated in the snippet.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements content filtering through its arun method by accepting parameters like word_count_threshold, excluded_tags, and various exclusion flags that control what content gets included in the final crawl result.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Content Filtering\n\nControl what content is included or excluded:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    # Content thresholds\n    word_count_threshold=10,        # Minimum words per block\n    \n    # Tag exclusions\n    excluded_tags=['form', 'header', 'footer', 'nav'],\n    \n    # Link filtering\n    exclude_external_links=True,    # Remove external links\n    exclude_social_media_links=True,  # Remove social media links\n    \n    # Media filtering\n    exclude_external_images=True   # Remove external images\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class provides storage for filtered content by defining fields like cleaned_html, links, and media that hold the results after applying the documented content filtering parameters like excluded_tags and link filtering options.",
      "ground_truth_trace_chain": "content-selection.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Content Filtering\n\nControl what content is included or excluded:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    # Content thresholds\n    word_count_threshold=10,        # Minimum words per block\n    \n    # Tag exclusions\n    excluded_tags=['form', 'header', 'footer', 'nav'],\n    \n    # Link filtering\n    exclude_external_links=True,    # Remove external links\n    exclude_social_media_links=True,  # Remove social media links\n    \n    # Media filtering\n    exclude_external_images=True   # Remove external images\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements content filtering by accepting configuration parameters like excluded_tags and thresholds that control what elements are included or excluded during web page crawling.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Content Filtering\n\nControl what content is included or excluded:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    # Content thresholds\n    word_count_threshold=10,        # Minimum words per block\n    \n    # Tag exclusions\n    excluded_tags=['form', 'header', 'footer', 'nav'],\n    \n    # Link filtering\n    exclude_external_links=True,    # Remove external links\n    exclude_social_media_links=True,  # Remove social media links\n    \n    # Media filtering\n    exclude_external_images=True   # Remove external images\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the interface through which the documented content filtering parameters can be passed as kwargs to the crawl method.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Domain-Based Filtering\n\nControl content based on domains:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    exclude_domains=[\"ads.com\", \"tracker.com\"],\n    exclude_social_media_domains=[\"facebook.com\", \"twitter.com\"],  # Custom social media domains to exclude\n    exclude_social_media_links=True\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The documentation snippet explicitly demonstrates a call 'crawler.arun(...)' with domain filtering parameters. This directly maps to the 'AsyncWebCrawler.arun()' method which is responsible for handling the crawl process and accepts additional keyword arguments (such as exclude_domains) that control content filtration.",
      "predicted_trace_chain": "docs/md_v2/basic/content-selection.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The trace starts with the documentation file, moves to the AsyncWebCrawler class (to which the 'crawler' instance belongs), and then to its 'arun()' method which is explicitly invoked in the example.",
      "ground_truth_relationship": "The arun() method's **kwargs parameter accepts domain filtering options like exclude_domains and exclude_social_media_domains documented in the example code snippet, which get passed through to the crawler_strategy.crawl() function for domain-based content control.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Domain-Based Filtering\n\nControl content based on domains:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    exclude_domains=[\"ads.com\", \"tracker.com\"],\n    exclude_social_media_domains=[\"facebook.com\", \"twitter.com\"],  # Custom social media domains to exclude\n    exclude_social_media_links=True\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "implicit",
      "relationship_type": "class usage",
      "relationship_explanation": "Although the snippet does not mention the class name explicitly, the 'crawler' variable used in the example is an instance of the 'AsyncWebCrawler' class. Its inclusion is inferred based on the method call and overall crawler instantiation pattern.",
      "predicted_trace_chain": "docs/md_v2/basic/content-selection.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain begins at the documentation file and directly leads to the AsyncWebCrawler class, which underlies the 'crawler' object used in the example.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements domain-based filtering through its arun method which accepts exclude_domains and exclude_social_media parameters that are passed to the underlying crawler strategy for URL filtering during web crawling.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Domain-Based Filtering\n\nControl content based on domains:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    exclude_domains=[\"ads.com\", \"tracker.com\"],\n    exclude_social_media_domains=[\"facebook.com\", \"twitter.com\"],  # Custom social media domains to exclude\n    exclude_social_media_links=True\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class manages the filtered domain crawl results by storing cleaned HTML, extracted links, and associated metadata that reflect the domain-based filtering rules specified in the documentation.",
      "ground_truth_trace_chain": "content-selection.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Domain-Based Filtering\n\nControl content based on domains:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    exclude_domains=[\"ads.com\", \"tracker.com\"],\n    exclude_social_media_domains=[\"facebook.com\", \"twitter.com\"],  # Custom social media domains to exclude\n    exclude_social_media_links=True\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements domain-based filtering during crawling by accepting exclude_domains and exclude_social_media parameters which are used to control which URLs are processed during the crawling operation.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Domain-Based Filtering\n\nControl content based on domains:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    exclude_domains=[\"ads.com\", \"tracker.com\"],\n    exclude_social_media_domains=[\"facebook.com\", \"twitter.com\"],  # Custom social media domains to exclude\n    exclude_social_media_links=True\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class provides the foundational interface for implementing domain-based filtering through its crawl method, which accepts kwargs that can include domain exclusion parameters documented in the example.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Common Use Cases\n\n1. **E-commerce Scraping**\n   ```python\n   # CSS Strategy for product listings\n   schema = {\n       \"name\": \"Products\",\n       \"baseSelector\": \".product\",\n       \"fields\": [\n           {\"name\": \"name\", \"selector\": \".title\", \"type\": \"text\"},\n           {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"}\n       ]\n   }\n   ```\n\n2. **News Article Extraction**\n   ```python\n   # LLM Strategy for article content\n   class Article(BaseModel):\n       title: str\n       content: str\n       author: str\n       date: str\n\n   strategy = LLMExtractionStrategy(\n       provider=\"ollama/llama2\",\n       schema=Article.schema()\n   )\n   ```\n\n3. **Content Analysis**\n   ```python\n   # Cosine Strategy for topic analysis\n   strategy = CosineStrategy(\n       semantic_filter=\"technology trends\",\n       top_k=5\n   )\n   ```",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "implements",
      "relationship_explanation": "The documentation snippet for E-commerce Scraping shows a CSS strategy by defining a 'schema' with a 'baseSelector' and 'fields'. This configuration matches the design of JsonCssExtractionStrategy, which uses CSS selectors to extract information. Although the class name is not explicitly mentioned in the snippet, the schema structure implies its use.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> JsonCssExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain starts from the documentation file 'docs/md_v2/extraction/overview.md', moves to the implicitly referenced JsonCssExtractionStrategy (which implements CSS-based extraction), and further traces to its base class ExtractionStrategy, confirming its role in the extraction process.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class directly implements the CSS-based e-commerce scraping example from the documentation by processing HTML elements according to a schema that defines base selectors and field mappings.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Common Use Cases\n\n1. **E-commerce Scraping**\n   ```python\n   # CSS Strategy for product listings\n   schema = {\n       \"name\": \"Products\",\n       \"baseSelector\": \".product\",\n       \"fields\": [\n           {\"name\": \"name\", \"selector\": \".title\", \"type\": \"text\"},\n           {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"}\n       ]\n   }\n   ```\n\n2. **News Article Extraction**\n   ```python\n   # LLM Strategy for article content\n   class Article(BaseModel):\n       title: str\n       content: str\n       author: str\n       date: str\n\n   strategy = LLMExtractionStrategy(\n       provider=\"ollama/llama2\",\n       schema=Article.schema()\n   )\n   ```\n\n3. **Content Analysis**\n   ```python\n   # Cosine Strategy for topic analysis\n   strategy = CosineStrategy(\n       semantic_filter=\"technology trends\",\n       top_k=5\n   )\n   ```",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "direct instantiation",
      "relationship_explanation": "In the News Article Extraction use case, the snippet directly instantiates LLMExtractionStrategy with parameters like provider and schema (using Article.schema()). This is a clear and explicit reference to the implementation that uses LLM-based extraction.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> LLMExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "Starting from the documentation file 'docs/md_v2/extraction/overview.md', the snippet explicitly creates an instance of LLMExtractionStrategy. Since LLMExtractionStrategy extends ExtractionStrategy, the chain naturally includes its base class to complete the traceability pathway.",
      "ground_truth_relationship": "The LLMExtractionStrategy class demonstrated in the documentation implements schema-based extraction for articles by accepting a provider and schema parameter in its initialization, which directly corresponds to the 'News Article Extraction' use case shown in the documentation example.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Common Use Cases\n\n1. **E-commerce Scraping**\n   ```python\n   # CSS Strategy for product listings\n   schema = {\n       \"name\": \"Products\",\n       \"baseSelector\": \".product\",\n       \"fields\": [\n           {\"name\": \"name\", \"selector\": \".title\", \"type\": \"text\"},\n           {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"}\n       ]\n   }\n   ```\n\n2. **News Article Extraction**\n   ```python\n   # LLM Strategy for article content\n   class Article(BaseModel):\n       title: str\n       content: str\n       author: str\n       date: str\n\n   strategy = LLMExtractionStrategy(\n       provider=\"ollama/llama2\",\n       schema=Article.schema()\n   )\n   ```\n\n3. **Content Analysis**\n   ```python\n   # Cosine Strategy for topic analysis\n   strategy = CosineStrategy(\n       semantic_filter=\"technology trends\",\n       top_k=5\n   )\n   ```",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 7,
      "artifact_title": "CosineStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "direct instantiation",
      "relationship_explanation": "For Content Analysis, the snippet explicitly calls CosineStrategy with parameters such as 'semantic_filter' and 'top_k'. This clear instantiation directly corresponds to the available artifact that implements topic analysis using cosine similarity.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> CosineStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The trace begins at 'docs/md_v2/extraction/overview.md' where CosineStrategy is explicitly instantiated. Recognizing that CosineStrategy inherits from ExtractionStrategy, the pathway extends to include its base class, thereby demonstrating the full hierarchical relationship.",
      "ground_truth_relationship": "The CosineStrategy class implements content analysis functionality by using cosine similarity and semantic filtering to cluster and analyze text content, as shown in the documentation's third example where it filters content based on 'technology trends' and returns top_k results.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> CosineStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Common Use Cases\n\n1. **E-commerce Scraping**\n   ```python\n   # CSS Strategy for product listings\n   schema = {\n       \"name\": \"Products\",\n       \"baseSelector\": \".product\",\n       \"fields\": [\n           {\"name\": \"name\", \"selector\": \".title\", \"type\": \"text\"},\n           {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"}\n       ]\n   }\n   ```\n\n2. **News Article Extraction**\n   ```python\n   # LLM Strategy for article content\n   class Article(BaseModel):\n       title: str\n       content: str\n       author: str\n       date: str\n\n   strategy = LLMExtractionStrategy(\n       provider=\"ollama/llama2\",\n       schema=Article.schema()\n   )\n   ```\n\n3. **Content Analysis**\n   ```python\n   # Cosine Strategy for topic analysis\n   strategy = CosineStrategy(\n       semantic_filter=\"technology trends\",\n       top_k=5\n   )\n   ```",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "ExtractionStrategy",
      "ground_truth_relationship": "The ExtractionStrategy abstract base class serves as the foundation for the three documented use cases (CSS, LLM, and Cosine strategies) by providing a common interface for extracting structured data through its abstract extract() method and parallel processing capabilities in run().",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Getting Started \ud83d\udee0\ufe0f\n\nFirst, let's import the necessary modules and create an instance of `AsyncWebCrawler`. We'll use an async context manager, which handles the setup and teardown of the crawler for us.\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        # We'll add our crawling code here\n        pass\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation and async context management",
      "relationship_explanation": "The documentation snippet explicitly shows the import and usage of AsyncWebCrawler via 'async with AsyncWebCrawler(verbose=True) as crawler:', demonstrating direct instantiation and context management.",
      "predicted_trace_chain": "quickstart.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "Starting from the 'quickstart.md' documentation, the code sample directly references AsyncWebCrawler which is used as an asynchronous context manager to manage setup and teardown.",
      "ground_truth_relationship": "The code implements an AsyncWebCrawler class with async context manager methods (__aenter__ and __aexit__) that directly support the documented usage pattern of initializing and cleaning up the crawler within an async context manager block.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Getting Started \ud83d\udee0\ufe0f\n\nFirst, let's import the necessary modules and create an instance of `AsyncWebCrawler`. We'll use an async context manager, which handles the setup and teardown of the crawler for us.\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        # We'll add our crawling code here\n        pass\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "default dependency implementation",
      "relationship_explanation": "Although AsyncPlaywrightCrawlerStrategy is not mentioned in the text snippet, AsyncWebCrawler internally instantiates it as the default crawling strategy when no crawler_strategy is provided.",
      "predicted_trace_chain": "quickstart.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The documentation\u2019s use of AsyncWebCrawler leads to its default dependency, AsyncPlaywrightCrawlerStrategy, which is responsible for the actual crawling tasks even though it is not explicitly imported in the snippet.",
      "ground_truth_relationship": null,
      "ground_truth_trace_chain": null,
      "traceability_granularity": "Class",
      "confusion_metrics": "False Positive",
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Getting Started \ud83d\udee0\ufe0f\n\nFirst, let's import the necessary modules and create an instance of `AsyncWebCrawler`. We'll use an async context manager, which handles the setup and teardown of the crawler for us.\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        # We'll add our crawling code here\n        pass\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "AsyncCrawlerStrategy is the abstract base class for crawler strategies. AsyncPlaywrightCrawlerStrategy extends it; therefore, it is implicitly connected to the documented usage via the default strategy implementation used by AsyncWebCrawler.",
      "predicted_trace_chain": "quickstart.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "Beginning at the documented AsyncWebCrawler usage, the chain continues with AsyncPlaywrightCrawlerStrategy (the concrete implementation) which in turn extends AsyncCrawlerStrategy, linking the abstract base class to the documented functionality.",
      "ground_truth_relationship": null,
      "ground_truth_trace_chain": null,
      "traceability_granularity": "Class",
      "confusion_metrics": "False Positive",
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Handling Errors\n\nAlways check if the crawl was successful:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nif not result.success:\n    print(f\"Crawl failed: {result.error_message}\")\n    print(f\"Status code: {result.status_code}\")\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "usage",
      "relationship_explanation": "The documentation snippet directly calls the 'arun' method on the crawler object (result = await crawler.arun(url=...)), which initiates the crawl process.",
      "predicted_trace_chain": "simple-crawling.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain starts at the documentation file 'simple-crawling.md' and follows to the 'AsyncWebCrawler.arun()' method that is explicitly invoked in the snippet to perform crawling.",
      "ground_truth_relationship": "The code implements error handling by returning a CrawlResult object with success and error_message fields that can be checked exactly as shown in the documentation example.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Handling Errors\n\nAlways check if the crawl was successful:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nif not result.success:\n    print(f\"Crawl failed: {result.error_message}\")\n    print(f\"Status code: {result.status_code}\")\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 20,
      "artifact_title": "CrawlResult.success",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "After invoking the crawl method, the snippet checks 'result.success' to determine if the crawl was successful. This attribute is part of the CrawlResult object.",
      "predicted_trace_chain": "simple-crawling.md -> AsyncWebCrawler.arun() -> CrawlResult.success",
      "predicted_trace_chain_explanation": "Starting from the documentation file, the chain proceeds to the 'AsyncWebCrawler.arun()' method whose return value is a CrawlResult. The 'success' attribute is then accessed to verify the outcome.",
      "ground_truth_relationship": "The boolean success property in CrawlResult enables error handling by providing a simple way to check if a crawl operation completed successfully, as demonstrated in the documentation's error handling example.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult.success",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Handling Errors\n\nAlways check if the crawl was successful:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nif not result.success:\n    print(f\"Crawl failed: {result.error_message}\")\n    print(f\"Status code: {result.status_code}\")\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 10,
      "artifact_title": "CrawlResult.error_message",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet prints 'result.error_message' when the crawl fails, indicating that the error details are provided by this attribute of the CrawlResult object.",
      "predicted_trace_chain": "simple-crawling.md -> AsyncWebCrawler.arun() -> CrawlResult.error_message",
      "predicted_trace_chain_explanation": "The trace starts from the documentation and goes to the 'AsyncWebCrawler.arun()' method. The returned CrawlResult is then used to access the 'error_message' attribute which conveys error information.",
      "ground_truth_relationship": "The error_message field in CrawlResult stores the failure reason shown in the documentation's error handling example when crawls are unsuccessful.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult.error_message",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Handling Errors\n\nAlways check if the crawl was successful:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nif not result.success:\n    print(f\"Crawl failed: {result.error_message}\")\n    print(f\"Status code: {result.status_code}\")\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 19,
      "artifact_title": "CrawlResult.status_code",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet prints out 'result.status_code' to display the HTTP status code returned by the crawl operation, thereby using this attribute from the CrawlResult.",
      "predicted_trace_chain": "simple-crawling.md -> AsyncWebCrawler.arun() -> CrawlResult.status_code",
      "predicted_trace_chain_explanation": "Following the chain from the documentation file to the crawling method and then to the CrawlResult, the 'status_code' attribute is used to retrieve the HTTP response status of the crawl.",
      "ground_truth_relationship": "The status_code field stores HTTP response codes from crawl attempts, enabling error handling as shown in the documentation where failed crawls can be diagnosed using result.status_code.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult.status_code",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Handling Errors\n\nAlways check if the crawl was successful:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nif not result.success:\n    print(f\"Crawl failed: {result.error_message}\")\n    print(f\"Status code: {result.status_code}\")\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class provides the necessary success, error_message, and status_code fields that enable error handling as demonstrated in the documentation's code example.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Handling Errors\n\nAlways check if the crawl was successful:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nif not result.success:\n    print(f\"Crawl failed: {result.error_message}\")\n    print(f\"Status code: {result.status_code}\")\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class provides the foundational crawl() method that returns an AsyncCrawlResponse, which contains the success, error_message, and status_code properties shown in the error handling documentation.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Handling Errors\n\nAlways check if the crawl was successful:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nif not result.success:\n    print(f\"Crawl failed: {result.error_message}\")\n    print(f\"Status code: {result.status_code}\")\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The code implements error handling through the AsyncCrawlResponse class which returns success status, error messages, and status codes that can be checked exactly as shown in the documentation's example.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Handling Errors\n\nAlways check if the crawl was successful:\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\nif not result.success:\n    print(f\"Crawl failed: {result.error_message}\")\n    print(f\"Status code: {result.status_code}\")\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The documentation demonstrates error handling using the success attribute and error_message fields that are explicitly set in the AsyncWebCrawler's arun() method when exceptions occur during crawling.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Media Processing\n\nCrawl4AI provides comprehensive media extraction and analysis capabilities. It automatically detects and processes various types of media elements while maintaining their context and relevance.\n\n### Image Processing\nThe library handles various image scenarios, including:\n- Regular images\n- Lazy-loaded images\n- Background images\n- Responsive images\n- Image metadata and context\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\nfor image in result.media[\"images\"]:\n    # Each image includes rich metadata\n    print(f\"Source: {image['src']}\")\n    print(f\"Alt text: {image['alt']}\")\n    print(f\"Description: {image['desc']}\")\n    print(f\"Context: {image['context']}\")  # Surrounding text\n    print(f\"Relevance score: {image['score']}\")  # 0-10 score\n```\n\n### Handling Lazy-Loaded Content\nCrawl4aai already handles lazy loading for media elements. You can also customize the wait time for lazy-loaded content:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=\"css:img[data-src]\",  # Wait for lazy images\n    delay_before_return_html=2.0   # Additional wait time\n)\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method usage",
      "relationship_explanation": "The documentation snippet explicitly calls 'crawler.arun(url=\"https://example.com\")'. This directly maps to the AsyncWebCrawler.arun() method which initiates the crawling process and returns a result.",
      "predicted_trace_chain": "docs/md_v2/advanced/content-processing.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The snippet starts at the documentation file and directly invokes the arun() method, establishing it as the entry point for the media processing functionality.",
      "ground_truth_relationship": "The arun() method implements the core crawling functionality described in the documentation, handling both regular and lazy-loaded media content through its customizable parameters like wait_for and delay_before_return_html while supporting caching and screenshot capabilities.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Media Processing\n\nCrawl4AI provides comprehensive media extraction and analysis capabilities. It automatically detects and processes various types of media elements while maintaining their context and relevance.\n\n### Image Processing\nThe library handles various image scenarios, including:\n- Regular images\n- Lazy-loaded images\n- Background images\n- Responsive images\n- Image metadata and context\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\nfor image in result.media[\"images\"]:\n    # Each image includes rich metadata\n    print(f\"Source: {image['src']}\")\n    print(f\"Alt text: {image['alt']}\")\n    print(f\"Description: {image['desc']}\")\n    print(f\"Context: {image['context']}\")  # Surrounding text\n    print(f\"Relevance score: {image['score']}\")  # 0-10 score\n```\n\n### Handling Lazy-Loaded Content\nCrawl4aai already handles lazy loading for media elements. You can also customize the wait time for lazy-loaded content:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=\"css:img[data-src]\",  # Wait for lazy images\n    delay_before_return_html=2.0   # Additional wait time\n)\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 8,
      "artifact_title": "CrawlResult",
      "predicted_relationship": "implicit",
      "relationship_type": "return type",
      "relationship_explanation": "The result from 'crawler.arun()' is a CrawlResult object which encapsulates various crawl outputs including media. The documentation's use of 'result.media' implies that the returned object conforms to the CrawlResult model.",
      "predicted_trace_chain": "docs/md_v2/advanced/content-processing.md -> AsyncWebCrawler.arun() -> CrawlResult",
      "predicted_trace_chain_explanation": "The arun() method returns a CrawlResult instance and the documentation accesses its media attribute, linking the documentation to the CrawlResult data model.",
      "ground_truth_relationship": "The CrawlResult class implements the media processing functionality described in the documentation through its 'media' dictionary field, which stores lists of processed media elements including images with their metadata like source, alt text, description, context, and relevance scores.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Media Processing\n\nCrawl4AI provides comprehensive media extraction and analysis capabilities. It automatically detects and processes various types of media elements while maintaining their context and relevance.\n\n### Image Processing\nThe library handles various image scenarios, including:\n- Regular images\n- Lazy-loaded images\n- Background images\n- Responsive images\n- Image metadata and context\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\nfor image in result.media[\"images\"]:\n    # Each image includes rich metadata\n    print(f\"Source: {image['src']}\")\n    print(f\"Alt text: {image['alt']}\")\n    print(f\"Description: {image['desc']}\")\n    print(f\"Context: {image['context']}\")  # Surrounding text\n    print(f\"Relevance score: {image['score']}\")  # 0-10 score\n```\n\n### Handling Lazy-Loaded Content\nCrawl4aai already handles lazy loading for media elements. You can also customize the wait time for lazy-loaded content:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=\"css:img[data-src]\",  # Wait for lazy images\n    delay_before_return_html=2.0   # Additional wait time\n)\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 16,
      "artifact_title": "CrawlResult.media",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The sample code iterates over 'result.media[\"images\"]', explicitly accessing the media attribute on the CrawlResult object to retrieve image metadata.",
      "predicted_trace_chain": "docs/md_v2/advanced/content-processing.md -> AsyncWebCrawler.arun() -> CrawlResult -> CrawlResult.media",
      "predicted_trace_chain_explanation": "Starting from the arun() method, the returned CrawlResult object is used to access the media attribute, directly fulfilling the media extraction functionality described in the documentation.",
      "ground_truth_relationship": "The CrawlResult.media dictionary property stores media-related data like images and their metadata (source, alt text, description, context, relevance score) extracted during web crawling.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult.media",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Media Processing\n\nCrawl4AI provides comprehensive media extraction and analysis capabilities. It automatically detects and processes various types of media elements while maintaining their context and relevance.\n\n### Image Processing\nThe library handles various image scenarios, including:\n- Regular images\n- Lazy-loaded images\n- Background images\n- Responsive images\n- Image metadata and context\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\nfor image in result.media[\"images\"]:\n    # Each image includes rich metadata\n    print(f\"Source: {image['src']}\")\n    print(f\"Alt text: {image['alt']}\")\n    print(f\"Description: {image['desc']}\")\n    print(f\"Context: {image['context']}\")  # Surrounding text\n    print(f\"Relevance score: {image['score']}\")  # 0-10 score\n```\n\n### Handling Lazy-Loaded Content\nCrawl4aai already handles lazy loading for media elements. You can also customize the wait time for lazy-loaded content:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=\"css:img[data-src]\",  # Wait for lazy images\n    delay_before_return_html=2.0   # Additional wait time\n)\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "implementation detail",
      "relationship_explanation": "The AsyncWebCrawler class uses a crawler strategy which, by default, is an instance of AsyncPlaywrightCrawlerStrategy. This strategy implements the crawl() method handling parameters such as 'wait_for' and 'delay_before_return_html' to manage lazy-loaded content, as described in the documentation.",
      "predicted_trace_chain": "docs/md_v2/advanced/content-processing.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The arun() method delegates crawling to its strategy, and AsyncPlaywrightCrawlerStrategy is responsible for processing options that enable lazy-loaded media handling, thus linking the documentation\u2019s lazy-loading functionality to this implementation.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements lazy-loaded image handling through its smart_wait() method, which detects and waits for lazy-loaded elements using CSS selectors or JavaScript functions as specified in the documentation's wait_for parameter.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Media Processing\n\nCrawl4AI provides comprehensive media extraction and analysis capabilities. It automatically detects and processes various types of media elements while maintaining their context and relevance.\n\n### Image Processing\nThe library handles various image scenarios, including:\n- Regular images\n- Lazy-loaded images\n- Background images\n- Responsive images\n- Image metadata and context\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\nfor image in result.media[\"images\"]:\n    # Each image includes rich metadata\n    print(f\"Source: {image['src']}\")\n    print(f\"Alt text: {image['alt']}\")\n    print(f\"Description: {image['desc']}\")\n    print(f\"Context: {image['context']}\")  # Surrounding text\n    print(f\"Relevance score: {image['score']}\")  # 0-10 score\n```\n\n### Handling Lazy-Loaded Content\nCrawl4aai already handles lazy loading for media elements. You can also customize the wait time for lazy-loaded content:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=\"css:img[data-src]\",  # Wait for lazy images\n    delay_before_return_html=2.0   # Additional wait time\n)\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "AsyncPlaywrightCrawlerStrategy extends AsyncCrawlerStrategy, which defines the abstract interface for crawler strategies. This hierarchical relationship underpins the implementation of crawl functionalities, including media extraction and lazy loading.",
      "predicted_trace_chain": "docs/md_v2/advanced/content-processing.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "By linking the documentation to AsyncWebCrawler.arun() and its underlying strategy, the chain extends to AsyncCrawlerStrategy to represent the base abstraction that enforces the crawl methods used for media processing.",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class provides the core interface for implementing media crawling capabilities described in the documentation, with the crawl() method being responsible for extracting images and handling lazy-loaded content.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Media Processing\n\nCrawl4AI provides comprehensive media extraction and analysis capabilities. It automatically detects and processes various types of media elements while maintaining their context and relevance.\n\n### Image Processing\nThe library handles various image scenarios, including:\n- Regular images\n- Lazy-loaded images\n- Background images\n- Responsive images\n- Image metadata and context\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\nfor image in result.media[\"images\"]:\n    # Each image includes rich metadata\n    print(f\"Source: {image['src']}\")\n    print(f\"Alt text: {image['alt']}\")\n    print(f\"Description: {image['desc']}\")\n    print(f\"Context: {image['context']}\")  # Surrounding text\n    print(f\"Relevance score: {image['score']}\")  # 0-10 score\n```\n\n### Handling Lazy-Loaded Content\nCrawl4aai already handles lazy loading for media elements. You can also customize the wait time for lazy-loaded content:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=\"css:img[data-src]\",  # Wait for lazy images\n    delay_before_return_html=2.0   # Additional wait time\n)\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements media processing through its aprocess_html method, which extracts and processes images with metadata (src, alt, context) using WebScrappingStrategy and stores the results in the media dictionary as documented in the code examples.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine various browser configurations:\n\n```python\nasync def crawl_with_advanced_config(url: str):\n    async with AsyncWebCrawler(\n        # Browser setup\n        browser_type=\"chromium\",\n        headless=True,\n        verbose=True,\n        \n        # Identity\n        user_agent=\"Custom User Agent\",\n        headers={\"Accept-Language\": \"en-US\"},\n        \n        # Proxy setup\n        proxy=\"http://proxy.example.com:8080\"\n    ) as crawler:\n        result = await crawler.arun(\n            url=url,\n            # Content handling\n            process_iframes=True,\n            screenshot=True,\n            \n            # Timing\n            page_timeout=60000,\n            delay_before_return_html=2.0,\n            \n            # Anti-detection\n            magic=True,\n            simulate_user=True,\n            \n            # Dynamic content\n            js_code=[\n                \"window.scrollTo(0, document.body.scrollHeight);\",\n                \"document.querySelector('.load-more')?.click();\"\n            ],\n            wait_for=\"css:.dynamic-content\"\n        )\n        \n        return {\n            \"content\": result.markdown,\n            \"screenshot\": result.screenshot,\n            \"success\": result.success\n        }\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "class instantiation",
      "relationship_explanation": "The code snippet explicitly creates an AsyncWebCrawler instance with advanced configuration parameters (e.g., browser_type, headless, user_agent, headers, and proxy) to set up the crawling environment.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The documentation file directly instantiates the AsyncWebCrawler class, marking the start of the trace chain.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements all the configuration options shown in the documentation example, including browser setup, identity management, proxy configuration, content handling, timing controls, and anti-detection features through its __init__ and arun methods.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine various browser configurations:\n\n```python\nasync def crawl_with_advanced_config(url: str):\n    async with AsyncWebCrawler(\n        # Browser setup\n        browser_type=\"chromium\",\n        headless=True,\n        verbose=True,\n        \n        # Identity\n        user_agent=\"Custom User Agent\",\n        headers={\"Accept-Language\": \"en-US\"},\n        \n        # Proxy setup\n        proxy=\"http://proxy.example.com:8080\"\n    ) as crawler:\n        result = await crawler.arun(\n            url=url,\n            # Content handling\n            process_iframes=True,\n            screenshot=True,\n            \n            # Timing\n            page_timeout=60000,\n            delay_before_return_html=2.0,\n            \n            # Anti-detection\n            magic=True,\n            simulate_user=True,\n            \n            # Dynamic content\n            js_code=[\n                \"window.scrollTo(0, document.body.scrollHeight);\",\n                \"document.querySelector('.load-more')?.click();\"\n            ],\n            wait_for=\"css:.dynamic-content\"\n        )\n        \n        return {\n            \"content\": result.markdown,\n            \"screenshot\": result.screenshot,\n            \"success\": result.success\n        }\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "Within the asynchronous context, the snippet calls the arun() method on the AsyncWebCrawler instance to perform the crawl. This call passes parameters for content handling, timing, anti-detection, and dynamic JavaScript actions.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the documentation file, the chain follows the instantiation of AsyncWebCrawler and then the direct method call arun(), which executes the crawl.",
      "ground_truth_relationship": "The documented example demonstrates how to use the arun() method with various configuration options, while the actual code implementation shows the core logic for processing these configurations through error handling, caching, and content extraction.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine various browser configurations:\n\n```python\nasync def crawl_with_advanced_config(url: str):\n    async with AsyncWebCrawler(\n        # Browser setup\n        browser_type=\"chromium\",\n        headless=True,\n        verbose=True,\n        \n        # Identity\n        user_agent=\"Custom User Agent\",\n        headers={\"Accept-Language\": \"en-US\"},\n        \n        # Proxy setup\n        proxy=\"http://proxy.example.com:8080\"\n    ) as crawler:\n        result = await crawler.arun(\n            url=url,\n            # Content handling\n            process_iframes=True,\n            screenshot=True,\n            \n            # Timing\n            page_timeout=60000,\n            delay_before_return_html=2.0,\n            \n            # Anti-detection\n            magic=True,\n            simulate_user=True,\n            \n            # Dynamic content\n            js_code=[\n                \"window.scrollTo(0, document.body.scrollHeight);\",\n                \"document.querySelector('.load-more')?.click();\"\n            ],\n            wait_for=\"css:.dynamic-content\"\n        )\n        \n        return {\n            \"content\": result.markdown,\n            \"screenshot\": result.screenshot,\n            \"success\": result.success\n        }\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "default composition",
      "relationship_explanation": "AsyncWebCrawler defaults to using AsyncPlaywrightCrawlerStrategy when no custom crawler_strategy is provided. Although not mentioned explicitly in the snippet, it is implicitly engaged to perform the underlying crawl operation.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The documentation\u2019s use of AsyncWebCrawler indirectly causes the internal instantiation of AsyncPlaywrightCrawlerStrategy, establishing this chain.",
      "ground_truth_relationship": "The example in the documentation demonstrates how to use key features implemented in the AsyncPlaywrightCrawlerStrategy class, such as browser configuration, proxy setup, content handling, and anti-detection mechanisms through a comprehensive crawl_with_advanced_config function.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine various browser configurations:\n\n```python\nasync def crawl_with_advanced_config(url: str):\n    async with AsyncWebCrawler(\n        # Browser setup\n        browser_type=\"chromium\",\n        headless=True,\n        verbose=True,\n        \n        # Identity\n        user_agent=\"Custom User Agent\",\n        headers={\"Accept-Language\": \"en-US\"},\n        \n        # Proxy setup\n        proxy=\"http://proxy.example.com:8080\"\n    ) as crawler:\n        result = await crawler.arun(\n            url=url,\n            # Content handling\n            process_iframes=True,\n            screenshot=True,\n            \n            # Timing\n            page_timeout=60000,\n            delay_before_return_html=2.0,\n            \n            # Anti-detection\n            magic=True,\n            simulate_user=True,\n            \n            # Dynamic content\n            js_code=[\n                \"window.scrollTo(0, document.body.scrollHeight);\",\n                \"document.querySelector('.load-more')?.click();\"\n            ],\n            wait_for=\"css:.dynamic-content\"\n        )\n        \n        return {\n            \"content\": result.markdown,\n            \"screenshot\": result.screenshot,\n            \"success\": result.success\n        }\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 15,
      "artifact_title": "CrawlResult.markdown",
      "predicted_relationship": "implicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "After the crawl operation, the returned result\u2019s markdown attribute is accessed to retrieve the processed content. This attribute is part of the CrawlResult object.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler -> AsyncWebCrawler.arun() -> CrawlResult.markdown",
      "predicted_trace_chain_explanation": "The chain begins with the documentation file, proceeds with the instantiation and method call on AsyncWebCrawler, and ends with accessing the markdown attribute from the resulting CrawlResult.",
      "ground_truth_relationship": null,
      "ground_truth_trace_chain": null,
      "traceability_granularity": "Class",
      "confusion_metrics": "False Positive",
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine various browser configurations:\n\n```python\nasync def crawl_with_advanced_config(url: str):\n    async with AsyncWebCrawler(\n        # Browser setup\n        browser_type=\"chromium\",\n        headless=True,\n        verbose=True,\n        \n        # Identity\n        user_agent=\"Custom User Agent\",\n        headers={\"Accept-Language\": \"en-US\"},\n        \n        # Proxy setup\n        proxy=\"http://proxy.example.com:8080\"\n    ) as crawler:\n        result = await crawler.arun(\n            url=url,\n            # Content handling\n            process_iframes=True,\n            screenshot=True,\n            \n            # Timing\n            page_timeout=60000,\n            delay_before_return_html=2.0,\n            \n            # Anti-detection\n            magic=True,\n            simulate_user=True,\n            \n            # Dynamic content\n            js_code=[\n                \"window.scrollTo(0, document.body.scrollHeight);\",\n                \"document.querySelector('.load-more')?.click();\"\n            ],\n            wait_for=\"css:.dynamic-content\"\n        )\n        \n        return {\n            \"content\": result.markdown,\n            \"screenshot\": result.screenshot,\n            \"success\": result.success\n        }\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 18,
      "artifact_title": "CrawlResult.screenshot",
      "predicted_relationship": "implicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet accesses result.screenshot to obtain a base64 encoded screenshot of the crawled page. This attribute is defined in the CrawlResult object.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler -> AsyncWebCrawler.arun() -> CrawlResult.screenshot",
      "predicted_trace_chain_explanation": "Starting from the documentation file, the process flows through the AsyncWebCrawler instantiation and its arun() method to finally access the screenshot attribute.",
      "ground_truth_relationship": "The CrawlResult.screenshot property stores the base64-encoded screenshot data that is requested through the screenshot=True parameter in the crawl_with_advanced_config example function.",
      "ground_truth_trace_chain": "browser-config.md -> CrawlResult.screenshot",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine various browser configurations:\n\n```python\nasync def crawl_with_advanced_config(url: str):\n    async with AsyncWebCrawler(\n        # Browser setup\n        browser_type=\"chromium\",\n        headless=True,\n        verbose=True,\n        \n        # Identity\n        user_agent=\"Custom User Agent\",\n        headers={\"Accept-Language\": \"en-US\"},\n        \n        # Proxy setup\n        proxy=\"http://proxy.example.com:8080\"\n    ) as crawler:\n        result = await crawler.arun(\n            url=url,\n            # Content handling\n            process_iframes=True,\n            screenshot=True,\n            \n            # Timing\n            page_timeout=60000,\n            delay_before_return_html=2.0,\n            \n            # Anti-detection\n            magic=True,\n            simulate_user=True,\n            \n            # Dynamic content\n            js_code=[\n                \"window.scrollTo(0, document.body.scrollHeight);\",\n                \"document.querySelector('.load-more')?.click();\"\n            ],\n            wait_for=\"css:.dynamic-content\"\n        )\n        \n        return {\n            \"content\": result.markdown,\n            \"screenshot\": result.screenshot,\n            \"success\": result.success\n        }\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 20,
      "artifact_title": "CrawlResult.success",
      "predicted_relationship": "implicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The example returns result.success to indicate if the crawling process completed successfully. This boolean attribute is part of the CrawlResult object interface.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler -> AsyncWebCrawler.arun() -> CrawlResult.success",
      "predicted_trace_chain_explanation": "The trace originates with the documentation file and follows through the use of AsyncWebCrawler and its arun() method to the access of the success attribute in the CrawlResult.",
      "ground_truth_relationship": "The success boolean field in CrawlResult is returned as part of the final dictionary in the comprehensive example to indicate whether the crawling operation completed successfully.",
      "ground_truth_trace_chain": "browser-config.md -> CrawlResult.success",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine various browser configurations:\n\n```python\nasync def crawl_with_advanced_config(url: str):\n    async with AsyncWebCrawler(\n        # Browser setup\n        browser_type=\"chromium\",\n        headless=True,\n        verbose=True,\n        \n        # Identity\n        user_agent=\"Custom User Agent\",\n        headers={\"Accept-Language\": \"en-US\"},\n        \n        # Proxy setup\n        proxy=\"http://proxy.example.com:8080\"\n    ) as crawler:\n        result = await crawler.arun(\n            url=url,\n            # Content handling\n            process_iframes=True,\n            screenshot=True,\n            \n            # Timing\n            page_timeout=60000,\n            delay_before_return_html=2.0,\n            \n            # Anti-detection\n            magic=True,\n            simulate_user=True,\n            \n            # Dynamic content\n            js_code=[\n                \"window.scrollTo(0, document.body.scrollHeight);\",\n                \"document.querySelector('.load-more')?.click();\"\n            ],\n            wait_for=\"css:.dynamic-content\"\n        )\n        \n        return {\n            \"content\": result.markdown,\n            \"screenshot\": result.screenshot,\n            \"success\": result.success\n        }\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the structured response object that captures all possible outputs from the crawl_with_advanced_config function, including the markdown, screenshot, and success fields shown in the example's return statement.",
      "ground_truth_trace_chain": "browser-config.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Comprehensive Example\n\nHere's how to combine various browser configurations:\n\n```python\nasync def crawl_with_advanced_config(url: str):\n    async with AsyncWebCrawler(\n        # Browser setup\n        browser_type=\"chromium\",\n        headless=True,\n        verbose=True,\n        \n        # Identity\n        user_agent=\"Custom User Agent\",\n        headers={\"Accept-Language\": \"en-US\"},\n        \n        # Proxy setup\n        proxy=\"http://proxy.example.com:8080\"\n    ) as crawler:\n        result = await crawler.arun(\n            url=url,\n            # Content handling\n            process_iframes=True,\n            screenshot=True,\n            \n            # Timing\n            page_timeout=60000,\n            delay_before_return_html=2.0,\n            \n            # Anti-detection\n            magic=True,\n            simulate_user=True,\n            \n            # Dynamic content\n            js_code=[\n                \"window.scrollTo(0, document.body.scrollHeight);\",\n                \"document.querySelector('.load-more')?.click();\"\n            ],\n            wait_for=\"css:.dynamic-content\"\n        )\n        \n        return {\n            \"content\": result.markdown,\n            \"screenshot\": result.screenshot,\n            \"success\": result.success\n        }\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the core interface methods that enable the comprehensive browser configurations shown in the documentation example, including crawling, screenshot capture, and user agent management.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Handling Dynamic Content\n\nConfigure browser to handle dynamic content:\n\n```python\n# Wait for dynamic content\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=\"js:() => document.querySelector('.content').children.length > 10\",\n    process_iframes=True     # Process iframe content\n)\n\n# Handle lazy-loaded images\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\",\n    delay_before_return_html=2.0  # Wait for images to load\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The documentation snippet directly calls the 'arun' method on the crawler (as seen in 'result = await crawler.arun(...)'). This shows that AsyncWebCrawler.arun() is explicitly used to initiate crawling of dynamic content with parameters such as 'wait_for', 'js_code', 'process_iframes', and 'delay_before_return_html'.",
      "predicted_trace_chain": "browser-config.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The snippet, extracted from 'docs/md_v2/basic/browser-config.md', explicitly demonstrates calling 'arun', which belongs to the AsyncWebCrawler class, making it the primary entry point in the chain.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method implements dynamic content handling by accepting custom JavaScript code and wait conditions through **kwargs, which directly supports the documented features like wait_for conditions and js_code execution for lazy-loading content.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Handling Dynamic Content\n\nConfigure browser to handle dynamic content:\n\n```python\n# Wait for dynamic content\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=\"js:() => document.querySelector('.content').children.length > 10\",\n    process_iframes=True     # Process iframe content\n)\n\n# Handle lazy-loaded images\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\",\n    delay_before_return_html=2.0  # Wait for images to load\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "underlying implementation",
      "relationship_explanation": "Although not directly mentioned in the documentation snippet, the dynamic content handling parameters ('wait_for', 'process_iframes', 'js_code', 'delay_before_return_html') are processed inside the crawl method of AsyncPlaywrightCrawlerStrategy. This strategy is used by AsyncWebCrawler and therefore implicitly supports the features demonstrated.",
      "predicted_trace_chain": "browser-config.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "Starting from the document 'browser-config.md', the call to AsyncWebCrawler.arun() eventually delegates to its default crawling strategy, AsyncPlaywrightCrawlerStrategy, which implements the dynamic content handling behavior, thereby completing the trace chain.",
      "ground_truth_relationship": "The code implements dynamic content handling through the smart_wait and crawl methods that support JavaScript execution, iframe processing, and configurable delays as documented in the example configuration snippets.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Handling Dynamic Content\n\nConfigure browser to handle dynamic content:\n\n```python\n# Wait for dynamic content\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=\"js:() => document.querySelector('.content').children.length > 10\",\n    process_iframes=True     # Process iframe content\n)\n\n# Handle lazy-loaded images\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\",\n    delay_before_return_html=2.0  # Wait for images to load\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class captures and stores the results of dynamic content crawling operations, including the raw HTML, processed content, and metadata generated from the browser interactions described in the documentation.",
      "ground_truth_trace_chain": "browser-config.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Handling Dynamic Content\n\nConfigure browser to handle dynamic content:\n\n```python\n# Wait for dynamic content\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=\"js:() => document.querySelector('.content').children.length > 10\",\n    process_iframes=True     # Process iframe content\n)\n\n# Handle lazy-loaded images\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\",\n    delay_before_return_html=2.0  # Wait for images to load\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class provides the foundational methods needed to implement the dynamic content handling capabilities described in the documentation, including crawl() and set_hook() methods that enable JavaScript execution and custom wait conditions.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Handling Dynamic Content\n\nConfigure browser to handle dynamic content:\n\n```python\n# Wait for dynamic content\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=\"js:() => document.querySelector('.content').children.length > 10\",\n    process_iframes=True     # Process iframe content\n)\n\n# Handle lazy-loaded images\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    js_code=\"window.scrollTo(0, document.body.scrollHeight);\",\n    delay_before_return_html=2.0  # Wait for images to load\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements dynamic content handling through its arun method, which accepts parameters like 'wait_for', 'js_code', and 'delay_before_return_html' to control browser behavior for dynamic content processing and iframe handling as shown in the documentation examples.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Basic Session Usage\n\nUse `session_id` to maintain state between requests:\n\n```python\nasync with AsyncWebCrawler() as crawler:\n    session_id = \"my_session\"\n    \n    # First request\n    result1 = await crawler.arun(\n        url=\"https://example.com/page1\",\n        session_id=session_id\n    )\n    \n    # Subsequent request using same session\n    result2 = await crawler.arun(\n        url=\"https://example.com/page2\",\n        session_id=session_id\n    )\n    \n    # Clean up when done\n    await crawler.crawler_strategy.kill_session(session_id)\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "Instantiation / Session Management",
      "relationship_explanation": "The documentation snippet shows the use of 'async with AsyncWebCrawler() as crawler:' which explicitly instantiates the AsyncWebCrawler class to maintain state between requests using a session_id.",
      "predicted_trace_chain": "docs/md_v2/advanced/session-management.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain begins at the session-management documentation where AsyncWebCrawler is directly instantiated to handle session-based crawling.",
      "ground_truth_relationship": "The AsyncWebCrawler code implements session management through the session_id parameter in the arun method, which gets stored in the CrawlResult object and can be passed between sequential requests as demonstrated in the documentation example.",
      "ground_truth_trace_chain": "session-management.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Basic Session Usage\n\nUse `session_id` to maintain state between requests:\n\n```python\nasync with AsyncWebCrawler() as crawler:\n    session_id = \"my_session\"\n    \n    # First request\n    result1 = await crawler.arun(\n        url=\"https://example.com/page1\",\n        session_id=session_id\n    )\n    \n    # Subsequent request using same session\n    result2 = await crawler.arun(\n        url=\"https://example.com/page2\",\n        session_id=session_id\n    )\n    \n    # Clean up when done\n    await crawler.crawler_strategy.kill_session(session_id)\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "Method Invocation",
      "relationship_explanation": "The code snippet calls the arun() method on the AsyncWebCrawler instance with a session_id parameter. This shows that the method is used to perform requests while maintaining session state.",
      "predicted_trace_chain": "docs/md_v2/advanced/session-management.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the documentation, the chain shows that after instantiating AsyncWebCrawler, its arun() method is invoked to execute the crawl request as part of session management.",
      "ground_truth_relationship": "The code implements session management by accepting a session_id parameter in the arun() method's kwargs and assigning it to the crawl_result.session_id field, enabling state persistence across multiple requests as demonstrated in the documentation.",
      "ground_truth_trace_chain": "session-management.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Basic Session Usage\n\nUse `session_id` to maintain state between requests:\n\n```python\nasync with AsyncWebCrawler() as crawler:\n    session_id = \"my_session\"\n    \n    # First request\n    result1 = await crawler.arun(\n        url=\"https://example.com/page1\",\n        session_id=session_id\n    )\n    \n    # Subsequent request using same session\n    result2 = await crawler.arun(\n        url=\"https://example.com/page2\",\n        session_id=session_id\n    )\n    \n    # Clean up when done\n    await crawler.crawler_strategy.kill_session(session_id)\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_id": 2,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_relationship": "explicit",
      "relationship_type": "Method Invocation for Session Cleanup",
      "relationship_explanation": "The documentation demonstrates cleaning up the session by calling kill_session() on the crawler's strategy. This call directly maps to the kill_session() method in the AsyncPlaywrightCrawlerStrategy class.",
      "predicted_trace_chain": "docs/md_v2/advanced/session-management.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_trace_chain_explanation": "The chain illustrates that the session management process involves the AsyncWebCrawler (which contains the crawler_strategy) and culminates in calling the kill_session() method from AsyncPlaywrightCrawlerStrategy to properly terminate the session.",
      "ground_truth_relationship": "The kill_session method implements the cleanup functionality shown in the documentation by closing both the browser page and context objects, then removing them from the session tracking dictionary when a session is no longer needed.",
      "ground_truth_trace_chain": "session-management.md -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Basic Session Usage\n\nUse `session_id` to maintain state between requests:\n\n```python\nasync with AsyncWebCrawler() as crawler:\n    session_id = \"my_session\"\n    \n    # First request\n    result1 = await crawler.arun(\n        url=\"https://example.com/page1\",\n        session_id=session_id\n    )\n    \n    # Subsequent request using same session\n    result2 = await crawler.arun(\n        url=\"https://example.com/page2\",\n        session_id=session_id\n    )\n    \n    # Clean up when done\n    await crawler.crawler_strategy.kill_session(session_id)\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class implements session tracking through its session_id field, which aligns with the documented session-based crawling functionality shown in the usage example.",
      "ground_truth_trace_chain": "session-management.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Basic Session Usage\n\nUse `session_id` to maintain state between requests:\n\n```python\nasync with AsyncWebCrawler() as crawler:\n    session_id = \"my_session\"\n    \n    # First request\n    result1 = await crawler.arun(\n        url=\"https://example.com/page1\",\n        session_id=session_id\n    )\n    \n    # Subsequent request using same session\n    result2 = await crawler.arun(\n        url=\"https://example.com/page2\",\n        session_id=session_id\n    )\n    \n    # Clean up when done\n    await crawler.crawler_strategy.kill_session(session_id)\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The code implements session management through the sessions dictionary in AsyncPlaywrightCrawlerStrategy, which stores browser contexts and pages mapped to session_ids as demonstrated in the documentation's session usage example.",
      "ground_truth_trace_chain": "session-management.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Basic Session Usage\n\nUse `session_id` to maintain state between requests:\n\n```python\nasync with AsyncWebCrawler() as crawler:\n    session_id = \"my_session\"\n    \n    # First request\n    result1 = await crawler.arun(\n        url=\"https://example.com/page1\",\n        session_id=session_id\n    )\n    \n    # Subsequent request using same session\n    result2 = await crawler.arun(\n        url=\"https://example.com/page2\",\n        session_id=session_id\n    )\n    \n    # Clean up when done\n    await crawler.crawler_strategy.kill_session(session_id)\n```",
      "document_location": "docs/md_v2/advanced/session-management.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the core methods that enable session-based crawling functionality shown in the documentation, including the crawl method that processes individual session-based requests.",
      "ground_truth_trace_chain": "session-management.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Handling Overlays and Fitting Content Remove overlay elements and fit content appropriately: ```python async with AsyncWebCrawler(headless=False) as crawler: result = await crawler.arun( url=\"your-url-here\", bypass_cache=True, word_count_threshold=10, remove_overlay_elements=True, screenshot=True ) ```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation/usage",
      "relationship_explanation": "The documentation snippet explicitly shows creating an AsyncWebCrawler instance via 'async with AsyncWebCrawler(headless=False) as crawler:'. This indicates direct use of the AsyncWebCrawler class as the primary interface for crawling.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain starts with the documentation file and directly references AsyncWebCrawler, as instantiated in the provided code snippet.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements overlay removal through its arun() method which accepts a remove_overlay_elements parameter that gets passed to the underlying crawler strategy for handling webpage overlays during content extraction.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Handling Overlays and Fitting Content Remove overlay elements and fit content appropriately: ```python async with AsyncWebCrawler(headless=False) as crawler: result = await crawler.arun( url=\"your-url-here\", bypass_cache=True, word_count_threshold=10, remove_overlay_elements=True, screenshot=True ) ```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method call",
      "relationship_explanation": "The code snippet directly calls the 'arun' method on the AsyncWebCrawler instance (i.e., 'result = await crawler.arun(...)'). This demonstrates the use of the crawling method for retrieving and processing content.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the documentation file, the chain follows from instantiating AsyncWebCrawler to invoking its 'arun()' method, showing its explicit usage in the example.",
      "ground_truth_relationship": "The code implements the documented overlay removal functionality through the arun() method which accepts remove_overlay_elements as a parameter and processes it along with other crawling configurations like word_count_threshold and screenshot options.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Handling Overlays and Fitting Content Remove overlay elements and fit content appropriately: ```python async with AsyncWebCrawler(headless=False) as crawler: result = await crawler.arun( url=\"your-url-here\", bypass_cache=True, word_count_threshold=10, remove_overlay_elements=True, screenshot=True ) ```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "implementation dependency",
      "relationship_explanation": "Although not directly mentioned in the snippet, AsyncWebCrawler by default instantiates AsyncPlaywrightCrawlerStrategy. This class implements key functionalities such as removing overlay elements (via its 'remove_overlay_elements' method) and taking screenshots (via 'take_screenshot'), which are triggered by parameters like 'remove_overlay_elements=True' and 'screenshot=True'.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain illustrates that while the documentation snippet only shows high\u2010level usage of AsyncWebCrawler and its 'arun()' method, the underlying behavior for handling overlays and fitting content is provided by AsyncPlaywrightCrawlerStrategy, used implicitly by AsyncWebCrawler.",
      "ground_truth_relationship": "The code implements overlay removal in the remove_overlay_elements method using JavaScript to detect and remove elements with high z-index, fixed positions, and common overlay selectors like cookie banners, popups, and modals, matching the documented functionality for handling overlays.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Handling Overlays and Fitting Content Remove overlay elements and fit content appropriately: ```python async with AsyncWebCrawler(headless=False) as crawler: result = await crawler.arun( url=\"your-url-here\", bypass_cache=True, word_count_threshold=10, remove_overlay_elements=True, screenshot=True ) ```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the outcomes of overlay removal and content fitting operations through its fit_html, fit_markdown, and cleaned_html fields that correspond to the documented overlay handling functionality.",
      "ground_truth_trace_chain": "quickstart.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Handling Overlays and Fitting Content Remove overlay elements and fit content appropriately: ```python async with AsyncWebCrawler(headless=False) as crawler: result = await crawler.arun( url=\"your-url-here\", bypass_cache=True, word_count_threshold=10, remove_overlay_elements=True, screenshot=True ) ```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface that enables overlay removal and content fitting through its crawl method, which the documentation demonstrates being used via the AsyncWebCrawler implementation.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Usage: Combining with JavaScript Execution\n\nFor pages that load data dynamically, you can combine the `JsonCssExtractionStrategy` with JavaScript execution:\n\n```python\nasync def extract_dynamic_structured_data():\n    schema = {\n        \"name\": \"Dynamic Crypto Prices\",\n        \"baseSelector\": \".crypto-row\",\n        \"fields\": [\n            {\"name\": \"name\", \"selector\": \".crypto-name\", \"type\": \"text\"},\n            {\"name\": \"price\", \"selector\": \".crypto-price\", \"type\": \"text\"},\n        ]\n    }\n\n    js_code = \"\"\"\n    window.scrollTo(0, document.body.scrollHeight);\n    await new Promise(resolve => setTimeout(resolve, 2000));  // Wait for 2 seconds\n    \"\"\"\n\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com/crypto-prices\",\n            extraction_strategy=extraction_strategy,\n            js_code=js_code,\n            wait_for=\".crypto-row:nth-child(20)\",  # Wait for 20 rows to load\n            bypass_cache=True,\n        )\n\n        crypto_data = json.loads(result.extracted_content)\n        print(f\"Extracted {len(crypto_data)} cryptocurrency entries\")\n\nasyncio.run(extract_dynamic_structured_data())\n```\n\nThis advanced example demonstrates how to:\n1. Execute JavaScript to trigger dynamic content loading.\n2. Wait for a specific condition (20 rows loaded) before extraction.\n3. Extract data from the dynamically loaded content.\n\nBy mastering the `JsonCssExtractionStrategy`, you can efficiently extract structured data from a wide variety of web pages, making it a valuable tool in your web scraping toolkit.\n\nFor more details on schema definitions and advanced extraction strategies, check out the[Advanced JsonCssExtraction](./css-advanced.md).",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation",
      "relationship_explanation": "The documentation snippet explicitly instantiates a JsonCssExtractionStrategy with a provided schema and verbose=True flag. This clearly shows its intended use for extracting structured data from dynamic pages using CSS selectors.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The document 'css.md' directly references the JsonCssExtractionStrategy, establishing it as the extraction mechanism for dynamic content.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class enables structured data extraction from dynamic web pages by processing a schema that defines CSS selectors for base elements and their fields, which directly supports the documented advanced usage pattern of combining with JavaScript execution for dynamic content scraping.",
      "ground_truth_trace_chain": "css.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Usage: Combining with JavaScript Execution\n\nFor pages that load data dynamically, you can combine the `JsonCssExtractionStrategy` with JavaScript execution:\n\n```python\nasync def extract_dynamic_structured_data():\n    schema = {\n        \"name\": \"Dynamic Crypto Prices\",\n        \"baseSelector\": \".crypto-row\",\n        \"fields\": [\n            {\"name\": \"name\", \"selector\": \".crypto-name\", \"type\": \"text\"},\n            {\"name\": \"price\", \"selector\": \".crypto-price\", \"type\": \"text\"},\n        ]\n    }\n\n    js_code = \"\"\"\n    window.scrollTo(0, document.body.scrollHeight);\n    await new Promise(resolve => setTimeout(resolve, 2000));  // Wait for 2 seconds\n    \"\"\"\n\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com/crypto-prices\",\n            extraction_strategy=extraction_strategy,\n            js_code=js_code,\n            wait_for=\".crypto-row:nth-child(20)\",  # Wait for 20 rows to load\n            bypass_cache=True,\n        )\n\n        crypto_data = json.loads(result.extracted_content)\n        print(f\"Extracted {len(crypto_data)} cryptocurrency entries\")\n\nasyncio.run(extract_dynamic_structured_data())\n```\n\nThis advanced example demonstrates how to:\n1. Execute JavaScript to trigger dynamic content loading.\n2. Wait for a specific condition (20 rows loaded) before extraction.\n3. Extract data from the dynamically loaded content.\n\nBy mastering the `JsonCssExtractionStrategy`, you can efficiently extract structured data from a wide variety of web pages, making it a valuable tool in your web scraping toolkit.\n\nFor more details on schema definitions and advanced extraction strategies, check out the[Advanced JsonCssExtraction](./css-advanced.md).",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation/usage",
      "relationship_explanation": "The snippet uses an async context manager to create an instance of AsyncWebCrawler (via 'async with AsyncWebCrawler(verbose=True) as crawler:'), which sets up the crawling environment for subsequent operations.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "Starting with the documentation in 'css.md', the creation of an AsyncWebCrawler instance is the necessary step to execute the crawling process described.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the dynamic data extraction functionality described in the documentation through its arun method, which supports JavaScript execution (js_code), waiting conditions (wait_for), and custom extraction strategies (JsonCssExtractionStrategy).",
      "ground_truth_trace_chain": "css.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Usage: Combining with JavaScript Execution\n\nFor pages that load data dynamically, you can combine the `JsonCssExtractionStrategy` with JavaScript execution:\n\n```python\nasync def extract_dynamic_structured_data():\n    schema = {\n        \"name\": \"Dynamic Crypto Prices\",\n        \"baseSelector\": \".crypto-row\",\n        \"fields\": [\n            {\"name\": \"name\", \"selector\": \".crypto-name\", \"type\": \"text\"},\n            {\"name\": \"price\", \"selector\": \".crypto-price\", \"type\": \"text\"},\n        ]\n    }\n\n    js_code = \"\"\"\n    window.scrollTo(0, document.body.scrollHeight);\n    await new Promise(resolve => setTimeout(resolve, 2000));  // Wait for 2 seconds\n    \"\"\"\n\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com/crypto-prices\",\n            extraction_strategy=extraction_strategy,\n            js_code=js_code,\n            wait_for=\".crypto-row:nth-child(20)\",  # Wait for 20 rows to load\n            bypass_cache=True,\n        )\n\n        crypto_data = json.loads(result.extracted_content)\n        print(f\"Extracted {len(crypto_data)} cryptocurrency entries\")\n\nasyncio.run(extract_dynamic_structured_data())\n```\n\nThis advanced example demonstrates how to:\n1. Execute JavaScript to trigger dynamic content loading.\n2. Wait for a specific condition (20 rows loaded) before extraction.\n3. Extract data from the dynamically loaded content.\n\nBy mastering the `JsonCssExtractionStrategy`, you can efficiently extract structured data from a wide variety of web pages, making it a valuable tool in your web scraping toolkit.\n\nFor more details on schema definitions and advanced extraction strategies, check out the[Advanced JsonCssExtraction](./css-advanced.md).",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "Within the code snippet, the arun() method of AsyncWebCrawler is invoked with parameters including URL, extraction_strategy, js_code, wait_for, and bypass_cache. This call initiates the actual crawl and extraction process.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain demonstrates that from the document 'css.md', an AsyncWebCrawler instance is created which then invokes its arun() method to perform the crawl as documented.",
      "ground_truth_relationship": "The arun() method implements support for dynamic content extraction by accepting parameters for js_code execution, extraction_strategy, and screenshot capabilities as shown in the documentation's advanced usage example.",
      "ground_truth_trace_chain": "css.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Usage: Combining with JavaScript Execution\n\nFor pages that load data dynamically, you can combine the `JsonCssExtractionStrategy` with JavaScript execution:\n\n```python\nasync def extract_dynamic_structured_data():\n    schema = {\n        \"name\": \"Dynamic Crypto Prices\",\n        \"baseSelector\": \".crypto-row\",\n        \"fields\": [\n            {\"name\": \"name\", \"selector\": \".crypto-name\", \"type\": \"text\"},\n            {\"name\": \"price\", \"selector\": \".crypto-price\", \"type\": \"text\"},\n        ]\n    }\n\n    js_code = \"\"\"\n    window.scrollTo(0, document.body.scrollHeight);\n    await new Promise(resolve => setTimeout(resolve, 2000));  // Wait for 2 seconds\n    \"\"\"\n\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com/crypto-prices\",\n            extraction_strategy=extraction_strategy,\n            js_code=js_code,\n            wait_for=\".crypto-row:nth-child(20)\",  # Wait for 20 rows to load\n            bypass_cache=True,\n        )\n\n        crypto_data = json.loads(result.extracted_content)\n        print(f\"Extracted {len(crypto_data)} cryptocurrency entries\")\n\nasyncio.run(extract_dynamic_structured_data())\n```\n\nThis advanced example demonstrates how to:\n1. Execute JavaScript to trigger dynamic content loading.\n2. Wait for a specific condition (20 rows loaded) before extraction.\n3. Extract data from the dynamically loaded content.\n\nBy mastering the `JsonCssExtractionStrategy`, you can efficiently extract structured data from a wide variety of web pages, making it a valuable tool in your web scraping toolkit.\n\nFor more details on schema definitions and advanced extraction strategies, check out the[Advanced JsonCssExtraction](./css-advanced.md).",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 11,
      "artifact_title": "CrawlResult.extracted_content",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute usage",
      "relationship_explanation": "After crawling, the code accesses result.extracted_content to retrieve the extracted data (which is then parsed using json.loads). This attribute is a public part of the CrawlResult interface.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> AsyncWebCrawler.arun() -> CrawlResult.extracted_content",
      "predicted_trace_chain_explanation": "After the crawl execution via AsyncWebCrawler.arun(), the resulting CrawlResult object provides the 'extracted_content' attribute, linking the execution to the final data extraction output.",
      "ground_truth_relationship": "The extracted_content attribute stores the dynamic crypto pricing data after it's scraped using JsonCssExtractionStrategy and processed through JavaScript execution.",
      "ground_truth_trace_chain": "css.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Usage: Combining with JavaScript Execution\n\nFor pages that load data dynamically, you can combine the `JsonCssExtractionStrategy` with JavaScript execution:\n\n```python\nasync def extract_dynamic_structured_data():\n    schema = {\n        \"name\": \"Dynamic Crypto Prices\",\n        \"baseSelector\": \".crypto-row\",\n        \"fields\": [\n            {\"name\": \"name\", \"selector\": \".crypto-name\", \"type\": \"text\"},\n            {\"name\": \"price\", \"selector\": \".crypto-price\", \"type\": \"text\"},\n        ]\n    }\n\n    js_code = \"\"\"\n    window.scrollTo(0, document.body.scrollHeight);\n    await new Promise(resolve => setTimeout(resolve, 2000));  // Wait for 2 seconds\n    \"\"\"\n\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com/crypto-prices\",\n            extraction_strategy=extraction_strategy,\n            js_code=js_code,\n            wait_for=\".crypto-row:nth-child(20)\",  # Wait for 20 rows to load\n            bypass_cache=True,\n        )\n\n        crypto_data = json.loads(result.extracted_content)\n        print(f\"Extracted {len(crypto_data)} cryptocurrency entries\")\n\nasyncio.run(extract_dynamic_structured_data())\n```\n\nThis advanced example demonstrates how to:\n1. Execute JavaScript to trigger dynamic content loading.\n2. Wait for a specific condition (20 rows loaded) before extraction.\n3. Extract data from the dynamically loaded content.\n\nBy mastering the `JsonCssExtractionStrategy`, you can efficiently extract structured data from a wide variety of web pages, making it a valuable tool in your web scraping toolkit.\n\nFor more details on schema definitions and advanced extraction strategies, check out the[Advanced JsonCssExtraction](./css-advanced.md).",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "JsonCssExtractionStrategy inherits from ExtractionStrategy. Although ExtractionStrategy is not mentioned directly in the snippet, its role is implicit since JsonCssExtractionStrategy implements its extraction interface.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> JsonCssExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain clarifies that the extraction operation is built upon the abstraction defined by ExtractionStrategy, which underpins the concrete implementation found in JsonCssExtractionStrategy.",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the foundational architecture for implementing specialized extraction strategies like JsonCssExtractionStrategy, which is demonstrated in the documentation example for extracting dynamic cryptocurrency data.",
      "ground_truth_trace_chain": "css.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Usage: Combining with JavaScript Execution\n\nFor pages that load data dynamically, you can combine the `JsonCssExtractionStrategy` with JavaScript execution:\n\n```python\nasync def extract_dynamic_structured_data():\n    schema = {\n        \"name\": \"Dynamic Crypto Prices\",\n        \"baseSelector\": \".crypto-row\",\n        \"fields\": [\n            {\"name\": \"name\", \"selector\": \".crypto-name\", \"type\": \"text\"},\n            {\"name\": \"price\", \"selector\": \".crypto-price\", \"type\": \"text\"},\n        ]\n    }\n\n    js_code = \"\"\"\n    window.scrollTo(0, document.body.scrollHeight);\n    await new Promise(resolve => setTimeout(resolve, 2000));  // Wait for 2 seconds\n    \"\"\"\n\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com/crypto-prices\",\n            extraction_strategy=extraction_strategy,\n            js_code=js_code,\n            wait_for=\".crypto-row:nth-child(20)\",  # Wait for 20 rows to load\n            bypass_cache=True,\n        )\n\n        crypto_data = json.loads(result.extracted_content)\n        print(f\"Extracted {len(crypto_data)} cryptocurrency entries\")\n\nasyncio.run(extract_dynamic_structured_data())\n```\n\nThis advanced example demonstrates how to:\n1. Execute JavaScript to trigger dynamic content loading.\n2. Wait for a specific condition (20 rows loaded) before extraction.\n3. Extract data from the dynamically loaded content.\n\nBy mastering the `JsonCssExtractionStrategy`, you can efficiently extract structured data from a wide variety of web pages, making it a valuable tool in your web scraping toolkit.\n\nFor more details on schema definitions and advanced extraction strategies, check out the[Advanced JsonCssExtraction](./css-advanced.md).",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the extracted_content field which holds the structured data parsed by JsonCssExtractionStrategy as shown in the documentation example where crypto price data is extracted and stored.",
      "ground_truth_trace_chain": "css.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Usage: Combining with JavaScript Execution\n\nFor pages that load data dynamically, you can combine the `JsonCssExtractionStrategy` with JavaScript execution:\n\n```python\nasync def extract_dynamic_structured_data():\n    schema = {\n        \"name\": \"Dynamic Crypto Prices\",\n        \"baseSelector\": \".crypto-row\",\n        \"fields\": [\n            {\"name\": \"name\", \"selector\": \".crypto-name\", \"type\": \"text\"},\n            {\"name\": \"price\", \"selector\": \".crypto-price\", \"type\": \"text\"},\n        ]\n    }\n\n    js_code = \"\"\"\n    window.scrollTo(0, document.body.scrollHeight);\n    await new Promise(resolve => setTimeout(resolve, 2000));  // Wait for 2 seconds\n    \"\"\"\n\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com/crypto-prices\",\n            extraction_strategy=extraction_strategy,\n            js_code=js_code,\n            wait_for=\".crypto-row:nth-child(20)\",  # Wait for 20 rows to load\n            bypass_cache=True,\n        )\n\n        crypto_data = json.loads(result.extracted_content)\n        print(f\"Extracted {len(crypto_data)} cryptocurrency entries\")\n\nasyncio.run(extract_dynamic_structured_data())\n```\n\nThis advanced example demonstrates how to:\n1. Execute JavaScript to trigger dynamic content loading.\n2. Wait for a specific condition (20 rows loaded) before extraction.\n3. Extract data from the dynamically loaded content.\n\nBy mastering the `JsonCssExtractionStrategy`, you can efficiently extract structured data from a wide variety of web pages, making it a valuable tool in your web scraping toolkit.\n\nFor more details on schema definitions and advanced extraction strategies, check out the[Advanced JsonCssExtraction](./css-advanced.md).",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements dynamic content loading through its crawl method by executing JavaScript code and waiting for specified selectors as documented in the example's advanced usage section for combining with JavaScript execution.",
      "ground_truth_trace_chain": "css.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Usage: Combining with JavaScript Execution\n\nFor pages that load data dynamically, you can combine the `JsonCssExtractionStrategy` with JavaScript execution:\n\n```python\nasync def extract_dynamic_structured_data():\n    schema = {\n        \"name\": \"Dynamic Crypto Prices\",\n        \"baseSelector\": \".crypto-row\",\n        \"fields\": [\n            {\"name\": \"name\", \"selector\": \".crypto-name\", \"type\": \"text\"},\n            {\"name\": \"price\", \"selector\": \".crypto-price\", \"type\": \"text\"},\n        ]\n    }\n\n    js_code = \"\"\"\n    window.scrollTo(0, document.body.scrollHeight);\n    await new Promise(resolve => setTimeout(resolve, 2000));  // Wait for 2 seconds\n    \"\"\"\n\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com/crypto-prices\",\n            extraction_strategy=extraction_strategy,\n            js_code=js_code,\n            wait_for=\".crypto-row:nth-child(20)\",  # Wait for 20 rows to load\n            bypass_cache=True,\n        )\n\n        crypto_data = json.loads(result.extracted_content)\n        print(f\"Extracted {len(crypto_data)} cryptocurrency entries\")\n\nasyncio.run(extract_dynamic_structured_data())\n```\n\nThis advanced example demonstrates how to:\n1. Execute JavaScript to trigger dynamic content loading.\n2. Wait for a specific condition (20 rows loaded) before extraction.\n3. Extract data from the dynamically loaded content.\n\nBy mastering the `JsonCssExtractionStrategy`, you can efficiently extract structured data from a wide variety of web pages, making it a valuable tool in your web scraping toolkit.\n\nFor more details on schema definitions and advanced extraction strategies, check out the[Advanced JsonCssExtraction](./css-advanced.md).",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the core interface methods that enable the dynamic data extraction capabilities demonstrated in the documentation's example, particularly through its crawl method that supports JavaScript execution parameters.",
      "ground_truth_trace_chain": "css.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### TopicSegmentationChunking\n\n`TopicSegmentationChunking` employs the TextTiling algorithm to segment text into topic-based chunks. This method identifies thematic boundaries.\n\n#### When to Use\n- Perfect for long documents with distinct topics.\n- Useful when preserving topic continuity is more important than maintaining text order.\n\n#### Parameters\n- `num_keywords` (int, optional): Number of keywords for each topic segment. Default is `3`.\n\n#### Example\n```python\nfrom crawl4ai.chunking_strategy import TopicSegmentationChunking\n\nchunker = TopicSegmentationChunking(num_keywords=3)\n\n# Sample text\ntext = \"This document contains several topics. Topic one discusses AI. Topic two covers machine learning.\"\n\n# Chunk the text\nchunks = chunker.chunk(text)\nprint(chunks)\n```",
      "document_location": "docs/md_v2/extraction/chunking.md",
      "artifact_id": 28,
      "artifact_title": "TopicSegmentationChunking",
      "predicted_relationship": "explicit",
      "relationship_type": "uses",
      "relationship_explanation": "The documentation snippet explicitly mentions and demonstrates the usage of the TopicSegmentationChunking class. The example shows the instantiation of TopicSegmentationChunking with a parameter (num_keywords=3) and its subsequent use to chunk text.",
      "predicted_trace_chain": "docs/md_v2/extraction/chunking.md -> TopicSegmentationChunking",
      "predicted_trace_chain_explanation": "The chain starts from the documentation file and directly maps to the TopicSegmentationChunking artifact as it is explicitly imported and used in the example code.",
      "ground_truth_relationship": "The code implements the TextTiling algorithm through NLTK's TextTilingTokenizer class while adding keyword extraction functionality based on term frequency, directly fulfilling the documentation's promise of topic-based text segmentation.",
      "ground_truth_trace_chain": "chunking.md -> ChunkingStrategy -> TopicSegmentationChunking",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### TopicSegmentationChunking\n\n`TopicSegmentationChunking` employs the TextTiling algorithm to segment text into topic-based chunks. This method identifies thematic boundaries.\n\n#### When to Use\n- Perfect for long documents with distinct topics.\n- Useful when preserving topic continuity is more important than maintaining text order.\n\n#### Parameters\n- `num_keywords` (int, optional): Number of keywords for each topic segment. Default is `3`.\n\n#### Example\n```python\nfrom crawl4ai.chunking_strategy import TopicSegmentationChunking\n\nchunker = TopicSegmentationChunking(num_keywords=3)\n\n# Sample text\ntext = \"This document contains several topics. Topic one discusses AI. Topic two covers machine learning.\"\n\n# Chunk the text\nchunks = chunker.chunk(text)\nprint(chunks)\n```",
      "document_location": "docs/md_v2/extraction/chunking.md",
      "artifact_id": 6,
      "artifact_title": "ChunkingStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "extends",
      "relationship_explanation": "TopicSegmentationChunking is implemented as a subclass of ChunkingStrategy. Although the base class is not explicitly mentioned in the documentation snippet, its relationship is implicit due to inheritance, defining the interface for chunking strategies.",
      "predicted_trace_chain": "docs/md_v2/extraction/chunking.md -> TopicSegmentationChunking -> ChunkingStrategy",
      "predicted_trace_chain_explanation": "The chain demonstrates that the documented TopicSegmentationChunking, which is directly used in the snippet, extends the ChunkingStrategy base class, establishing an implicit trace between the documentation and the abstract interface.",
      "ground_truth_relationship": "The ChunkingStrategy abstract base class defines the interface that TopicSegmentationChunking must implement through the chunk() method to perform text segmentation using the TextTiling algorithm.",
      "ground_truth_trace_chain": "chunking.md -> ChunkingStrategy -> ChunkingStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Cosine Strategy\n\nThe Cosine Strategy in Crawl4AI uses similarity-based clustering to identify and extract relevant content sections from web pages. This strategy is particularly useful when you need to find and extract content based on semantic similarity rather than structural patterns.\n\n## How It Works\n\nThe Cosine Strategy:\n1. Breaks down page content into meaningful chunks\n2. Converts text into vector representations\n3. Calculates similarity between chunks\n4. Clusters similar content together\n5. Ranks and filters content based on relevance",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 7,
      "artifact_title": "CosineStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "implements and extends",
      "relationship_explanation": "The documentation snippet is titled 'Cosine Strategy' and explicitly describes a method that uses cosine similarity for clustering and content extraction. This directly corresponds to the CosineStrategy class (Artifact 7), which implements similarity-based clustering by converting text into vector representations and grouping similar text chunks.",
      "predicted_trace_chain": "docs/md_v2/extraction/cosine.md -> CosineStrategy",
      "predicted_trace_chain_explanation": "The trace begins at the documentation file 'docs/md_v2/extraction/cosine.md' and directly leads to the CosineStrategy class, as the strategy detailed in the document is implemented by this class.",
      "ground_truth_relationship": "The code implements the documented 5-step Cosine Strategy workflow through the extract() method, which breaks content into chunks (step 1), generates embeddings via get_embeddings() (step 2), performs similarity calculations in hierarchical_clustering() (step 3), groups content using cluster labels (step 4), and ranks content using filter_clusters_by_word_count() (step 5).",
      "ground_truth_trace_chain": "cosine.md -> ExtractionStrategy -> CosineStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Cosine Strategy\n\nThe Cosine Strategy in Crawl4AI uses similarity-based clustering to identify and extract relevant content sections from web pages. This strategy is particularly useful when you need to find and extract content based on semantic similarity rather than structural patterns.\n\n## How It Works\n\nThe Cosine Strategy:\n1. Breaks down page content into meaningful chunks\n2. Converts text into vector representations\n3. Calculates similarity between chunks\n4. Clusters similar content together\n5. Ranks and filters content based on relevance",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "CosineStrategy extends ExtractionStrategy, meaning that all extraction functionalities and interfaces defined in ExtractionStrategy form the foundation for CosineStrategy. Although the documentation does not explicitly mention ExtractionStrategy, it is implicitly involved as the parent class that provides the framework for extraction strategies like CosineStrategy.",
      "predicted_trace_chain": "docs/md_v2/extraction/cosine.md -> CosineStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "Starting from the documentation, the chain first leads to CosineStrategy, which directly implements the functionalities described. The chain then extends to ExtractionStrategy, showing that CosineStrategy is built upon the extraction framework provided by ExtractionStrategy.",
      "ground_truth_relationship": "The ExtractionStrategy abstract base class provides the foundational structure for implementing the documented Cosine Strategy by defining the interface for content extraction and parallel processing through its extract() and run() methods.",
      "ground_truth_trace_chain": "cosine.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Timing Control\n\n### Delays and Timeouts\n\nControl timing of interactions:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    page_timeout=60000,              # Page load timeout (ms)\n    delay_before_return_html=2.0,    # Wait before capturing content\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "invocation",
      "relationship_explanation": "The code snippet directly invokes the 'arun' method (as seen in 'crawler.arun(...)') and passes timing parameters such as 'page_timeout' and 'delay_before_return_html'. This clearly demonstrates its use for controlling delays and timeouts.",
      "predicted_trace_chain": "page-interaction.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The documentation in 'page-interaction.md' explicitly calls the AsyncWebCrawler.arun() method, making it the direct entry point for timing control in the crawler.",
      "ground_truth_relationship": "The code implements the documented timing controls through the **kwargs parameter in the arun() method, which accepts page_timeout and delay_before_return_html settings that are passed to the crawler_strategy.crawl() function.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Timing Control\n\n### Delays and Timeouts\n\nControl timing of interactions:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    page_timeout=60000,              # Page load timeout (ms)\n    delay_before_return_html=2.0,    # Wait before capturing content\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "delegation",
      "relationship_explanation": "Within AsyncWebCrawler.arun(), the crawler delegates the actual processing to its internal crawler strategy. By default, this is an instance of AsyncPlaywrightCrawlerStrategy whose 'crawl' method (implemented in this class) uses 'page_timeout' and 'delay_before_return_html' to control page load timing and delay before returning the HTML. This implementation detail supports the documented timing control behavior.",
      "predicted_trace_chain": "page-interaction.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain begins with the documented call to AsyncWebCrawler.arun(), which internally leverages the AsyncPlaywrightCrawlerStrategy to execute the crawl and apply the provided timing parameters. This intermediate step is necessary because the timing controls are implemented in AsyncPlaywrightCrawlerStrategy.",
      "ground_truth_relationship": "The code implements timing control through parameters like page_timeout and delay_before_return_html in the crawl method of AsyncPlaywrightCrawlerStrategy, where page_timeout controls the maximum wait time for page loads and delay_before_return_html adds a pause before capturing the final HTML content.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Timing Control\n\n### Delays and Timeouts\n\nControl timing of interactions:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    page_timeout=60000,              # Page load timeout (ms)\n    delay_before_return_html=2.0,    # Wait before capturing content\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the final output after applying the documented timing controls like page_timeout and delay_before_return_html during web crawling.",
      "ground_truth_trace_chain": "page-interaction.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Timing Control\n\n### Delays and Timeouts\n\nControl timing of interactions:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    page_timeout=60000,              # Page load timeout (ms)\n    delay_before_return_html=2.0,    # Wait before capturing content\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the interface that enables timing control through its crawl method's **kwargs parameter, which can accept the documented page_timeout and delay_before_return_html parameters.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Timing Control\n\n### Delays and Timeouts\n\nControl timing of interactions:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    page_timeout=60000,              # Page load timeout (ms)\n    delay_before_return_html=2.0,    # Wait before capturing content\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements timing control through its arun method which accepts page_timeout and delay_before_return_html parameters that are passed to the underlying crawler_strategy for managing page load timeouts and content capture delays.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Standard Markdown\n\nHTML converted to clean markdown format. Great for:\n- Content analysis\n- Documentation\n- Readability\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    include_links_on_markdown=True  # Include links in markdown\n)\nprint(result.markdown)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The documentation snippet shows a usage example that explicitly calls 'crawler.arun(...)'. This directly corresponds to the method 'AsyncWebCrawler.arun()' from the available artifacts.",
      "predicted_trace_chain": "output-formats.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The trace chain starts with the documentation file 'output-formats.md' and then leads directly to the invoked method 'AsyncWebCrawler.arun()', which is the entry point for the crawling process shown in the snippet.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method processes HTML content asynchronously and converts it to markdown format, with options to include links as shown in the documentation example through the kwargs parameter passed to aprocess_html().",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Standard Markdown\n\nHTML converted to clean markdown format. Great for:\n- Content analysis\n- Documentation\n- Readability\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    include_links_on_markdown=True  # Include links in markdown\n)\nprint(result.markdown)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 15,
      "artifact_title": "CrawlResult.markdown",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "In the usage example, after the call to 'crawler.arun()', the snippet prints 'result.markdown'. This directly accesses the 'markdown' attribute of the CrawlResult object returned by the method.",
      "predicted_trace_chain": "output-formats.md -> AsyncWebCrawler.arun() -> CrawlResult.markdown",
      "predicted_trace_chain_explanation": "The trace chain connects the documentation file to the 'arun' method and then to the 'markdown' attribute of the returned CrawlResult object, indicating that the clean markdown output is provided via this attribute.",
      "ground_truth_relationship": "The markdown property on CrawlResult stores the HTML-to-Markdown converted text output as an optional string value that can be accessed after crawling a webpage.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult.markdown",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Standard Markdown\n\nHTML converted to clean markdown format. Great for:\n- Content analysis\n- Documentation\n- Readability\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    include_links_on_markdown=True  # Include links in markdown\n)\nprint(result.markdown)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class includes a 'markdown' field that stores the converted HTML content as standard markdown format, which directly enables the functionality shown in the documentation example where crawler.arun() returns markdown output.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Standard Markdown\n\nHTML converted to clean markdown format. Great for:\n- Content analysis\n- Documentation\n- Readability\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    include_links_on_markdown=True  # Include links in markdown\n)\nprint(result.markdown)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "AsyncCrawlerStrategy defines the abstract interface for web crawling operations that support the documented markdown conversion functionality through its crawl method which returns responses that can be formatted into markdown.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Standard Markdown\n\nHTML converted to clean markdown format. Great for:\n- Content analysis\n- Documentation\n- Readability\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    include_links_on_markdown=True  # Include links in markdown\n)\nprint(result.markdown)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements web crawling functionality that enables HTML-to-markdown conversion by fetching web content using Playwright, as demonstrated in the documentation's example code showing how to retrieve and convert webpage content to markdown format.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Standard Markdown\n\nHTML converted to clean markdown format. Great for:\n- Content analysis\n- Documentation\n- Readability\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    include_links_on_markdown=True  # Include links in markdown\n)\nprint(result.markdown)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the documented markdown conversion functionality through its arun() method, which processes HTML content and converts it to markdown format while optionally preserving links as specified by the include_links_on_markdown parameter.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Example 2: Extract Relevant Content\n\nIn this example, we instruct the LLM to extract only content related to technology from the NBC News business page.\n\n```python\nimport os\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nasync def extract_tech_content():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\",\n                api_token=os.getenv('OPENAI_API_KEY'),\n                instruction=\"Extract only content related to technology\"\n            ),\n            bypass_cache=True,\n        )\n\n    tech_content = json.loads(result.extracted_content)\n    print(f\"Number of tech-related items extracted: {len(tech_content)}\")\n\n    with open(\".data/tech_content.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(tech_content, f, indent=2)\n\nasyncio.run(extract_tech_content())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "import and context management",
      "relationship_explanation": "The documentation snippet explicitly imports AsyncWebCrawler and uses it as an async context manager to initiate a crawl, which is central to the example.",
      "predicted_trace_chain": "llm.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The document (llm.md) directly references the AsyncWebCrawler class; this is the starting point of the crawling process in the example.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the functionality shown in the documentation example by providing asynchronous web crawling capabilities with customizable extraction strategies, as demonstrated in the example's use of LLMExtractionStrategy to extract tech-related content from NBC News.",
      "ground_truth_trace_chain": "llm.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example 2: Extract Relevant Content\n\nIn this example, we instruct the LLM to extract only content related to technology from the NBC News business page.\n\n```python\nimport os\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nasync def extract_tech_content():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\",\n                api_token=os.getenv('OPENAI_API_KEY'),\n                instruction=\"Extract only content related to technology\"\n            ),\n            bypass_cache=True,\n        )\n\n    tech_content = json.loads(result.extracted_content)\n    print(f\"Number of tech-related items extracted: {len(tech_content)}\")\n\n    with open(\".data/tech_content.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(tech_content, f, indent=2)\n\nasyncio.run(extract_tech_content())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "Within the code example, the 'arun()' method is called on an AsyncWebCrawler instance to perform the crawling and extraction operation.",
      "predicted_trace_chain": "llm.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the document (llm.md), the AsyncWebCrawler is used and then its 'arun()' method is invoked to execute the crawl operation.",
      "ground_truth_relationship": "The documentation demonstrates how to use the arun() method with LLMExtractionStrategy to filter website content based on specific criteria, while the code shows the actual implementation that handles crawling, caching, and content extraction with various strategies.",
      "ground_truth_trace_chain": "llm.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example 2: Extract Relevant Content\n\nIn this example, we instruct the LLM to extract only content related to technology from the NBC News business page.\n\n```python\nimport os\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nasync def extract_tech_content():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\",\n                api_token=os.getenv('OPENAI_API_KEY'),\n                instruction=\"Extract only content related to technology\"\n            ),\n            bypass_cache=True,\n        )\n\n    tech_content = json.loads(result.extracted_content)\n    print(f\"Number of tech-related items extracted: {len(tech_content)}\")\n\n    with open(\".data/tech_content.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(tech_content, f, indent=2)\n\nasyncio.run(extract_tech_content())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "class instantiation",
      "relationship_explanation": "The example explicitly creates an instance of LLMExtractionStrategy, passing parameters such as provider, api_token, and an instruction to extract technology-related content.",
      "predicted_trace_chain": "llm.md -> LLMExtractionStrategy",
      "predicted_trace_chain_explanation": "From the document (llm.md), there is a direct instantiation of LLMExtractionStrategy for handling the extraction task.",
      "ground_truth_relationship": "The LLMExtractionStrategy class implements the documented content extraction functionality by processing HTML content through LLM models with specific instructions, as shown in Example 2 where it extracts only technology-related content from NBC News using GPT-4.",
      "ground_truth_trace_chain": "llm.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example 2: Extract Relevant Content\n\nIn this example, we instruct the LLM to extract only content related to technology from the NBC News business page.\n\n```python\nimport os\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nasync def extract_tech_content():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\",\n                api_token=os.getenv('OPENAI_API_KEY'),\n                instruction=\"Extract only content related to technology\"\n            ),\n            bypass_cache=True,\n        )\n\n    tech_content = json.loads(result.extracted_content)\n    print(f\"Number of tech-related items extracted: {len(tech_content)}\")\n\n    with open(\".data/tech_content.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(tech_content, f, indent=2)\n\nasyncio.run(extract_tech_content())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "LLMExtractionStrategy extends the abstract base class ExtractionStrategy, thereby inheriting its extraction interface which underpins the extraction functionality demonstrated in the snippet.",
      "predicted_trace_chain": "llm.md -> LLMExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "Because LLMExtractionStrategy is used in the example and it inherits from ExtractionStrategy, the base extraction interface (ExtractionStrategy) is implicitly involved in the process.",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the core framework that enables the documented example to execute custom content extraction logic through its LLMExtractionStrategy subclass, particularly shown in the example where it extracts tech-related content from NBC News.",
      "ground_truth_trace_chain": "llm.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example 2: Extract Relevant Content\n\nIn this example, we instruct the LLM to extract only content related to technology from the NBC News business page.\n\n```python\nimport os\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nasync def extract_tech_content():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\",\n                api_token=os.getenv('OPENAI_API_KEY'),\n                instruction=\"Extract only content related to technology\"\n            ),\n            bypass_cache=True,\n        )\n\n    tech_content = json.loads(result.extracted_content)\n    print(f\"Number of tech-related items extracted: {len(tech_content)}\")\n\n    with open(\".data/tech_content.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(tech_content, f, indent=2)\n\nasyncio.run(extract_tech_content())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 11,
      "artifact_title": "CrawlResult.extracted_content",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet accesses the 'extracted_content' attribute from the result of the crawl (an instance of CrawlResult) to retrieve the JSON data extracted by the strategy.",
      "predicted_trace_chain": "llm.md -> AsyncWebCrawler.arun() -> CrawlResult.extracted_content",
      "predicted_trace_chain_explanation": "From the document (llm.md), the AsyncWebCrawler's 'arun()' method returns a CrawlResult which exposes the 'extracted_content' attribute used to obtain the extracted technology-related data.",
      "ground_truth_relationship": "The extracted_content property stores the text content filtered by LLMExtractionStrategy as shown in the example where tech-related content from NBC News is stored and later parsed as JSON.",
      "ground_truth_trace_chain": "llm.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Example 2: Extract Relevant Content\n\nIn this example, we instruct the LLM to extract only content related to technology from the NBC News business page.\n\n```python\nimport os\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nasync def extract_tech_content():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\",\n                api_token=os.getenv('OPENAI_API_KEY'),\n                instruction=\"Extract only content related to technology\"\n            ),\n            bypass_cache=True,\n        )\n\n    tech_content = json.loads(result.extracted_content)\n    print(f\"Number of tech-related items extracted: {len(tech_content)}\")\n\n    with open(\".data/tech_content.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(tech_content, f, indent=2)\n\nasyncio.run(extract_tech_content())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the asynchronous web crawling functionality shown in the documentation example by providing methods like crawl() that handle browser automation, HTML extraction, and custom configurations needed for the AsyncWebCrawler's arun() method.",
      "ground_truth_trace_chain": "llm.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Example 2: Extract Relevant Content\n\nIn this example, we instruct the LLM to extract only content related to technology from the NBC News business page.\n\n```python\nimport os\nimport json\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nasync def extract_tech_content():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            extraction_strategy=LLMExtractionStrategy(\n                provider=\"openai/gpt-4o\",\n                api_token=os.getenv('OPENAI_API_KEY'),\n                instruction=\"Extract only content related to technology\"\n            ),\n            bypass_cache=True,\n        )\n\n    tech_content = json.loads(result.extracted_content)\n    print(f\"Number of tech-related items extracted: {len(tech_content)}\")\n\n    with open(\".data/tech_content.json\", \"w\", encoding=\"utf-8\") as f:\n        json.dump(tech_content, f, indent=2)\n\nasyncio.run(extract_tech_content())\n```",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the core methods that enable the example's web crawling functionality, including crawl() which is used by AsyncWebCrawler to fetch and process the NBC News business page.",
      "ground_truth_trace_chain": "llm.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## CSS Selectors\n\nThe simplest way to extract specific content:\n\n```python\n# Extract specific content using CSS selector\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    css_selector=\".main-article\"  # Target main article content\n)\n\n# Multiple selectors\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    css_selector=\"article h1, article .content\"  # Target heading and content\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "public method invocation",
      "relationship_explanation": "The documentation snippet directly demonstrates the invocation of the 'arun' method on a crawler instance by passing the 'css_selector' parameter. This explicitly shows that users can pass CSS selectors (e.g. '.main-article' or 'article h1, article .content') to extract specific content.",
      "predicted_trace_chain": "docs/md_v2/basic/content-selection.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain starts at the documentation file 'docs/md_v2/basic/content-selection.md' which shows the usage example, and leads directly to the 'AsyncWebCrawler.arun()' method that implements this functionality.",
      "ground_truth_relationship": "The code implements CSS selector-based content extraction through the css_selector parameter in the arun method, which is passed through to the HTML processing logic to filter and extract specific elements from the crawled webpage.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## CSS Selectors\n\nThe simplest way to extract specific content:\n\n```python\n# Extract specific content using CSS selector\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    css_selector=\".main-article\"  # Target main article content\n)\n\n# Multiple selectors\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    css_selector=\"article h1, article .content\"  # Target heading and content\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "implicit",
      "relationship_type": "class usage",
      "relationship_explanation": "Although the snippet does not explicitly name the class, the variable 'crawler' used in the example is an instance of AsyncWebCrawler, which provides the 'arun' method. This implicitly connects the documentation to the AsyncWebCrawler class.",
      "predicted_trace_chain": "docs/md_v2/basic/content-selection.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain begins with the documentation file and leads to the AsyncWebCrawler class, whose instance is used to call the 'arun()' method, thereby supporting CSS selector based extraction.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements CSS selector functionality in its arun() method through the css_selector parameter, which is passed to the WebScrappingStrategy's scrap() function to target specific HTML elements as shown in the documentation examples.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## CSS Selectors\n\nThe simplest way to extract specific content:\n\n```python\n# Extract specific content using CSS selector\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    css_selector=\".main-article\"  # Target main article content\n)\n\n# Multiple selectors\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    css_selector=\"article h1, article .content\"  # Target heading and content\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the extracted content from CSS selectors in its extracted_content field, enabling the targeted content extraction functionality described in the documentation.",
      "ground_truth_trace_chain": "content-selection.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## CSS Selectors\n\nThe simplest way to extract specific content:\n\n```python\n# Extract specific content using CSS selector\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    css_selector=\".main-article\"  # Target main article content\n)\n\n# Multiple selectors\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    css_selector=\"article h1, article .content\"  # Target heading and content\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements CSS selector functionality through its crawl method, which uses Playwright's page.wait_for_selector() to target and extract specific content elements as described in the documentation.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## CSS Selectors\n\nThe simplest way to extract specific content:\n\n```python\n# Extract specific content using CSS selector\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    css_selector=\".main-article\"  # Target main article content\n)\n\n# Multiple selectors\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    css_selector=\"article h1, article .content\"  # Target heading and content\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface that enables CSS selector-based content extraction through its crawl method, which is demonstrated in the documentation examples.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "# Magic Mode & Anti-Bot Protection\n\nCrawl4AI provides powerful anti-detection capabilities, with Magic Mode being the simplest and most comprehensive solution.\n\n## Magic Mode\n\nThe easiest way to bypass anti-bot protections:\n\n```python\nasync with AsyncWebCrawler() as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        magic=True  # Enables all anti-detection features\n    )\n```\n\nMagic Mode automatically:\n- Masks browser automation signals\n- Simulates human-like behavior\n- Overrides navigator properties\n- Handles cookie consent popups\n- Manages browser fingerprinting\n- Randomizes timing patterns\n",
      "document_location": "docs/md_v2/advanced/magic-mode.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "uses",
      "relationship_explanation": "The documentation snippet explicitly shows the use of 'AsyncWebCrawler' in a context manager ('async with AsyncWebCrawler() as crawler:'), making it the entry point for enabling Magic Mode.",
      "predicted_trace_chain": "docs/md_v2/advanced/magic-mode.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain starts with the documentation file which directly invokes the AsyncWebCrawler class for initiating the crawl.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements Magic Mode's anti-bot protections through its crawler_strategy parameter which defaults to AsyncPlaywrightCrawlerStrategy, handling browser automation masking and human behavior simulation through its arun() method's **kwargs parameters.",
      "ground_truth_trace_chain": "magic-mode.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Magic Mode & Anti-Bot Protection\n\nCrawl4AI provides powerful anti-detection capabilities, with Magic Mode being the simplest and most comprehensive solution.\n\n## Magic Mode\n\nThe easiest way to bypass anti-bot protections:\n\n```python\nasync with AsyncWebCrawler() as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        magic=True  # Enables all anti-detection features\n    )\n```\n\nMagic Mode automatically:\n- Masks browser automation signals\n- Simulates human-like behavior\n- Overrides navigator properties\n- Handles cookie consent popups\n- Manages browser fingerprinting\n- Randomizes timing patterns\n",
      "document_location": "docs/md_v2/advanced/magic-mode.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The usage example calls the 'arun' method on an AsyncWebCrawler instance with the parameter 'magic=True', directly demonstrating how Magic Mode is activated.",
      "predicted_trace_chain": "docs/md_v2/advanced/magic-mode.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain follows from the documented creation of an AsyncWebCrawler instance to the invocation of its 'arun' method, where the Magic Mode flag is passed.",
      "ground_truth_relationship": "The arun() method accepts a 'magic' parameter in its **kwargs which, when set to True, enables the anti-bot protection features described in the documentation by delegating the actual crawling behavior to the crawler_strategy object.",
      "ground_truth_trace_chain": "magic-mode.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Magic Mode & Anti-Bot Protection\n\nCrawl4AI provides powerful anti-detection capabilities, with Magic Mode being the simplest and most comprehensive solution.\n\n## Magic Mode\n\nThe easiest way to bypass anti-bot protections:\n\n```python\nasync with AsyncWebCrawler() as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        magic=True  # Enables all anti-detection features\n    )\n```\n\nMagic Mode automatically:\n- Masks browser automation signals\n- Simulates human-like behavior\n- Overrides navigator properties\n- Handles cookie consent popups\n- Manages browser fingerprinting\n- Randomizes timing patterns\n",
      "document_location": "docs/md_v2/advanced/magic-mode.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "implements",
      "relationship_explanation": "Although not directly mentioned in the snippet, AsyncWebCrawler defaults to using AsyncPlaywrightCrawlerStrategy as its crawler strategy. Its 'crawl' method checks for the 'magic' parameter (alongside 'override_navigator' and 'simulate_user') and injects anti-detection scripts, thus implementing the Magic Mode behavior.",
      "predicted_trace_chain": "docs/md_v2/advanced/magic-mode.md -> AsyncWebCrawler -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "This chain extends from the explicit use of AsyncWebCrawler and its 'arun' method to the underlying strategy class that processes the 'magic' flag to activate anti-bot protections.",
      "ground_truth_relationship": "The code implements Magic Mode by combining anti-bot features like stealth browser configurations, navigator property overrides, and human-like behavior simulations through the magic=True parameter in the crawl method.",
      "ground_truth_trace_chain": "magic-mode.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Magic Mode & Anti-Bot Protection\n\nCrawl4AI provides powerful anti-detection capabilities, with Magic Mode being the simplest and most comprehensive solution.\n\n## Magic Mode\n\nThe easiest way to bypass anti-bot protections:\n\n```python\nasync with AsyncWebCrawler() as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        magic=True  # Enables all anti-detection features\n    )\n```\n\nMagic Mode automatically:\n- Masks browser automation signals\n- Simulates human-like behavior\n- Overrides navigator properties\n- Handles cookie consent popups\n- Manages browser fingerprinting\n- Randomizes timing patterns\n",
      "document_location": "docs/md_v2/advanced/magic-mode.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "AsyncCrawlerStrategy is the abstract base class for AsyncPlaywrightCrawlerStrategy. It defines the interface for asynchronous crawling, upon which the Magic Mode enhancements are built.",
      "predicted_trace_chain": "docs/md_v2/advanced/magic-mode.md -> AsyncWebCrawler -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "This extended chain indicates that the Magic Mode functionality is rooted in the design of asynchronous crawling as defined by AsyncCrawlerStrategy, which is inherited by the implementation in AsyncPlaywrightCrawlerStrategy.",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interfaces needed to implement Magic Mode's anti-bot features through its abstract methods for crawling, screenshots, user agent manipulation, and custom hooks.",
      "ground_truth_trace_chain": "magic-mode.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Magic Mode & Anti-Bot Protection\n\nCrawl4AI provides powerful anti-detection capabilities, with Magic Mode being the simplest and most comprehensive solution.\n\n## Magic Mode\n\nThe easiest way to bypass anti-bot protections:\n\n```python\nasync with AsyncWebCrawler() as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        magic=True  # Enables all anti-detection features\n    )\n```\n\nMagic Mode automatically:\n- Masks browser automation signals\n- Simulates human-like behavior\n- Overrides navigator properties\n- Handles cookie consent popups\n- Manages browser fingerprinting\n- Randomizes timing patterns\n",
      "document_location": "docs/md_v2/advanced/magic-mode.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class captures the outcomes of Magic Mode anti-bot operations by storing essential crawling data including success status, cleaned HTML, metadata, and session information needed to verify successful anti-detection measures.",
      "ground_truth_trace_chain": "magic-mode.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Using LLMExtractionStrategy with Different Providers Crawl4AI supports multiple LLM providers for extraction: ```python from crawl4ai.extraction_strategy import LLMExtractionStrategy from pydantic import BaseModel, Field class OpenAIModelFee(BaseModel): model_name: str = Field(..., description=\"Name of the OpenAI model.\") input_fee: str = Field(..., description=\"Fee for input token for the OpenAI model.\") output_fee: str = Field(..., description=\"Fee for output token for the OpenAI model.\") # OpenAI await extract_structured_data_using_llm(\"openai/gpt-4o\", os.getenv(\"OPENAI_API_KEY\")) # Hugging Face await extract_structured_data_using_llm( \"huggingface/meta-llama/Meta-Llama-3.1-8B-Instruct\", os.getenv(\"HUGGINGFACE_API_KEY\") ) # Ollama await extract_structured_data_using_llm(\"ollama/llama3.2\") # With custom headers custom_headers = { \"Authorization\": \"Bearer your-custom-token\", \"X-Custom-Header\": \"Some-Value\" } await extract_structured_data_using_llm(extra_headers=custom_headers) ```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "implements extraction functionality",
      "relationship_explanation": "The documentation snippet explicitly imports LLMExtractionStrategy from crawl4ai.extraction_strategy and shows its use in supporting multiple LLM providers for data extraction. This direct reference makes it an explicit trace.",
      "predicted_trace_chain": "quickstart.md -> LLMExtractionStrategy",
      "predicted_trace_chain_explanation": "The trace chain starts at the document quickstart.md where the example code directly imports and uses LLMExtractionStrategy.",
      "ground_truth_relationship": "The LLMExtractionStrategy class implements provider flexibility by accepting different LLM services (OpenAI, Hugging Face, Ollama) through its constructor's provider parameter and handling their authentication via api_token, which directly corresponds to the documented usage examples showing multiple provider configurations.",
      "ground_truth_trace_chain": "quickstart.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Using LLMExtractionStrategy with Different Providers Crawl4AI supports multiple LLM providers for extraction: ```python from crawl4ai.extraction_strategy import LLMExtractionStrategy from pydantic import BaseModel, Field class OpenAIModelFee(BaseModel): model_name: str = Field(..., description=\"Name of the OpenAI model.\") input_fee: str = Field(..., description=\"Fee for input token for the OpenAI model.\") output_fee: str = Field(..., description=\"Fee for output token for the OpenAI model.\") # OpenAI await extract_structured_data_using_llm(\"openai/gpt-4o\", os.getenv(\"OPENAI_API_KEY\")) # Hugging Face await extract_structured_data_using_llm( \"huggingface/meta-llama/Meta-Llama-3.1-8B-Instruct\", os.getenv(\"HUGGINGFACE_API_KEY\") ) # Ollama await extract_structured_data_using_llm(\"ollama/llama3.2\") # With custom headers custom_headers = { \"Authorization\": \"Bearer your-custom-token\", \"X-Custom-Header\": \"Some-Value\" } await extract_structured_data_using_llm(extra_headers=custom_headers) ```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "LLMExtractionStrategy is a subclass of ExtractionStrategy. Although ExtractionStrategy is not directly mentioned in the snippet, it is implicitly part of the extraction framework as the abstract base class for extraction strategies.",
      "predicted_trace_chain": "quickstart.md -> LLMExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain shows that quickstart.md uses LLMExtractionStrategy which, in turn, extends ExtractionStrategy, linking the documented functionality to its underlying abstraction.",
      "ground_truth_relationship": "The ExtractionStrategy abstract base class serves as the foundation for implementing different LLM provider-specific extraction strategies, which the documentation demonstrates through examples of OpenAI, HuggingFace, and Ollama implementations.",
      "ground_truth_trace_chain": "quickstart.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Explanation of the Schema\n\nThe schema defines how to extract the data:\n\n- `name`: A descriptive name for the extraction task.\n- `baseSelector`: The CSS selector for the repeating elements (in this case, table rows).\n- `fields`: An array of fields to extract from each element:\n  - `name`: The name to give the extracted data.\n  - `selector`: The CSS selector to find the specific data within the base element.\n  - `type`: The type of data to extract (usually \"text\" for textual content).\n\n## Advantages of JsonCssExtractionStrategy\n\n1. **Speed**: CSS selectors are fast to execute, making this method efficient for large datasets.\n2. **Precision**: You can target exactly the elements you need.\n3. **Structured Output**: The result is already structured as JSON, ready for further processing.\n4. **No External Dependencies**: Unlike LLM-based strategies, this doesn't require any API calls to external services.",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "implements",
      "relationship_explanation": "The documentation snippet explicitly names the JsonCssExtractionStrategy and explains its advantages (speed, precision, structured JSON output, and no external dependencies), which directly corresponds to the implementation provided by this class.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The document 'css.md' outlines a schema for extraction via CSS selectors and clearly highlights JsonCssExtractionStrategy, establishing a direct trace from the documentation to this artifact.",
      "ground_truth_relationship": "The code implements the documented schema structure by using BeautifulSoup's select() method to extract data according to the baseSelector and fields defined in the schema configuration.",
      "ground_truth_trace_chain": "css.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Explanation of the Schema\n\nThe schema defines how to extract the data:\n\n- `name`: A descriptive name for the extraction task.\n- `baseSelector`: The CSS selector for the repeating elements (in this case, table rows).\n- `fields`: An array of fields to extract from each element:\n  - `name`: The name to give the extracted data.\n  - `selector`: The CSS selector to find the specific data within the base element.\n  - `type`: The type of data to extract (usually \"text\" for textual content).\n\n## Advantages of JsonCssExtractionStrategy\n\n1. **Speed**: CSS selectors are fast to execute, making this method efficient for large datasets.\n2. **Precision**: You can target exactly the elements you need.\n3. **Structured Output**: The result is already structured as JSON, ready for further processing.\n4. **No External Dependencies**: Unlike LLM-based strategies, this doesn't require any API calls to external services.",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "contrast",
      "relationship_explanation": "The documentation contrasts JsonCssExtractionStrategy with LLM\u2010based methods by mentioning the absence of external API calls. This indirectly references LLMExtractionStrategy, which relies on external API services.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> LLMExtractionStrategy",
      "predicted_trace_chain_explanation": "By emphasizing the benefit of not requiring external dependencies, the document implicitly contrasts with LLMExtractionStrategy, linking the advantages of JsonCssExtractionStrategy to the drawbacks of LLM-based approaches.",
      "ground_truth_relationship": null,
      "ground_truth_trace_chain": null,
      "traceability_granularity": "Class",
      "confusion_metrics": "False Positive",
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Explanation of the Schema\n\nThe schema defines how to extract the data:\n\n- `name`: A descriptive name for the extraction task.\n- `baseSelector`: The CSS selector for the repeating elements (in this case, table rows).\n- `fields`: An array of fields to extract from each element:\n  - `name`: The name to give the extracted data.\n  - `selector`: The CSS selector to find the specific data within the base element.\n  - `type`: The type of data to extract (usually \"text\" for textual content).\n\n## Advantages of JsonCssExtractionStrategy\n\n1. **Speed**: CSS selectors are fast to execute, making this method efficient for large datasets.\n2. **Precision**: You can target exactly the elements you need.\n3. **Structured Output**: The result is already structured as JSON, ready for further processing.\n4. **No External Dependencies**: Unlike LLM-based strategies, this doesn't require any API calls to external services.",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "JsonCssExtractionStrategy is built as a concrete implementation of the ExtractionStrategy abstract base class. Although not directly mentioned in the documentation, the structured schema detailed in the text implies the use of an extraction interface, which is provided by ExtractionStrategy.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The document's focus on a schema for extraction indirectly points to the foundational role of ExtractionStrategy in standardizing extraction methods, with JsonCssExtractionStrategy being a direct implementation of this interface.",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the abstract foundation that enables different extraction methods like JsonCssExtractionStrategy to implement specific extraction logic while sharing common parallel processing capabilities through its run() method.",
      "ground_truth_trace_chain": "css.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Adding a Chunking Strategy \ud83e\udde9\n\nLet's add a chunking strategy: `RegexChunking`! This strategy splits the text based on a given regex pattern.\n\n```python\nfrom crawl4ai.chunking_strategy import RegexChunking\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            chunking_strategy=RegexChunking(patterns=[\"\\n\\n\"])\n        )\n        print(f\"RegexChunking result: {result.extracted_content[:200]}...\")\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 26,
      "artifact_title": "RegexChunking",
      "predicted_relationship": "explicit",
      "relationship_type": "usage",
      "relationship_explanation": "The documentation snippet explicitly instructs adding a chunking strategy using RegexChunking. It is directly imported and instantiated with a regex pattern, demonstrating its use as the chunking strategy.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> RegexChunking",
      "predicted_trace_chain_explanation": "The snippet from 'quickstart.md' directly mentions RegexChunking, establishing it as the chosen chunking strategy for the crawl.",
      "ground_truth_relationship": "The RegexChunking class implementation splits text into chunks using regex patterns supplied in its constructor, with a default pattern of '\\n\\n' that matches double newlines as shown in both the documentation example and code definition.",
      "ground_truth_trace_chain": "quickstart.md -> ChunkingStrategy -> RegexChunking",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Adding a Chunking Strategy \ud83e\udde9\n\nLet's add a chunking strategy: `RegexChunking`! This strategy splits the text based on a given regex pattern.\n\n```python\nfrom crawl4ai.chunking_strategy import RegexChunking\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            chunking_strategy=RegexChunking(patterns=[\"\\n\\n\"])\n        )\n        print(f\"RegexChunking result: {result.extracted_content[:200]}...\")\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 6,
      "artifact_title": "ChunkingStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "RegexChunking extends ChunkingStrategy. Although ChunkingStrategy is not mentioned directly in the snippet, it underpins RegexChunking and provides the abstract interface that RegexChunking implements.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> RegexChunking -> ChunkingStrategy",
      "predicted_trace_chain_explanation": "The chain shows that RegexChunking, explicitly referenced in the documentation, inherits from ChunkingStrategy, indicating its role in the overall chunking strategy hierarchy.",
      "ground_truth_relationship": "The abstract ChunkingStrategy class serves as the base interface that RegexChunking extends to implement text splitting functionality through its required chunk method.",
      "ground_truth_trace_chain": "quickstart.md -> ChunkingStrategy -> ChunkingStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Adding a Chunking Strategy \ud83e\udde9\n\nLet's add a chunking strategy: `RegexChunking`! This strategy splits the text based on a given regex pattern.\n\n```python\nfrom crawl4ai.chunking_strategy import RegexChunking\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            chunking_strategy=RegexChunking(patterns=[\"\\n\\n\"])\n        )\n        print(f\"RegexChunking result: {result.extracted_content[:200]}...\")\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "usage",
      "relationship_explanation": "The code example creates an instance of AsyncWebCrawler with verbose=True, demonstrating its role as the main crawling component.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The documentation snippet shows the instantiation of AsyncWebCrawler as the starting point for the crawling process.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the documented RegexChunking functionality through its arun() method, which accepts a chunking_strategy parameter defaulting to RegexChunking() for splitting extracted text content.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Adding a Chunking Strategy \ud83e\udde9\n\nLet's add a chunking strategy: `RegexChunking`! This strategy splits the text based on a given regex pattern.\n\n```python\nfrom crawl4ai.chunking_strategy import RegexChunking\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            chunking_strategy=RegexChunking(patterns=[\"\\n\\n\"])\n        )\n        print(f\"RegexChunking result: {result.extracted_content[:200]}...\")\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method call",
      "relationship_explanation": "The example calls the arun() method on the AsyncWebCrawler instance to perform the crawl and pass the RegexChunking strategy. This method processes the crawl and applies the provided chunking strategy.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain indicates that from the crawl initiation via AsyncWebCrawler, the arun() method is used to execute the crawl with the specified chunking strategy.",
      "ground_truth_relationship": "The code implements the RegexChunking strategy mentioned in the documentation by accepting a chunking_strategy parameter in the arun() method, which defaults to RegexChunking() and validates it against the ChunkingStrategy type.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Adding a Chunking Strategy \ud83e\udde9\n\nLet's add a chunking strategy: `RegexChunking`! This strategy splits the text based on a given regex pattern.\n\n```python\nfrom crawl4ai.chunking_strategy import RegexChunking\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            chunking_strategy=RegexChunking(patterns=[\"\\n\\n\"])\n        )\n        print(f\"RegexChunking result: {result.extracted_content[:200]}...\")\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 11,
      "artifact_title": "CrawlResult.extracted_content",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "After crawling, the result returned is accessed for its 'extracted_content' attribute, which holds the processed content. This attribute is explicitly printed in the snippet.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> CrawlResult.extracted_content",
      "predicted_trace_chain_explanation": "The print statement in the documentation snippet accesses 'extracted_content' from the crawl result, establishing it as the final data retrieval step in the chain.",
      "ground_truth_relationship": "The extracted_content field in CrawlResult stores the text content after it has been processed by the RegexChunking strategy which splits the content using regex patterns.",
      "ground_truth_trace_chain": "quickstart.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Adding a Chunking Strategy \ud83e\udde9\n\nLet's add a chunking strategy: `RegexChunking`! This strategy splits the text based on a given regex pattern.\n\n```python\nfrom crawl4ai.chunking_strategy import RegexChunking\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            chunking_strategy=RegexChunking(patterns=[\"\\n\\n\"])\n        )\n        print(f\"RegexChunking result: {result.extracted_content[:200]}...\")\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class includes an extracted_content field to store the text chunks produced by the RegexChunking strategy described in the documentation.",
      "ground_truth_trace_chain": "quickstart.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Adding a Chunking Strategy \ud83e\udde9\n\nLet's add a chunking strategy: `RegexChunking`! This strategy splits the text based on a given regex pattern.\n\n```python\nfrom crawl4ai.chunking_strategy import RegexChunking\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            chunking_strategy=RegexChunking(patterns=[\"\\n\\n\"])\n        )\n        print(f\"RegexChunking result: {result.extracted_content[:200]}...\")\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy implements browser automation capabilities that enable the crawler to process RegexChunking by retrieving HTML content which can then be split using regex patterns as shown in the documentation.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Adding a Chunking Strategy \ud83e\udde9\n\nLet's add a chunking strategy: `RegexChunking`! This strategy splits the text based on a given regex pattern.\n\n```python\nfrom crawl4ai.chunking_strategy import RegexChunking\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n            chunking_strategy=RegexChunking(patterns=[\"\\n\\n\"])\n        )\n        print(f\"RegexChunking result: {result.extracted_content[:200]}...\")\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the core interface methods that enable the crawler to support various strategies like RegexChunking through its abstract crawl methods and configuration options.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Combining Strategies\n\nYou can combine strategies for more powerful extraction:\n\n```python\n# First use CSS strategy for initial structure\ncss_result = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=css_strategy\n)\n\n# Then use LLM for semantic analysis\nllm_result = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=llm_strategy\n)\n```",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method usage",
      "relationship_explanation": "The documentation snippet explicitly calls the arun() method on the crawler object (e.g., await crawler.arun(...)), which directly corresponds to the AsyncWebCrawler.arun() method in the code.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The trace starts from the documentation file and points directly to the method call of AsyncWebCrawler.arun(), which is the entry point used to perform extraction with different strategies.",
      "ground_truth_relationship": "The arun() method implements the documented combining strategies pattern by accepting an extraction_strategy parameter that allows different strategies to be passed in sequentially as shown in the documentation example.",
      "ground_truth_trace_chain": "overview.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Combining Strategies\n\nYou can combine strategies for more powerful extraction:\n\n```python\n# First use CSS strategy for initial structure\ncss_result = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=css_strategy\n)\n\n# Then use LLM for semantic analysis\nllm_result = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=llm_strategy\n)\n```",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "strategy implementation",
      "relationship_explanation": "In the snippet a variable 'css_strategy' is provided to the arun() method. Although not named explicitly, this implies a CSS-based extraction strategy. JsonCssExtractionStrategy is an implementation that uses CSS selectors to extract initial HTML structure.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> AsyncWebCrawler.arun() -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "Starting from the documentation, the use of crawler.arun() with a CSS strategy implicitly maps to the JsonCssExtractionStrategy, which implements the strategy for CSS-based extraction.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class implements one part of the documented combination approach by using CSS selectors to extract structured data from HTML, which can then be combined with other strategies like LLM processing.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Combining Strategies\n\nYou can combine strategies for more powerful extraction:\n\n```python\n# First use CSS strategy for initial structure\ncss_result = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=css_strategy\n)\n\n# Then use LLM for semantic analysis\nllm_result = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=llm_strategy\n)\n```",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "strategy implementation",
      "relationship_explanation": "The snippet shows a separate call to crawler.arun() with an 'llm_strategy' variable for semantic analysis. This implies the use of an LLM-based extraction strategy. LLMExtractionStrategy is the corresponding artifact that handles extraction using LLMs.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> AsyncWebCrawler.arun() -> LLMExtractionStrategy",
      "predicted_trace_chain_explanation": "From the documentation, the second extraction call using llm_strategy is traced to LLMExtractionStrategy, indicating its role in semantic analysis as part of the combined strategies.",
      "ground_truth_relationship": "The LLMExtractionStrategy class enables the documented functionality of combined crawling strategies by providing a specialized extraction method that can process content after initial CSS-based extraction, using LLM models for semantic analysis through its extract() and run() methods.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Combining Strategies\n\nYou can combine strategies for more powerful extraction:\n\n```python\n# First use CSS strategy for initial structure\ncss_result = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=css_strategy\n)\n\n# Then use LLM for semantic analysis\nllm_result = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=llm_strategy\n)\n```",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "Both JsonCssExtractionStrategy and LLMExtractionStrategy extend the abstract base class ExtractionStrategy. This base class defines the common interface for extraction strategies used in the crawler.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> [JsonCssExtractionStrategy / LLMExtractionStrategy] -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The extraction strategies used in the documentation example ultimately derive from ExtractionStrategy, making it an essential part of the extraction strategy chain.",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the foundational structure for implementing different extraction strategies that can be combined sequentially as shown in the documentation through its abstract extract() method and parallel processing run() method.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Combining Strategies\n\nYou can combine strategies for more powerful extraction:\n\n```python\n# First use CSS strategy for initial structure\ncss_result = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=css_strategy\n)\n\n# Then use LLM for semantic analysis\nllm_result = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=llm_strategy\n)\n```",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class enables storage of multiple extraction results by providing fields like extracted_content and metadata that can hold output from different strategies like CSS and LLM approaches shown in the documentation.",
      "ground_truth_trace_chain": "overview.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Combining Strategies\n\nYou can combine strategies for more powerful extraction:\n\n```python\n# First use CSS strategy for initial structure\ncss_result = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=css_strategy\n)\n\n# Then use LLM for semantic analysis\nllm_result = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=llm_strategy\n)\n```",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class provides the foundational interface that allows different crawling strategies (like CSS and LLM) to be implemented and combined as shown in the documentation.",
      "ground_truth_trace_chain": "overview.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Combining Strategies\n\nYou can combine strategies for more powerful extraction:\n\n```python\n# First use CSS strategy for initial structure\ncss_result = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=css_strategy\n)\n\n# Then use LLM for semantic analysis\nllm_result = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=llm_strategy\n)\n```",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class enables sequential execution of different extraction strategies through its crawl method, which returns AsyncCrawlResponse objects that can be used as input for subsequent extraction operations as shown in the documentation example.",
      "ground_truth_trace_chain": "overview.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Combining Strategies\n\nYou can combine strategies for more powerful extraction:\n\n```python\n# First use CSS strategy for initial structure\ncss_result = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=css_strategy\n)\n\n# Then use LLM for semantic analysis\nllm_result = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=llm_strategy\n)\n```",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class supports combining strategies through its 'arun' method which accepts different extraction_strategy parameters, allowing sequential application of CSS and LLM strategies as shown in the documentation.",
      "ground_truth_trace_chain": "overview.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Custom Headers\n\nAdd security-related headers:\n\n```python\nheaders = {\n    \"X-Forwarded-For\": \"203.0.113.195\",\n    \"Accept-Language\": \"en-US,en;q=0.9\",\n    \"Cache-Control\": \"no-cache\",\n    \"Pragma\": \"no-cache\"\n}\n\nasync with AsyncWebCrawler(headers=headers) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation",
      "relationship_explanation": "The documentation snippet explicitly creates an instance of AsyncWebCrawler by passing custom headers, as shown in 'async with AsyncWebCrawler(headers=headers) as crawler:'. This demonstrates direct usage of the class.",
      "predicted_trace_chain": "proxy-security.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The trace begins at the document 'proxy-security.md' where AsyncWebCrawler is directly instantiated with custom headers.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements custom header support through its constructor's **kwargs parameter, which gets passed to the AsyncPlaywrightCrawlerStrategy to configure HTTP headers like X-Forwarded-For and Cache-Control as shown in the documentation example.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Custom Headers\n\nAdd security-related headers:\n\n```python\nheaders = {\n    \"X-Forwarded-For\": \"203.0.113.195\",\n    \"Accept-Language\": \"en-US,en;q=0.9\",\n    \"Cache-Control\": \"no-cache\",\n    \"Pragma\": \"no-cache\"\n}\n\nasync with AsyncWebCrawler(headers=headers) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "In the usage example, the 'arun()' method is explicitly invoked on the AsyncWebCrawler instance to perform the crawling action on the given URL.",
      "predicted_trace_chain": "proxy-security.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain starts from the documentation and proceeds through the AsyncWebCrawler instance to its 'arun()' method, which is directly called in the snippet.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method accepts custom headers through its crawler_strategy component, allowing users to set security-related headers like X-Forwarded-For and Cache-Control as shown in the documentation.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Custom Headers\n\nAdd security-related headers:\n\n```python\nheaders = {\n    \"X-Forwarded-For\": \"203.0.113.195\",\n    \"Accept-Language\": \"en-US,en;q=0.9\",\n    \"Cache-Control\": \"no-cache\",\n    \"Pragma\": \"no-cache\"\n}\n\nasync with AsyncWebCrawler(headers=headers) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "composition",
      "relationship_explanation": "Although not directly mentioned in the snippet, AsyncWebCrawler defaults to using AsyncPlaywrightCrawlerStrategy as its crawling strategy. The custom headers provided in the snippet are passed through to this strategy via its 'headers' attribute.",
      "predicted_trace_chain": "proxy-security.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "This pathway illustrates that AsyncWebCrawler internally instantiates AsyncPlaywrightCrawlerStrategy, implicitly utilizing the custom headers for its crawling configuration.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements custom header functionality through its set_custom_headers method and context.set_extra_http_headers, allowing headers like X-Forwarded-For and Cache-Control to be set as shown in the documentation.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Custom Headers\n\nAdd security-related headers:\n\n```python\nheaders = {\n    \"X-Forwarded-For\": \"203.0.113.195\",\n    \"Accept-Language\": \"en-US,en;q=0.9\",\n    \"Cache-Control\": \"no-cache\",\n    \"Pragma\": \"no-cache\"\n}\n\nasync with AsyncWebCrawler(headers=headers) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "AsyncPlaywrightCrawlerStrategy extends the abstract class AsyncCrawlerStrategy. This base class defines the contract for crawler strategies, linking the header functionality indirectly to the overall crawling interface.",
      "predicted_trace_chain": "proxy-security.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain identifies that AsyncWebCrawler delegates crawling to AsyncPlaywrightCrawlerStrategy, which in turn implements the interface specified by AsyncCrawlerStrategy, completing the inheritance pathway.",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines core crawler methods that enable custom header manipulation shown in the documentation through its crawl and update_user_agent methods.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Custom Headers\n\nAdd security-related headers:\n\n```python\nheaders = {\n    \"X-Forwarded-For\": \"203.0.113.195\",\n    \"Accept-Language\": \"en-US,en;q=0.9\",\n    \"Cache-Control\": \"no-cache\",\n    \"Pragma\": \"no-cache\"\n}\n\nasync with AsyncWebCrawler(headers=headers) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores response_headers as an optional dictionary field to capture the custom headers used in HTTP requests like those shown in the documentation example.",
      "ground_truth_trace_chain": "proxy-security.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Timeouts and Waiting\n\nControl page loading behavior:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    page_timeout=60000,              # Page load timeout (ms)\n    delay_before_return_html=2.0,    # Wait before content capture\n    wait_for=\"css:.dynamic-content\"  # Wait for specific element\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "usage",
      "relationship_explanation": "The documentation snippet explicitly demonstrates the use of 'crawler.arun()' with parameters such as 'page_timeout', 'delay_before_return_html', and 'wait_for'. This call directly corresponds to the AsyncWebCrawler.arun() method, which serves as the entry point for configuring timeouts and waiting behavior.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain starts with the document 'docs/md_v2/basic/browser-config.md' and directly traces to the AsyncWebCrawler.arun() method, which is directly invoked in the example.",
      "ground_truth_relationship": "The code implements the documented timeout and waiting controls through the **kwargs parameter in arun(), which passes page_timeout, delay_before_return_html, and wait_for options to the crawler_strategy.crawl() method.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Timeouts and Waiting\n\nControl page loading behavior:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    page_timeout=60000,              # Page load timeout (ms)\n    delay_before_return_html=2.0,    # Wait before content capture\n    wait_for=\"css:.dynamic-content\"  # Wait for specific element\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "implementation",
      "relationship_explanation": "AsyncWebCrawler.arun() internally calls the crawl method of its crawler strategy. By default, AsyncWebCrawler instantiates an AsyncPlaywrightCrawlerStrategy, which processes parameters like 'page_timeout', 'delay_before_return_html', and 'wait_for'. This indicates that the waiting and timeout behavior documented is implemented here.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain moves from the document through the AsyncWebCrawler.arun() method to its underlying crawler strategy, AsyncPlaywrightCrawlerStrategy, where the timeout and waiting logic is executed.",
      "ground_truth_relationship": "The code implements the documented timeout and waiting behavior through the smart_wait method, which handles page_timeout for load control and delay_before_return_html for content capture timing, while also supporting CSS selector waiting via wait_for parameter in the crawl method.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Timeouts and Waiting\n\nControl page loading behavior:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    page_timeout=60000,              # Page load timeout (ms)\n    delay_before_return_html=2.0,    # Wait before content capture\n    wait_for=\"css:.dynamic-content\"  # Wait for specific element\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "AsyncPlaywrightCrawlerStrategy extends AsyncCrawlerStrategy, which defines the abstract interface for crawling methods including 'crawl'. This inheritance ensures that the contract for handling timeouts and waiting behavior is maintained across implementations.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain further extends to the abstract base class AsyncCrawlerStrategy, establishing the inheritance relationship that underpins the implementation of the timeouts and waiting functionality.",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class provides the foundation for implementing webpage crawling with timeout and waiting capabilities through its crawl method that accepts **kwargs parameter where timeout and waiting configurations can be passed.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Timeouts and Waiting\n\nControl page loading behavior:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    page_timeout=60000,              # Page load timeout (ms)\n    delay_before_return_html=2.0,    # Wait before content capture\n    wait_for=\"css:.dynamic-content\"  # Wait for specific element\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the final output data after applying the documented timeout and waiting configurations during web crawling, including success status, HTML content, and any error messages that may occur if timeouts are exceeded.",
      "ground_truth_trace_chain": "browser-config.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Timeouts and Waiting\n\nControl page loading behavior:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    page_timeout=60000,              # Page load timeout (ms)\n    delay_before_return_html=2.0,    # Wait before content capture\n    wait_for=\"css:.dynamic-content\"  # Wait for specific element\n)\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The arun() method in AsyncWebCrawler implements the documented timeout and waiting functionality through its **kwargs parameter, which accepts page_timeout, delay_before_return_html, and wait_for settings that are passed to the underlying crawler strategy.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Adjust Thresholds Iteratively**\n   - Start with default values\n   - Adjust based on results\n   - Monitor clustering quality\n\n2. **Choose Appropriate Word Count Thresholds**\n   - Higher for articles (100+)\n   - Lower for reviews/comments (20+)\n   - Medium for product descriptions (50+)\n\n3. **Optimize Performance**\n   ```python\n   strategy = CosineStrategy(\n       word_count_threshold=10,  # Filter early\n       top_k=5,                 # Limit results\n       verbose=True             # Monitor performance\n   )\n   ```\n\n4. **Handle Different Content Types**\n   ```python\n   # For mixed content pages\n   strategy = CosineStrategy(\n       semantic_filter=\"product features\",\n       sim_threshold=0.4,      # More flexible matching\n       max_dist=0.3,          # Larger clusters\n       top_k=3                # Multiple relevant sections\n   )\n   ```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 7,
      "artifact_title": "CosineStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation/usage",
      "relationship_explanation": "The documentation snippet explicitly shows code examples which instantiate and configure CosineStrategy with parameters like word_count_threshold, top_k, verbose, semantic_filter, sim_threshold, and max_dist. This demonstrates direct usage of the CosineStrategy class in the context of adjusting clustering thresholds and performance for content extraction.",
      "predicted_trace_chain": "cosine.md -> CosineStrategy",
      "predicted_trace_chain_explanation": "The trace starts from the document 'cosine.md' (extracted from the location) and directly references the CosineStrategy class as it is instantiated in the provided code examples.",
      "ground_truth_relationship": "The documentation's recommended parameter values for different content types (articles, reviews, comments) are directly implemented in the CosineStrategy class through configurable parameters like word_count_threshold, sim_threshold, and max_dist which control text filtering and clustering behavior.",
      "ground_truth_trace_chain": "cosine.md -> ExtractionStrategy -> CosineStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Best Practices\n\n1. **Adjust Thresholds Iteratively**\n   - Start with default values\n   - Adjust based on results\n   - Monitor clustering quality\n\n2. **Choose Appropriate Word Count Thresholds**\n   - Higher for articles (100+)\n   - Lower for reviews/comments (20+)\n   - Medium for product descriptions (50+)\n\n3. **Optimize Performance**\n   ```python\n   strategy = CosineStrategy(\n       word_count_threshold=10,  # Filter early\n       top_k=5,                 # Limit results\n       verbose=True             # Monitor performance\n   )\n   ```\n\n4. **Handle Different Content Types**\n   ```python\n   # For mixed content pages\n   strategy = CosineStrategy(\n       semantic_filter=\"product features\",\n       sim_threshold=0.4,      # More flexible matching\n       max_dist=0.3,          # Larger clusters\n       top_k=3                # Multiple relevant sections\n   )\n   ```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "CosineStrategy extends ExtractionStrategy, which serves as the foundational base class for extraction strategies. Although ExtractionStrategy isn\u2019t directly mentioned in the snippet, its inclusion is implicit through the inheritance hierarchy that CosineStrategy relies on.",
      "predicted_trace_chain": "cosine.md -> CosineStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain demonstrates that the document references CosineStrategy explicitly, and because CosineStrategy is a subclass of ExtractionStrategy, the dependency continues to ExtractionStrategy, forming the complete trace pathway.",
      "ground_truth_relationship": "The ExtractionStrategy class implements a flexible framework that supports the documented best practices by allowing configurable thresholds, word counts, and optimization parameters through its kwargs constructor parameter.",
      "ground_truth_trace_chain": "cosine.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Authenticated Proxy\n\nUse proxy with authentication:\n\n```python\nproxy_config = {\n    \"server\": \"http://proxy.example.com:8080\",\n    \"username\": \"user\",\n    \"password\": \"pass\"\n}\n\nasync with AsyncWebCrawler(proxy_config=proxy_config) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation and parameter forwarding",
      "relationship_explanation": "The documentation snippet explicitly instantiates AsyncWebCrawler with a 'proxy_config' parameter for authenticated proxy usage.",
      "predicted_trace_chain": "proxy-security.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The document from 'docs/md_v2/advanced/proxy-security.md' directly demonstrates creating an AsyncWebCrawler instance with a proxy configuration.",
      "ground_truth_relationship": "The AsyncWebCrawler class accepts a proxy_config parameter in its initialization which gets passed to the underlying AsyncPlaywrightCrawlerStrategy to enable authenticated proxy connections as demonstrated in the documentation example.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Authenticated Proxy\n\nUse proxy with authentication:\n\n```python\nproxy_config = {\n    \"server\": \"http://proxy.example.com:8080\",\n    \"username\": \"user\",\n    \"password\": \"pass\"\n}\n\nasync with AsyncWebCrawler(proxy_config=proxy_config) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The snippet explicitly calls the 'arun' method on the AsyncWebCrawler instance to perform a crawl operation.",
      "predicted_trace_chain": "proxy-security.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "After instantiating AsyncWebCrawler with authentication parameters, the document calls its 'arun' method to initiate a crawl.",
      "ground_truth_relationship": "The code's arun() method implements proxy support by accepting proxy configuration through its crawler_strategy.crawl() function call, which aligns with the documentation showing how to initialize AsyncWebCrawler with proxy_config for authenticated proxy access.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Authenticated Proxy\n\nUse proxy with authentication:\n\n```python\nproxy_config = {\n    \"server\": \"http://proxy.example.com:8080\",\n    \"username\": \"user\",\n    \"password\": \"pass\"\n}\n\nasync with AsyncWebCrawler(proxy_config=proxy_config) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "parameter forwarding and dependency injection",
      "relationship_explanation": "Although not directly mentioned, AsyncWebCrawler, by default, instantiates AsyncPlaywrightCrawlerStrategy with the kwargs (including 'proxy_config'). This strategy handles proxy authentication internally.",
      "predicted_trace_chain": "proxy-security.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "AsyncWebCrawler forwards the proxy configuration to its default crawler strategy, AsyncPlaywrightCrawlerStrategy, which processes the authenticated proxy settings.",
      "ground_truth_relationship": "The code implements authenticated proxy support by configuring browser_args with ProxySettings containing server, username, and password from the proxy_config dictionary during browser initialization in the start() method.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Authenticated Proxy\n\nUse proxy with authentication:\n\n```python\nproxy_config = {\n    \"server\": \"http://proxy.example.com:8080\",\n    \"username\": \"user\",\n    \"password\": \"pass\"\n}\n\nasync with AsyncWebCrawler(proxy_config=proxy_config) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "AsyncPlaywrightCrawlerStrategy extends AsyncCrawlerStrategy, thus inheriting the standard crawl interface that underpins proxy-based crawling operations.",
      "predicted_trace_chain": "proxy-security.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "The crawling operation relies on the interface defined in AsyncCrawlerStrategy, which is implemented by AsyncPlaywrightCrawlerStrategy that receives the proxy configuration.",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface that enables proxy-authenticated web crawling through its abstract crawl methods, which the documentation demonstrates how to configure using proxy_config.",
      "ground_truth_trace_chain": "proxy-security.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Authenticated Proxy\n\nUse proxy with authentication:\n\n```python\nproxy_config = {\n    \"server\": \"http://proxy.example.com:8080\",\n    \"username\": \"user\",\n    \"password\": \"pass\"\n}\n\nasync with AsyncWebCrawler(proxy_config=proxy_config) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/advanced/proxy-security.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the structure for storing crawling results when making authenticated proxy requests, capturing details like success status, HTML content, and error messages that may occur during proxy-authenticated web requests.",
      "ground_truth_trace_chain": "proxy-security.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### SlidingWindowChunking\n\n`SlidingWindowChunking` uses a sliding window approach to create overlapping chunks. Each chunk has a fixed length, and the window slides by a specified step size.\n\n#### When to Use\n- Ideal for creating overlapping chunks to preserve context.\n- Useful for tasks where context from adjacent chunks is needed.\n\n#### Parameters\n- `window_size` (int, optional): Number of words in each chunk. Default is `100`.\n- `step` (int, optional): Number of words to slide the window. Default is `50`.\n\n#### Example\n```python\nfrom crawl4ai.chunking_strategy import SlidingWindowChunking\n\nchunker = SlidingWindowChunking(window_size=10, step=5)\n\n# Sample text\ntext = \"This is a sample text. It will be split using a sliding window approach to preserve context.\"\n\n# Chunk the text\nchunks = chunker.chunk(text)\nprint(chunks)\n```",
      "document_location": "docs/md_v2/extraction/chunking.md",
      "artifact_id": 27,
      "artifact_title": "SlidingWindowChunking",
      "predicted_relationship": "explicit",
      "relationship_type": "class usage",
      "relationship_explanation": "The documentation snippet explicitly mentions the SlidingWindowChunking class by name. It describes that the class uses a sliding window approach to create overlapping chunks, details its parameters (window_size and step), and shows a usage example that imports and instantiates SlidingWindowChunking.",
      "predicted_trace_chain": "docs/md_v2/extraction/chunking.md -> SlidingWindowChunking",
      "predicted_trace_chain_explanation": "The chain begins from the documentation file 'docs/md_v2/extraction/chunking.md' and directly identifies the SlidingWindowChunking class as documented through its explicit mention and example code.",
      "ground_truth_relationship": "The code implements the sliding window algorithm by using list slicing with window_size and step parameters to create overlapping text chunks, directly corresponding to the documentation's description of a sliding window approach for preserving context.",
      "ground_truth_trace_chain": "chunking.md -> ChunkingStrategy -> SlidingWindowChunking",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### SlidingWindowChunking\n\n`SlidingWindowChunking` uses a sliding window approach to create overlapping chunks. Each chunk has a fixed length, and the window slides by a specified step size.\n\n#### When to Use\n- Ideal for creating overlapping chunks to preserve context.\n- Useful for tasks where context from adjacent chunks is needed.\n\n#### Parameters\n- `window_size` (int, optional): Number of words in each chunk. Default is `100`.\n- `step` (int, optional): Number of words to slide the window. Default is `50`.\n\n#### Example\n```python\nfrom crawl4ai.chunking_strategy import SlidingWindowChunking\n\nchunker = SlidingWindowChunking(window_size=10, step=5)\n\n# Sample text\ntext = \"This is a sample text. It will be split using a sliding window approach to preserve context.\"\n\n# Chunk the text\nchunks = chunker.chunk(text)\nprint(chunks)\n```",
      "document_location": "docs/md_v2/extraction/chunking.md",
      "artifact_id": 6,
      "artifact_title": "ChunkingStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "SlidingWindowChunking is implemented as a subclass of ChunkingStrategy. Although the documentation does not explicitly mention ChunkingStrategy, its presence is inferred since SlidingWindowChunking extends it, indicating that the base functionality for chunking is defined in ChunkingStrategy.",
      "predicted_trace_chain": "docs/md_v2/extraction/chunking.md -> SlidingWindowChunking -> ChunkingStrategy",
      "predicted_trace_chain_explanation": "The pathway starts with the documentation file and moves to SlidingWindowChunking as explicitly referenced, then extends to its base class ChunkingStrategy, demonstrating the inheritance relationship which underpins the documented functionality.",
      "ground_truth_relationship": "The ChunkingStrategy abstract base class defines the core interface through its chunk method that SlidingWindowChunking implements to create overlapping text segments using the sliding window approach.",
      "ground_truth_trace_chain": "chunking.md -> ChunkingStrategy -> ChunkingStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Structured Data Extraction\n\nCrawl4AI offers two powerful approaches for structured data extraction:\n\n### 1. LLM-Based Extraction\n\nUse any LLM (OpenAI, HuggingFace, Ollama, etc.) to extract structured data with high accuracy:\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass KnowledgeGraph(BaseModel):\n    entities: List[dict]\n    relationships: List[dict]\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/nemotron\",  # or \"huggingface/...\", \"ollama/...\"\n    api_token=\"your-token\",   # not needed for Ollama\n    schema=KnowledgeGraph.schema(),\n    instruction=\"Extract entities and relationships from the content\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\nknowledge_graph = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation/import",
      "relationship_explanation": "The documentation snippet explicitly imports and instantiates LLMExtractionStrategy to perform LLM-based extraction of structured data.",
      "predicted_trace_chain": "output-formats.md -> LLMExtractionStrategy",
      "predicted_trace_chain_explanation": "Starting from the document 'output-formats.md', the snippet directly uses LLMExtractionStrategy to set up the extraction strategy.",
      "ground_truth_relationship": "The LLMExtractionStrategy class implements structured data extraction by accepting a provider (like Ollama or HuggingFace), schema, and instruction parameters exactly as shown in the documentation, while handling the internal complexity of chunking, rate limiting, and parallel processing for different LLM providers.",
      "ground_truth_trace_chain": "output-formats.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Structured Data Extraction\n\nCrawl4AI offers two powerful approaches for structured data extraction:\n\n### 1. LLM-Based Extraction\n\nUse any LLM (OpenAI, HuggingFace, Ollama, etc.) to extract structured data with high accuracy:\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass KnowledgeGraph(BaseModel):\n    entities: List[dict]\n    relationships: List[dict]\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/nemotron\",  # or \"huggingface/...\", \"ollama/...\"\n    api_token=\"your-token\",   # not needed for Ollama\n    schema=KnowledgeGraph.schema(),\n    instruction=\"Extract entities and relationships from the content\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\nknowledge_graph = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance/implementation",
      "relationship_explanation": "LLMExtractionStrategy extends the abstract class ExtractionStrategy. Although ExtractionStrategy is not directly mentioned in the snippet, its role is implicit as the base class providing the extraction interface.",
      "predicted_trace_chain": "output-formats.md -> LLMExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain shows that the document leads to the use of LLMExtractionStrategy, which in turn implements the ExtractionStrategy interface.",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the core infrastructure for implementing different extraction methods including the LLM-based extraction shown in the documentation through its abstract extract() method and parallel processing run() method.",
      "ground_truth_trace_chain": "output-formats.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Structured Data Extraction\n\nCrawl4AI offers two powerful approaches for structured data extraction:\n\n### 1. LLM-Based Extraction\n\nUse any LLM (OpenAI, HuggingFace, Ollama, etc.) to extract structured data with high accuracy:\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass KnowledgeGraph(BaseModel):\n    entities: List[dict]\n    relationships: List[dict]\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/nemotron\",  # or \"huggingface/...\", \"ollama/...\"\n    api_token=\"your-token\",   # not needed for Ollama\n    schema=KnowledgeGraph.schema(),\n    instruction=\"Extract entities and relationships from the content\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\nknowledge_graph = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The documentation snippet shows a call to crawler.arun(), which clearly demonstrates the usage of AsyncWebCrawler's arun() method to initiate the crawling process with the configured extraction strategy.",
      "predicted_trace_chain": "output-formats.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain indicates that from 'output-formats.md' the code calls the arun() method, linking the crawling process to the extraction setup.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method implements the documented structured data extraction by accepting an extraction_strategy parameter that can be configured with LLMExtractionStrategy to process crawled content through various LLM providers.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Structured Data Extraction\n\nCrawl4AI offers two powerful approaches for structured data extraction:\n\n### 1. LLM-Based Extraction\n\nUse any LLM (OpenAI, HuggingFace, Ollama, etc.) to extract structured data with high accuracy:\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass KnowledgeGraph(BaseModel):\n    entities: List[dict]\n    relationships: List[dict]\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/nemotron\",  # or \"huggingface/...\", \"ollama/...\"\n    api_token=\"your-token\",   # not needed for Ollama\n    schema=KnowledgeGraph.schema(),\n    instruction=\"Extract entities and relationships from the content\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\nknowledge_graph = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 11,
      "artifact_title": "CrawlResult.extracted_content",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "After the crawl, the snippet accesses the 'extracted_content' attribute of the result, which holds the structured extraction output as a JSON string.",
      "predicted_trace_chain": "output-formats.md -> AsyncWebCrawler.arun() -> CrawlResult.extracted_content",
      "predicted_trace_chain_explanation": "This chain demonstrates that the output from the arun() method is a CrawlResult instance, from which the 'extracted_content' attribute is accessed to retrieve the structured data.",
      "ground_truth_relationship": "The extracted_content field in CrawlResult stores the structured data output produced by LLMExtractionStrategy as a JSON string, which can then be parsed into a Pydantic model.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Structured Data Extraction\n\nCrawl4AI offers two powerful approaches for structured data extraction:\n\n### 1. LLM-Based Extraction\n\nUse any LLM (OpenAI, HuggingFace, Ollama, etc.) to extract structured data with high accuracy:\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass KnowledgeGraph(BaseModel):\n    entities: List[dict]\n    relationships: List[dict]\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/nemotron\",  # or \"huggingface/...\", \"ollama/...\"\n    api_token=\"your-token\",   # not needed for Ollama\n    schema=KnowledgeGraph.schema(),\n    instruction=\"Extract entities and relationships from the content\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\nknowledge_graph = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class captures the LLM extraction output in its extracted_content field, which stores the structured data produced by the LLMExtractionStrategy as documented in the example.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Structured Data Extraction\n\nCrawl4AI offers two powerful approaches for structured data extraction:\n\n### 1. LLM-Based Extraction\n\nUse any LLM (OpenAI, HuggingFace, Ollama, etc.) to extract structured data with high accuracy:\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass KnowledgeGraph(BaseModel):\n    entities: List[dict]\n    relationships: List[dict]\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/nemotron\",  # or \"huggingface/...\", \"ollama/...\"\n    api_token=\"your-token\",   # not needed for Ollama\n    schema=KnowledgeGraph.schema(),\n    instruction=\"Extract entities and relationships from the content\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\nknowledge_graph = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface that enables asynchronous web crawling capabilities needed to support the documented structured data extraction features through its crawl and crawl_many methods.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Structured Data Extraction\n\nCrawl4AI offers two powerful approaches for structured data extraction:\n\n### 1. LLM-Based Extraction\n\nUse any LLM (OpenAI, HuggingFace, Ollama, etc.) to extract structured data with high accuracy:\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass KnowledgeGraph(BaseModel):\n    entities: List[dict]\n    relationships: List[dict]\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/nemotron\",  # or \"huggingface/...\", \"ollama/...\"\n    api_token=\"your-token\",   # not needed for Ollama\n    schema=KnowledgeGraph.schema(),\n    instruction=\"Extract entities and relationships from the content\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\nknowledge_graph = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class provides the foundational web crawling functionality needed to fetch web content that can then be processed by the LLM-based extraction strategy described in the documentation.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Structured Data Extraction\n\nCrawl4AI offers two powerful approaches for structured data extraction:\n\n### 1. LLM-Based Extraction\n\nUse any LLM (OpenAI, HuggingFace, Ollama, etc.) to extract structured data with high accuracy:\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass KnowledgeGraph(BaseModel):\n    entities: List[dict]\n    relationships: List[dict]\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/nemotron\",  # or \"huggingface/...\", \"ollama/...\"\n    api_token=\"your-token\",   # not needed for Ollama\n    schema=KnowledgeGraph.schema(),\n    instruction=\"Extract entities and relationships from the content\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\nknowledge_graph = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the documented LLM-based extraction functionality through its arun() method, which accepts an extraction_strategy parameter that can be set to LLMExtractionStrategy for structured data extraction using various LLM providers.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "Let's break down the key concepts:\n\n### Nested Objects\n\nTo create a nested object, use `\"type\": \"nested\"` and provide a `fields` array for the nested structure:\n\n```python\n{\n    \"name\": \"details\",\n    \"selector\": \"div.product-details\",\n    \"type\": \"nested\",\n    \"fields\": [\n        {\n            \"name\": \"brand\",\n            \"selector\": \"span.brand\",\n            \"type\": \"text\"\n        },\n        {\n            \"name\": \"model\",\n            \"selector\": \"span.model\",\n            \"type\": \"text\"\n        }\n    ]\n}\n```\n\n### Simple Lists\n\nFor a simple list of identical items, use `\"type\": \"list\"`:\n\n```python\n{\n    \"name\": \"features\",\n    \"selector\": \"ul.product-features li\",\n    \"type\": \"list\",\n    \"fields\": [\n        {\n            \"name\": \"feature\",\n            \"type\": \"text\"\n        }\n    ]\n}\n```\n\n### Nested Lists\n\nFor a list of complex objects, use `\"type\": \"nested_list\"`:\n\n```python\n{\n    \"name\": \"products\",\n    \"selector\": \"div.product\",\n    \"type\": \"nested_list\",\n    \"fields\": [\n        // ... fields for each product\n    ]\n}\n```\n\n### Lists of Objects\n\nSimilar to nested lists, but typically used for simpler objects within the list:\n\n```python\n{\n    \"name\": \"related_products\",\n    \"selector\": \"ul.related-products li\",\n    \"type\": \"list\",\n    \"fields\": [\n        {\n            \"name\": \"name\",\n            \"selector\": \"span.related-name\",\n            \"type\": \"text\"\n        },\n        {\n            \"name\": \"price\",\n            \"selector\": \"span.related-price\",\n            \"type\": \"text\"\n        }\n    ]\n}\n```",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "implements extraction logic using JSON schema",
      "relationship_explanation": "The documentation snippet provides examples for defining extraction schemas with keys such as 'type', 'nested', 'list', and 'nested_list'. This schema definition pattern aligns with the functionality provided by the JsonCssExtractionStrategy class, which accepts a schema (including 'fields' definitions) to extract content from HTML documents using CSS selectors. Although the class is not explicitly named in the documentation example, the demonstrated schema structure is implicitly used by JsonCssExtractionStrategy.",
      "predicted_trace_chain": "css-advanced.md -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain starts from the documentation file 'css-advanced.md' (derived from the provided location) which explains the schema format for nested objects and lists. This leads implicitly to the JsonCssExtractionStrategy class, as it is the artifact that implements extraction based on such structured schema definitions.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class implements a BeautifulSoup-based parser that processes nested JSON schemas with CSS selectors to extract structured data according to the documented field types (nested, list, nested_list) and their hierarchical relationships.",
      "ground_truth_trace_chain": "css-advanced.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "Let's break down the key concepts:\n\n### Nested Objects\n\nTo create a nested object, use `\"type\": \"nested\"` and provide a `fields` array for the nested structure:\n\n```python\n{\n    \"name\": \"details\",\n    \"selector\": \"div.product-details\",\n    \"type\": \"nested\",\n    \"fields\": [\n        {\n            \"name\": \"brand\",\n            \"selector\": \"span.brand\",\n            \"type\": \"text\"\n        },\n        {\n            \"name\": \"model\",\n            \"selector\": \"span.model\",\n            \"type\": \"text\"\n        }\n    ]\n}\n```\n\n### Simple Lists\n\nFor a simple list of identical items, use `\"type\": \"list\"`:\n\n```python\n{\n    \"name\": \"features\",\n    \"selector\": \"ul.product-features li\",\n    \"type\": \"list\",\n    \"fields\": [\n        {\n            \"name\": \"feature\",\n            \"type\": \"text\"\n        }\n    ]\n}\n```\n\n### Nested Lists\n\nFor a list of complex objects, use `\"type\": \"nested_list\"`:\n\n```python\n{\n    \"name\": \"products\",\n    \"selector\": \"div.product\",\n    \"type\": \"nested_list\",\n    \"fields\": [\n        // ... fields for each product\n    ]\n}\n```\n\n### Lists of Objects\n\nSimilar to nested lists, but typically used for simpler objects within the list:\n\n```python\n{\n    \"name\": \"related_products\",\n    \"selector\": \"ul.related-products li\",\n    \"type\": \"list\",\n    \"fields\": [\n        {\n            \"name\": \"name\",\n            \"selector\": \"span.related-name\",\n            \"type\": \"text\"\n        },\n        {\n            \"name\": \"price\",\n            \"selector\": \"span.related-price\",\n            \"type\": \"text\"\n        }\n    ]\n}\n```",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_title": "ExtractionStrategy",
      "ground_truth_relationship": "The ExtractionStrategy abstract class provides the core framework for implementing different extraction patterns (nested, list, nested_list) described in the documentation through its extract() method that processes HTML content into structured data blocks.",
      "ground_truth_trace_chain": "css-advanced.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Video and Audio Content\nThe library extracts video and audio elements with their metadata:\n\n```python\n# Process videos\nfor video in result.media[\"videos\"]:\n    print(f\"Video source: {video['src']}\")\n    print(f\"Type: {video['type']}\")\n    print(f\"Duration: {video.get('duration')}\")\n    print(f\"Thumbnail: {video.get('poster')}\")\n\n# Process audio\nfor audio in result.media[\"audios\"]:\n    print(f\"Audio source: {audio['src']}\")\n    print(f\"Type: {audio['type']}\")\n    print(f\"Duration: {audio.get('duration')}\")\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 8,
      "artifact_title": "CrawlResult",
      "predicted_relationship": "explicit",
      "relationship_type": "class usage",
      "relationship_explanation": "The documentation snippet shows code accessing 'result.media', implying that the result object is an instance of the CrawlResult class, which defines a public attribute for storing media elements such as videos and audios.",
      "predicted_trace_chain": "content-processing.md -> CrawlResult",
      "predicted_trace_chain_explanation": "Starting from the 'content-processing.md' documentation snippet, the usage of 'result.media' directly maps to the CrawlResult class, making it the primary artifact representing extracted media content.",
      "ground_truth_relationship": "The CrawlResult class stores video and audio metadata in its media dictionary field, which the documentation demonstrates how to iterate through and access using media['videos'] and media['audios'] paths.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Video and Audio Content\nThe library extracts video and audio elements with their metadata:\n\n```python\n# Process videos\nfor video in result.media[\"videos\"]:\n    print(f\"Video source: {video['src']}\")\n    print(f\"Type: {video['type']}\")\n    print(f\"Duration: {video.get('duration')}\")\n    print(f\"Thumbnail: {video.get('poster')}\")\n\n# Process audio\nfor audio in result.media[\"audios\"]:\n    print(f\"Audio source: {audio['src']}\")\n    print(f\"Type: {audio['type']}\")\n    print(f\"Duration: {audio.get('duration')}\")\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 16,
      "artifact_title": "CrawlResult.media",
      "predicted_relationship": "explicit",
      "relationship_type": "class-level attribute usage",
      "relationship_explanation": "The snippet explicitly iterates over result.media['videos'] and result.media['audios'], which corresponds to the 'media' attribute defined in the CrawlResult class. This attribute is responsible for holding video and audio metadata.",
      "predicted_trace_chain": "content-processing.md -> CrawlResult -> CrawlResult.media",
      "predicted_trace_chain_explanation": "The chain begins with the documentation snippet ('content-processing.md'), which accesses the media contents of the result object. Since the result object is an instance of CrawlResult, and its 'media' attribute (CrawlResult.media) holds the multimedia information, the trace chain proceeds from CrawlResult to its media attribute.",
      "ground_truth_relationship": "The CrawlResult.media dictionary stores extracted video and audio elements as lists of metadata dictionaries, which are then accessed and printed in the documentation example.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult.media",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### [LLM-Based Extraction](llm.md)\n\n`LLMExtractionStrategy` uses Language Models to extract structured data from web content. This approach is highly flexible and can understand content semantically.\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass Product(BaseModel):\n    name: str\n    price: float\n    description: str\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/llama2\",\n    schema=Product.schema(),\n    instruction=\"Extract product details from the page\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/product\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- Complex data structures\n- Content requiring interpretation\n- Flexible content formats\n- Natural language processing",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "implements",
      "relationship_explanation": "The documentation snippet explicitly mentions LLMExtractionStrategy by using backticks and showing its import and instantiation. The code sample passes parameters such as provider, schema, and instruction to LLMExtractionStrategy, indicating it is the class responsible for LLM-based extraction.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> LLMExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain starts from the document 'docs/md_v2/extraction/overview.md'. LLMExtractionStrategy is explicitly highlighted in the snippet, and since it extends ExtractionStrategy (artifact_id 21), the chain includes ExtractionStrategy to reflect the inheritance relationship.",
      "ground_truth_relationship": "The code implements the documented LLM extraction functionality by initializing a strategy with provider, schema, and instruction parameters, then using these to process HTML content through language models to extract structured data according to the specified schema or instructions.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### [LLM-Based Extraction](llm.md)\n\n`LLMExtractionStrategy` uses Language Models to extract structured data from web content. This approach is highly flexible and can understand content semantically.\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass Product(BaseModel):\n    name: str\n    price: float\n    description: str\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/llama2\",\n    schema=Product.schema(),\n    instruction=\"Extract product details from the page\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/product\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- Complex data structures\n- Content requiring interpretation\n- Flexible content formats\n- Natural language processing",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "implicit",
      "relationship_type": "uses",
      "relationship_explanation": "The usage example shows 'crawler.arun()' being called with an extraction_strategy argument. Although the snippet does not explicitly define or import the crawler, this method call implies that the crawling process leverages the extraction strategy. Hence, the call to AsyncWebCrawler.arun() is indirectly linked to the LLM-based extraction functionality.",
      "predicted_trace_chain": "docs/md_v2/extraction/overview.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the document 'docs/md_v2/extraction/overview.md', the code snippet invokes the 'arun()' method, which is provided by AsyncWebCrawler (artifact_id 4) and detailed in its method artifact (artifact_id 5). This chain shows the implicit dependency of the extraction process on the crawler's arun() method.",
      "ground_truth_relationship": "The arun() method implements the core crawling logic that enables the LLMExtractionStrategy to process web content by handling URL fetching, caching, and passing the retrieved HTML to the specified extraction strategy for structured data extraction.",
      "ground_truth_trace_chain": "overview.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### [LLM-Based Extraction](llm.md)\n\n`LLMExtractionStrategy` uses Language Models to extract structured data from web content. This approach is highly flexible and can understand content semantically.\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass Product(BaseModel):\n    name: str\n    price: float\n    description: str\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/llama2\",\n    schema=Product.schema(),\n    instruction=\"Extract product details from the page\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/product\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- Complex data structures\n- Content requiring interpretation\n- Flexible content formats\n- Natural language processing",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class provides fields like extracted_content and metadata to store the structured data obtained through LLMExtractionStrategy's semantic parsing of web content.",
      "ground_truth_trace_chain": "overview.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### [LLM-Based Extraction](llm.md)\n\n`LLMExtractionStrategy` uses Language Models to extract structured data from web content. This approach is highly flexible and can understand content semantically.\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass Product(BaseModel):\n    name: str\n    price: float\n    description: str\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/llama2\",\n    schema=Product.schema(),\n    instruction=\"Extract product details from the page\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/product\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- Complex data structures\n- Content requiring interpretation\n- Flexible content formats\n- Natural language processing",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the web crawling infrastructure that enables the LLMExtractionStrategy to access and retrieve web content before passing it to language models for semantic extraction.",
      "ground_truth_trace_chain": "overview.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### [LLM-Based Extraction](llm.md)\n\n`LLMExtractionStrategy` uses Language Models to extract structured data from web content. This approach is highly flexible and can understand content semantically.\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass Product(BaseModel):\n    name: str\n    price: float\n    description: str\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/llama2\",\n    schema=Product.schema(),\n    instruction=\"Extract product details from the page\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/product\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- Complex data structures\n- Content requiring interpretation\n- Flexible content formats\n- Natural language processing",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements support for the documented LLMExtractionStrategy through its arun() method's extraction_strategy parameter, which processes the extracted content and integrates it with the caching system.",
      "ground_truth_trace_chain": "overview.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### [LLM-Based Extraction](llm.md)\n\n`LLMExtractionStrategy` uses Language Models to extract structured data from web content. This approach is highly flexible and can understand content semantically.\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass Product(BaseModel):\n    name: str\n    price: float\n    description: str\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/llama2\",\n    schema=Product.schema(),\n    instruction=\"Extract product details from the page\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/product\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- Complex data structures\n- Content requiring interpretation\n- Flexible content formats\n- Natural language processing",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "ExtractionStrategy",
      "ground_truth_relationship": "The ExtractionStrategy abstract base class provides the core infrastructure that enables the documented LLMExtractionStrategy to implement flexible content extraction through language models by defining required extract() and run() methods that process HTML content into structured data.",
      "ground_truth_trace_chain": "overview.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### [LLM-Based Extraction](llm.md)\n\n`LLMExtractionStrategy` uses Language Models to extract structured data from web content. This approach is highly flexible and can understand content semantically.\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass Product(BaseModel):\n    name: str\n    price: float\n    description: str\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/llama2\",\n    schema=Product.schema(),\n    instruction=\"Extract product details from the page\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com/product\",\n    extraction_strategy=strategy\n)\n```\n\n**Best for:**\n- Complex data structures\n- Content requiring interpretation\n- Flexible content formats\n- Natural language processing",
      "document_location": "docs/md_v2/extraction/overview.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class provides the foundational methods that the LLMExtractionStrategy needs to crawl web content before performing LLM-based data extraction.",
      "ground_truth_trace_chain": "overview.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Basic Usage\n\nHere's the simplest way to crawl a webpage:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(url=\"https://example.com\")\n        print(result.markdown)  # Print clean markdown content\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "usage/instantiation",
      "relationship_explanation": "The documentation snippet explicitly imports and instantiates the AsyncWebCrawler class using 'async with AsyncWebCrawler() as crawler:', clearly demonstrating its usage as the primary interface for crawling a webpage.",
      "predicted_trace_chain": "docs/md_v2/basic/simple-crawling.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "Starting at the documentation file 'docs/md_v2/basic/simple-crawling.md', the code sample directly references and instantiates the 'AsyncWebCrawler' class.",
      "ground_truth_relationship": "The code implements an AsyncWebCrawler class with an arun method that enables asynchronous web crawling exactly as shown in the basic usage documentation, including the async context manager pattern using __aenter__ and __aexit__ methods.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Basic Usage\n\nHere's the simplest way to crawl a webpage:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(url=\"https://example.com\")\n        print(result.markdown)  # Print clean markdown content\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The snippet calls 'crawler.arun(url=\"https://example.com\")', which clearly demonstrates the use of the 'arun()' method of the AsyncWebCrawler class to perform the crawl operation.",
      "predicted_trace_chain": "docs/md_v2/basic/simple-crawling.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain starts from the basic usage documentation, where an instance of AsyncWebCrawler is created and then its 'arun()' method is invoked to initiate crawling.",
      "ground_truth_relationship": "The code implements the documented basic usage example by providing an async method 'arun()' that accepts a URL parameter and handles web crawling, content extraction, and caching logic to return a CrawlResult object containing the crawled content.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Basic Usage\n\nHere's the simplest way to crawl a webpage:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(url=\"https://example.com\")\n        print(result.markdown)  # Print clean markdown content\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 15,
      "artifact_title": "CrawlResult.markdown",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "After crawling, the code prints 'result.markdown', which accesses the public 'markdown' field of the CrawlResult object that is returned by the 'arun()' method.",
      "predicted_trace_chain": "docs/md_v2/basic/simple-crawling.md -> AsyncWebCrawler.arun() -> CrawlResult.markdown",
      "predicted_trace_chain_explanation": "The chain indicates that the crawl operation via AsyncWebCrawler.arun() returns a CrawlResult, and the 'markdown' attribute of this object is subsequently accessed for displaying the content.",
      "ground_truth_relationship": "The CrawlResult.markdown field stores the cleaned webpage content returned by AsyncWebCrawler.arun() which can be accessed as shown in the basic usage example.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult.markdown",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Basic Usage\n\nHere's the simplest way to crawl a webpage:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(url=\"https://example.com\")\n        print(result.markdown)  # Print clean markdown content\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines all possible return values from the crawler.arun() method shown in the documentation, including the markdown property that's used in the example print statement.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Basic Usage\n\nHere's the simplest way to crawl a webpage:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(url=\"https://example.com\")\n        print(result.markdown)  # Print clean markdown content\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class provides the core implementation for the documented AsyncWebCrawler usage example by managing browser automation, page navigation, and content extraction through the crawl() method that processes the URL parameter shown in the basic usage documentation.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Basic Usage\n\nHere's the simplest way to crawl a webpage:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(url=\"https://example.com\")\n        print(result.markdown)  # Print clean markdown content\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface methods used by the AsyncWebCrawler shown in the basic usage documentation, where crawl() is the underlying method powering the arun() functionality.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Tips for Using JsonCssExtractionStrategy\n\n1. **Inspect the Page**: Use browser developer tools to identify the correct CSS selectors.\n2. **Test Selectors**: Verify your selectors in the browser console before using them in the script.\n3. **Handle Dynamic Content**: If the page uses JavaScript to load content, you may need to combine this with JS execution (see the Advanced Usage section).\n4. **Error Handling**: Always check the `result.success` flag and handle potential failures.",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "class implementation",
      "relationship_explanation": "The documentation snippet is titled 'Tips for Using JsonCssExtractionStrategy' and directly names the JsonCssExtractionStrategy class. This class uses CSS selectors to extract content based on a defined JSON schema and therefore directly implements the functionality described in the tips (such as inspecting and testing CSS selectors for dynamic content).",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "Starting from the documentation file (docs/md_v2/extraction/css.md), the chain directly leads to JsonCssExtractionStrategy because the tips refer explicitly to using this extraction strategy.",
      "ground_truth_relationship": "The code implements a CSS-based extraction strategy that directly aligns with the documentation's tips by using BeautifulSoup selectors to parse HTML elements according to a predefined schema, which explains why the docs emphasize inspecting and testing CSS selectors before use.",
      "ground_truth_trace_chain": "css.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Tips for Using JsonCssExtractionStrategy\n\n1. **Inspect the Page**: Use browser developer tools to identify the correct CSS selectors.\n2. **Test Selectors**: Verify your selectors in the browser console before using them in the script.\n3. **Handle Dynamic Content**: If the page uses JavaScript to load content, you may need to combine this with JS execution (see the Advanced Usage section).\n4. **Error Handling**: Always check the `result.success` flag and handle potential failures.",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "Although not mentioned by name in the snippet, JsonCssExtractionStrategy inherits from ExtractionStrategy. This abstract base class establishes the interface for extraction strategies, which underpins the functionality of JsonCssExtractionStrategy. The documentation\u2019s context on selector-based extraction implicitly relies on this base functionality.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The documentation file leads implicitly to ExtractionStrategy because JsonCssExtractionStrategy is built upon it, forming an essential part of the extraction chain.",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the foundation for implementing JSON/CSS extraction with error handling and parallel processing capabilities that the documentation's tips guide users to properly utilize.",
      "ground_truth_trace_chain": "css.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Tips for Using JsonCssExtractionStrategy\n\n1. **Inspect the Page**: Use browser developer tools to identify the correct CSS selectors.\n2. **Test Selectors**: Verify your selectors in the browser console before using them in the script.\n3. **Handle Dynamic Content**: If the page uses JavaScript to load content, you may need to combine this with JS execution (see the Advanced Usage section).\n4. **Error Handling**: Always check the `result.success` flag and handle potential failures.",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_id": 20,
      "artifact_title": "CrawlResult.success",
      "predicted_relationship": "explicit",
      "relationship_type": "class attribute",
      "relationship_explanation": "The documentation advises that users 'Always check the result.success flag' to handle potential failures. This flag is a public attribute of the result object, defined as CrawlResult.success, and indicates whether a crawl operation succeeded.",
      "predicted_trace_chain": "docs/md_v2/extraction/css.md -> CrawlResult.success",
      "predicted_trace_chain_explanation": "The chain begins at the documentation file and directly points to the CrawlResult.success attribute, which is explicitly mentioned in the documentation as part of the error handling tip.",
      "ground_truth_relationship": "The success boolean flag in CrawlResult directly implements the error handling guidance from the documentation by providing a way to verify if extraction operations completed successfully.",
      "ground_truth_trace_chain": "css.md -> CrawlResult.success",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Tips for Using JsonCssExtractionStrategy\n\n1. **Inspect the Page**: Use browser developer tools to identify the correct CSS selectors.\n2. **Test Selectors**: Verify your selectors in the browser console before using them in the script.\n3. **Handle Dynamic Content**: If the page uses JavaScript to load content, you may need to combine this with JS execution (see the Advanced Usage section).\n4. **Error Handling**: Always check the `result.success` flag and handle potential failures.",
      "document_location": "docs/md_v2/extraction/css.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class implements error handling guidance from the documentation through its 'success' boolean flag and 'error_message' field, allowing developers to check crawl status and handle failures as recommended.",
      "ground_truth_trace_chain": "css.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Fit Markdown: Smart Content Extraction\nOne of Crawl4AI's most powerful features is `fit_markdown`. This feature uses advanced heuristics to identify and extract the main content from a webpage while excluding irrelevant elements.\n\n#### How Fit Markdown Works\n- Analyzes content density and distribution\n- Identifies content patterns and structures\n- Removes boilerplate content (headers, footers, sidebars)\n- Preserves the most relevant content blocks\n- Maintains content hierarchy and formatting\n\n#### Perfect For:\n- Blog posts and articles\n- News content\n- Documentation pages\n- Any page with a clear main content area\n\n#### Not Recommended For:\n- E-commerce product listings\n- Search results pages\n- Social media feeds\n- Pages with multiple equal-weight content sections\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Get the most relevant content\nmain_content = result.fit_markdown\n\n# Compare with regular markdown\nall_content = result.markdown\n\nprint(f\"Fit Markdown Length: {len(main_content)}\")\nprint(f\"Regular Markdown Length: {len(all_content)}\")\n```\n\n#### Example Use Case\n```python\nasync def extract_article_content(url: str) -> str:\n    \"\"\"Extract main article content from a blog or news site.\"\"\"\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(url=url)\n        \n        # fit_markdown will focus on the article content,\n        # excluding navigation, ads, and other distractions\n        return result.fit_markdown\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "class instantiation",
      "relationship_explanation": "The documentation snippet demonstrates the instantiation of an AsyncWebCrawler using a context manager (i.e., 'async with AsyncWebCrawler() as crawler:'), which is an explicit call to create a crawler object.",
      "predicted_trace_chain": "content-processing.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain begins at the documentation file 'content-processing.md', which explicitly creates an instance of AsyncWebCrawler, establishing the starting point for further method calls.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the fit_markdown feature through its aprocess_html method, which extracts and processes the main content using a scraping strategy that identifies and preserves relevant content blocks while excluding boilerplate elements.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Fit Markdown: Smart Content Extraction\nOne of Crawl4AI's most powerful features is `fit_markdown`. This feature uses advanced heuristics to identify and extract the main content from a webpage while excluding irrelevant elements.\n\n#### How Fit Markdown Works\n- Analyzes content density and distribution\n- Identifies content patterns and structures\n- Removes boilerplate content (headers, footers, sidebars)\n- Preserves the most relevant content blocks\n- Maintains content hierarchy and formatting\n\n#### Perfect For:\n- Blog posts and articles\n- News content\n- Documentation pages\n- Any page with a clear main content area\n\n#### Not Recommended For:\n- E-commerce product listings\n- Search results pages\n- Social media feeds\n- Pages with multiple equal-weight content sections\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Get the most relevant content\nmain_content = result.fit_markdown\n\n# Compare with regular markdown\nall_content = result.markdown\n\nprint(f\"Fit Markdown Length: {len(main_content)}\")\nprint(f\"Regular Markdown Length: {len(all_content)}\")\n```\n\n#### Example Use Case\n```python\nasync def extract_article_content(url: str) -> str:\n    \"\"\"Extract main article content from a blog or news site.\"\"\"\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(url=url)\n        \n        # fit_markdown will focus on the article content,\n        # excluding navigation, ads, and other distractions\n        return result.fit_markdown\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "In the code examples, the 'arun()' method is directly called on the crawler instance (result = await crawler.arun(url=...)), making it an explicitly referenced method that performs the crawl action.",
      "predicted_trace_chain": "content-processing.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the documentation file, the chain follows the use of the AsyncWebCrawler instance to invoke its 'arun()' method, which is the key operation for content extraction.",
      "ground_truth_relationship": "The code implements the AsyncWebCrawler.arun() method that processes webpage content and enables the fit_markdown feature by passing the crawled HTML through extraction and chunking strategies to identify relevant content blocks while filtering out boilerplate elements.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Fit Markdown: Smart Content Extraction\nOne of Crawl4AI's most powerful features is `fit_markdown`. This feature uses advanced heuristics to identify and extract the main content from a webpage while excluding irrelevant elements.\n\n#### How Fit Markdown Works\n- Analyzes content density and distribution\n- Identifies content patterns and structures\n- Removes boilerplate content (headers, footers, sidebars)\n- Preserves the most relevant content blocks\n- Maintains content hierarchy and formatting\n\n#### Perfect For:\n- Blog posts and articles\n- News content\n- Documentation pages\n- Any page with a clear main content area\n\n#### Not Recommended For:\n- E-commerce product listings\n- Search results pages\n- Social media feeds\n- Pages with multiple equal-weight content sections\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Get the most relevant content\nmain_content = result.fit_markdown\n\n# Compare with regular markdown\nall_content = result.markdown\n\nprint(f\"Fit Markdown Length: {len(main_content)}\")\nprint(f\"Regular Markdown Length: {len(all_content)}\")\n```\n\n#### Example Use Case\n```python\nasync def extract_article_content(url: str) -> str:\n    \"\"\"Extract main article content from a blog or news site.\"\"\"\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(url=url)\n        \n        # fit_markdown will focus on the article content,\n        # excluding navigation, ads, and other distractions\n        return result.fit_markdown\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 12,
      "artifact_title": "CrawlResult.fit_markdown",
      "predicted_relationship": "explicit",
      "relationship_type": "class attribute access",
      "relationship_explanation": "The snippet accesses the 'fit_markdown' attribute of the result object (main_content = result.fit_markdown) to retrieve the optimized, filtered main content extracted by Crawl4AI, making it an explicit feature described in the documentation.",
      "predicted_trace_chain": "content-processing.md -> AsyncWebCrawler.arun() -> CrawlResult.fit_markdown",
      "predicted_trace_chain_explanation": "After invoking 'arun()', the returned CrawlResult object provides the 'fit_markdown' property. The chain clearly shows that the documentation\u2019s use of 'fit_markdown' is a consequence of the crawling operation performed by AsyncWebCrawler.arun().",
      "ground_truth_relationship": "The CrawlResult class defines fit_markdown as an optional string property that stores the extracted main content after applying content extraction heuristics to remove boilerplate elements from webpages.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult.fit_markdown",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Fit Markdown: Smart Content Extraction\nOne of Crawl4AI's most powerful features is `fit_markdown`. This feature uses advanced heuristics to identify and extract the main content from a webpage while excluding irrelevant elements.\n\n#### How Fit Markdown Works\n- Analyzes content density and distribution\n- Identifies content patterns and structures\n- Removes boilerplate content (headers, footers, sidebars)\n- Preserves the most relevant content blocks\n- Maintains content hierarchy and formatting\n\n#### Perfect For:\n- Blog posts and articles\n- News content\n- Documentation pages\n- Any page with a clear main content area\n\n#### Not Recommended For:\n- E-commerce product listings\n- Search results pages\n- Social media feeds\n- Pages with multiple equal-weight content sections\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Get the most relevant content\nmain_content = result.fit_markdown\n\n# Compare with regular markdown\nall_content = result.markdown\n\nprint(f\"Fit Markdown Length: {len(main_content)}\")\nprint(f\"Regular Markdown Length: {len(all_content)}\")\n```\n\n#### Example Use Case\n```python\nasync def extract_article_content(url: str) -> str:\n    \"\"\"Extract main article content from a blog or news site.\"\"\"\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(url=url)\n        \n        # fit_markdown will focus on the article content,\n        # excluding navigation, ads, and other distractions\n        return result.fit_markdown\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 15,
      "artifact_title": "CrawlResult.markdown",
      "predicted_relationship": "explicit",
      "relationship_type": "class attribute access",
      "relationship_explanation": "The 'markdown' attribute, accessed via 'result.markdown', is used in the examples to compare the regular content extraction with the enhanced 'fit_markdown' output, making its use explicitly evident in the documentation.",
      "predicted_trace_chain": "content-processing.md -> AsyncWebCrawler.arun() -> CrawlResult.markdown",
      "predicted_trace_chain_explanation": "This chain illustrates that after executing AsyncWebCrawler.arun(), the CrawlResult object provides both 'markdown' and 'fit_markdown', with the documentation explicitly contrasting these attributes to highlight the effectiveness of the fit_markdown feature.",
      "ground_truth_relationship": "The markdown property serves as the base text extraction method that captures all webpage content, contrasting with fit_markdown which provides filtered, relevant content only.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult.markdown",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Fit Markdown: Smart Content Extraction\nOne of Crawl4AI's most powerful features is `fit_markdown`. This feature uses advanced heuristics to identify and extract the main content from a webpage while excluding irrelevant elements.\n\n#### How Fit Markdown Works\n- Analyzes content density and distribution\n- Identifies content patterns and structures\n- Removes boilerplate content (headers, footers, sidebars)\n- Preserves the most relevant content blocks\n- Maintains content hierarchy and formatting\n\n#### Perfect For:\n- Blog posts and articles\n- News content\n- Documentation pages\n- Any page with a clear main content area\n\n#### Not Recommended For:\n- E-commerce product listings\n- Search results pages\n- Social media feeds\n- Pages with multiple equal-weight content sections\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Get the most relevant content\nmain_content = result.fit_markdown\n\n# Compare with regular markdown\nall_content = result.markdown\n\nprint(f\"Fit Markdown Length: {len(main_content)}\")\nprint(f\"Regular Markdown Length: {len(all_content)}\")\n```\n\n#### Example Use Case\n```python\nasync def extract_article_content(url: str) -> str:\n    \"\"\"Extract main article content from a blog or news site.\"\"\"\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(url=url)\n        \n        # fit_markdown will focus on the article content,\n        # excluding navigation, ads, and other distractions\n        return result.fit_markdown\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class implements the fit_markdown feature through a dedicated string field that stores the extracted main content after applying heuristic filtering to remove boilerplate elements from the full markdown content.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Fit Markdown: Smart Content Extraction\nOne of Crawl4AI's most powerful features is `fit_markdown`. This feature uses advanced heuristics to identify and extract the main content from a webpage while excluding irrelevant elements.\n\n#### How Fit Markdown Works\n- Analyzes content density and distribution\n- Identifies content patterns and structures\n- Removes boilerplate content (headers, footers, sidebars)\n- Preserves the most relevant content blocks\n- Maintains content hierarchy and formatting\n\n#### Perfect For:\n- Blog posts and articles\n- News content\n- Documentation pages\n- Any page with a clear main content area\n\n#### Not Recommended For:\n- E-commerce product listings\n- Search results pages\n- Social media feeds\n- Pages with multiple equal-weight content sections\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Get the most relevant content\nmain_content = result.fit_markdown\n\n# Compare with regular markdown\nall_content = result.markdown\n\nprint(f\"Fit Markdown Length: {len(main_content)}\")\nprint(f\"Regular Markdown Length: {len(all_content)}\")\n```\n\n#### Example Use Case\n```python\nasync def extract_article_content(url: str) -> str:\n    \"\"\"Extract main article content from a blog or news site.\"\"\"\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(url=url)\n        \n        # fit_markdown will focus on the article content,\n        # excluding navigation, ads, and other distractions\n        return result.fit_markdown\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the fit_markdown functionality through its content extraction methods, particularly in the crawl() method which handles page loading and content processing to enable smart content identification while removing unwanted elements through remove_overlay_elements().",
      "ground_truth_trace_chain": "content-processing.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Fit Markdown: Smart Content Extraction\nOne of Crawl4AI's most powerful features is `fit_markdown`. This feature uses advanced heuristics to identify and extract the main content from a webpage while excluding irrelevant elements.\n\n#### How Fit Markdown Works\n- Analyzes content density and distribution\n- Identifies content patterns and structures\n- Removes boilerplate content (headers, footers, sidebars)\n- Preserves the most relevant content blocks\n- Maintains content hierarchy and formatting\n\n#### Perfect For:\n- Blog posts and articles\n- News content\n- Documentation pages\n- Any page with a clear main content area\n\n#### Not Recommended For:\n- E-commerce product listings\n- Search results pages\n- Social media feeds\n- Pages with multiple equal-weight content sections\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Get the most relevant content\nmain_content = result.fit_markdown\n\n# Compare with regular markdown\nall_content = result.markdown\n\nprint(f\"Fit Markdown Length: {len(main_content)}\")\nprint(f\"Regular Markdown Length: {len(all_content)}\")\n```\n\n#### Example Use Case\n```python\nasync def extract_article_content(url: str) -> str:\n    \"\"\"Extract main article content from a blog or news site.\"\"\"\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(url=url)\n        \n        # fit_markdown will focus on the article content,\n        # excluding navigation, ads, and other distractions\n        return result.fit_markdown\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the core interface methods that enable the fit_markdown functionality through its crawl() method, which returns AsyncCrawlResponse objects containing the extracted content.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Iframe Content\n\nProcess content inside iframes:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    process_iframes=True,  # Extract iframe content\n    remove_overlay_elements=True  # Remove popups/modals that might block iframes\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "usage",
      "relationship_explanation": "The documentation snippet shows a direct invocation of 'crawler.arun()' with keyword arguments (process_iframes=True and remove_overlay_elements=True). This call maps explicitly to the 'AsyncWebCrawler.arun()' method implementation.",
      "predicted_trace_chain": "content-selection.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The document (content-selection.md) explicitly calls the 'arun()' method of the crawler object, which is implemented in 'AsyncWebCrawler.arun()', making it the direct entry point for the described functionality.",
      "ground_truth_relationship": "The arun() method implements iframe processing through its kwargs parameter, which accepts process_iframes and remove_overlay_elements options that are passed to the crawler_strategy.crawl() function.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Iframe Content\n\nProcess content inside iframes:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    process_iframes=True,  # Extract iframe content\n    remove_overlay_elements=True  # Remove popups/modals that might block iframes\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "implements",
      "relationship_explanation": "The options 'process_iframes=True' and 'remove_overlay_elements=True' passed to 'crawler.arun()' are handled internally by the crawl method of the distributed crawler strategy. 'AsyncPlaywrightCrawlerStrategy' (used by AsyncWebCrawler by default) implements logic to process iframe content and remove intrusive overlay elements, though it is not directly mentioned in the snippet.",
      "predicted_trace_chain": "content-selection.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The explicit call to 'AsyncWebCrawler.arun()' delegates the crawling work to its underlying strategy, 'AsyncPlaywrightCrawlerStrategy', which contains the implementations for processing iframes and removing overlays, thereby forming the implicit traceability path.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements iframe content processing through its process_iframes method, which locates iframes, extracts their content, and replaces them with div elements containing the extracted content when process_iframes=True is passed to the crawl method.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Iframe Content\n\nProcess content inside iframes:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    process_iframes=True,  # Extract iframe content\n    remove_overlay_elements=True  # Remove popups/modals that might block iframes\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class provides fields for storing iframe-processed content through its html, cleaned_html, and extracted_content attributes which can contain the processed iframe results when process_iframes=True is set.",
      "ground_truth_trace_chain": "content-selection.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Iframe Content\n\nProcess content inside iframes:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    process_iframes=True,  # Extract iframe content\n    remove_overlay_elements=True  # Remove popups/modals that might block iframes\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class provides the crawl method that implements the iframe processing capabilities documented in the example through its **kwargs parameter, which can accept process_iframes and remove_overlay_elements flags.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Iframe Content\n\nProcess content inside iframes:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    process_iframes=True,  # Extract iframe content\n    remove_overlay_elements=True  # Remove popups/modals that might block iframes\n)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements iframe processing through its arun() method which accepts process_iframes and remove_overlay_elements parameters to control iframe content extraction and overlay handling during web crawling.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Complex Interactions Example\n\nHere's an example of handling a dynamic page with multiple interactions:\n\n```python\nasync def crawl_dynamic_content():\n    async with AsyncWebCrawler() as crawler:\n        # Initial page load\n        result = await crawler.arun(\n            url=\"https://example.com\",\n            # Handle cookie consent\n            js_code=\"document.querySelector('.cookie-accept')?.click();\",\n            wait_for=\"css:.main-content\"\n        )\n\n        # Load more content\n        session_id = \"dynamic_session\"  # Keep session for multiple interactions\n        \n        for page in range(3):  # Load 3 pages of content\n            result = await crawler.arun(\n                url=\"https://example.com\",\n                session_id=session_id,\n                js_code=[\n                    # Scroll to bottom\n                    \"window.scrollTo(0, document.body.scrollHeight);\",\n                    # Store current item count\n                    \"window.previousCount = document.querySelectorAll('.item').length;\",\n                    # Click load more\n                    \"document.querySelector('.load-more')?.click();\"\n                ],\n                # Wait for new items\n                wait_for=\"\"\"() => {\n                    const currentCount = document.querySelectorAll('.item').length;\n                    return currentCount > window.previousCount;\n                }\"\"\",\n                # Only execute JS without reloading page\n                js_only=True if page > 0 else False\n            )\n            \n            # Process content after each load\n            print(f\"Page {page + 1} items:\", len(result.cleaned_html))\n            \n        # Clean up session\n        await crawler.crawler_strategy.kill_session(session_id)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation/usage",
      "relationship_explanation": "The documentation snippet begins with 'async with AsyncWebCrawler() as crawler:', explicitly instantiating the AsyncWebCrawler class to manage crawling sessions.",
      "predicted_trace_chain": "page-interaction.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The document 'page-interaction.md' directly shows the initialization of AsyncWebCrawler, establishing it as the starting point for all subsequent interactions.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the documented complex page interactions through its arun method, which supports session management, JavaScript execution, and dynamic content loading through parameters like session_id, js_code, and wait_for as shown in the example.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Complex Interactions Example\n\nHere's an example of handling a dynamic page with multiple interactions:\n\n```python\nasync def crawl_dynamic_content():\n    async with AsyncWebCrawler() as crawler:\n        # Initial page load\n        result = await crawler.arun(\n            url=\"https://example.com\",\n            # Handle cookie consent\n            js_code=\"document.querySelector('.cookie-accept')?.click();\",\n            wait_for=\"css:.main-content\"\n        )\n\n        # Load more content\n        session_id = \"dynamic_session\"  # Keep session for multiple interactions\n        \n        for page in range(3):  # Load 3 pages of content\n            result = await crawler.arun(\n                url=\"https://example.com\",\n                session_id=session_id,\n                js_code=[\n                    # Scroll to bottom\n                    \"window.scrollTo(0, document.body.scrollHeight);\",\n                    # Store current item count\n                    \"window.previousCount = document.querySelectorAll('.item').length;\",\n                    # Click load more\n                    \"document.querySelector('.load-more')?.click();\"\n                ],\n                # Wait for new items\n                wait_for=\"\"\"() => {\n                    const currentCount = document.querySelectorAll('.item').length;\n                    return currentCount > window.previousCount;\n                }\"\"\",\n                # Only execute JS without reloading page\n                js_only=True if page > 0 else False\n            )\n            \n            # Process content after each load\n            print(f\"Page {page + 1} items:\", len(result.cleaned_html))\n            \n        # Clean up session\n        await crawler.crawler_strategy.kill_session(session_id)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The example calls 'await crawler.arun(...)' for both initial page load and subsequent dynamic interactions. The method is invoked with parameters like 'js_code', 'wait_for', 'session_id', and 'js_only' to handle complex page behaviors.",
      "predicted_trace_chain": "page-interaction.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the AsyncWebCrawler instance created in the document, the arun() method is used to perform the crawling operation with dynamic interactions, making it a key link in the chain.",
      "ground_truth_relationship": "The arun() method implements the documented dynamic page crawling by accepting parameters for URL, JavaScript code execution, session management, and wait conditions, which enables the complex interactions shown in the example like handling cookie consent and infinite scroll pagination.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Complex Interactions Example\n\nHere's an example of handling a dynamic page with multiple interactions:\n\n```python\nasync def crawl_dynamic_content():\n    async with AsyncWebCrawler() as crawler:\n        # Initial page load\n        result = await crawler.arun(\n            url=\"https://example.com\",\n            # Handle cookie consent\n            js_code=\"document.querySelector('.cookie-accept')?.click();\",\n            wait_for=\"css:.main-content\"\n        )\n\n        # Load more content\n        session_id = \"dynamic_session\"  # Keep session for multiple interactions\n        \n        for page in range(3):  # Load 3 pages of content\n            result = await crawler.arun(\n                url=\"https://example.com\",\n                session_id=session_id,\n                js_code=[\n                    # Scroll to bottom\n                    \"window.scrollTo(0, document.body.scrollHeight);\",\n                    # Store current item count\n                    \"window.previousCount = document.querySelectorAll('.item').length;\",\n                    # Click load more\n                    \"document.querySelector('.load-more')?.click();\"\n                ],\n                # Wait for new items\n                wait_for=\"\"\"() => {\n                    const currentCount = document.querySelectorAll('.item').length;\n                    return currentCount > window.previousCount;\n                }\"\"\",\n                # Only execute JS without reloading page\n                js_only=True if page > 0 else False\n            )\n            \n            # Process content after each load\n            print(f\"Page {page + 1} items:\", len(result.cleaned_html))\n            \n        # Clean up session\n        await crawler.crawler_strategy.kill_session(session_id)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 9,
      "artifact_title": "CrawlResult.cleaned_html",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet accesses 'result.cleaned_html' (via 'len(result.cleaned_html)') to process and print the number of items loaded, indicating the use of the cleaned_html property from the crawl result.",
      "predicted_trace_chain": "page-interaction.md -> AsyncWebCrawler -> AsyncWebCrawler.arun() -> CrawlResult.cleaned_html",
      "predicted_trace_chain_explanation": "The result returned by AsyncWebCrawler.arun() is an instance of CrawlResult, and its 'cleaned_html' attribute is used explicitly in the document to verify the outcome of the crawl.",
      "ground_truth_relationship": "The cleaned_html attribute stores the processed HTML content after each dynamic page load iteration as shown in the example where it's used to track the number of loaded items.",
      "ground_truth_trace_chain": "page-interaction.md -> CrawlResult.cleaned_html",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Complex Interactions Example\n\nHere's an example of handling a dynamic page with multiple interactions:\n\n```python\nasync def crawl_dynamic_content():\n    async with AsyncWebCrawler() as crawler:\n        # Initial page load\n        result = await crawler.arun(\n            url=\"https://example.com\",\n            # Handle cookie consent\n            js_code=\"document.querySelector('.cookie-accept')?.click();\",\n            wait_for=\"css:.main-content\"\n        )\n\n        # Load more content\n        session_id = \"dynamic_session\"  # Keep session for multiple interactions\n        \n        for page in range(3):  # Load 3 pages of content\n            result = await crawler.arun(\n                url=\"https://example.com\",\n                session_id=session_id,\n                js_code=[\n                    # Scroll to bottom\n                    \"window.scrollTo(0, document.body.scrollHeight);\",\n                    # Store current item count\n                    \"window.previousCount = document.querySelectorAll('.item').length;\",\n                    # Click load more\n                    \"document.querySelector('.load-more')?.click();\"\n                ],\n                # Wait for new items\n                wait_for=\"\"\"() => {\n                    const currentCount = document.querySelectorAll('.item').length;\n                    return currentCount > window.previousCount;\n                }\"\"\",\n                # Only execute JS without reloading page\n                js_only=True if page > 0 else False\n            )\n            \n            # Process content after each load\n            print(f\"Page {page + 1} items:\", len(result.cleaned_html))\n            \n        # Clean up session\n        await crawler.crawler_strategy.kill_session(session_id)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 2,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "At the end of the example, 'await crawler.crawler_strategy.kill_session(session_id)' is called to clean up the session. This shows an explicit invocation of the kill_session() method to terminate an ongoing session in dynamic interactions.",
      "predicted_trace_chain": "page-interaction.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_trace_chain_explanation": "After using the AsyncWebCrawler instance for dynamic content loading, the document calls the kill_session() method (inherited from AsyncPlaywrightCrawlerStrategy) to properly release session resources, completing the interaction chain.",
      "ground_truth_relationship": "The kill_session method is used at the end of the complex interaction example to clean up browser resources by closing the page and context objects associated with a specific session_id, preventing memory leaks during multi-page dynamic content crawling.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Complex Interactions Example\n\nHere's an example of handling a dynamic page with multiple interactions:\n\n```python\nasync def crawl_dynamic_content():\n    async with AsyncWebCrawler() as crawler:\n        # Initial page load\n        result = await crawler.arun(\n            url=\"https://example.com\",\n            # Handle cookie consent\n            js_code=\"document.querySelector('.cookie-accept')?.click();\",\n            wait_for=\"css:.main-content\"\n        )\n\n        # Load more content\n        session_id = \"dynamic_session\"  # Keep session for multiple interactions\n        \n        for page in range(3):  # Load 3 pages of content\n            result = await crawler.arun(\n                url=\"https://example.com\",\n                session_id=session_id,\n                js_code=[\n                    # Scroll to bottom\n                    \"window.scrollTo(0, document.body.scrollHeight);\",\n                    # Store current item count\n                    \"window.previousCount = document.querySelectorAll('.item').length;\",\n                    # Click load more\n                    \"document.querySelector('.load-more')?.click();\"\n                ],\n                # Wait for new items\n                wait_for=\"\"\"() => {\n                    const currentCount = document.querySelectorAll('.item').length;\n                    return currentCount > window.previousCount;\n                }\"\"\",\n                # Only execute JS without reloading page\n                js_only=True if page > 0 else False\n            )\n            \n            # Process content after each load\n            print(f\"Page {page + 1} items:\", len(result.cleaned_html))\n            \n        # Clean up session\n        await crawler.crawler_strategy.kill_session(session_id)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the data structure that stores and organizes the crawled content, headers, and metadata returned by each crawler.arun() call in the documented dynamic content crawling example.",
      "ground_truth_trace_chain": "page-interaction.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Complex Interactions Example\n\nHere's an example of handling a dynamic page with multiple interactions:\n\n```python\nasync def crawl_dynamic_content():\n    async with AsyncWebCrawler() as crawler:\n        # Initial page load\n        result = await crawler.arun(\n            url=\"https://example.com\",\n            # Handle cookie consent\n            js_code=\"document.querySelector('.cookie-accept')?.click();\",\n            wait_for=\"css:.main-content\"\n        )\n\n        # Load more content\n        session_id = \"dynamic_session\"  # Keep session for multiple interactions\n        \n        for page in range(3):  # Load 3 pages of content\n            result = await crawler.arun(\n                url=\"https://example.com\",\n                session_id=session_id,\n                js_code=[\n                    # Scroll to bottom\n                    \"window.scrollTo(0, document.body.scrollHeight);\",\n                    # Store current item count\n                    \"window.previousCount = document.querySelectorAll('.item').length;\",\n                    # Click load more\n                    \"document.querySelector('.load-more')?.click();\"\n                ],\n                # Wait for new items\n                wait_for=\"\"\"() => {\n                    const currentCount = document.querySelectorAll('.item').length;\n                    return currentCount > window.previousCount;\n                }\"\"\",\n                # Only execute JS without reloading page\n                js_only=True if page > 0 else False\n            )\n            \n            # Process content after each load\n            print(f\"Page {page + 1} items:\", len(result.cleaned_html))\n            \n        # Clean up session\n        await crawler.crawler_strategy.kill_session(session_id)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the complex interaction example by providing methods like crawl() and smart_wait() that handle dynamic page loading, cookie consent, session management, and JavaScript execution as shown in the documentation's crawl_dynamic_content() example.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Complex Interactions Example\n\nHere's an example of handling a dynamic page with multiple interactions:\n\n```python\nasync def crawl_dynamic_content():\n    async with AsyncWebCrawler() as crawler:\n        # Initial page load\n        result = await crawler.arun(\n            url=\"https://example.com\",\n            # Handle cookie consent\n            js_code=\"document.querySelector('.cookie-accept')?.click();\",\n            wait_for=\"css:.main-content\"\n        )\n\n        # Load more content\n        session_id = \"dynamic_session\"  # Keep session for multiple interactions\n        \n        for page in range(3):  # Load 3 pages of content\n            result = await crawler.arun(\n                url=\"https://example.com\",\n                session_id=session_id,\n                js_code=[\n                    # Scroll to bottom\n                    \"window.scrollTo(0, document.body.scrollHeight);\",\n                    # Store current item count\n                    \"window.previousCount = document.querySelectorAll('.item').length;\",\n                    # Click load more\n                    \"document.querySelector('.load-more')?.click();\"\n                ],\n                # Wait for new items\n                wait_for=\"\"\"() => {\n                    const currentCount = document.querySelectorAll('.item').length;\n                    return currentCount > window.previousCount;\n                }\"\"\",\n                # Only execute JS without reloading page\n                js_only=True if page > 0 else False\n            )\n            \n            # Process content after each load\n            print(f\"Page {page + 1} items:\", len(result.cleaned_html))\n            \n        # Clean up session\n        await crawler.crawler_strategy.kill_session(session_id)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the essential interface methods used by the documented complex interaction example, particularly through its crawl method that enables the dynamic page interactions shown in the crawl_dynamic_content function.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Tips for Advanced Usage\n\n1. **Start Simple**: Begin with a basic schema and gradually add complexity.\n2. **Test Incrementally**: Test each part of your schema separately before combining them.\n3. **Use Chrome DevTools**: The Element Inspector is invaluable for identifying the correct selectors.\n4. **Handle Missing Data**: Use the `default` key in your field definitions to handle cases where data might be missing.\n5. **Leverage Transforms**: Use the `transform` key to clean or format extracted data (e.g., converting prices to numbers).\n6. **Consider Performance**: Very complex schemas might slow down extraction. Balance complexity with performance needs.\n\nBy mastering these advanced techniques, you can use JsonCssExtractionStrategy to extract highly structured data from even the most complex web pages, making it a powerful tool for web scraping and data analysis tasks.",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "implements",
      "relationship_explanation": "The documentation snippet explicitly mentions JsonCssExtractionStrategy as the recommended tool to 'extract highly structured data' from complex web pages. It also advises users to start with a basic schema and use keys like 'default' and 'transform', which are features supported by the JsonCssExtractionStrategy implementation.",
      "predicted_trace_chain": "css-advanced.md -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain begins with the document 'css-advanced.md' (the file from which the documentation snippet is extracted) and directly points to the JsonCssExtractionStrategy, which is explicitly referenced as the advanced extraction method.",
      "ground_truth_relationship": "The code implements a CSS-based data extraction strategy that directly supports the documented tips, particularly the 'Start Simple' and 'Test Incrementally' recommendations by allowing users to define and process schemas gradually through the schema parameter.",
      "ground_truth_trace_chain": "css-advanced.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Tips for Advanced Usage\n\n1. **Start Simple**: Begin with a basic schema and gradually add complexity.\n2. **Test Incrementally**: Test each part of your schema separately before combining them.\n3. **Use Chrome DevTools**: The Element Inspector is invaluable for identifying the correct selectors.\n4. **Handle Missing Data**: Use the `default` key in your field definitions to handle cases where data might be missing.\n5. **Leverage Transforms**: Use the `transform` key to clean or format extracted data (e.g., converting prices to numbers).\n6. **Consider Performance**: Very complex schemas might slow down extraction. Balance complexity with performance needs.\n\nBy mastering these advanced techniques, you can use JsonCssExtractionStrategy to extract highly structured data from even the most complex web pages, making it a powerful tool for web scraping and data analysis tasks.",
      "document_location": "docs/md_v2/extraction/css-advanced.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "JsonCssExtractionStrategy is a subclass of ExtractionStrategy. Although ExtractionStrategy is not mentioned directly in the text snippet, its presence is implicit because any use of JsonCssExtractionStrategy automatically involves its base class, which defines the extraction interface and underlying schema handling.",
      "predicted_trace_chain": "css-advanced.md -> JsonCssExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "Starting from the document 'css-advanced.md', the documentation explicitly points to JsonCssExtractionStrategy. Following the inheritance hierarchy, JsonCssExtractionStrategy extends ExtractionStrategy. This chain emphasizes the dependency and design flow within the code.",
      "ground_truth_relationship": "The ExtractionStrategy base class implements the parallel processing functionality mentioned in the 'Consider Performance' tip by using ThreadPoolExecutor to handle complex data extraction tasks efficiently.",
      "ground_truth_trace_chain": "css-advanced.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Manual Anti-Bot Options\n\nWhile Magic Mode is recommended, you can also configure individual anti-detection features:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    simulate_user=True,        # Simulate human behavior\n    override_navigator=True    # Mask automation signals\n)\n```\n\nNote: When `magic=True` is used, you don't need to set these individual options.\n",
      "document_location": "docs/md_v2/advanced/magic-mode.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "usage",
      "relationship_explanation": "The documentation snippet directly demonstrates the use of the 'arun' method by invoking 'crawler.arun()' with the anti-detection parameters 'simulate_user' and 'override_navigator'. This explicit usage maps to the AsyncWebCrawler.arun() method.",
      "predicted_trace_chain": "docs/md_v2/advanced/magic-mode.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the documentation file, the example call to crawler.arun() directly maps to the AsyncWebCrawler.arun() artifact, establishing the primary entry point for anti-bot configuration.",
      "ground_truth_relationship": "The arun() method accepts keyword arguments like simulate_user and override_navigator which enable fine-grained control over anti-bot features as documented in the Manual Anti-Bot Options section.",
      "ground_truth_trace_chain": "magic-mode.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Manual Anti-Bot Options\n\nWhile Magic Mode is recommended, you can also configure individual anti-detection features:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    simulate_user=True,        # Simulate human behavior\n    override_navigator=True    # Mask automation signals\n)\n```\n\nNote: When `magic=True` is used, you don't need to set these individual options.\n",
      "document_location": "docs/md_v2/advanced/magic-mode.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "implementation",
      "relationship_explanation": "Although not explicitly mentioned in the snippet, AsyncWebCrawler.arun() internally calls the crawl method of its default strategy, AsyncPlaywrightCrawlerStrategy. This class processes the parameters 'simulate_user' and 'override_navigator', implementing the manual anti-bot options described in the documentation.",
      "predicted_trace_chain": "docs/md_v2/advanced/magic-mode.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain illustrates that the documented usage of arun() leads to the default crawling strategy, AsyncPlaywrightCrawlerStrategy, which is responsible for handling the anti-detection configurations.",
      "ground_truth_relationship": "The code implements manual anti-bot options through parameters like simulate_user and override_navigator in the crawl method, which inject scripts to override navigator properties and simulate user interactions when these flags are set to true.",
      "ground_truth_trace_chain": "magic-mode.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Manual Anti-Bot Options\n\nWhile Magic Mode is recommended, you can also configure individual anti-detection features:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    simulate_user=True,        # Simulate human behavior\n    override_navigator=True    # Mask automation signals\n)\n```\n\nNote: When `magic=True` is used, you don't need to set these individual options.\n",
      "document_location": "docs/md_v2/advanced/magic-mode.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "AsyncPlaywrightCrawlerStrategy extends AsyncCrawlerStrategy, which serves as the abstract base defining the crawling interface, including how anti-bot parameters might be handled. This establishes the underlying architectural design for crawler strategies.",
      "predicted_trace_chain": "docs/md_v2/advanced/magic-mode.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "This trace chain captures the complete inheritance pathway from the documented call to the abstract base, showing how the anti-bot options are eventually managed within the crawler's design.",
      "ground_truth_relationship": "The AsyncCrawlerStrategy class defines the abstract interface for implementing the documented anti-bot features through abstract methods like crawl() that accept kwargs parameters where options like simulate_user and override_navigator can be passed.",
      "ground_truth_trace_chain": "magic-mode.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Manual Anti-Bot Options\n\nWhile Magic Mode is recommended, you can also configure individual anti-detection features:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    simulate_user=True,        # Simulate human behavior\n    override_navigator=True    # Mask automation signals\n)\n```\n\nNote: When `magic=True` is used, you don't need to set these individual options.\n",
      "document_location": "docs/md_v2/advanced/magic-mode.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class captures all the crawling outcomes including success/failure status and extracted content, which provides the return structure for the anti-bot crawling operations documented in the manual configuration options.",
      "ground_truth_trace_chain": "magic-mode.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Manual Anti-Bot Options\n\nWhile Magic Mode is recommended, you can also configure individual anti-detection features:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    simulate_user=True,        # Simulate human behavior\n    override_navigator=True    # Mask automation signals\n)\n```\n\nNote: When `magic=True` is used, you don't need to set these individual options.\n",
      "document_location": "docs/md_v2/advanced/magic-mode.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The documentation discusses manual anti-bot options like 'simulate_user' and 'override_navigator' which are passed as kwargs to the AsyncWebCrawler's arun() method and forwarded to the crawler_strategy's constructor.",
      "ground_truth_trace_chain": "magic-mode.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Wait Conditions\n\n### CSS-Based Waiting\n\nWait for elements to appear:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=\"css:.dynamic-content\"  # Wait for element with class 'dynamic-content'\n)\n```\n\n### JavaScript-Based Waiting\n\nWait for custom conditions:\n\n```python\n# Wait for number of elements\nwait_condition = \"\"\"() => {\n    return document.querySelectorAll('.item').length > 10;\n}\"\"\"\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=f\"js:{wait_condition}\"\n)\n\n# Wait for dynamic content to load\nwait_for_content = \"\"\"() => {\n    const content = document.querySelector('.content');\n    return content && content.innerText.length > 100;\n}\"\"\"\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=f\"js:{wait_for_content}\"\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method usage",
      "relationship_explanation": "The documentation snippet shows explicit usage of the method with the sample call 'await crawler.arun(...)'. The wait conditions (both CSS and JS based) are passed as the 'wait_for' parameter to this method, directly mapping to its intended interface.",
      "predicted_trace_chain": "docs/md_v2/basic/page-interaction.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The documentation example originates from 'docs/md_v2/basic/page-interaction.md' and directly calls 'AsyncWebCrawler.arun()', establishing a clear, explicit trace from the document to this method.",
      "ground_truth_relationship": "The arun() method implements waiting functionality through its **kwargs parameter, which accepts the 'wait_for' conditions documented in both CSS and JavaScript formats to control when crawling proceeds.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Wait Conditions\n\n### CSS-Based Waiting\n\nWait for elements to appear:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=\"css:.dynamic-content\"  # Wait for element with class 'dynamic-content'\n)\n```\n\n### JavaScript-Based Waiting\n\nWait for custom conditions:\n\n```python\n# Wait for number of elements\nwait_condition = \"\"\"() => {\n    return document.querySelectorAll('.item').length > 10;\n}\"\"\"\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=f\"js:{wait_condition}\"\n)\n\n# Wait for dynamic content to load\nwait_for_content = \"\"\"() => {\n    const content = document.querySelector('.content');\n    return content && content.innerText.length > 100;\n}\"\"\"\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=f\"js:{wait_for_content}\"\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "implementation dependency",
      "relationship_explanation": "Though not mentioned by name in the snippet, the underlying implementation of wait conditions is handled inside AsyncPlaywrightCrawlerStrategy. Its 'crawl' method (which is invoked by arun()) calls the internal 'smart_wait' function to process the 'wait_for' parameter, interpreting the 'css:' and 'js:' prefixes.",
      "predicted_trace_chain": "docs/md_v2/basic/page-interaction.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The 'AsyncWebCrawler.arun()' method uses a default crawler strategy, which is an instance of AsyncPlaywrightCrawlerStrategy. This makes the link implicit \u2013 the documented wait condition functionality is ultimately provided by AsyncPlaywrightCrawlerStrategy.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy implements the documented wait conditions through its smart_wait method, which handles both CSS-based waiting using page.wait_for_selector and JavaScript-based waiting using page.evaluate for custom conditions.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Wait Conditions\n\n### CSS-Based Waiting\n\nWait for elements to appear:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=\"css:.dynamic-content\"  # Wait for element with class 'dynamic-content'\n)\n```\n\n### JavaScript-Based Waiting\n\nWait for custom conditions:\n\n```python\n# Wait for number of elements\nwait_condition = \"\"\"() => {\n    return document.querySelectorAll('.item').length > 10;\n}\"\"\"\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=f\"js:{wait_condition}\"\n)\n\n# Wait for dynamic content to load\nwait_for_content = \"\"\"() => {\n    const content = document.querySelector('.content');\n    return content && content.innerText.length > 100;\n}\"\"\"\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=f\"js:{wait_for_content}\"\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "AsyncCrawlerStrategy serves as the abstract base class for crawler strategies. AsyncPlaywrightCrawlerStrategy extends it to provide concrete implementations, including the wait condition logic. This inheritance chain underpins the overall functionality described in the documentation.",
      "predicted_trace_chain": "docs/md_v2/basic/page-interaction.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "By following the chain from the document's usage of 'arun()', one reaches AsyncPlaywrightCrawlerStrategy, which in turn inherits from AsyncCrawlerStrategy. This chain highlights the foundational role of the abstract base class even though its functionality is realized in its subclass.",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class provides the base interface that enables waiting functionality through its crawl method's **kwargs parameter, which can accept the wait_for conditions described in the documentation.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Wait Conditions\n\n### CSS-Based Waiting\n\nWait for elements to appear:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=\"css:.dynamic-content\"  # Wait for element with class 'dynamic-content'\n)\n```\n\n### JavaScript-Based Waiting\n\nWait for custom conditions:\n\n```python\n# Wait for number of elements\nwait_condition = \"\"\"() => {\n    return document.querySelectorAll('.item').length > 10;\n}\"\"\"\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=f\"js:{wait_condition}\"\n)\n\n# Wait for dynamic content to load\nwait_for_content = \"\"\"() => {\n    const content = document.querySelector('.content');\n    return content && content.innerText.length > 100;\n}\"\"\"\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=f\"js:{wait_for_content}\"\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the data collected after waiting for dynamic content to load using the documented CSS and JavaScript wait conditions, including the final HTML, extracted content, and success status.",
      "ground_truth_trace_chain": "page-interaction.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Wait Conditions\n\n### CSS-Based Waiting\n\nWait for elements to appear:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=\"css:.dynamic-content\"  # Wait for element with class 'dynamic-content'\n)\n```\n\n### JavaScript-Based Waiting\n\nWait for custom conditions:\n\n```python\n# Wait for number of elements\nwait_condition = \"\"\"() => {\n    return document.querySelectorAll('.item').length > 10;\n}\"\"\"\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=f\"js:{wait_condition}\"\n)\n\n# Wait for dynamic content to load\nwait_for_content = \"\"\"() => {\n    const content = document.querySelector('.content');\n    return content && content.innerText.length > 100;\n}\"\"\"\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    wait_for=f\"js:{wait_for_content}\"\n)\n```",
      "document_location": "docs/md_v2/basic/page-interaction.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler's arun() method implements the documented wait conditions through its kwargs parameter, which allows passing CSS selectors and JavaScript expressions via the wait_for parameter to control when the crawler proceeds with extraction.",
      "ground_truth_trace_chain": "page-interaction.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Basic Configuration\n\nCommon browser settings:\n\n```python\nasync with AsyncWebCrawler(\n    headless=True,           # Run in headless mode (no GUI)\n    verbose=True,           # Enable detailed logging\n    sleep_on_close=False    # No delay when closing browser\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation and context management",
      "relationship_explanation": "The documentation snippet explicitly demonstrates the instantiation of the AsyncWebCrawler class using a context manager (async with AsyncWebCrawler(...)). The provided parameters such as headless, verbose, and sleep_on_close directly reflect its configurable public interface.",
      "predicted_trace_chain": "browser-config.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The trace chain starts from the document 'browser-config.md' and directly references the AsyncWebCrawler class as it is explicitly instantiated in the code example.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the documented configuration options through its __init__ method, where headless, verbose, and sleep_on_close parameters are passed via kwargs to the underlying AsyncPlaywrightCrawlerStrategy.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Basic Configuration\n\nCommon browser settings:\n\n```python\nasync with AsyncWebCrawler(\n    headless=True,           # Run in headless mode (no GUI)\n    verbose=True,           # Enable detailed logging\n    sleep_on_close=False    # No delay when closing browser\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The documentation snippet shows a direct call to the 'arun' method (await crawler.arun(url=\"https://example.com\")), demonstrating its use to execute a crawling operation. This method forms part of the public interface of AsyncWebCrawler.",
      "predicted_trace_chain": "browser-config.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain begins with the document 'browser-config.md', moves to the instantiation of the AsyncWebCrawler class, and then follows the explicit invocation of its 'arun' method, thereby linking the usage example to the underlying code artifacts.",
      "ground_truth_relationship": "The code implements an async crawler method that accepts the documented configuration parameters like headless, verbose, and sleep_on_close through its constructor while providing additional flexibility through optional parameters such as word_count_threshold, extraction_strategy, and chunking_strategy.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Basic Configuration\n\nCommon browser settings:\n\n```python\nasync with AsyncWebCrawler(\n    headless=True,           # Run in headless mode (no GUI)\n    verbose=True,           # Enable detailed logging\n    sleep_on_close=False    # No delay when closing browser\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the structure of the return value from the AsyncWebCrawler.arun() method shown in the configuration documentation, storing crawled data like HTML, links, and metadata from the target URL.",
      "ground_truth_trace_chain": "browser-config.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Basic Configuration\n\nCommon browser settings:\n\n```python\nasync with AsyncWebCrawler(\n    headless=True,           # Run in headless mode (no GUI)\n    verbose=True,           # Enable detailed logging\n    sleep_on_close=False    # No delay when closing browser\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the documented browser configuration options through its constructor parameters and start() method, specifically handling headless mode, verbose logging, and sleep_on_close functionality as shown in the example configuration.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Basic Configuration\n\nCommon browser settings:\n\n```python\nasync with AsyncWebCrawler(\n    headless=True,           # Run in headless mode (no GUI)\n    verbose=True,           # Enable detailed logging\n    sleep_on_close=False    # No delay when closing browser\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core methods that enable the browser configuration settings shown in the documentation, including the crawl functionality used by AsyncWebCrawler's arun method.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Customizing LLM Provider\n\nCrawl4AI uses the `litellm` library under the hood, which allows you to use any LLM provider you want. Just pass the correct model name and API token:\n\n```python\nextraction_strategy=LLMExtractionStrategy(\n    provider=\"your_llm_provider/model_name\",\n    api_token=\"your_api_token\",\n    instruction=\"Your extraction instruction\"\n)\n```\n\nThis flexibility allows you to integrate with various LLM providers and tailor the extraction process to your specific needs.",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation",
      "relationship_explanation": "The documentation snippet directly shows an instance being created with LLMExtractionStrategy using parameters (provider, api_token, instruction). This clearly demonstrates that the class is used to customize the LLM provider within Crawl4AI.",
      "predicted_trace_chain": "llm.md -> LLMExtractionStrategy",
      "predicted_trace_chain_explanation": "The trace starts from the document 'llm.md' where LLM customization is described and leads directly to the LLMExtractionStrategy artifact, which implements the customizable extraction logic.",
      "ground_truth_relationship": "The code implements the documented LLM provider customization by allowing users to specify a provider and API token through the LLMExtractionStrategy class constructor, which then uses these parameters to initialize the extraction process with the specified LLM service.",
      "ground_truth_trace_chain": "llm.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Customizing LLM Provider\n\nCrawl4AI uses the `litellm` library under the hood, which allows you to use any LLM provider you want. Just pass the correct model name and API token:\n\n```python\nextraction_strategy=LLMExtractionStrategy(\n    provider=\"your_llm_provider/model_name\",\n    api_token=\"your_api_token\",\n    instruction=\"Your extraction instruction\"\n)\n```\n\nThis flexibility allows you to integrate with various LLM providers and tailor the extraction process to your specific needs.",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "LLMExtractionStrategy inherits from ExtractionStrategy. Although the base class is not explicitly mentioned in the snippet, it is a vital part of the extraction framework that establishes a contract for extraction strategies used in Crawl4AI.",
      "predicted_trace_chain": "llm.md -> LLMExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain begins at 'llm.md', moves to the explicitly referenced LLMExtractionStrategy, and then extends to its base class ExtractionStrategy, highlighting the inheritance relationship that underpins the extraction mechanism.",
      "ground_truth_relationship": "The ExtractionStrategy abstract base class serves as the foundation for implementing custom LLM providers through its extensible design, which aligns with the documentation's description of using different LLM providers via the litellm library.",
      "ground_truth_trace_chain": "llm.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Understanding Parameters \ud83e\udde0\n\nBy default, Crawl4AI caches the results of your crawls. This means that subsequent crawls of the same URL will be much faster! Let's see this in action.\n\n```python\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        # First crawl (caches the result)\n        result1 = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n        print(f\"First crawl result: {result1.markdown[:100]}...\")\n\n        # Force to crawl again\n        result2 = await crawler.arun(url=\"https://www.nbcnews.com/business\", bypass_cache=True)\n        print(f\"Second crawl result: {result2.markdown[:100]}...\")\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation",
      "relationship_explanation": "The snippet explicitly instantiates AsyncWebCrawler using 'async with AsyncWebCrawler(verbose=True) as crawler:', demonstrating a direct use of this class as the starting point for crawling operations.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The documentation (docs/md_v2/basic/quickstart.md) begins by creating an AsyncWebCrawler object, which establishes it as the primary interface for initiating crawls.",
      "ground_truth_relationship": "The code implements caching functionality through the AsyncWebCrawler class which uses async_db_manager to store and retrieve crawl results, while providing a bypass_cache parameter in the arun method that controls whether to use cached results as demonstrated in the documentation example.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Understanding Parameters \ud83e\udde0\n\nBy default, Crawl4AI caches the results of your crawls. This means that subsequent crawls of the same URL will be much faster! Let's see this in action.\n\n```python\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        # First crawl (caches the result)\n        result1 = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n        print(f\"First crawl result: {result1.markdown[:100]}...\")\n\n        # Force to crawl again\n        result2 = await crawler.arun(url=\"https://www.nbcnews.com/business\", bypass_cache=True)\n        print(f\"Second crawl result: {result2.markdown[:100]}...\")\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "Within the snippet the 'arun' method is called on the AsyncWebCrawler instance (e.g., result1 = await crawler.arun(url=...)), which shows that crawling functionality is implemented via this method.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain starts with instantiation of AsyncWebCrawler, followed by the use of its 'arun()' method to perform the crawl operation, demonstrating its role in the overall crawling workflow.",
      "ground_truth_relationship": "The code implements caching by checking for cached content using async_db_manager.aget_cached_url(url) when bypass_cache is False, while the documentation demonstrates this functionality through example code showing two crawls - one that uses cache and another that bypasses it.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Understanding Parameters \ud83e\udde0\n\nBy default, Crawl4AI caches the results of your crawls. This means that subsequent crawls of the same URL will be much faster! Let's see this in action.\n\n```python\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        # First crawl (caches the result)\n        result1 = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n        print(f\"First crawl result: {result1.markdown[:100]}...\")\n\n        # Force to crawl again\n        result2 = await crawler.arun(url=\"https://www.nbcnews.com/business\", bypass_cache=True)\n        print(f\"Second crawl result: {result2.markdown[:100]}...\")\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 15,
      "artifact_title": "CrawlResult.markdown",
      "predicted_relationship": "explicit",
      "relationship_type": "property access",
      "relationship_explanation": "The code snippet accesses the 'markdown' attribute from the object returned by 'arun()' (result1.markdown[:100]), illustrating that the crawl output is encapsulated in a CrawlResult instance with a public 'markdown' field.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler -> AsyncWebCrawler.arun() -> CrawlResult.markdown",
      "predicted_trace_chain_explanation": "This chain links the initial crawler instantiation to the method call and finally to the 'markdown' property of the CrawlResult object, showing how the documentation demonstrates retrieval of crawl results.",
      "ground_truth_relationship": "The CrawlResult.markdown property stores the crawled webpage content in markdown format, which is demonstrated in the documentation example where it's accessed to print the first 100 characters of each crawl result.",
      "ground_truth_trace_chain": "quickstart.md -> CrawlResult.markdown",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Understanding Parameters \ud83e\udde0\n\nBy default, Crawl4AI caches the results of your crawls. This means that subsequent crawls of the same URL will be much faster! Let's see this in action.\n\n```python\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        # First crawl (caches the result)\n        result1 = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n        print(f\"First crawl result: {result1.markdown[:100]}...\")\n\n        # Force to crawl again\n        result2 = await crawler.arun(url=\"https://www.nbcnews.com/business\", bypass_cache=True)\n        print(f\"Second crawl result: {result2.markdown[:100]}...\")\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class contains key fields like 'markdown' and 'success' that store the cached crawl results mentioned in the documentation example's demonstration of caching behavior.",
      "ground_truth_trace_chain": "quickstart.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Understanding Parameters \ud83e\udde0\n\nBy default, Crawl4AI caches the results of your crawls. This means that subsequent crawls of the same URL will be much faster! Let's see this in action.\n\n```python\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        # First crawl (caches the result)\n        result1 = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n        print(f\"First crawl result: {result1.markdown[:100]}...\")\n\n        # Force to crawl again\n        result2 = await crawler.arun(url=\"https://www.nbcnews.com/business\", bypass_cache=True)\n        print(f\"Second crawl result: {result2.markdown[:100]}...\")\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements caching through the use_cached_html parameter, which when true stores HTML content in a local file and retrieves it on subsequent requests, matching the documentation's description of caching crawl results for faster subsequent crawls.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Understanding Parameters \ud83e\udde0\n\nBy default, Crawl4AI caches the results of your crawls. This means that subsequent crawls of the same URL will be much faster! Let's see this in action.\n\n```python\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        # First crawl (caches the result)\n        result1 = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n        print(f\"First crawl result: {result1.markdown[:100]}...\")\n\n        # Force to crawl again\n        result2 = await crawler.arun(url=\"https://www.nbcnews.com/business\", bypass_cache=True)\n        print(f\"Second crawl result: {result2.markdown[:100]}...\")\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core crawling methods that enable the caching functionality demonstrated in the documentation through its crawl method, which concrete implementations can use to handle cached and non-cached requests.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Technique 1: Custom Execution Hooks\n\nCrawl4AI allows you to set custom hooks that execute at different stages of the crawling process. This is particularly useful for handling complex loading scenarios.\n\nHere's an example that waits for new content to appear before proceeding:\n\n```python\nasync def advanced_session_crawl_with_hooks():\n    first_commit = \"\"\n\n    async def on_execution_started(page):\n        nonlocal first_commit\n        try:\n            while True:\n                await page.wait_for_selector(\"li.commit-item h4\")\n                commit = await page.query_selector(\"li.commit-item h4\")\n                commit = await commit.evaluate(\"(element) => element.textContent\")\n                commit = commit.strip()\n                if commit and commit != first_commit:\n                    first_commit = commit\n                    break\n                await asyncio.sleep(0.5)\n        except Exception as e:\n            print(f\"Warning: New content didn't appear after JavaScript execution: {e}\")\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        crawler.crawler_strategy.set_hook(\"on_execution_started\", on_execution_started)\n\n        url = \"https://github.com/example/repo/commits/main\"\n        session_id = \"commit_session\"\n        all_commits = []\n\n        js_next_page = \"\"\"\n        const button = document.querySelector('a.pagination-next');\n        if (button) button.click();\n        \"\"\"\n\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                css_selector=\"li.commit-item\",\n                js_code=js_next_page if page > 0 else None,\n                bypass_cache=True,\n                js_only=page > 0\n            )\n\n            commits = result.extracted_content.select(\"li.commit-item\")\n            all_commits.extend(commits)\n            print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        await crawler.crawler_strategy.kill_session(session_id)\n        print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\")\n\nasyncio.run(advanced_session_crawl_with_hooks())\n```\n\nThis technique uses a custom `on_execution_started` hook to ensure new content has loaded before proceeding to the next step.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation / class usage",
      "relationship_explanation": "The documentation snippet explicitly instantiates AsyncWebCrawler with 'async with AsyncWebCrawler(verbose=True) as crawler', indicating that this class is used to manage the crawling session.",
      "predicted_trace_chain": "session-management-advanced.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The trace starts from the documentation file 'session-management-advanced.md' and directly references the AsyncWebCrawler class, which is the entry point for the advanced crawling process.",
      "ground_truth_relationship": "The AsyncWebCrawler class provides the foundational infrastructure for implementing custom execution hooks through its crawler_strategy attribute, which can be set and accessed during crawling operations as shown in the documentation example.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Technique 1: Custom Execution Hooks\n\nCrawl4AI allows you to set custom hooks that execute at different stages of the crawling process. This is particularly useful for handling complex loading scenarios.\n\nHere's an example that waits for new content to appear before proceeding:\n\n```python\nasync def advanced_session_crawl_with_hooks():\n    first_commit = \"\"\n\n    async def on_execution_started(page):\n        nonlocal first_commit\n        try:\n            while True:\n                await page.wait_for_selector(\"li.commit-item h4\")\n                commit = await page.query_selector(\"li.commit-item h4\")\n                commit = await commit.evaluate(\"(element) => element.textContent\")\n                commit = commit.strip()\n                if commit and commit != first_commit:\n                    first_commit = commit\n                    break\n                await asyncio.sleep(0.5)\n        except Exception as e:\n            print(f\"Warning: New content didn't appear after JavaScript execution: {e}\")\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        crawler.crawler_strategy.set_hook(\"on_execution_started\", on_execution_started)\n\n        url = \"https://github.com/example/repo/commits/main\"\n        session_id = \"commit_session\"\n        all_commits = []\n\n        js_next_page = \"\"\"\n        const button = document.querySelector('a.pagination-next');\n        if (button) button.click();\n        \"\"\"\n\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                css_selector=\"li.commit-item\",\n                js_code=js_next_page if page > 0 else None,\n                bypass_cache=True,\n                js_only=page > 0\n            )\n\n            commits = result.extracted_content.select(\"li.commit-item\")\n            all_commits.extend(commits)\n            print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        await crawler.crawler_strategy.kill_session(session_id)\n        print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\")\n\nasyncio.run(advanced_session_crawl_with_hooks())\n```\n\nThis technique uses a custom `on_execution_started` hook to ensure new content has loaded before proceeding to the next step.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The example code calls 'await crawler.arun(...)' to perform the crawling operation, demonstrating explicit usage of the 'arun' method on the AsyncWebCrawler object.",
      "predicted_trace_chain": "session-management-advanced.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the documentation file, the chain moves to the AsyncWebCrawler class and then to its 'arun()' method, which is used to fetch and process webpage content.",
      "ground_truth_relationship": "The arun() method implements the core asynchronous crawling functionality that enables custom hooks like 'on_execution_started' to be executed during the crawling process through the crawler_strategy object.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Technique 1: Custom Execution Hooks\n\nCrawl4AI allows you to set custom hooks that execute at different stages of the crawling process. This is particularly useful for handling complex loading scenarios.\n\nHere's an example that waits for new content to appear before proceeding:\n\n```python\nasync def advanced_session_crawl_with_hooks():\n    first_commit = \"\"\n\n    async def on_execution_started(page):\n        nonlocal first_commit\n        try:\n            while True:\n                await page.wait_for_selector(\"li.commit-item h4\")\n                commit = await page.query_selector(\"li.commit-item h4\")\n                commit = await commit.evaluate(\"(element) => element.textContent\")\n                commit = commit.strip()\n                if commit and commit != first_commit:\n                    first_commit = commit\n                    break\n                await asyncio.sleep(0.5)\n        except Exception as e:\n            print(f\"Warning: New content didn't appear after JavaScript execution: {e}\")\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        crawler.crawler_strategy.set_hook(\"on_execution_started\", on_execution_started)\n\n        url = \"https://github.com/example/repo/commits/main\"\n        session_id = \"commit_session\"\n        all_commits = []\n\n        js_next_page = \"\"\"\n        const button = document.querySelector('a.pagination-next');\n        if (button) button.click();\n        \"\"\"\n\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                css_selector=\"li.commit-item\",\n                js_code=js_next_page if page > 0 else None,\n                bypass_cache=True,\n                js_only=page > 0\n            )\n\n            commits = result.extracted_content.select(\"li.commit-item\")\n            all_commits.extend(commits)\n            print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        await crawler.crawler_strategy.kill_session(session_id)\n        print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\")\n\nasyncio.run(advanced_session_crawl_with_hooks())\n```\n\nThis technique uses a custom `on_execution_started` hook to ensure new content has loaded before proceeding to the next step.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 3,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy.set_hook()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "Within the snippet, the custom execution hook 'on_execution_started' is registered using the call 'crawler.crawler_strategy.set_hook(\"on_execution_started\", on_execution_started)', directly invoking the set_hook() method.",
      "predicted_trace_chain": "session-management-advanced.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy.set_hook()",
      "predicted_trace_chain_explanation": "The documentation begins with the AsyncWebCrawler instance, whose 'crawler_strategy' (an instance of AsyncPlaywrightCrawlerStrategy) is used to set a custom hook, forming a clear trace from the doc to the set_hook() method.",
      "ground_truth_relationship": "The set_hook method enables the custom hook functionality described in the documentation by storing the provided hook callback in a dictionary that gets executed at specific points in the crawling lifecycle.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncPlaywrightCrawlerStrategy.set_hook()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Technique 1: Custom Execution Hooks\n\nCrawl4AI allows you to set custom hooks that execute at different stages of the crawling process. This is particularly useful for handling complex loading scenarios.\n\nHere's an example that waits for new content to appear before proceeding:\n\n```python\nasync def advanced_session_crawl_with_hooks():\n    first_commit = \"\"\n\n    async def on_execution_started(page):\n        nonlocal first_commit\n        try:\n            while True:\n                await page.wait_for_selector(\"li.commit-item h4\")\n                commit = await page.query_selector(\"li.commit-item h4\")\n                commit = await commit.evaluate(\"(element) => element.textContent\")\n                commit = commit.strip()\n                if commit and commit != first_commit:\n                    first_commit = commit\n                    break\n                await asyncio.sleep(0.5)\n        except Exception as e:\n            print(f\"Warning: New content didn't appear after JavaScript execution: {e}\")\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        crawler.crawler_strategy.set_hook(\"on_execution_started\", on_execution_started)\n\n        url = \"https://github.com/example/repo/commits/main\"\n        session_id = \"commit_session\"\n        all_commits = []\n\n        js_next_page = \"\"\"\n        const button = document.querySelector('a.pagination-next');\n        if (button) button.click();\n        \"\"\"\n\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                css_selector=\"li.commit-item\",\n                js_code=js_next_page if page > 0 else None,\n                bypass_cache=True,\n                js_only=page > 0\n            )\n\n            commits = result.extracted_content.select(\"li.commit-item\")\n            all_commits.extend(commits)\n            print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        await crawler.crawler_strategy.kill_session(session_id)\n        print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\")\n\nasyncio.run(advanced_session_crawl_with_hooks())\n```\n\nThis technique uses a custom `on_execution_started` hook to ensure new content has loaded before proceeding to the next step.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 2,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The snippet explicitly calls 'await crawler.crawler_strategy.kill_session(session_id)' to terminate a crawling session, thereby utilizing the kill_session() method of the crawler strategy.",
      "predicted_trace_chain": "session-management-advanced.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_trace_chain_explanation": "The chain begins with the documentation file, passes through the AsyncWebCrawler (which holds the crawler_strategy), and ends with the explicit invocation of the 'kill_session()' method to close the session.",
      "ground_truth_relationship": "The kill_session method cleans up browser resources by closing the page and context objects associated with a specific session ID, as demonstrated in the documentation's crawler cleanup after commit crawling.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Advanced Technique 1: Custom Execution Hooks\n\nCrawl4AI allows you to set custom hooks that execute at different stages of the crawling process. This is particularly useful for handling complex loading scenarios.\n\nHere's an example that waits for new content to appear before proceeding:\n\n```python\nasync def advanced_session_crawl_with_hooks():\n    first_commit = \"\"\n\n    async def on_execution_started(page):\n        nonlocal first_commit\n        try:\n            while True:\n                await page.wait_for_selector(\"li.commit-item h4\")\n                commit = await page.query_selector(\"li.commit-item h4\")\n                commit = await commit.evaluate(\"(element) => element.textContent\")\n                commit = commit.strip()\n                if commit and commit != first_commit:\n                    first_commit = commit\n                    break\n                await asyncio.sleep(0.5)\n        except Exception as e:\n            print(f\"Warning: New content didn't appear after JavaScript execution: {e}\")\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        crawler.crawler_strategy.set_hook(\"on_execution_started\", on_execution_started)\n\n        url = \"https://github.com/example/repo/commits/main\"\n        session_id = \"commit_session\"\n        all_commits = []\n\n        js_next_page = \"\"\"\n        const button = document.querySelector('a.pagination-next');\n        if (button) button.click();\n        \"\"\"\n\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                css_selector=\"li.commit-item\",\n                js_code=js_next_page if page > 0 else None,\n                bypass_cache=True,\n                js_only=page > 0\n            )\n\n            commits = result.extracted_content.select(\"li.commit-item\")\n            all_commits.extend(commits)\n            print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        await crawler.crawler_strategy.kill_session(session_id)\n        print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\")\n\nasyncio.run(advanced_session_crawl_with_hooks())\n```\n\nThis technique uses a custom `on_execution_started` hook to ensure new content has loaded before proceeding to the next step.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class captures the output of custom hook executions by storing the extracted content and session state that are essential for implementing the documented commit-tracking functionality.",
      "ground_truth_trace_chain": "session-management-advanced.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Technique 1: Custom Execution Hooks\n\nCrawl4AI allows you to set custom hooks that execute at different stages of the crawling process. This is particularly useful for handling complex loading scenarios.\n\nHere's an example that waits for new content to appear before proceeding:\n\n```python\nasync def advanced_session_crawl_with_hooks():\n    first_commit = \"\"\n\n    async def on_execution_started(page):\n        nonlocal first_commit\n        try:\n            while True:\n                await page.wait_for_selector(\"li.commit-item h4\")\n                commit = await page.query_selector(\"li.commit-item h4\")\n                commit = await commit.evaluate(\"(element) => element.textContent\")\n                commit = commit.strip()\n                if commit and commit != first_commit:\n                    first_commit = commit\n                    break\n                await asyncio.sleep(0.5)\n        except Exception as e:\n            print(f\"Warning: New content didn't appear after JavaScript execution: {e}\")\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        crawler.crawler_strategy.set_hook(\"on_execution_started\", on_execution_started)\n\n        url = \"https://github.com/example/repo/commits/main\"\n        session_id = \"commit_session\"\n        all_commits = []\n\n        js_next_page = \"\"\"\n        const button = document.querySelector('a.pagination-next');\n        if (button) button.click();\n        \"\"\"\n\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                css_selector=\"li.commit-item\",\n                js_code=js_next_page if page > 0 else None,\n                bypass_cache=True,\n                js_only=page > 0\n            )\n\n            commits = result.extracted_content.select(\"li.commit-item\")\n            all_commits.extend(commits)\n            print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        await crawler.crawler_strategy.kill_session(session_id)\n        print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\")\n\nasyncio.run(advanced_session_crawl_with_hooks())\n```\n\nThis technique uses a custom `on_execution_started` hook to ensure new content has loaded before proceeding to the next step.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_title": "CrawlResult.extracted_content",
      "ground_truth_relationship": "The extracted_content field in CrawlResult stores the scraped HTML content that the hook functions in the documentation wait for and validate before proceeding with further crawling operations.",
      "ground_truth_trace_chain": "session-management-advanced.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Technique 1: Custom Execution Hooks\n\nCrawl4AI allows you to set custom hooks that execute at different stages of the crawling process. This is particularly useful for handling complex loading scenarios.\n\nHere's an example that waits for new content to appear before proceeding:\n\n```python\nasync def advanced_session_crawl_with_hooks():\n    first_commit = \"\"\n\n    async def on_execution_started(page):\n        nonlocal first_commit\n        try:\n            while True:\n                await page.wait_for_selector(\"li.commit-item h4\")\n                commit = await page.query_selector(\"li.commit-item h4\")\n                commit = await commit.evaluate(\"(element) => element.textContent\")\n                commit = commit.strip()\n                if commit and commit != first_commit:\n                    first_commit = commit\n                    break\n                await asyncio.sleep(0.5)\n        except Exception as e:\n            print(f\"Warning: New content didn't appear after JavaScript execution: {e}\")\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        crawler.crawler_strategy.set_hook(\"on_execution_started\", on_execution_started)\n\n        url = \"https://github.com/example/repo/commits/main\"\n        session_id = \"commit_session\"\n        all_commits = []\n\n        js_next_page = \"\"\"\n        const button = document.querySelector('a.pagination-next');\n        if (button) button.click();\n        \"\"\"\n\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                css_selector=\"li.commit-item\",\n                js_code=js_next_page if page > 0 else None,\n                bypass_cache=True,\n                js_only=page > 0\n            )\n\n            commits = result.extracted_content.select(\"li.commit-item\")\n            all_commits.extend(commits)\n            print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        await crawler.crawler_strategy.kill_session(session_id)\n        print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\")\n\nasyncio.run(advanced_session_crawl_with_hooks())\n```\n\nThis technique uses a custom `on_execution_started` hook to ensure new content has loaded before proceeding to the next step.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements custom hooks through its set_hook() and execute_hook() methods, which enable execution of custom functions at specific stages of the crawling process like 'on_execution_started' as described in the documentation.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Advanced Technique 1: Custom Execution Hooks\n\nCrawl4AI allows you to set custom hooks that execute at different stages of the crawling process. This is particularly useful for handling complex loading scenarios.\n\nHere's an example that waits for new content to appear before proceeding:\n\n```python\nasync def advanced_session_crawl_with_hooks():\n    first_commit = \"\"\n\n    async def on_execution_started(page):\n        nonlocal first_commit\n        try:\n            while True:\n                await page.wait_for_selector(\"li.commit-item h4\")\n                commit = await page.query_selector(\"li.commit-item h4\")\n                commit = await commit.evaluate(\"(element) => element.textContent\")\n                commit = commit.strip()\n                if commit and commit != first_commit:\n                    first_commit = commit\n                    break\n                await asyncio.sleep(0.5)\n        except Exception as e:\n            print(f\"Warning: New content didn't appear after JavaScript execution: {e}\")\n\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        crawler.crawler_strategy.set_hook(\"on_execution_started\", on_execution_started)\n\n        url = \"https://github.com/example/repo/commits/main\"\n        session_id = \"commit_session\"\n        all_commits = []\n\n        js_next_page = \"\"\"\n        const button = document.querySelector('a.pagination-next');\n        if (button) button.click();\n        \"\"\"\n\n        for page in range(3):\n            result = await crawler.arun(\n                url=url,\n                session_id=session_id,\n                css_selector=\"li.commit-item\",\n                js_code=js_next_page if page > 0 else None,\n                bypass_cache=True,\n                js_only=page > 0\n            )\n\n            commits = result.extracted_content.select(\"li.commit-item\")\n            all_commits.extend(commits)\n            print(f\"Page {page + 1}: Found {len(commits)} commits\")\n\n        await crawler.crawler_strategy.kill_session(session_id)\n        print(f\"Successfully crawled {len(all_commits)} commits across 3 pages\")\n\nasyncio.run(advanced_session_crawl_with_hooks())\n```\n\nThis technique uses a custom `on_execution_started` hook to ensure new content has loaded before proceeding to the next step.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The set_hook method in AsyncCrawlerStrategy enables the documented custom hook functionality by allowing users to register callback functions like on_execution_started that execute at specific crawling stages.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Cleaned HTML\n\nSanitized HTML with unnecessary elements removed. Automatically:\n- Removes scripts and styles\n- Cleans up formatting\n- Preserves semantic structure\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    excluded_tags=['form', 'header', 'footer'],  # Additional tags to remove\n    keep_data_attributes=False  # Remove data-* attributes\n)\nprint(result.cleaned_html)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The documentation snippet shows a direct call to 'crawler.arun(...)', which is an explicit invocation of the AsyncWebCrawler.arun() method. This method is responsible for initiating the crawl, processing the input URL, and returning a CrawlResult object that contains the cleaned HTML output.",
      "predicted_trace_chain": "docs/md_v2/basic/output-formats.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain starts from the documentation file 'docs/md_v2/basic/output-formats.md' where the usage example is provided, then it directly calls the 'AsyncWebCrawler.arun()' method to demonstrate how the crawl result (including cleaned HTML) is obtained.",
      "ground_truth_relationship": "The arun() method implements HTML cleaning by processing raw HTML through sanitization and extraction strategies, with configurable excluded tags and data attributes as shown in the documentation example.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Cleaned HTML\n\nSanitized HTML with unnecessary elements removed. Automatically:\n- Removes scripts and styles\n- Cleans up formatting\n- Preserves semantic structure\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    excluded_tags=['form', 'header', 'footer'],  # Additional tags to remove\n    keep_data_attributes=False  # Remove data-* attributes\n)\nprint(result.cleaned_html)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_id": 9,
      "artifact_title": "CrawlResult.cleaned_html",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet prints 'result.cleaned_html' immediately after the crawl operation. This indicates that the cleaned_html attribute of the CrawlResult object holds the sanitized HTML. This attribute is an integral part of the output format produced by the crawling process.",
      "predicted_trace_chain": "docs/md_v2/basic/output-formats.md -> AsyncWebCrawler.arun() -> CrawlResult.cleaned_html",
      "predicted_trace_chain_explanation": "The chain illustrates that the documentation example begins with calling 'AsyncWebCrawler.arun()', which returns a CrawlResult instance. From this instance, the 'cleaned_html' attribute is accessed to provide the cleaned and sanitized HTML, as described in the documentation.",
      "ground_truth_relationship": "The cleaned_html property in CrawlResult stores the sanitized HTML string after removing unwanted tags and attributes as shown in the documentation example.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult.cleaned_html",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Cleaned HTML\n\nSanitized HTML with unnecessary elements removed. Automatically:\n- Removes scripts and styles\n- Cleans up formatting\n- Preserves semantic structure\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    excluded_tags=['form', 'header', 'footer'],  # Additional tags to remove\n    keep_data_attributes=False  # Remove data-* attributes\n)\nprint(result.cleaned_html)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the cleaned_html as an optional string field that contains the sanitized HTML output described in the documentation after removing scripts, styles, and user-specified excluded tags.",
      "ground_truth_trace_chain": "output-formats.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Cleaned HTML\n\nSanitized HTML with unnecessary elements removed. Automatically:\n- Removes scripts and styles\n- Cleans up formatting\n- Preserves semantic structure\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    excluded_tags=['form', 'header', 'footer'],  # Additional tags to remove\n    keep_data_attributes=False  # Remove data-* attributes\n)\nprint(result.cleaned_html)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface for web crawlers that enable HTML cleaning through required methods like crawl() which processes URLs and returns cleaned responses as documented in the example usage.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Cleaned HTML\n\nSanitized HTML with unnecessary elements removed. Automatically:\n- Removes scripts and styles\n- Cleans up formatting\n- Preserves semantic structure\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    excluded_tags=['form', 'header', 'footer'],  # Additional tags to remove\n    keep_data_attributes=False  # Remove data-* attributes\n)\nprint(result.cleaned_html)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements HTML cleaning by removing unwanted elements through methods like remove_overlay_elements() and processes iframes while respecting the excluded_tags parameter during page content extraction.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Cleaned HTML\n\nSanitized HTML with unnecessary elements removed. Automatically:\n- Removes scripts and styles\n- Cleans up formatting\n- Preserves semantic structure\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    excluded_tags=['form', 'header', 'footer'],  # Additional tags to remove\n    keep_data_attributes=False  # Remove data-* attributes\n)\nprint(result.cleaned_html)\n```",
      "document_location": "docs/md_v2/basic/output-formats.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler's aprocess_html method implements HTML cleaning by using a WebScrappingStrategy to remove unwanted elements and produce cleaned_html output, which directly fulfills the documentation's promise of sanitizing and removing unnecessary HTML elements while preserving structure.",
      "ground_truth_trace_chain": "output-formats.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Advanced Session-Based Crawling with Dynamic Content For modern web applications with dynamic content loading, here's how to handle pagination and content updates: ```python async def crawl_dynamic_content(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/microsoft/TypeScript/commits/main\" session_id = \"typescript_commits_session\" js_next_page = \"\"\" const button = document.querySelector('a[data-testid=\"pagination-next-button\"]'); if (button) button.click(); \"\"\" wait_for = \"\"\"() => { const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4'); if (commits.length === 0) return false; const firstCommit = commits[0].textContent.trim(); return firstCommit !== window.firstCommit; }\"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.Box-sc-g0xbh4-0\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.markdown-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3):  # Crawl 3 pages result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.Box-sc-g0xbh4-0\", extraction_strategy=extraction_strategy, js_code=js_next_page if page > 0 else None, wait_for=wait_for if page > 0 else None, js_only=page > 0, bypass_cache=True, headless=False, ) await crawler.crawler_strategy.kill_session(session_id) ```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation",
      "relationship_explanation": "The documentation snippet explicitly creates an instance of AsyncWebCrawler using an async context manager (async with AsyncWebCrawler(verbose=True) as crawler:), which makes it the main entry point for crawling tasks.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain starts from the document 'quickstart.md', which directly instantiates AsyncWebCrawler to orchestrate the crawling process.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements session-based dynamic content crawling through its arun method, which supports pagination and content updates via custom JavaScript injection (js_next_page) and wait conditions as shown in the documentation example.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Advanced Session-Based Crawling with Dynamic Content For modern web applications with dynamic content loading, here's how to handle pagination and content updates: ```python async def crawl_dynamic_content(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/microsoft/TypeScript/commits/main\" session_id = \"typescript_commits_session\" js_next_page = \"\"\" const button = document.querySelector('a[data-testid=\"pagination-next-button\"]'); if (button) button.click(); \"\"\" wait_for = \"\"\"() => { const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4'); if (commits.length === 0) return false; const firstCommit = commits[0].textContent.trim(); return firstCommit !== window.firstCommit; }\"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.Box-sc-g0xbh4-0\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.markdown-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3):  # Crawl 3 pages result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.Box-sc-g0xbh4-0\", extraction_strategy=extraction_strategy, js_code=js_next_page if page > 0 else None, wait_for=wait_for if page > 0 else None, js_only=page > 0, bypass_cache=True, headless=False, ) await crawler.crawler_strategy.kill_session(session_id) ```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method call",
      "relationship_explanation": "Within the example code, the arun() method of AsyncWebCrawler is explicitly called to crawl a URL using provided parameters such as session_id, css_selector, and extraction_strategy.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain shows that from the document, after creating an AsyncWebCrawler instance, its arun() method is used to perform the actual crawling.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method enables session-based dynamic crawling by accepting parameters like session_id, js_code, and wait_for that allow executing JavaScript and waiting for dynamic content updates as described in the documentation example.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Advanced Session-Based Crawling with Dynamic Content For modern web applications with dynamic content loading, here's how to handle pagination and content updates: ```python async def crawl_dynamic_content(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/microsoft/TypeScript/commits/main\" session_id = \"typescript_commits_session\" js_next_page = \"\"\" const button = document.querySelector('a[data-testid=\"pagination-next-button\"]'); if (button) button.click(); \"\"\" wait_for = \"\"\"() => { const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4'); if (commits.length === 0) return false; const firstCommit = commits[0].textContent.trim(); return firstCommit !== window.firstCommit; }\"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.Box-sc-g0xbh4-0\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.markdown-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3):  # Crawl 3 pages result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.Box-sc-g0xbh4-0\", extraction_strategy=extraction_strategy, js_code=js_next_page if page > 0 else None, wait_for=wait_for if page > 0 else None, js_only=page > 0, bypass_cache=True, headless=False, ) await crawler.crawler_strategy.kill_session(session_id) ```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation",
      "relationship_explanation": "The snippet explicitly instantiates JsonCssExtractionStrategy with a provided schema to extract commit information from the crawled HTML, making it the extraction strategy for the crawl.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "Starting from the documentation, the chain directly instantiates JsonCssExtractionStrategy to handle content extraction based on a defined schema.",
      "ground_truth_relationship": "The JsonCssExtractionStrategy class implements the structured data extraction logic described in the documentation by parsing the schema's baseSelector and fields to extract commit information from GitHub's dynamic pages.",
      "ground_truth_trace_chain": "quickstart.md -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Advanced Session-Based Crawling with Dynamic Content For modern web applications with dynamic content loading, here's how to handle pagination and content updates: ```python async def crawl_dynamic_content(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/microsoft/TypeScript/commits/main\" session_id = \"typescript_commits_session\" js_next_page = \"\"\" const button = document.querySelector('a[data-testid=\"pagination-next-button\"]'); if (button) button.click(); \"\"\" wait_for = \"\"\"() => { const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4'); if (commits.length === 0) return false; const firstCommit = commits[0].textContent.trim(); return firstCommit !== window.firstCommit; }\"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.Box-sc-g0xbh4-0\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.markdown-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3):  # Crawl 3 pages result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.Box-sc-g0xbh4-0\", extraction_strategy=extraction_strategy, js_code=js_next_page if page > 0 else None, wait_for=wait_for if page > 0 else None, js_only=page > 0, bypass_cache=True, headless=False, ) await crawler.crawler_strategy.kill_session(session_id) ```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 2,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_relationship": "explicit",
      "relationship_type": "method call",
      "relationship_explanation": "After each crawl iteration, the example calls kill_session() on crawler.crawler_strategy to terminate the session by passing a session_id, ensuring proper cleanup of the browser context.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler -> crawler.crawler_strategy -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "predicted_trace_chain_explanation": "This chain illustrates that starting from the document, AsyncWebCrawler internally uses a crawler_strategy (an instance of AsyncPlaywrightCrawlerStrategy) whose kill_session() method is explicitly called for session management.",
      "ground_truth_relationship": "The kill_session method cleans up browser resources by closing the Playwright page and context objects when the dynamic content crawling session is complete.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncPlaywrightCrawlerStrategy.kill_session()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Advanced Session-Based Crawling with Dynamic Content For modern web applications with dynamic content loading, here's how to handle pagination and content updates: ```python async def crawl_dynamic_content(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/microsoft/TypeScript/commits/main\" session_id = \"typescript_commits_session\" js_next_page = \"\"\" const button = document.querySelector('a[data-testid=\"pagination-next-button\"]'); if (button) button.click(); \"\"\" wait_for = \"\"\"() => { const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4'); if (commits.length === 0) return false; const firstCommit = commits[0].textContent.trim(); return firstCommit !== window.firstCommit; }\"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.Box-sc-g0xbh4-0\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.markdown-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3):  # Crawl 3 pages result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.Box-sc-g0xbh4-0\", extraction_strategy=extraction_strategy, js_code=js_next_page if page > 0 else None, wait_for=wait_for if page > 0 else None, js_only=page > 0, bypass_cache=True, headless=False, ) await crawler.crawler_strategy.kill_session(session_id) ```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "composition/implementation",
      "relationship_explanation": "Although not explicitly named in the snippet, AsyncWebCrawler by default instantiates AsyncPlaywrightCrawlerStrategy when no custom crawler_strategy is provided. This strategy handles the low-level browser interactions.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain reflects that AsyncWebCrawler internally composes AsyncPlaywrightCrawlerStrategy to manage crawls, even though the strategy is implicitly utilized in the example.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements session-based crawling with dynamic content handling through its crawl() method, which supports pagination through JavaScript execution (js_code parameter) and dynamic content loading (wait_for parameter) as shown in the documentation example.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Advanced Session-Based Crawling with Dynamic Content For modern web applications with dynamic content loading, here's how to handle pagination and content updates: ```python async def crawl_dynamic_content(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/microsoft/TypeScript/commits/main\" session_id = \"typescript_commits_session\" js_next_page = \"\"\" const button = document.querySelector('a[data-testid=\"pagination-next-button\"]'); if (button) button.click(); \"\"\" wait_for = \"\"\"() => { const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4'); if (commits.length === 0) return false; const firstCommit = commits[0].textContent.trim(); return firstCommit !== window.firstCommit; }\"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.Box-sc-g0xbh4-0\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.markdown-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3):  # Crawl 3 pages result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.Box-sc-g0xbh4-0\", extraction_strategy=extraction_strategy, js_code=js_next_page if page > 0 else None, wait_for=wait_for if page > 0 else None, js_only=page > 0, bypass_cache=True, headless=False, ) await crawler.crawler_strategy.kill_session(session_id) ```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "AsyncPlaywrightCrawlerStrategy, which is used by AsyncWebCrawler, extends AsyncCrawlerStrategy. This base class defines the abstract interface for crawler strategies, forming part of the underlying design.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain shows the inheritance hierarchy: AsyncWebCrawler uses AsyncPlaywrightCrawlerStrategy, which in turn extends AsyncCrawlerStrategy, establishing the fundamental structure for crawling operations.",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface methods needed to implement the advanced session-based crawling functionality shown in the documentation, particularly the crawl method that handles the dynamic content extraction.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Advanced Session-Based Crawling with Dynamic Content For modern web applications with dynamic content loading, here's how to handle pagination and content updates: ```python async def crawl_dynamic_content(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/microsoft/TypeScript/commits/main\" session_id = \"typescript_commits_session\" js_next_page = \"\"\" const button = document.querySelector('a[data-testid=\"pagination-next-button\"]'); if (button) button.click(); \"\"\" wait_for = \"\"\"() => { const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4'); if (commits.length === 0) return false; const firstCommit = commits[0].textContent.trim(); return firstCommit !== window.firstCommit; }\"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.Box-sc-g0xbh4-0\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.markdown-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3):  # Crawl 3 pages result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.Box-sc-g0xbh4-0\", extraction_strategy=extraction_strategy, js_code=js_next_page if page > 0 else None, wait_for=wait_for if page > 0 else None, js_only=page > 0, bypass_cache=True, headless=False, ) await crawler.crawler_strategy.kill_session(session_id) ```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the scraped data and metadata from dynamic content crawling sessions, with fields like session_id and extracted_content that directly correspond to the session-based crawling approach shown in the documentation.",
      "ground_truth_trace_chain": "quickstart.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Advanced Session-Based Crawling with Dynamic Content For modern web applications with dynamic content loading, here's how to handle pagination and content updates: ```python async def crawl_dynamic_content(): async with AsyncWebCrawler(verbose=True) as crawler: url = \"https://github.com/microsoft/TypeScript/commits/main\" session_id = \"typescript_commits_session\" js_next_page = \"\"\" const button = document.querySelector('a[data-testid=\"pagination-next-button\"]'); if (button) button.click(); \"\"\" wait_for = \"\"\"() => { const commits = document.querySelectorAll('li.Box-sc-g0xbh4-0 h4'); if (commits.length === 0) return false; const firstCommit = commits[0].textContent.trim(); return firstCommit !== window.firstCommit; }\"\"\" schema = { \"name\": \"Commit Extractor\", \"baseSelector\": \"li.Box-sc-g0xbh4-0\", \"fields\": [ { \"name\": \"title\", \"selector\": \"h4.markdown-title\", \"type\": \"text\", \"transform\": \"strip\", }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) for page in range(3):  # Crawl 3 pages result = await crawler.arun( url=url, session_id=session_id, css_selector=\"li.Box-sc-g0xbh4-0\", extraction_strategy=extraction_strategy, js_code=js_next_page if page > 0 else None, wait_for=wait_for if page > 0 else None, js_only=page > 0, bypass_cache=True, headless=False, ) await crawler.crawler_strategy.kill_session(session_id) ```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "ExtractionStrategy",
      "ground_truth_relationship": "The ExtractionStrategy abstract base class defines the core interface needed to support the document's dynamic content extraction example, particularly through its extract method that processes HTML blocks into structured data as shown in the documentation's schema-based extraction.",
      "ground_truth_trace_chain": "quickstart.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Basic Usage\n\n```python\nfrom crawl4ai.extraction_strategy import CosineStrategy\n\nstrategy = CosineStrategy(\n    semantic_filter=\"product reviews\",    # Target content type\n    word_count_threshold=10,             # Minimum words per cluster\n    sim_threshold=0.3                    # Similarity threshold\n)\n\nasync with AsyncWebCrawler() as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com/reviews\",\n        extraction_strategy=strategy\n    )\n    \n    content = result.extracted_content\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 7,
      "artifact_title": "CosineStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "import and instantiation",
      "relationship_explanation": "The documentation snippet explicitly imports CosineStrategy from crawl4ai.extraction_strategy and creates an instance with parameters 'semantic_filter', 'word_count_threshold', and 'sim_threshold'. This directly demonstrates its usage.",
      "predicted_trace_chain": "docs/md_v2/extraction/cosine.md -> CosineStrategy",
      "predicted_trace_chain_explanation": "The document ('docs/md_v2/extraction/cosine.md') shows an import and instantiation of CosineStrategy, establishing a direct link from the documentation to the CosineStrategy class.",
      "ground_truth_relationship": "The code implements the CosineStrategy class with configurable parameters for semantic filtering, word count thresholds, and similarity thresholds exactly as shown in the basic usage documentation example, allowing users to create instances with custom filtering criteria for web content extraction.",
      "ground_truth_trace_chain": "cosine.md -> ExtractionStrategy -> CosineStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Basic Usage\n\n```python\nfrom crawl4ai.extraction_strategy import CosineStrategy\n\nstrategy = CosineStrategy(\n    semantic_filter=\"product reviews\",    # Target content type\n    word_count_threshold=10,             # Minimum words per cluster\n    sim_threshold=0.3                    # Similarity threshold\n)\n\nasync with AsyncWebCrawler() as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com/reviews\",\n        extraction_strategy=strategy\n    )\n    \n    content = result.extracted_content\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "extends",
      "relationship_explanation": "CosineStrategy is defined as a subclass of ExtractionStrategy. Although ExtractionStrategy is not directly mentioned in the snippet, it is inherently used as the base class for CosineStrategy, thus forming an implicit relationship.",
      "predicted_trace_chain": "docs/md_v2/extraction/cosine.md -> CosineStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "Starting at the document, the chain goes to CosineStrategy (which is explicitly used) and then to its base class, ExtractionStrategy, to indicate the inherited extraction interface.",
      "ground_truth_relationship": "The ExtractionStrategy base class defines the core interface and parallel processing functionality shown in the documentation example, where specific strategies like CosineStrategy inherit and implement the extract method with their own parameters.",
      "ground_truth_trace_chain": "cosine.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Basic Usage\n\n```python\nfrom crawl4ai.extraction_strategy import CosineStrategy\n\nstrategy = CosineStrategy(\n    semantic_filter=\"product reviews\",    # Target content type\n    word_count_threshold=10,             # Minimum words per cluster\n    sim_threshold=0.3                    # Similarity threshold\n)\n\nasync with AsyncWebCrawler() as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com/reviews\",\n        extraction_strategy=strategy\n    )\n    \n    content = result.extracted_content\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "usage",
      "relationship_explanation": "The snippet uses AsyncWebCrawler in an asynchronous context manager (using 'async with'), demonstrating that the crawler is directly instantiated and operated for web crawling.",
      "predicted_trace_chain": "docs/md_v2/extraction/cosine.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The document directly instantiates AsyncWebCrawler, establishing a clear trace from the documentation to the AsyncWebCrawler class.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the documented functionality by providing an async context manager with arun() method that accepts URL and extraction strategy parameters, exactly matching the basic usage example shown in the documentation.",
      "ground_truth_trace_chain": "cosine.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Basic Usage\n\n```python\nfrom crawl4ai.extraction_strategy import CosineStrategy\n\nstrategy = CosineStrategy(\n    semantic_filter=\"product reviews\",    # Target content type\n    word_count_threshold=10,             # Minimum words per cluster\n    sim_threshold=0.3                    # Similarity threshold\n)\n\nasync with AsyncWebCrawler() as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com/reviews\",\n        extraction_strategy=strategy\n    )\n    \n    content = result.extracted_content\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "After instantiating AsyncWebCrawler, the snippet calls the 'arun()' method to perform the crawl, passing in the URL and the extraction strategy. This is an explicit usage of the arun() method.",
      "predicted_trace_chain": "docs/md_v2/extraction/cosine.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain depicts that the document first uses AsyncWebCrawler and then the arun() method of that class to retrieve crawl results, forming a clear pathway.",
      "ground_truth_relationship": "The code implements an asynchronous crawling method that accepts the extraction_strategy parameter shown in the documentation example, processing the URL with configurable thresholds and returning a CrawlResult containing extracted content.",
      "ground_truth_trace_chain": "cosine.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Basic Usage\n\n```python\nfrom crawl4ai.extraction_strategy import CosineStrategy\n\nstrategy = CosineStrategy(\n    semantic_filter=\"product reviews\",    # Target content type\n    word_count_threshold=10,             # Minimum words per cluster\n    sim_threshold=0.3                    # Similarity threshold\n)\n\nasync with AsyncWebCrawler() as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com/reviews\",\n        extraction_strategy=strategy\n    )\n    \n    content = result.extracted_content\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 11,
      "artifact_title": "CrawlResult.extracted_content",
      "predicted_relationship": "implicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The return object from crawler.arun() is expected to be a CrawlResult, and the snippet accesses its 'extracted_content' attribute to obtain the extracted data. This is an implicit reference to the public interface provided by CrawlResult.",
      "predicted_trace_chain": "docs/md_v2/extraction/cosine.md -> AsyncWebCrawler -> AsyncWebCrawler.arun() -> CrawlResult.extracted_content",
      "predicted_trace_chain_explanation": "The document\u2019s usage begins with AsyncWebCrawler, moves to invoking its arun() method (which returns a CrawlResult), and then accesses the extracted_content attribute, demonstrating a complete chain from the documentation to the specific attribute.",
      "ground_truth_relationship": "The extracted_content property holds the text content gathered by the crawler after applying the specified semantic filtering and clustering strategy.",
      "ground_truth_trace_chain": "cosine.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Basic Usage\n\n```python\nfrom crawl4ai.extraction_strategy import CosineStrategy\n\nstrategy = CosineStrategy(\n    semantic_filter=\"product reviews\",    # Target content type\n    word_count_threshold=10,             # Minimum words per cluster\n    sim_threshold=0.3                    # Similarity threshold\n)\n\nasync with AsyncWebCrawler() as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com/reviews\",\n        extraction_strategy=strategy\n    )\n    \n    content = result.extracted_content\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the structure that holds the crawling output, including the extracted_content field shown being accessed in the documentation's example code.",
      "ground_truth_trace_chain": "cosine.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Basic Usage\n\n```python\nfrom crawl4ai.extraction_strategy import CosineStrategy\n\nstrategy = CosineStrategy(\n    semantic_filter=\"product reviews\",    # Target content type\n    word_count_threshold=10,             # Minimum words per cluster\n    sim_threshold=0.3                    # Similarity threshold\n)\n\nasync with AsyncWebCrawler() as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com/reviews\",\n        extraction_strategy=strategy\n    )\n    \n    content = result.extracted_content\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The code implements an AsyncPlaywrightCrawlerStrategy class that powers the AsyncWebCrawler shown in the documentation, handling the low-level browser automation needed to execute the semantic content extraction described in the example usage.",
      "ground_truth_trace_chain": "cosine.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Basic Usage\n\n```python\nfrom crawl4ai.extraction_strategy import CosineStrategy\n\nstrategy = CosineStrategy(\n    semantic_filter=\"product reviews\",    # Target content type\n    word_count_threshold=10,             # Minimum words per cluster\n    sim_threshold=0.3                    # Similarity threshold\n)\n\nasync with AsyncWebCrawler() as crawler:\n    result = await crawler.arun(\n        url=\"https://example.com/reviews\",\n        extraction_strategy=strategy\n    )\n    \n    content = result.extracted_content\n```",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface methods that enable the documented crawler usage pattern, including the main crawl() method that processes URLs and returns responses.",
      "ground_truth_trace_chain": "cosine.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Logging and Debugging\n\nEnable verbose mode for detailed logging:\n\n```python\nasync with AsyncWebCrawler(verbose=True) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "Class instantiation and configuration",
      "relationship_explanation": "The documentation snippet explicitly instantiates AsyncWebCrawler with verbose mode enabled. The usage of 'AsyncWebCrawler(verbose=True)' shows that the class is being directly used to enable detailed logging and debugging.",
      "predicted_trace_chain": "docs/md_v2/basic/simple-crawling.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The document 'simple-crawling.md' directly initiates an AsyncWebCrawler instance, establishing the starting point of the traceability chain for logging and debugging functionality.",
      "ground_truth_relationship": "The verbose parameter in the AsyncWebCrawler class enables detailed logging through conditional print statements that track crawler initialization, warmup status, and crawling progress throughout the code's execution.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Logging and Debugging\n\nEnable verbose mode for detailed logging:\n\n```python\nasync with AsyncWebCrawler(verbose=True) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "Method invocation",
      "relationship_explanation": "The documentation snippet explicitly calls the 'arun' method (result = await crawler.arun(url=\"https://example.com\")) on the AsyncWebCrawler instance to perform the crawling operation. This demonstrates how the public interface of AsyncWebCrawler is used.",
      "predicted_trace_chain": "docs/md_v2/basic/simple-crawling.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the document 'simple-crawling.md', the chain flows through the instantiation of AsyncWebCrawler and then to the invocation of its 'arun()' method, illustrating the pathway of using the crawler for web crawling with logging enabled.",
      "ground_truth_relationship": "The code implements verbose logging by conditionally printing crawl timing and status information when verbose=True is set, matching the documentation's guidance for enabling detailed logging output.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Logging and Debugging\n\nEnable verbose mode for detailed logging:\n\n```python\nasync with AsyncWebCrawler(verbose=True) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class enables detailed logging by storing diagnostic information like error_message, status_code, and response_headers that get populated when verbose mode is enabled.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Logging and Debugging\n\nEnable verbose mode for detailed logging:\n\n```python\nasync with AsyncWebCrawler(verbose=True) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The code implements verbose logging functionality through the 'verbose' parameter in the AsyncPlaywrightCrawlerStrategy class, which when set to True prints crawling progress messages using print statements prefixed with '[LOG]'.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Logging and Debugging\n\nEnable verbose mode for detailed logging:\n\n```python\nasync with AsyncWebCrawler(verbose=True) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The abstract AsyncCrawlerStrategy class provides the foundation for implementing verbose logging through its crawl methods, which the documentation demonstrates how to enable via the verbose parameter.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Content Cleaning\n\n### Understanding Clean Content\nWhen crawling web pages, you often encounter a lot of noise - advertisements, navigation menus, footers, popups, and other irrelevant content. Crawl4AI automatically cleans this noise using several approaches:\n\n1. **Basic Cleaning**: Removes unwanted HTML elements and attributes\n2. **Content Relevance**: Identifies and preserves meaningful content blocks\n3. **Layout Analysis**: Understands page structure to identify main content areas\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    word_count_threshold=10,        # Remove blocks with fewer words\n    excluded_tags=['form', 'nav'],  # Remove specific HTML tags\n    remove_overlay_elements=True    # Remove popups/modals\n)\n\n# Get clean content\nprint(result.cleaned_html)  # Cleaned HTML\nprint(result.markdown)      # Clean markdown version\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "invocation",
      "relationship_explanation": "The documentation snippet explicitly shows usage of the 'arun()' method via the call 'result = await crawler.arun(...)'. This method is the entry point for crawling and cleaning content, as the parameters (e.g. word_count_threshold, remove_overlay_elements) are directly passed to it.",
      "predicted_trace_chain": "content-processing.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from the document 'content-processing.md' (extracted from the location), the chain immediately leads to 'AsyncWebCrawler.arun()' since the usage example directly invokes this method.",
      "ground_truth_relationship": "The arun() method implements the documented content cleaning features by accepting parameters like word_count_threshold and excluded_tags which control how text blocks are filtered and HTML elements are removed during the crawling process.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Content Cleaning\n\n### Understanding Clean Content\nWhen crawling web pages, you often encounter a lot of noise - advertisements, navigation menus, footers, popups, and other irrelevant content. Crawl4AI automatically cleans this noise using several approaches:\n\n1. **Basic Cleaning**: Removes unwanted HTML elements and attributes\n2. **Content Relevance**: Identifies and preserves meaningful content blocks\n3. **Layout Analysis**: Understands page structure to identify main content areas\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    word_count_threshold=10,        # Remove blocks with fewer words\n    excluded_tags=['form', 'nav'],  # Remove specific HTML tags\n    remove_overlay_elements=True    # Remove popups/modals\n)\n\n# Get clean content\nprint(result.cleaned_html)  # Cleaned HTML\nprint(result.markdown)      # Clean markdown version\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 9,
      "artifact_title": "CrawlResult.cleaned_html",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet prints 'result.cleaned_html' to display the cleaned HTML. This attribute represents the output after the cleaning process has been applied, showing the noise\u2010free HTML content.",
      "predicted_trace_chain": "content-processing.md -> CrawlResult.cleaned_html",
      "predicted_trace_chain_explanation": "The document demonstrates how the cleaned HTML is retrieved via the 'cleaned_html' attribute of the crawl result, making it a direct link from the documentation to this attribute.",
      "ground_truth_relationship": "The cleaned_html Optional[str] property stores the sanitized HTML output after Crawl4AI applies its content cleaning steps including basic cleaning, content relevance checks, and layout analysis.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult.cleaned_html",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Content Cleaning\n\n### Understanding Clean Content\nWhen crawling web pages, you often encounter a lot of noise - advertisements, navigation menus, footers, popups, and other irrelevant content. Crawl4AI automatically cleans this noise using several approaches:\n\n1. **Basic Cleaning**: Removes unwanted HTML elements and attributes\n2. **Content Relevance**: Identifies and preserves meaningful content blocks\n3. **Layout Analysis**: Understands page structure to identify main content areas\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    word_count_threshold=10,        # Remove blocks with fewer words\n    excluded_tags=['form', 'nav'],  # Remove specific HTML tags\n    remove_overlay_elements=True    # Remove popups/modals\n)\n\n# Get clean content\nprint(result.cleaned_html)  # Cleaned HTML\nprint(result.markdown)      # Clean markdown version\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 15,
      "artifact_title": "CrawlResult.markdown",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The example includes printing 'result.markdown', which provides the markdown version of the cleaned content. This shows how the processed content is made available in a different format.",
      "predicted_trace_chain": "content-processing.md -> CrawlResult.markdown",
      "predicted_trace_chain_explanation": "Starting from the 'content-processing.md' document, the extraction of markdown content is directly traced to the 'CrawlResult.markdown' attribute as used in the example.",
      "ground_truth_relationship": "The markdown property in CrawlResult provides a cleaned, text-based version of the crawled content after removing noise elements like ads and popups as described in the Content Cleaning documentation.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult.markdown",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Content Cleaning\n\n### Understanding Clean Content\nWhen crawling web pages, you often encounter a lot of noise - advertisements, navigation menus, footers, popups, and other irrelevant content. Crawl4AI automatically cleans this noise using several approaches:\n\n1. **Basic Cleaning**: Removes unwanted HTML elements and attributes\n2. **Content Relevance**: Identifies and preserves meaningful content blocks\n3. **Layout Analysis**: Understands page structure to identify main content areas\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    word_count_threshold=10,        # Remove blocks with fewer words\n    excluded_tags=['form', 'nav'],  # Remove specific HTML tags\n    remove_overlay_elements=True    # Remove popups/modals\n)\n\n# Get clean content\nprint(result.cleaned_html)  # Cleaned HTML\nprint(result.markdown)      # Clean markdown version\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "implementation",
      "relationship_explanation": "Although not directly mentioned in the usage snippet, 'AsyncPlaywrightCrawlerStrategy' is the underlying crawler strategy used by 'AsyncWebCrawler.arun()'. The parameter 'remove_overlay_elements=True' in the call triggers internal cleaning functionality (i.e. removal of overlays/popups) that is implemented within this strategy.",
      "predicted_trace_chain": "content-processing.md -> AsyncWebCrawler.arun() -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain begins with the document, moves to the explicit call of 'AsyncWebCrawler.arun()', and then extends to 'AsyncPlaywrightCrawlerStrategy' since the arun() method delegates the cleaning (via remove_overlay_elements) to this strategy, forming an implicit link.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the content cleaning functionality through its remove_overlay_elements method, which programmatically removes unwanted HTML elements like popups, modals, and cookie notices using JavaScript selectors that match the documented cleaning approaches.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Content Cleaning\n\n### Understanding Clean Content\nWhen crawling web pages, you often encounter a lot of noise - advertisements, navigation menus, footers, popups, and other irrelevant content. Crawl4AI automatically cleans this noise using several approaches:\n\n1. **Basic Cleaning**: Removes unwanted HTML elements and attributes\n2. **Content Relevance**: Identifies and preserves meaningful content blocks\n3. **Layout Analysis**: Understands page structure to identify main content areas\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    word_count_threshold=10,        # Remove blocks with fewer words\n    excluded_tags=['form', 'nav'],  # Remove specific HTML tags\n    remove_overlay_elements=True    # Remove popups/modals\n)\n\n# Get clean content\nprint(result.cleaned_html)  # Cleaned HTML\nprint(result.markdown)      # Clean markdown version\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the outputs of content cleaning operations through its cleaned_html, markdown, and fit_markdown fields that correspond to the different cleaning approaches described in the documentation.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Content Cleaning\n\n### Understanding Clean Content\nWhen crawling web pages, you often encounter a lot of noise - advertisements, navigation menus, footers, popups, and other irrelevant content. Crawl4AI automatically cleans this noise using several approaches:\n\n1. **Basic Cleaning**: Removes unwanted HTML elements and attributes\n2. **Content Relevance**: Identifies and preserves meaningful content blocks\n3. **Layout Analysis**: Understands page structure to identify main content areas\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    word_count_threshold=10,        # Remove blocks with fewer words\n    excluded_tags=['form', 'nav'],  # Remove specific HTML tags\n    remove_overlay_elements=True    # Remove popups/modals\n)\n\n# Get clean content\nprint(result.cleaned_html)  # Cleaned HTML\nprint(result.markdown)      # Clean markdown version\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface for implementing the content cleaning operations described in the documentation through abstract methods like crawl() which processes URLs and applies the cleaning configurations.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Content Cleaning\n\n### Understanding Clean Content\nWhen crawling web pages, you often encounter a lot of noise - advertisements, navigation menus, footers, popups, and other irrelevant content. Crawl4AI automatically cleans this noise using several approaches:\n\n1. **Basic Cleaning**: Removes unwanted HTML elements and attributes\n2. **Content Relevance**: Identifies and preserves meaningful content blocks\n3. **Layout Analysis**: Understands page structure to identify main content areas\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    word_count_threshold=10,        # Remove blocks with fewer words\n    excluded_tags=['form', 'nav'],  # Remove specific HTML tags\n    remove_overlay_elements=True    # Remove popups/modals\n)\n\n# Get clean content\nprint(result.cleaned_html)  # Cleaned HTML\nprint(result.markdown)      # Clean markdown version\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the documented content cleaning through its arun method, which uses word_count_threshold and excluded elements (defined in WebScrappingStrategy) to remove noise and preserve meaningful content as described in the documentation.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "# Browser Configuration\n\nCrawl4AI supports multiple browser engines and offers extensive configuration options for browser behavior.\n\n## Browser Types\n\nChoose from three browser engines:\n\n```python\n# Chromium (default)\nasync with AsyncWebCrawler(browser_type=\"chromium\") as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Firefox\nasync with AsyncWebCrawler(browser_type=\"firefox\") as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# WebKit\nasync with AsyncWebCrawler(browser_type=\"webkit\") as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "usage",
      "relationship_explanation": "The documentation snippet shows direct instantiation of the AsyncWebCrawler class using the browser_type parameter (e.g., 'chromium', 'firefox', 'webkit'), which clearly demonstrates its role in supporting multiple browser engines.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The code example in the documentation directly creates an AsyncWebCrawler instance, making it an explicit reference in the traceability chain.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements browser type selection through its crawler_strategy parameter, which accepts different browser engines (chromium, firefox, webkit) as documented in the configuration guide.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Browser Configuration\n\nCrawl4AI supports multiple browser engines and offers extensive configuration options for browser behavior.\n\n## Browser Types\n\nChoose from three browser engines:\n\n```python\n# Chromium (default)\nasync with AsyncWebCrawler(browser_type=\"chromium\") as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Firefox\nasync with AsyncWebCrawler(browser_type=\"firefox\") as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# WebKit\nasync with AsyncWebCrawler(browser_type=\"webkit\") as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The example code calls the arun() method on the AsyncWebCrawler instance to commence crawling, thus explicitly demonstrating its use as part of the browser configuration workflow.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The method call chain in the documentation directly shows the invocation of the arun() method after creating an AsyncWebCrawler instance.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method implements the browser engine selection documented in the configuration guide by accepting a browser_type parameter that determines which engine (Chromium, Firefox, or WebKit) will be used for crawling the specified URL.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Browser Configuration\n\nCrawl4AI supports multiple browser engines and offers extensive configuration options for browser behavior.\n\n## Browser Types\n\nChoose from three browser engines:\n\n```python\n# Chromium (default)\nasync with AsyncWebCrawler(browser_type=\"chromium\") as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Firefox\nasync with AsyncWebCrawler(browser_type=\"firefox\") as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# WebKit\nasync with AsyncWebCrawler(browser_type=\"webkit\") as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "internal dependency",
      "relationship_explanation": "While not directly mentioned in the documentation snippet, AsyncWebCrawler internally defaults to using AsyncPlaywrightCrawlerStrategy to handle browser automation and configuration based on the browser_type parameter. This underlying strategy is essential for enabling the behavior described.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "AsyncWebCrawler automatically instantiates AsyncPlaywrightCrawlerStrategy when no alternative strategy is provided, making it an implicit but necessary link in the browser configuration chain.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements browser type selection through its start() method, where it uses the browser_type parameter to launch either Chromium (default), Firefox, or WebKit browsers as documented in the configuration guide.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Browser Configuration\n\nCrawl4AI supports multiple browser engines and offers extensive configuration options for browser behavior.\n\n## Browser Types\n\nChoose from three browser engines:\n\n```python\n# Chromium (default)\nasync with AsyncWebCrawler(browser_type=\"chromium\") as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Firefox\nasync with AsyncWebCrawler(browser_type=\"firefox\") as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# WebKit\nasync with AsyncWebCrawler(browser_type=\"webkit\") as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "AsyncPlaywrightCrawlerStrategy extends AsyncCrawlerStrategy. This inheritance relationship underpins the design of the crawling strategies, ensuring that browser configurations comply with a defined abstract interface.",
      "predicted_trace_chain": "docs/md_v2/basic/browser-config.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "This chain outlines the inheritance hierarchy that supports browser configuration, where AsyncCrawlerStrategy serves as the abstract base class for its implementing strategies.",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the core interface methods that each browser type (Chromium, Firefox, WebKit) must implement to provide unified crawling functionality.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "# Browser Configuration\n\nCrawl4AI supports multiple browser engines and offers extensive configuration options for browser behavior.\n\n## Browser Types\n\nChoose from three browser engines:\n\n```python\n# Chromium (default)\nasync with AsyncWebCrawler(browser_type=\"chromium\") as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Firefox\nasync with AsyncWebCrawler(browser_type=\"firefox\") as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# WebKit\nasync with AsyncWebCrawler(browser_type=\"webkit\") as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the structured data model that stores the crawling outcomes for any of the three supported browser types (Chromium, Firefox, or WebKit) documented in the browser configuration guide.",
      "ground_truth_trace_chain": "browser-config.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Error Handling and Retries\n\nWhen working with external LLM APIs, it's important to handle potential errors and implement retry logic. Here's an example of how you might do this:\n\n```python\nimport asyncio\nfrom tenacity import retry, stop_after_attempt, wait_exponential\n\nclass LLMExtractionError(Exception):\n    pass\n\n@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))\nasync def extract_with_retry(crawler, url, extraction_strategy):\n    try:\n        result = await crawler.arun(url=url, extraction_strategy=extraction_strategy, bypass_cache=True)\n        return json.loads(result.extracted_content)\n    except Exception as e:\n        raise LLMExtractionError(f\"Failed to extract content: {str(e)}\")\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        try:\n            content = await extract_with_retry(\n                crawler,\n                \"https://www.example.com\",\n                LLMExtractionStrategy(\n                    provider=\"openai/gpt-4o\",\n                    api_token=os.getenv('OPENAI_API_KEY'),\n                    instruction=\"Extract and summarize main points\"\n                )\n            )\n            print(\"Extracted content:\", content)\n        except LLMExtractionError as e:\n            print(f\"Extraction failed after retries: {e}\")\n\nasyncio.run(main())\n```\n\nThis example uses the `tenacity` library to implement a retry mechanism with exponential backoff, which can help handle temporary failures or rate limiting from the LLM API.",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation and usage",
      "relationship_explanation": "The documentation snippet explicitly creates an AsyncWebCrawler instance using 'async with AsyncWebCrawler(verbose=True) as crawler', indicating its direct role in initiating the crawl process.",
      "predicted_trace_chain": "docs/md_v2/extraction/llm.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain starts from the document location and directly instantiates AsyncWebCrawler, establishing the entry point for the subsequent extraction workflow.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the documented error handling through its arun() method which wraps crawling operations in a try-except block, allowing it to work seamlessly with the documented retry decorator pattern for handling API failures.",
      "ground_truth_trace_chain": "llm.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Error Handling and Retries\n\nWhen working with external LLM APIs, it's important to handle potential errors and implement retry logic. Here's an example of how you might do this:\n\n```python\nimport asyncio\nfrom tenacity import retry, stop_after_attempt, wait_exponential\n\nclass LLMExtractionError(Exception):\n    pass\n\n@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))\nasync def extract_with_retry(crawler, url, extraction_strategy):\n    try:\n        result = await crawler.arun(url=url, extraction_strategy=extraction_strategy, bypass_cache=True)\n        return json.loads(result.extracted_content)\n    except Exception as e:\n        raise LLMExtractionError(f\"Failed to extract content: {str(e)}\")\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        try:\n            content = await extract_with_retry(\n                crawler,\n                \"https://www.example.com\",\n                LLMExtractionStrategy(\n                    provider=\"openai/gpt-4o\",\n                    api_token=os.getenv('OPENAI_API_KEY'),\n                    instruction=\"Extract and summarize main points\"\n                )\n            )\n            print(\"Extracted content:\", content)\n        except LLMExtractionError as e:\n            print(f\"Extraction failed after retries: {e}\")\n\nasyncio.run(main())\n```\n\nThis example uses the `tenacity` library to implement a retry mechanism with exponential backoff, which can help handle temporary failures or rate limiting from the LLM API.",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "strategy instantiation",
      "relationship_explanation": "The snippet explicitly instantiates LLMExtractionStrategy with parameters (provider, api_token, instruction), which is used to define how the content extraction via an LLM should be performed.",
      "predicted_trace_chain": "docs/md_v2/extraction/llm.md -> LLMExtractionStrategy",
      "predicted_trace_chain_explanation": "Starting from the document, the LLMExtractionStrategy is directly instantiated, showing that it is the chosen strategy for LLM-based extraction in this example.",
      "ground_truth_relationship": "The code implements error handling and retries through a custom LLMExtractionStrategy class that uses ThreadPoolExecutor for parallel processing and includes error handling in its extract() method, which appends error information to extracted_content when exceptions occur.",
      "ground_truth_trace_chain": "llm.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Error Handling and Retries\n\nWhen working with external LLM APIs, it's important to handle potential errors and implement retry logic. Here's an example of how you might do this:\n\n```python\nimport asyncio\nfrom tenacity import retry, stop_after_attempt, wait_exponential\n\nclass LLMExtractionError(Exception):\n    pass\n\n@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))\nasync def extract_with_retry(crawler, url, extraction_strategy):\n    try:\n        result = await crawler.arun(url=url, extraction_strategy=extraction_strategy, bypass_cache=True)\n        return json.loads(result.extracted_content)\n    except Exception as e:\n        raise LLMExtractionError(f\"Failed to extract content: {str(e)}\")\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        try:\n            content = await extract_with_retry(\n                crawler,\n                \"https://www.example.com\",\n                LLMExtractionStrategy(\n                    provider=\"openai/gpt-4o\",\n                    api_token=os.getenv('OPENAI_API_KEY'),\n                    instruction=\"Extract and summarize main points\"\n                )\n            )\n            print(\"Extracted content:\", content)\n        except LLMExtractionError as e:\n            print(f\"Extraction failed after retries: {e}\")\n\nasyncio.run(main())\n```\n\nThis example uses the `tenacity` library to implement a retry mechanism with exponential backoff, which can help handle temporary failures or rate limiting from the LLM API.",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "implicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The code calls the 'arun()' method on the AsyncWebCrawler instance (via 'crawler.arun(...)'), which is implicitly responsible for executing the crawl and extraction operation with the provided strategy.",
      "predicted_trace_chain": "docs/md_v2/extraction/llm.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "This chain illustrates that the asynchronous crawling process is carried out by invoking the arun() method of AsyncWebCrawler, seamlessly linking to the extraction outcome.",
      "ground_truth_relationship": "The AsyncWebCrawler.arun() method implements comprehensive error handling by catching all exceptions in a try-except block and returning a CrawlResult object with error details, which aligns with the documentation's emphasis on error handling for external API interactions.",
      "ground_truth_trace_chain": "llm.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Error Handling and Retries\n\nWhen working with external LLM APIs, it's important to handle potential errors and implement retry logic. Here's an example of how you might do this:\n\n```python\nimport asyncio\nfrom tenacity import retry, stop_after_attempt, wait_exponential\n\nclass LLMExtractionError(Exception):\n    pass\n\n@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))\nasync def extract_with_retry(crawler, url, extraction_strategy):\n    try:\n        result = await crawler.arun(url=url, extraction_strategy=extraction_strategy, bypass_cache=True)\n        return json.loads(result.extracted_content)\n    except Exception as e:\n        raise LLMExtractionError(f\"Failed to extract content: {str(e)}\")\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        try:\n            content = await extract_with_retry(\n                crawler,\n                \"https://www.example.com\",\n                LLMExtractionStrategy(\n                    provider=\"openai/gpt-4o\",\n                    api_token=os.getenv('OPENAI_API_KEY'),\n                    instruction=\"Extract and summarize main points\"\n                )\n            )\n            print(\"Extracted content:\", content)\n        except LLMExtractionError as e:\n            print(f\"Extraction failed after retries: {e}\")\n\nasyncio.run(main())\n```\n\nThis example uses the `tenacity` library to implement a retry mechanism with exponential backoff, which can help handle temporary failures or rate limiting from the LLM API.",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_id": 11,
      "artifact_title": "CrawlResult.extracted_content",
      "predicted_relationship": "implicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet accesses 'result.extracted_content' to retrieve the processed extraction output from the crawl result, demonstrating usage of this public attribute as the endpoint for extraction data.",
      "predicted_trace_chain": "docs/md_v2/extraction/llm.md -> AsyncWebCrawler.arun() -> CrawlResult.extracted_content",
      "predicted_trace_chain_explanation": "This chain shows that the output from the arun() method is a CrawlResult object, from which the 'extracted_content' attribute is accessed to obtain the final extracted information.",
      "ground_truth_relationship": "The CrawlResult.extracted_content field stores the text data retrieved from web pages that gets processed through LLM extraction, which can be retried using the documented retry mechanism if the extraction fails.",
      "ground_truth_trace_chain": "llm.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Error Handling and Retries\n\nWhen working with external LLM APIs, it's important to handle potential errors and implement retry logic. Here's an example of how you might do this:\n\n```python\nimport asyncio\nfrom tenacity import retry, stop_after_attempt, wait_exponential\n\nclass LLMExtractionError(Exception):\n    pass\n\n@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))\nasync def extract_with_retry(crawler, url, extraction_strategy):\n    try:\n        result = await crawler.arun(url=url, extraction_strategy=extraction_strategy, bypass_cache=True)\n        return json.loads(result.extracted_content)\n    except Exception as e:\n        raise LLMExtractionError(f\"Failed to extract content: {str(e)}\")\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        try:\n            content = await extract_with_retry(\n                crawler,\n                \"https://www.example.com\",\n                LLMExtractionStrategy(\n                    provider=\"openai/gpt-4o\",\n                    api_token=os.getenv('OPENAI_API_KEY'),\n                    instruction=\"Extract and summarize main points\"\n                )\n            )\n            print(\"Extracted content:\", content)\n        except LLMExtractionError as e:\n            print(f\"Extraction failed after retries: {e}\")\n\nasyncio.run(main())\n```\n\nThis example uses the `tenacity` library to implement a retry mechanism with exponential backoff, which can help handle temporary failures or rate limiting from the LLM API.",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class has error handling fields like error_message and status_code that support the documented retry mechanism by storing error information when API calls fail.",
      "ground_truth_trace_chain": "llm.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Error Handling and Retries\n\nWhen working with external LLM APIs, it's important to handle potential errors and implement retry logic. Here's an example of how you might do this:\n\n```python\nimport asyncio\nfrom tenacity import retry, stop_after_attempt, wait_exponential\n\nclass LLMExtractionError(Exception):\n    pass\n\n@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))\nasync def extract_with_retry(crawler, url, extraction_strategy):\n    try:\n        result = await crawler.arun(url=url, extraction_strategy=extraction_strategy, bypass_cache=True)\n        return json.loads(result.extracted_content)\n    except Exception as e:\n        raise LLMExtractionError(f\"Failed to extract content: {str(e)}\")\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        try:\n            content = await extract_with_retry(\n                crawler,\n                \"https://www.example.com\",\n                LLMExtractionStrategy(\n                    provider=\"openai/gpt-4o\",\n                    api_token=os.getenv('OPENAI_API_KEY'),\n                    instruction=\"Extract and summarize main points\"\n                )\n            )\n            print(\"Extracted content:\", content)\n        except LLMExtractionError as e:\n            print(f\"Extraction failed after retries: {e}\")\n\nasyncio.run(main())\n```\n\nThis example uses the `tenacity` library to implement a retry mechanism with exponential backoff, which can help handle temporary failures or rate limiting from the LLM API.",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The code implements error handling through class closures and cleanup methods in the crawler strategy, complementing the documented retry mechanism by ensuring proper resource management even when errors occur during crawling operations.",
      "ground_truth_trace_chain": "llm.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Error Handling and Retries\n\nWhen working with external LLM APIs, it's important to handle potential errors and implement retry logic. Here's an example of how you might do this:\n\n```python\nimport asyncio\nfrom tenacity import retry, stop_after_attempt, wait_exponential\n\nclass LLMExtractionError(Exception):\n    pass\n\n@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))\nasync def extract_with_retry(crawler, url, extraction_strategy):\n    try:\n        result = await crawler.arun(url=url, extraction_strategy=extraction_strategy, bypass_cache=True)\n        return json.loads(result.extracted_content)\n    except Exception as e:\n        raise LLMExtractionError(f\"Failed to extract content: {str(e)}\")\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        try:\n            content = await extract_with_retry(\n                crawler,\n                \"https://www.example.com\",\n                LLMExtractionStrategy(\n                    provider=\"openai/gpt-4o\",\n                    api_token=os.getenv('OPENAI_API_KEY'),\n                    instruction=\"Extract and summarize main points\"\n                )\n            )\n            print(\"Extracted content:\", content)\n        except LLMExtractionError as e:\n            print(f\"Extraction failed after retries: {e}\")\n\nasyncio.run(main())\n```\n\nThis example uses the `tenacity` library to implement a retry mechanism with exponential backoff, which can help handle temporary failures or rate limiting from the LLM API.",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the interface that concrete crawlers must implement to work with the error handling and retry logic shown in the documentation, where specific implementations would handle the actual HTTP requests and content extraction that might need retrying.",
      "ground_truth_trace_chain": "llm.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Error Handling and Retries\n\nWhen working with external LLM APIs, it's important to handle potential errors and implement retry logic. Here's an example of how you might do this:\n\n```python\nimport asyncio\nfrom tenacity import retry, stop_after_attempt, wait_exponential\n\nclass LLMExtractionError(Exception):\n    pass\n\n@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))\nasync def extract_with_retry(crawler, url, extraction_strategy):\n    try:\n        result = await crawler.arun(url=url, extraction_strategy=extraction_strategy, bypass_cache=True)\n        return json.loads(result.extracted_content)\n    except Exception as e:\n        raise LLMExtractionError(f\"Failed to extract content: {str(e)}\")\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        try:\n            content = await extract_with_retry(\n                crawler,\n                \"https://www.example.com\",\n                LLMExtractionStrategy(\n                    provider=\"openai/gpt-4o\",\n                    api_token=os.getenv('OPENAI_API_KEY'),\n                    instruction=\"Extract and summarize main points\"\n                )\n            )\n            print(\"Extracted content:\", content)\n        except LLMExtractionError as e:\n            print(f\"Extraction failed after retries: {e}\")\n\nasyncio.run(main())\n```\n\nThis example uses the `tenacity` library to implement a retry mechanism with exponential backoff, which can help handle temporary failures or rate limiting from the LLM API.",
      "document_location": "docs/md_v2/extraction/llm.md",
      "artifact_title": "ExtractionStrategy",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the foundational retry-compatible extraction interface that the documentation's error handling system wraps with the @retry decorator to implement resilient LLM processing.",
      "ground_truth_trace_chain": "llm.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Complete Example\n\nHere's a more comprehensive example showing common usage patterns:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com\",\n            # Content filtering\n            word_count_threshold=10,\n            excluded_tags=['form', 'header'],\n            exclude_external_links=True,\n            \n            # Content processing\n            process_iframes=True,\n            remove_overlay_elements=True,\n            \n            # Cache control\n            bypass_cache=False  # Use cache if available\n        )\n        \n        if result.success:\n            # Print clean content\n            print(\"Content:\", result.markdown[:500])  # First 500 chars\n            \n            # Process images\n            for image in result.media[\"images\"]:\n                print(f\"Found image: {image['src']}\")\n            \n            # Process links\n            for link in result.links[\"internal\"]:\n                print(f\"Internal link: {link['href']}\")\n                \n        else:\n            print(f\"Crawl failed: {result.error_message}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "class usage",
      "relationship_explanation": "The documentation snippet explicitly imports and instantiates AsyncWebCrawler using 'from crawl4ai import AsyncWebCrawler' and 'async with AsyncWebCrawler(verbose=True) as crawler:'.",
      "predicted_trace_chain": "simple-crawling.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The example in 'simple-crawling.md' starts by creating an instance of AsyncWebCrawler, establishing a direct relationship with this class.",
      "ground_truth_relationship": "The code implements the AsyncWebCrawler class with methods like arun() that directly support all the documented functionality shown in the example, including content filtering, processing, and cache control through corresponding parameters.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Complete Example\n\nHere's a more comprehensive example showing common usage patterns:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com\",\n            # Content filtering\n            word_count_threshold=10,\n            excluded_tags=['form', 'header'],\n            exclude_external_links=True,\n            \n            # Content processing\n            process_iframes=True,\n            remove_overlay_elements=True,\n            \n            # Cache control\n            bypass_cache=False  # Use cache if available\n        )\n        \n        if result.success:\n            # Print clean content\n            print(\"Content:\", result.markdown[:500])  # First 500 chars\n            \n            # Process images\n            for image in result.media[\"images\"]:\n                print(f\"Found image: {image['src']}\")\n            \n            # Process links\n            for link in result.links[\"internal\"]:\n                print(f\"Internal link: {link['href']}\")\n                \n        else:\n            print(f\"Crawl failed: {result.error_message}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method call",
      "relationship_explanation": "Within the example, the method 'arun' is explicitly called on the AsyncWebCrawler instance to perform the crawling process.",
      "predicted_trace_chain": "simple-crawling.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "After instantiating AsyncWebCrawler, the example invokes its 'arun' method, forming a direct chain from the document to this method.",
      "ground_truth_relationship": "The documented example demonstrates usage patterns of AsyncWebCrawler.arun() by showing how its various parameters like word_count_threshold, bypass_cache, and other content filtering options are implemented in the actual method definition through parameter validation, cache checking, and content processing logic.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Complete Example\n\nHere's a more comprehensive example showing common usage patterns:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com\",\n            # Content filtering\n            word_count_threshold=10,\n            excluded_tags=['form', 'header'],\n            exclude_external_links=True,\n            \n            # Content processing\n            process_iframes=True,\n            remove_overlay_elements=True,\n            \n            # Cache control\n            bypass_cache=False  # Use cache if available\n        )\n        \n        if result.success:\n            # Print clean content\n            print(\"Content:\", result.markdown[:500])  # First 500 chars\n            \n            # Process images\n            for image in result.media[\"images\"]:\n                print(f\"Found image: {image['src']}\")\n            \n            # Process links\n            for link in result.links[\"internal\"]:\n                print(f\"Internal link: {link['href']}\")\n                \n        else:\n            print(f\"Crawl failed: {result.error_message}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 20,
      "artifact_title": "CrawlResult.success",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The code snippet checks 'if result.success:' to determine if the crawl was successful, indicating direct use of the 'success' attribute from the CrawlResult object.",
      "predicted_trace_chain": "simple-crawling.md -> AsyncWebCrawler.arun() -> CrawlResult.success",
      "predicted_trace_chain_explanation": "The crawl result returned from AsyncWebCrawler.arun() provides the 'success' attribute, which is then used in the decision logic in the example.",
      "ground_truth_relationship": "The success boolean property in CrawlResult is used to check if the crawl operation completed successfully before processing the extracted content, media and links from the crawled page.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult.success",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Complete Example\n\nHere's a more comprehensive example showing common usage patterns:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com\",\n            # Content filtering\n            word_count_threshold=10,\n            excluded_tags=['form', 'header'],\n            exclude_external_links=True,\n            \n            # Content processing\n            process_iframes=True,\n            remove_overlay_elements=True,\n            \n            # Cache control\n            bypass_cache=False  # Use cache if available\n        )\n        \n        if result.success:\n            # Print clean content\n            print(\"Content:\", result.markdown[:500])  # First 500 chars\n            \n            # Process images\n            for image in result.media[\"images\"]:\n                print(f\"Found image: {image['src']}\")\n            \n            # Process links\n            for link in result.links[\"internal\"]:\n                print(f\"Internal link: {link['href']}\")\n                \n        else:\n            print(f\"Crawl failed: {result.error_message}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 15,
      "artifact_title": "CrawlResult.markdown",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The example prints 'result.markdown[:500]' to output the clean content, directly accessing the markdown attribute of the CrawlResult.",
      "predicted_trace_chain": "simple-crawling.md -> AsyncWebCrawler.arun() -> CrawlResult.markdown",
      "predicted_trace_chain_explanation": "The AsyncWebCrawler.arun() call returns a CrawlResult, from which the 'markdown' attribute is accessed for content display.",
      "ground_truth_relationship": "The CrawlResult.markdown field contains the cleaned content from the web crawl which is accessed in the example code via result.markdown[:500] to display the first 500 characters of crawled content.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult.markdown",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Complete Example\n\nHere's a more comprehensive example showing common usage patterns:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com\",\n            # Content filtering\n            word_count_threshold=10,\n            excluded_tags=['form', 'header'],\n            exclude_external_links=True,\n            \n            # Content processing\n            process_iframes=True,\n            remove_overlay_elements=True,\n            \n            # Cache control\n            bypass_cache=False  # Use cache if available\n        )\n        \n        if result.success:\n            # Print clean content\n            print(\"Content:\", result.markdown[:500])  # First 500 chars\n            \n            # Process images\n            for image in result.media[\"images\"]:\n                print(f\"Found image: {image['src']}\")\n            \n            # Process links\n            for link in result.links[\"internal\"]:\n                print(f\"Internal link: {link['href']}\")\n                \n        else:\n            print(f\"Crawl failed: {result.error_message}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 16,
      "artifact_title": "CrawlResult.media",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The sample code iterates over 'result.media[\"images\"]' to process and print information about found images, indicating usage of the CrawlResult.media attribute.",
      "predicted_trace_chain": "simple-crawling.md -> AsyncWebCrawler.arun() -> CrawlResult.media",
      "predicted_trace_chain_explanation": "After obtaining the CrawlResult from the 'arun' method, the example accesses the 'media' attribute to extract image sources.",
      "ground_truth_relationship": "The CrawlResult.media dictionary property stores extracted media elements like images, which can then be accessed and processed as shown in the example documentation where image sources are printed using result.media['images'].",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult.media",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Complete Example\n\nHere's a more comprehensive example showing common usage patterns:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com\",\n            # Content filtering\n            word_count_threshold=10,\n            excluded_tags=['form', 'header'],\n            exclude_external_links=True,\n            \n            # Content processing\n            process_iframes=True,\n            remove_overlay_elements=True,\n            \n            # Cache control\n            bypass_cache=False  # Use cache if available\n        )\n        \n        if result.success:\n            # Print clean content\n            print(\"Content:\", result.markdown[:500])  # First 500 chars\n            \n            # Process images\n            for image in result.media[\"images\"]:\n                print(f\"Found image: {image['src']}\")\n            \n            # Process links\n            for link in result.links[\"internal\"]:\n                print(f\"Internal link: {link['href']}\")\n                \n        else:\n            print(f\"Crawl failed: {result.error_message}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 14,
      "artifact_title": "CrawlResult.links",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "In the example, the 'result.links[\"internal\"]' attribute is used to process internal links, directly referencing the links attribute of CrawlResult.",
      "predicted_trace_chain": "simple-crawling.md -> AsyncWebCrawler.arun() -> CrawlResult.links",
      "predicted_trace_chain_explanation": "The result from AsyncWebCrawler.arun() includes the 'links' attribute, which the documentation example utilizes for printing internal links.",
      "ground_truth_relationship": "The CrawlResult.links dictionary attribute stores categorized links ('internal' and 'external') that were found during crawling, as demonstrated in the example where internal links are accessed via result.links['internal'].",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult.links",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Complete Example\n\nHere's a more comprehensive example showing common usage patterns:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com\",\n            # Content filtering\n            word_count_threshold=10,\n            excluded_tags=['form', 'header'],\n            exclude_external_links=True,\n            \n            # Content processing\n            process_iframes=True,\n            remove_overlay_elements=True,\n            \n            # Cache control\n            bypass_cache=False  # Use cache if available\n        )\n        \n        if result.success:\n            # Print clean content\n            print(\"Content:\", result.markdown[:500])  # First 500 chars\n            \n            # Process images\n            for image in result.media[\"images\"]:\n                print(f\"Found image: {image['src']}\")\n            \n            # Process links\n            for link in result.links[\"internal\"]:\n                print(f\"Internal link: {link['href']}\")\n                \n        else:\n            print(f\"Crawl failed: {result.error_message}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 10,
      "artifact_title": "CrawlResult.error_message",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "If crawling fails, the example prints out 'result.error_message', directly accessing the error_message attribute of the CrawlResult.",
      "predicted_trace_chain": "simple-crawling.md -> AsyncWebCrawler.arun() -> CrawlResult.error_message",
      "predicted_trace_chain_explanation": "The failure branch in the example demonstrates the direct dependency on the 'error_message' attribute provided by the CrawlResult object.",
      "ground_truth_relationship": "The error_message field in CrawlResult enables error handling in the example code by providing the failure reason when result.success is False.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult.error_message",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Complete Example\n\nHere's a more comprehensive example showing common usage patterns:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com\",\n            # Content filtering\n            word_count_threshold=10,\n            excluded_tags=['form', 'header'],\n            exclude_external_links=True,\n            \n            # Content processing\n            process_iframes=True,\n            remove_overlay_elements=True,\n            \n            # Cache control\n            bypass_cache=False  # Use cache if available\n        )\n        \n        if result.success:\n            # Print clean content\n            print(\"Content:\", result.markdown[:500])  # First 500 chars\n            \n            # Process images\n            for image in result.media[\"images\"]:\n                print(f\"Found image: {image['src']}\")\n            \n            # Process links\n            for link in result.links[\"internal\"]:\n                print(f\"Internal link: {link['href']}\")\n                \n        else:\n            print(f\"Crawl failed: {result.error_message}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the data structure that holds all the crawling outputs shown in the example code, including the success status, markdown content, media items, and links that are accessed in the documented example's result handling section.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Complete Example\n\nHere's a more comprehensive example showing common usage patterns:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com\",\n            # Content filtering\n            word_count_threshold=10,\n            excluded_tags=['form', 'header'],\n            exclude_external_links=True,\n            \n            # Content processing\n            process_iframes=True,\n            remove_overlay_elements=True,\n            \n            # Cache control\n            bypass_cache=False  # Use cache if available\n        )\n        \n        if result.success:\n            # Print clean content\n            print(\"Content:\", result.markdown[:500])  # First 500 chars\n            \n            # Process images\n            for image in result.media[\"images\"]:\n                print(f\"Found image: {image['src']}\")\n            \n            # Process links\n            for link in result.links[\"internal\"]:\n                print(f\"Internal link: {link['href']}\")\n                \n        else:\n            print(f\"Crawl failed: {result.error_message}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class directly implements all the crawler features shown in the example documentation, including content filtering, iframe processing, and cache control through its comprehensive crawl() method that handles parameters like process_iframes, bypass_cache, and excluded_tags.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Complete Example\n\nHere's a more comprehensive example showing common usage patterns:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(\n            url=\"https://example.com\",\n            # Content filtering\n            word_count_threshold=10,\n            excluded_tags=['form', 'header'],\n            exclude_external_links=True,\n            \n            # Content processing\n            process_iframes=True,\n            remove_overlay_elements=True,\n            \n            # Cache control\n            bypass_cache=False  # Use cache if available\n        )\n        \n        if result.success:\n            # Print clean content\n            print(\"Content:\", result.markdown[:500])  # First 500 chars\n            \n            # Process images\n            for image in result.media[\"images\"]:\n                print(f\"Found image: {image['src']}\")\n            \n            # Process links\n            for link in result.links[\"internal\"]:\n                print(f\"Internal link: {link['href']}\")\n                \n        else:\n            print(f\"Crawl failed: {result.error_message}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface methods that enable the comprehensive crawling functionality demonstrated in the documentation example, including URL processing, screenshot capture, and hook management.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Structured Content Selection\n\n### Using LLMs for Smart Selection\n\nUse LLMs to intelligently extract specific types of content:\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass ArticleContent(BaseModel):\n    title: str\n    main_points: List[str]\n    conclusion: str\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/nemotron\",  # Works with any supported LLM\n    schema=ArticleContent.schema(),\n    instruction=\"Extract the main article title, key points, and conclusion\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\narticle = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 24,
      "artifact_title": "LLMExtractionStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation/import",
      "relationship_explanation": "The documentation snippet explicitly imports and instantiates LLMExtractionStrategy to configure an LLM\u2010based extraction strategy for smart content selection.",
      "predicted_trace_chain": "docs/md_v2/basic/content-selection.md -> LLMExtractionStrategy",
      "predicted_trace_chain_explanation": "The documentation directly starts with the usage example from the document, showing a direct import and instantiation of LLMExtractionStrategy.",
      "ground_truth_relationship": "The LLMExtractionStrategy class implements structured content extraction by accepting a schema (like ArticleContent), provider, and instruction parameters, then using LLM completions to parse web content into the specified structured format.",
      "ground_truth_trace_chain": "content-selection.md -> ExtractionStrategy -> LLMExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Structured Content Selection\n\n### Using LLMs for Smart Selection\n\nUse LLMs to intelligently extract specific types of content:\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass ArticleContent(BaseModel):\n    title: str\n    main_points: List[str]\n    conclusion: str\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/nemotron\",  # Works with any supported LLM\n    schema=ArticleContent.schema(),\n    instruction=\"Extract the main article title, key points, and conclusion\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\narticle = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class extension",
      "relationship_explanation": "LLMExtractionStrategy is an extension of ExtractionStrategy. Although ExtractionStrategy is not explicitly mentioned in the snippet, it underpins the extraction functionality, making it a necessary base class.",
      "predicted_trace_chain": "docs/md_v2/basic/content-selection.md -> LLMExtractionStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The chain starts at the document and moves to LLMExtractionStrategy, which extends ExtractionStrategy, thereby linking the document\u2019s functionality to its abstract extraction interface.",
      "ground_truth_relationship": "The ExtractionStrategy abstract base class provides the foundation for implementing specialized content extractors like LLMExtractionStrategy shown in the documentation, with its extract() method defining the core interface for pulling structured data from HTML content.",
      "ground_truth_trace_chain": "content-selection.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Structured Content Selection\n\n### Using LLMs for Smart Selection\n\nUse LLMs to intelligently extract specific types of content:\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass ArticleContent(BaseModel):\n    title: str\n    main_points: List[str]\n    conclusion: str\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/nemotron\",  # Works with any supported LLM\n    schema=ArticleContent.schema(),\n    instruction=\"Extract the main article title, key points, and conclusion\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\narticle = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "implicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The example calls 'crawler.arun()' to perform the crawling operation while supplying the extraction strategy. This indicates that the 'arun()' method of the crawler is used to integrate and execute the extraction process.",
      "predicted_trace_chain": "docs/md_v2/basic/content-selection.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain reflects that the document initiates the crawling process by calling AsyncWebCrawler.arun(), which is responsible for processing the URL with the provided extraction strategy.",
      "ground_truth_relationship": "The arun() method implements the documented LLM-based extraction functionality by accepting an extraction_strategy parameter that processes the crawled content according to the specified schema and instructions.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Structured Content Selection\n\n### Using LLMs for Smart Selection\n\nUse LLMs to intelligently extract specific types of content:\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass ArticleContent(BaseModel):\n    title: str\n    main_points: List[str]\n    conclusion: str\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/nemotron\",  # Works with any supported LLM\n    schema=ArticleContent.schema(),\n    instruction=\"Extract the main article title, key points, and conclusion\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\narticle = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_id": 11,
      "artifact_title": "CrawlResult.extracted_content",
      "predicted_relationship": "implicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "The snippet shows the use of 'result.extracted_content' to retrieve the structured content extracted by the LLM. This attribute is central to obtaining the output of the extraction process.",
      "predicted_trace_chain": "docs/md_v2/basic/content-selection.md -> CrawlResult.extracted_content",
      "predicted_trace_chain_explanation": "The document ultimately accesses the 'extracted_content' attribute from the crawl result, completing the end-to-end chain from content extraction to data utilization.",
      "ground_truth_relationship": "The CrawlResult.extracted_content field stores the LLM-processed structured content as a JSON string that matches the defined Pydantic schema for later parsing into typed objects.",
      "ground_truth_trace_chain": "content-selection.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Structured Content Selection\n\n### Using LLMs for Smart Selection\n\nUse LLMs to intelligently extract specific types of content:\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass ArticleContent(BaseModel):\n    title: str\n    main_points: List[str]\n    conclusion: str\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/nemotron\",  # Works with any supported LLM\n    schema=ArticleContent.schema(),\n    instruction=\"Extract the main article title, key points, and conclusion\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\narticle = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the extracted_content field that holds the structured data parsed by LLMExtractionStrategy into the ArticleContent format shown in the documentation.",
      "ground_truth_trace_chain": "content-selection.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Structured Content Selection\n\n### Using LLMs for Smart Selection\n\nUse LLMs to intelligently extract specific types of content:\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass ArticleContent(BaseModel):\n    title: str\n    main_points: List[str]\n    conclusion: str\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/nemotron\",  # Works with any supported LLM\n    schema=ArticleContent.schema(),\n    instruction=\"Extract the main article title, key points, and conclusion\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\narticle = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface methods that enable the documented LLM-based content extraction by providing the crawling functionality needed to fetch web content before it can be processed by the LLMExtractionStrategy.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Structured Content Selection\n\n### Using LLMs for Smart Selection\n\nUse LLMs to intelligently extract specific types of content:\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass ArticleContent(BaseModel):\n    title: str\n    main_points: List[str]\n    conclusion: str\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/nemotron\",  # Works with any supported LLM\n    schema=ArticleContent.schema(),\n    instruction=\"Extract the main article title, key points, and conclusion\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\narticle = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the backend infrastructure needed for the LLMExtractionStrategy to perform web crawling and content extraction, specifically providing the browser automation capabilities required to fetch web content that can then be processed by the LLM for structured content selection.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Structured Content Selection\n\n### Using LLMs for Smart Selection\n\nUse LLMs to intelligently extract specific types of content:\n\n```python\nfrom pydantic import BaseModel\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\n\nclass ArticleContent(BaseModel):\n    title: str\n    main_points: List[str]\n    conclusion: str\n\nstrategy = LLMExtractionStrategy(\n    provider=\"ollama/nemotron\",  # Works with any supported LLM\n    schema=ArticleContent.schema(),\n    instruction=\"Extract the main article title, key points, and conclusion\"\n)\n\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    extraction_strategy=strategy\n)\narticle = json.loads(result.extracted_content)\n```",
      "document_location": "docs/md_v2/basic/content-selection.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements the structured content selection described in the documentation through its arun() method, which accepts an extraction_strategy parameter that can be configured with an LLMExtractionStrategy to extract specific content types using LLMs.",
      "ground_truth_trace_chain": "content-selection.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Proxy Configuration\n\nUse proxies for enhanced access:\n\n```python\n# Simple proxy\nasync with AsyncWebCrawler(\n    proxy=\"http://proxy.example.com:8080\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Proxy with authentication\nproxy_config = {\n    \"server\": \"http://proxy.example.com:8080\",\n    \"username\": \"user\",\n    \"password\": \"pass\"\n}\nasync with AsyncWebCrawler(proxy_config=proxy_config) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "instantiation/usage",
      "relationship_explanation": "The documentation snippet explicitly shows the instantiation of AsyncWebCrawler with proxy parameters (e.g., proxy and proxy_config) used in the 'async with AsyncWebCrawler(...)' block.",
      "predicted_trace_chain": "browser-config.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The snippet from 'browser-config.md' directly demonstrates the use of AsyncWebCrawler, establishing it as the entry point for proxy configuration in the crawling process.",
      "ground_truth_relationship": "The AsyncWebCrawler class accepts proxy configuration through its constructor's **kwargs parameter, which gets passed to the AsyncPlaywrightCrawlerStrategy for handling HTTP proxy settings during web crawling operations.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Proxy Configuration\n\nUse proxies for enhanced access:\n\n```python\n# Simple proxy\nasync with AsyncWebCrawler(\n    proxy=\"http://proxy.example.com:8080\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Proxy with authentication\nproxy_config = {\n    \"server\": \"http://proxy.example.com:8080\",\n    \"username\": \"user\",\n    \"password\": \"pass\"\n}\nasync with AsyncWebCrawler(proxy_config=proxy_config) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The code snippet calls 'crawler.arun(url=\"https://example.com\")', explicitly demonstrating the use of the arun() method of AsyncWebCrawler to perform the crawling operation.",
      "predicted_trace_chain": "browser-config.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "Starting from 'browser-config.md', the chain continues with AsyncWebCrawler's arun() method, depicting how the crawler executes the request with proxy settings.",
      "ground_truth_relationship": "The arun() method accepts proxy configurations through its underlying crawler_strategy.crawl() call, enabling the proxy usage patterns shown in the documentation for both simple and authenticated proxies.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Proxy Configuration\n\nUse proxies for enhanced access:\n\n```python\n# Simple proxy\nasync with AsyncWebCrawler(\n    proxy=\"http://proxy.example.com:8080\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Proxy with authentication\nproxy_config = {\n    \"server\": \"http://proxy.example.com:8080\",\n    \"username\": \"user\",\n    \"password\": \"pass\"\n}\nasync with AsyncWebCrawler(proxy_config=proxy_config) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "composition/delegation",
      "relationship_explanation": "Although not mentioned by name in the snippet, AsyncWebCrawler internally creates an instance of AsyncPlaywrightCrawlerStrategy (its default crawler_strategy) which accepts and processes the proxy and proxy_config parameters.",
      "predicted_trace_chain": "browser-config.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "The proxy configuration snippet implies the use of AsyncWebCrawler, which delegates crawling tasks to its default strategy, AsyncPlaywrightCrawlerStrategy, thereby linking proxy support to this strategy.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements proxy support through its browser_args configuration, where it creates ProxySettings objects using either a simple proxy string or a proxy_config dictionary containing server, username, and password as shown in the documentation.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Proxy Configuration\n\nUse proxies for enhanced access:\n\n```python\n# Simple proxy\nasync with AsyncWebCrawler(\n    proxy=\"http://proxy.example.com:8080\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Proxy with authentication\nproxy_config = {\n    \"server\": \"http://proxy.example.com:8080\",\n    \"username\": \"user\",\n    \"password\": \"pass\"\n}\nasync with AsyncWebCrawler(proxy_config=proxy_config) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "inheritance",
      "relationship_explanation": "AsyncPlaywrightCrawlerStrategy extends AsyncCrawlerStrategy. This base class underpins the strategy\u2019s implementation, indirectly supporting proxy configuration even though it is not directly referenced in the snippet.",
      "predicted_trace_chain": "browser-config.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "The chain extends from the instantiation of AsyncWebCrawler to its default strategy (AsyncPlaywrightCrawlerStrategy) and further to its base class, AsyncCrawlerStrategy, highlighting the inheritance structure that forms the foundation for proxy handling.",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the interface that enables proxy-based crawling functionality through its abstract crawl methods, which the documentation demonstrates how to configure with both simple and authenticated proxy settings.",
      "ground_truth_trace_chain": "browser-config.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Proxy Configuration\n\nUse proxies for enhanced access:\n\n```python\n# Simple proxy\nasync with AsyncWebCrawler(\n    proxy=\"http://proxy.example.com:8080\"\n) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n\n# Proxy with authentication\nproxy_config = {\n    \"server\": \"http://proxy.example.com:8080\",\n    \"username\": \"user\",\n    \"password\": \"pass\"\n}\nasync with AsyncWebCrawler(proxy_config=proxy_config) as crawler:\n    result = await crawler.arun(url=\"https://example.com\")\n```",
      "document_location": "docs/md_v2/basic/browser-config.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class provides fields to store the crawling output including proxy-related data like response_headers and status_code which are essential for tracking proxy communication results shown in the proxy configuration documentation.",
      "ground_truth_trace_chain": "browser-config.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Basic Usage\n\nSimply provide a URL and let Crawl4AI do the magic!\n\n```python\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n        print(f\"Basic crawl result: {result.markdown[:500]}\")  # Print first 500 characters\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "class instantiation and usage",
      "relationship_explanation": "The documentation snippet directly instantiates and uses the AsyncWebCrawler class with 'async with AsyncWebCrawler(verbose=True) as crawler:', explicitly demonstrating its usage as the central crawler class in Crawl4AI.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The chain starts from the 'docs/md_v2/basic/quickstart.md' documentation and leads directly to the AsyncWebCrawler class, which is explicitly instantiated in the usage example.",
      "ground_truth_relationship": "The documentation demonstrates the basic usage of AsyncWebCrawler's arun() method through an async context manager, which is directly implemented in the code through __aenter__ and __aexit__ methods along with the core arun() function that processes web crawling requests.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Basic Usage\n\nSimply provide a URL and let Crawl4AI do the magic!\n\n```python\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n        print(f\"Basic crawl result: {result.markdown[:500]}\")  # Print first 500 characters\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "Within the usage example, the 'arun' method of AsyncWebCrawler is invoked using 'await crawler.arun(url=\"https://www.nbcnews.com/business\")', which clearly shows that this method is responsible for performing the crawling function.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The trace chain begins at the documentation and flows through the AsyncWebCrawler instance to its 'arun' method, illustrating the method call sequence used to perform the crawl.",
      "ground_truth_relationship": "The code implements the documented basic usage by providing an arun() method that accepts a URL parameter and handles the core web crawling functionality including HTML extraction, caching, and processing while returning a CrawlResult object containing the crawled content.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Basic Usage\n\nSimply provide a URL and let Crawl4AI do the magic!\n\n```python\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n        print(f\"Basic crawl result: {result.markdown[:500]}\")  # Print first 500 characters\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_id": 15,
      "artifact_title": "CrawlResult.markdown",
      "predicted_relationship": "explicit",
      "relationship_type": "attribute access",
      "relationship_explanation": "After calling the 'arun' method, the returned result (a CrawlResult object) is accessed via its 'markdown' attribute (result.markdown[:500]). This shows that the output includes markdown content, which is a key component of the public interface.",
      "predicted_trace_chain": "docs/md_v2/basic/quickstart.md -> AsyncWebCrawler -> AsyncWebCrawler.arun() -> CrawlResult.markdown",
      "predicted_trace_chain_explanation": "Starting from the documentation, the chain passes through the AsyncWebCrawler class and its 'arun' method before accessing the 'markdown' attribute of the returned CrawlResult, forming a complete traceability pathway.",
      "ground_truth_relationship": "The markdown attribute in CrawlResult stores the extracted text content that gets printed in the example code's output after crawling the website.",
      "ground_truth_trace_chain": "quickstart.md -> CrawlResult.markdown",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Basic Usage\n\nSimply provide a URL and let Crawl4AI do the magic!\n\n```python\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n        print(f\"Basic crawl result: {result.markdown[:500]}\")  # Print first 500 characters\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class defines the data structure that stores the crawled webpage content including markdown output shown in the basic usage example's print statement.",
      "ground_truth_trace_chain": "quickstart.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Basic Usage\n\nSimply provide a URL and let Crawl4AI do the magic!\n\n```python\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n        print(f\"Basic crawl result: {result.markdown[:500]}\")  # Print first 500 characters\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements the core crawling functionality demonstrated in the documentation's basic usage example by providing the underlying browser automation and HTML extraction capabilities needed for the AsyncWebCrawler.arun() method.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Basic Usage\n\nSimply provide a URL and let Crawl4AI do the magic!\n\n```python\nasync def main():\n    async with AsyncWebCrawler(verbose=True) as crawler:\n        result = await crawler.arun(url=\"https://www.nbcnews.com/business\")\n        print(f\"Basic crawl result: {result.markdown[:500]}\")  # Print first 500 characters\n\nasyncio.run(main())\n```",
      "document_location": "docs/md_v2/basic/quickstart.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class defines the core interface that enables the basic URL crawling functionality shown in the documentation through its required crawl method.",
      "ground_truth_trace_chain": "quickstart.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Error Handling\n\n```python\ntry:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        extraction_strategy=strategy\n    )\n    \n    if result.success:\n        content = json.loads(result.extracted_content)\n        if not content:\n            print(\"No relevant content found\")\n    else:\n        print(f\"Extraction failed: {result.error_message}\")\n        \nexcept Exception as e:\n    print(f\"Error during extraction: {str(e)}\")\n```\n\nThe Cosine Strategy is particularly effective when:\n- Content structure is inconsistent\n- You need semantic understanding\n- You want to find similar content blocks\n- Structure-based extraction (CSS/XPath) isn't reliable\n\nIt works well with other strategies and can be used as a pre-processing step for LLM-based extraction.",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 7,
      "artifact_title": "CosineStrategy",
      "predicted_relationship": "explicit",
      "relationship_type": "mentioned as an effective extraction strategy",
      "relationship_explanation": "The documentation explicitly names 'Cosine Strategy' and explains its effectiveness when dealing with inconsistent content structure and the need for semantic understanding. This directly points to the CosineStrategy class as an extraction option.",
      "predicted_trace_chain": "docs/md_v2/extraction/cosine.md -> CosineStrategy",
      "predicted_trace_chain_explanation": "Starting from the cosine.md document, the text explicitly references CosineStrategy, establishing a direct link between the documentation and this class.",
      "ground_truth_relationship": "The CosineStrategy class implements semantic-based content extraction using cosine similarity and hierarchical clustering, aligning with the documentation's description of handling inconsistent content structures and enabling semantic understanding through its filter_documents_embeddings and hierarchical_clustering methods.",
      "ground_truth_trace_chain": "cosine.md -> ExtractionStrategy -> CosineStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Error Handling\n\n```python\ntry:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        extraction_strategy=strategy\n    )\n    \n    if result.success:\n        content = json.loads(result.extracted_content)\n        if not content:\n            print(\"No relevant content found\")\n    else:\n        print(f\"Extraction failed: {result.error_message}\")\n        \nexcept Exception as e:\n    print(f\"Error during extraction: {str(e)}\")\n```\n\nThe Cosine Strategy is particularly effective when:\n- Content structure is inconsistent\n- You need semantic understanding\n- You want to find similar content blocks\n- Structure-based extraction (CSS/XPath) isn't reliable\n\nIt works well with other strategies and can be used as a pre-processing step for LLM-based extraction.",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class extension",
      "relationship_explanation": "CosineStrategy is built on top of ExtractionStrategy, its abstract base class. Although not directly named in the snippet, its role is implicit since CosineStrategy extends this foundational class.",
      "predicted_trace_chain": "docs/md_v2/extraction/cosine.md -> CosineStrategy -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "The documentation\u2019s mention of CosineStrategy inherently includes its inheritance from ExtractionStrategy, marking a trace from the document, through CosineStrategy, down to its base class.",
      "ground_truth_relationship": "The ExtractionStrategy base class provides the foundational structure for implementing different content extraction methods, including the Cosine Strategy mentioned in the documentation, through its abstract extract() method and parallel processing capabilities in run().",
      "ground_truth_trace_chain": "cosine.md -> ExtractionStrategy -> ExtractionStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Error Handling\n\n```python\ntry:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        extraction_strategy=strategy\n    )\n    \n    if result.success:\n        content = json.loads(result.extracted_content)\n        if not content:\n            print(\"No relevant content found\")\n    else:\n        print(f\"Extraction failed: {result.error_message}\")\n        \nexcept Exception as e:\n    print(f\"Error during extraction: {str(e)}\")\n```\n\nThe Cosine Strategy is particularly effective when:\n- Content structure is inconsistent\n- You need semantic understanding\n- You want to find similar content blocks\n- Structure-based extraction (CSS/XPath) isn't reliable\n\nIt works well with other strategies and can be used as a pre-processing step for LLM-based extraction.",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method usage",
      "relationship_explanation": "The code example in the documentation shows a call to 'crawler.arun()' for crawling and extraction. This usage explicitly maps to the AsyncWebCrawler.arun() method which performs the operation and returns the result used in error handling.",
      "predicted_trace_chain": "docs/md_v2/extraction/cosine.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The trace chain begins at the cosine.md document and moves directly to the AsyncWebCrawler.arun() method, as the code snippet demonstrates its invocation.",
      "ground_truth_relationship": "The code's async_def arun() method implements comprehensive error handling through nested try-catch blocks that align with the documentation's example, returning CrawlResult objects with success/failure states and error messages for both extraction and general execution failures.",
      "ground_truth_trace_chain": "cosine.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Error Handling\n\n```python\ntry:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        extraction_strategy=strategy\n    )\n    \n    if result.success:\n        content = json.loads(result.extracted_content)\n        if not content:\n            print(\"No relevant content found\")\n    else:\n        print(f\"Extraction failed: {result.error_message}\")\n        \nexcept Exception as e:\n    print(f\"Error during extraction: {str(e)}\")\n```\n\nThe Cosine Strategy is particularly effective when:\n- Content structure is inconsistent\n- You need semantic understanding\n- You want to find similar content blocks\n- Structure-based extraction (CSS/XPath) isn't reliable\n\nIt works well with other strategies and can be used as a pre-processing step for LLM-based extraction.",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_id": 8,
      "artifact_title": "CrawlResult",
      "predicted_relationship": "explicit",
      "relationship_type": "data structure usage",
      "relationship_explanation": "The documentation example inspects attributes such as 'success', 'extracted_content', and 'error_message' from the result of the crawl, which corresponds directly to the CrawlResult data model.",
      "predicted_trace_chain": "docs/md_v2/extraction/cosine.md -> AsyncWebCrawler.arun() -> CrawlResult",
      "predicted_trace_chain_explanation": "The call to AsyncWebCrawler.arun() returns a CrawlResult instance; the documentation then utilizes its fields for error handling and content assessment, forming a complete trace chain.",
      "ground_truth_relationship": "The CrawlResult class provides essential fields like success, error_message, and extracted_content that directly support the error handling flow shown in the documentation by enabling status checking and error reporting during the crawler execution.",
      "ground_truth_trace_chain": "cosine.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Error Handling\n\n```python\ntry:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        extraction_strategy=strategy\n    )\n    \n    if result.success:\n        content = json.loads(result.extracted_content)\n        if not content:\n            print(\"No relevant content found\")\n    else:\n        print(f\"Extraction failed: {result.error_message}\")\n        \nexcept Exception as e:\n    print(f\"Error during extraction: {str(e)}\")\n```\n\nThe Cosine Strategy is particularly effective when:\n- Content structure is inconsistent\n- You need semantic understanding\n- You want to find similar content blocks\n- Structure-based extraction (CSS/XPath) isn't reliable\n\nIt works well with other strategies and can be used as a pre-processing step for LLM-based extraction.",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_title": "CrawlResult.error_message",
      "ground_truth_relationship": "The error_message field in CrawlResult is used to store failure details when content extraction fails, as shown in the error handling documentation where it's accessed via result.error_message to provide user feedback.",
      "ground_truth_trace_chain": "cosine.md -> CrawlResult.error_message",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Error Handling\n\n```python\ntry:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        extraction_strategy=strategy\n    )\n    \n    if result.success:\n        content = json.loads(result.extracted_content)\n        if not content:\n            print(\"No relevant content found\")\n    else:\n        print(f\"Extraction failed: {result.error_message}\")\n        \nexcept Exception as e:\n    print(f\"Error during extraction: {str(e)}\")\n```\n\nThe Cosine Strategy is particularly effective when:\n- Content structure is inconsistent\n- You need semantic understanding\n- You want to find similar content blocks\n- Structure-based extraction (CSS/XPath) isn't reliable\n\nIt works well with other strategies and can be used as a pre-processing step for LLM-based extraction.",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_title": "CrawlResult.extracted_content",
      "ground_truth_relationship": "The optional extracted_content field in CrawlResult stores the semantically-matched content found by the crawler using strategies like Cosine matching, which gets parsed as JSON if extraction succeeds.",
      "ground_truth_trace_chain": "cosine.md -> CrawlResult.extracted_content",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Error Handling\n\n```python\ntry:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        extraction_strategy=strategy\n    )\n    \n    if result.success:\n        content = json.loads(result.extracted_content)\n        if not content:\n            print(\"No relevant content found\")\n    else:\n        print(f\"Extraction failed: {result.error_message}\")\n        \nexcept Exception as e:\n    print(f\"Error during extraction: {str(e)}\")\n```\n\nThe Cosine Strategy is particularly effective when:\n- Content structure is inconsistent\n- You need semantic understanding\n- You want to find similar content blocks\n- Structure-based extraction (CSS/XPath) isn't reliable\n\nIt works well with other strategies and can be used as a pre-processing step for LLM-based extraction.",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_title": "CrawlResult.success",
      "ground_truth_relationship": "The CrawlResult.success boolean property is used in the error handling code to determine if content extraction succeeded before attempting to process the results.",
      "ground_truth_trace_chain": "cosine.md -> CrawlResult.success",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Error Handling\n\n```python\ntry:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        extraction_strategy=strategy\n    )\n    \n    if result.success:\n        content = json.loads(result.extracted_content)\n        if not content:\n            print(\"No relevant content found\")\n    else:\n        print(f\"Extraction failed: {result.error_message}\")\n        \nexcept Exception as e:\n    print(f\"Error during extraction: {str(e)}\")\n```\n\nThe Cosine Strategy is particularly effective when:\n- Content structure is inconsistent\n- You need semantic understanding\n- You want to find similar content blocks\n- Structure-based extraction (CSS/XPath) isn't reliable\n\nIt works well with other strategies and can be used as a pre-processing step for LLM-based extraction.",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The AsyncWebCrawler class implements comprehensive error handling through try-catch blocks in its arun() method, which directly corresponds to the documented error handling pattern for managing crawler execution failures and content extraction issues.",
      "ground_truth_trace_chain": "cosine.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Error Handling\n\n```python\ntry:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        extraction_strategy=strategy\n    )\n    \n    if result.success:\n        content = json.loads(result.extracted_content)\n        if not content:\n            print(\"No relevant content found\")\n    else:\n        print(f\"Extraction failed: {result.error_message}\")\n        \nexcept Exception as e:\n    print(f\"Error during extraction: {str(e)}\")\n```\n\nThe Cosine Strategy is particularly effective when:\n- Content structure is inconsistent\n- You need semantic understanding\n- You want to find similar content blocks\n- Structure-based extraction (CSS/XPath) isn't reliable\n\nIt works well with other strategies and can be used as a pre-processing step for LLM-based extraction.",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements comprehensive error handling through try-catch blocks and error messages, matching the documentation's emphasis on handling extraction failures, timeouts, and general exceptions during web crawling operations.",
      "ground_truth_trace_chain": "cosine.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Error Handling\n\n```python\ntry:\n    result = await crawler.arun(\n        url=\"https://example.com\",\n        extraction_strategy=strategy\n    )\n    \n    if result.success:\n        content = json.loads(result.extracted_content)\n        if not content:\n            print(\"No relevant content found\")\n    else:\n        print(f\"Extraction failed: {result.error_message}\")\n        \nexcept Exception as e:\n    print(f\"Error during extraction: {str(e)}\")\n```\n\nThe Cosine Strategy is particularly effective when:\n- Content structure is inconsistent\n- You need semantic understanding\n- You want to find similar content blocks\n- Structure-based extraction (CSS/XPath) isn't reliable\n\nIt works well with other strategies and can be used as a pre-processing step for LLM-based extraction.",
      "document_location": "docs/md_v2/extraction/cosine.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class provides the interface methods that enable the error-handled crawling operations shown in the documentation, particularly through its crawl method which returns AsyncCrawlResponse objects that contain success and error states.",
      "ground_truth_trace_chain": "cosine.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Smart Link Filtering\nControl which links are included in the results:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    exclude_external_links=True,          # Remove external links\n    exclude_social_media_links=True,      # Remove social media links\n    exclude_social_media_domains=[                # Custom social media domains\n        \"facebook.com\", \"twitter.com\", \"instagram.com\"\n    ],\n    exclude_domains=[\"ads.example.com\"]   # Exclude specific domains\n)\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method invocation",
      "relationship_explanation": "The documentation snippet clearly shows a direct call to 'crawler.arun()' with keyword arguments for smart link filtering. This usage explicitly maps to the 'AsyncWebCrawler.arun()' method, which is designed to accept additional parameters (via **kwargs) that can control behaviors such as excluding external and social media links.",
      "predicted_trace_chain": "docs/md_v2/advanced/content-processing.md -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The chain starts from the documentation file (docs/md_v2/advanced/content-processing.md) and directly points to the implementation of the 'arun()' method since the usage example in the document invokes this method.",
      "ground_truth_relationship": "The arun method accepts filtering parameters through **kwargs which allows for the documented link filtering options like exclude_external_links and exclude_domains to be passed through to the crawler_strategy.crawl() method.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Smart Link Filtering\nControl which links are included in the results:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    exclude_external_links=True,          # Remove external links\n    exclude_social_media_links=True,      # Remove social media links\n    exclude_social_media_domains=[                # Custom social media domains\n        \"facebook.com\", \"twitter.com\", \"instagram.com\"\n    ],\n    exclude_domains=[\"ads.example.com\"]   # Exclude specific domains\n)\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "implicit",
      "relationship_type": "object instantiation",
      "relationship_explanation": "Although the snippet directly calls 'arun()', the 'crawler' object is implicitly an instance of the 'AsyncWebCrawler' class. This class encapsulates the 'arun()' method and underpins the overall crawling functionality, including smart link filtering.",
      "predicted_trace_chain": "docs/md_v2/advanced/content-processing.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "This chain indicates that the documentation, while explicitly invoking 'arun()', implicitly relies on the 'AsyncWebCrawler' class to provide this method. The crawler instance (of type AsyncWebCrawler) is the origin of the method call, forming the complete pathway.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements link filtering through kwargs passed to the arun method, which processes URL filtering parameters documented in the smart link filtering example to control which links are included in the crawl results.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "### Smart Link Filtering\nControl which links are included in the results:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    exclude_external_links=True,          # Remove external links\n    exclude_social_media_links=True,      # Remove social media links\n    exclude_social_media_domains=[                # Custom social media domains\n        \"facebook.com\", \"twitter.com\", \"instagram.com\"\n    ],\n    exclude_domains=[\"ads.example.com\"]   # Exclude specific domains\n)\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "CrawlResult",
      "ground_truth_relationship": "The CrawlResult class stores the filtered links data structure in its 'links' dictionary field, which gets populated based on the smart filtering parameters shown in the documentation like exclude_external_links and exclude_domains.",
      "ground_truth_trace_chain": "content-processing.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Smart Link Filtering\nControl which links are included in the results:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    exclude_external_links=True,          # Remove external links\n    exclude_social_media_links=True,      # Remove social media links\n    exclude_social_media_domains=[                # Custom social media domains\n        \"facebook.com\", \"twitter.com\", \"instagram.com\"\n    ],\n    exclude_domains=[\"ads.example.com\"]   # Exclude specific domains\n)\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The documentation describes URL filtering options that are implemented through parameters passed to the crawler's arun() method, which are then processed within the crawl() method of the AsyncPlaywrightCrawlerStrategy class to control which links are included in the crawling results.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "### Smart Link Filtering\nControl which links are included in the results:\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com\",\n    exclude_external_links=True,          # Remove external links\n    exclude_social_media_links=True,      # Remove social media links\n    exclude_social_media_domains=[                # Custom social media domains\n        \"facebook.com\", \"twitter.com\", \"instagram.com\"\n    ],\n    exclude_domains=[\"ads.example.com\"]   # Exclude specific domains\n)\n```",
      "document_location": "docs/md_v2/advanced/content-processing.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract class provides the core interface for implementing the smart link filtering functionality through its crawl method that accepts kwargs, which allows passing filter parameters like exclude_external_links and exclude_domains.",
      "ground_truth_trace_chain": "content-processing.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Understanding the Response\n\nThe `arun()` method returns a `CrawlResult` object with several useful properties. Here's a quick overview (see [CrawlResult](../api/crawl-result.md) for complete details):\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Different content formats\nprint(result.html)         # Raw HTML\nprint(result.cleaned_html) # Cleaned HTML\nprint(result.markdown)     # Markdown version\nprint(result.fit_markdown) # Most relevant content in markdown\n\n# Check success status\nprint(result.success)      # True if crawl succeeded\nprint(result.status_code)  # HTTP status code (e.g., 200, 404)\n\n# Access extracted media and links\nprint(result.media)        # Dictionary of found media (images, videos, audio)\nprint(result.links)        # Dictionary of internal and external links\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 8,
      "artifact_title": "CrawlResult",
      "predicted_relationship": "explicit",
      "relationship_type": "class",
      "relationship_explanation": "The documentation snippet explicitly references CrawlResult (via the link [CrawlResult]) and shows it as the return type from the arun() method. This signals that CrawlResult is the primary data model encapsulating the crawl response.",
      "predicted_trace_chain": "docs/md_v2/basic/simple-crawling.md -> CrawlResult",
      "predicted_trace_chain_explanation": "The trace starts at the documentation file and directly points to the CrawlResult class, which defines the response structure.",
      "ground_truth_relationship": "The CrawlResult class defines all the properties demonstrated in the documentation example through type-annotated fields, including html, cleaned_html, markdown, fit_markdown, success, status_code, media, and links.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Understanding the Response\n\nThe `arun()` method returns a `CrawlResult` object with several useful properties. Here's a quick overview (see [CrawlResult](../api/crawl-result.md) for complete details):\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Different content formats\nprint(result.html)         # Raw HTML\nprint(result.cleaned_html) # Cleaned HTML\nprint(result.markdown)     # Markdown version\nprint(result.fit_markdown) # Most relevant content in markdown\n\n# Check success status\nprint(result.success)      # True if crawl succeeded\nprint(result.status_code)  # HTTP status code (e.g., 200, 404)\n\n# Access extracted media and links\nprint(result.media)        # Dictionary of found media (images, videos, audio)\nprint(result.links)        # Dictionary of internal and external links\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 13,
      "artifact_title": "CrawlResult.html",
      "predicted_relationship": "explicit",
      "relationship_type": "class-level attribute",
      "relationship_explanation": "The sample code uses 'print(result.html)' to output raw HTML. This explicitly maps to the CrawlResult.html attribute.",
      "predicted_trace_chain": "docs/md_v2/basic/simple-crawling.md -> CrawlResult -> CrawlResult.html",
      "predicted_trace_chain_explanation": "Starting from the documentation file, the trace goes to the CrawlResult class and then to its html attribute used for returning raw HTML.",
      "ground_truth_relationship": "The code defines a string property 'html' that stores the raw HTML content mentioned in the documentation's overview of CrawlResult properties.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult.html",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Understanding the Response\n\nThe `arun()` method returns a `CrawlResult` object with several useful properties. Here's a quick overview (see [CrawlResult](../api/crawl-result.md) for complete details):\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Different content formats\nprint(result.html)         # Raw HTML\nprint(result.cleaned_html) # Cleaned HTML\nprint(result.markdown)     # Markdown version\nprint(result.fit_markdown) # Most relevant content in markdown\n\n# Check success status\nprint(result.success)      # True if crawl succeeded\nprint(result.status_code)  # HTTP status code (e.g., 200, 404)\n\n# Access extracted media and links\nprint(result.media)        # Dictionary of found media (images, videos, audio)\nprint(result.links)        # Dictionary of internal and external links\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 9,
      "artifact_title": "CrawlResult.cleaned_html",
      "predicted_relationship": "explicit",
      "relationship_type": "class-level attribute",
      "relationship_explanation": "The snippet shows 'print(result.cleaned_html)' to display the cleaned HTML, directly corresponding to the CrawlResult.cleaned_html attribute.",
      "predicted_trace_chain": "docs/md_v2/basic/simple-crawling.md -> CrawlResult -> CrawlResult.cleaned_html",
      "predicted_trace_chain_explanation": "The documentation file references CrawlResult and then its cleaned_html attribute for cleaned content.",
      "ground_truth_relationship": "The CrawlResult class defines cleaned_html as an optional string property that stores the sanitized version of the webpage's HTML content after processing.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult.cleaned_html",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Understanding the Response\n\nThe `arun()` method returns a `CrawlResult` object with several useful properties. Here's a quick overview (see [CrawlResult](../api/crawl-result.md) for complete details):\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Different content formats\nprint(result.html)         # Raw HTML\nprint(result.cleaned_html) # Cleaned HTML\nprint(result.markdown)     # Markdown version\nprint(result.fit_markdown) # Most relevant content in markdown\n\n# Check success status\nprint(result.success)      # True if crawl succeeded\nprint(result.status_code)  # HTTP status code (e.g., 200, 404)\n\n# Access extracted media and links\nprint(result.media)        # Dictionary of found media (images, videos, audio)\nprint(result.links)        # Dictionary of internal and external links\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 15,
      "artifact_title": "CrawlResult.markdown",
      "predicted_relationship": "explicit",
      "relationship_type": "class-level attribute",
      "relationship_explanation": "Usage example 'print(result.markdown)' clearly shows that the markdown version of the content is provided by this attribute.",
      "predicted_trace_chain": "docs/md_v2/basic/simple-crawling.md -> CrawlResult -> CrawlResult.markdown",
      "predicted_trace_chain_explanation": "The chain starts at the documentation file, moves to CrawlResult, and then highlights the markdown property as demonstrated in the code sample.",
      "ground_truth_relationship": "The CrawlResult class includes a markdown property that stores the converted Markdown representation of the crawled webpage content, which can be accessed through result.markdown as shown in the documentation example.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult.markdown",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Understanding the Response\n\nThe `arun()` method returns a `CrawlResult` object with several useful properties. Here's a quick overview (see [CrawlResult](../api/crawl-result.md) for complete details):\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Different content formats\nprint(result.html)         # Raw HTML\nprint(result.cleaned_html) # Cleaned HTML\nprint(result.markdown)     # Markdown version\nprint(result.fit_markdown) # Most relevant content in markdown\n\n# Check success status\nprint(result.success)      # True if crawl succeeded\nprint(result.status_code)  # HTTP status code (e.g., 200, 404)\n\n# Access extracted media and links\nprint(result.media)        # Dictionary of found media (images, videos, audio)\nprint(result.links)        # Dictionary of internal and external links\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 12,
      "artifact_title": "CrawlResult.fit_markdown",
      "predicted_relationship": "explicit",
      "relationship_type": "class-level attribute",
      "relationship_explanation": "The example 'print(result.fit_markdown)' shows the use of this attribute to output the most relevant markdown content.",
      "predicted_trace_chain": "docs/md_v2/basic/simple-crawling.md -> CrawlResult -> CrawlResult.fit_markdown",
      "predicted_trace_chain_explanation": "The documentation file directs the reader to CrawlResult, which in turn provides the fit_markdown property capturing key markdown content.",
      "ground_truth_relationship": "The fit_markdown property in CrawlResult stores an optional string containing only the most relevant content of a crawled webpage in markdown format.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult.fit_markdown",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Understanding the Response\n\nThe `arun()` method returns a `CrawlResult` object with several useful properties. Here's a quick overview (see [CrawlResult](../api/crawl-result.md) for complete details):\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Different content formats\nprint(result.html)         # Raw HTML\nprint(result.cleaned_html) # Cleaned HTML\nprint(result.markdown)     # Markdown version\nprint(result.fit_markdown) # Most relevant content in markdown\n\n# Check success status\nprint(result.success)      # True if crawl succeeded\nprint(result.status_code)  # HTTP status code (e.g., 200, 404)\n\n# Access extracted media and links\nprint(result.media)        # Dictionary of found media (images, videos, audio)\nprint(result.links)        # Dictionary of internal and external links\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 20,
      "artifact_title": "CrawlResult.success",
      "predicted_relationship": "explicit",
      "relationship_type": "class-level attribute",
      "relationship_explanation": "The documentation uses 'print(result.success)' to check if crawling was successful, directly referring to the success attribute.",
      "predicted_trace_chain": "docs/md_v2/basic/simple-crawling.md -> CrawlResult -> CrawlResult.success",
      "predicted_trace_chain_explanation": "The trace path starts from the documentation file to the CrawlResult class and then to its success attribute, which indicates the crawl status.",
      "ground_truth_relationship": "The CrawlResult.success property is implemented as a boolean field that indicates whether a web crawl operation completed successfully, as shown in the documentation's example where it can be checked via result.success.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult.success",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Understanding the Response\n\nThe `arun()` method returns a `CrawlResult` object with several useful properties. Here's a quick overview (see [CrawlResult](../api/crawl-result.md) for complete details):\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Different content formats\nprint(result.html)         # Raw HTML\nprint(result.cleaned_html) # Cleaned HTML\nprint(result.markdown)     # Markdown version\nprint(result.fit_markdown) # Most relevant content in markdown\n\n# Check success status\nprint(result.success)      # True if crawl succeeded\nprint(result.status_code)  # HTTP status code (e.g., 200, 404)\n\n# Access extracted media and links\nprint(result.media)        # Dictionary of found media (images, videos, audio)\nprint(result.links)        # Dictionary of internal and external links\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 19,
      "artifact_title": "CrawlResult.status_code",
      "predicted_relationship": "explicit",
      "relationship_type": "class-level attribute",
      "relationship_explanation": "The sample 'print(result.status_code)' reflects the retrieval of the HTTP status code (e.g., 200, 404) from the CrawlResult object.",
      "predicted_trace_chain": "docs/md_v2/basic/simple-crawling.md -> CrawlResult -> CrawlResult.status_code",
      "predicted_trace_chain_explanation": "Starting from the documentation file, the trace leads to the CrawlResult class and then to its status_code attribute which returns the HTTP response code.",
      "ground_truth_relationship": "The CrawlResult's status_code property, implemented as an Optional[int], stores the HTTP status code from the web request which the documentation shows being used to verify successful crawls through print statements.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult.status_code",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Understanding the Response\n\nThe `arun()` method returns a `CrawlResult` object with several useful properties. Here's a quick overview (see [CrawlResult](../api/crawl-result.md) for complete details):\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Different content formats\nprint(result.html)         # Raw HTML\nprint(result.cleaned_html) # Cleaned HTML\nprint(result.markdown)     # Markdown version\nprint(result.fit_markdown) # Most relevant content in markdown\n\n# Check success status\nprint(result.success)      # True if crawl succeeded\nprint(result.status_code)  # HTTP status code (e.g., 200, 404)\n\n# Access extracted media and links\nprint(result.media)        # Dictionary of found media (images, videos, audio)\nprint(result.links)        # Dictionary of internal and external links\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 16,
      "artifact_title": "CrawlResult.media",
      "predicted_relationship": "explicit",
      "relationship_type": "class-level attribute",
      "relationship_explanation": "The code example 'print(result.media)' is used to access media extracted during crawling, mapping directly to the CrawlResult.media attribute.",
      "predicted_trace_chain": "docs/md_v2/basic/simple-crawling.md -> CrawlResult -> CrawlResult.media",
      "predicted_trace_chain_explanation": "The chain begins at the documentation file, references the CrawlResult class, and points out the media attribute for extracted media information.",
      "ground_truth_relationship": "The code defines an empty dictionary property 'media' that will store lists of media elements (images, videos, audio) extracted during crawling, which directly implements the media property shown in the documentation example.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult.media",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Understanding the Response\n\nThe `arun()` method returns a `CrawlResult` object with several useful properties. Here's a quick overview (see [CrawlResult](../api/crawl-result.md) for complete details):\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Different content formats\nprint(result.html)         # Raw HTML\nprint(result.cleaned_html) # Cleaned HTML\nprint(result.markdown)     # Markdown version\nprint(result.fit_markdown) # Most relevant content in markdown\n\n# Check success status\nprint(result.success)      # True if crawl succeeded\nprint(result.status_code)  # HTTP status code (e.g., 200, 404)\n\n# Access extracted media and links\nprint(result.media)        # Dictionary of found media (images, videos, audio)\nprint(result.links)        # Dictionary of internal and external links\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_id": 14,
      "artifact_title": "CrawlResult.links",
      "predicted_relationship": "explicit",
      "relationship_type": "class-level attribute",
      "relationship_explanation": "The example 'print(result.links)' demonstrates that the links (both internal and external) are accessible via the CrawlResult.links attribute.",
      "predicted_trace_chain": "docs/md_v2/basic/simple-crawling.md -> CrawlResult -> CrawlResult.links",
      "predicted_trace_chain_explanation": "The documentation file leads to CrawlResult and subsequently to its links property, which provides information on discovered links.",
      "ground_truth_relationship": "The code implements a dictionary property that stores both internal and external links found during crawling, which is documented as an accessible property of the CrawlResult object.",
      "ground_truth_trace_chain": "simple-crawling.md -> CrawlResult.links",
      "traceability_granularity": "Statement-level",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Understanding the Response\n\nThe `arun()` method returns a `CrawlResult` object with several useful properties. Here's a quick overview (see [CrawlResult](../api/crawl-result.md) for complete details):\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Different content formats\nprint(result.html)         # Raw HTML\nprint(result.cleaned_html) # Cleaned HTML\nprint(result.markdown)     # Markdown version\nprint(result.fit_markdown) # Most relevant content in markdown\n\n# Check success status\nprint(result.success)      # True if crawl succeeded\nprint(result.status_code)  # HTTP status code (e.g., 200, 404)\n\n# Access extracted media and links\nprint(result.media)        # Dictionary of found media (images, videos, audio)\nprint(result.links)        # Dictionary of internal and external links\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "AsyncCrawlerStrategy",
      "ground_truth_relationship": "The AsyncCrawlerStrategy class defines the interface that enables the asynchronous crawling functionality shown in the documentation's 'arun()' example, requiring concrete implementations to handle URL crawling and return response objects containing HTML, markdown, and media data.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Understanding the Response\n\nThe `arun()` method returns a `CrawlResult` object with several useful properties. Here's a quick overview (see [CrawlResult](../api/crawl-result.md) for complete details):\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Different content formats\nprint(result.html)         # Raw HTML\nprint(result.cleaned_html) # Cleaned HTML\nprint(result.markdown)     # Markdown version\nprint(result.fit_markdown) # Most relevant content in markdown\n\n# Check success status\nprint(result.success)      # True if crawl succeeded\nprint(result.status_code)  # HTTP status code (e.g., 200, 404)\n\n# Access extracted media and links\nprint(result.media)        # Dictionary of found media (images, videos, audio)\nprint(result.links)        # Dictionary of internal and external links\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "ground_truth_relationship": "The documented CrawlResult properties directly correspond to the HTML, status codes, media, and links that are extracted and processed by the AsyncPlaywrightCrawlerStrategy's crawl() method using Playwright's page APIs.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Understanding the Response\n\nThe `arun()` method returns a `CrawlResult` object with several useful properties. Here's a quick overview (see [CrawlResult](../api/crawl-result.md) for complete details):\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Different content formats\nprint(result.html)         # Raw HTML\nprint(result.cleaned_html) # Cleaned HTML\nprint(result.markdown)     # Markdown version\nprint(result.fit_markdown) # Most relevant content in markdown\n\n# Check success status\nprint(result.success)      # True if crawl succeeded\nprint(result.status_code)  # HTTP status code (e.g., 200, 404)\n\n# Access extracted media and links\nprint(result.media)        # Dictionary of found media (images, videos, audio)\nprint(result.links)        # Dictionary of internal and external links\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "AsyncWebCrawler.arun()",
      "ground_truth_relationship": "The arun() method implementation directly returns a CrawlResult object containing all the documented properties like html, cleaned_html, markdown, success, status_code, media and links by processing the crawled webpage content through various extraction and chunking strategies.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Understanding the Response\n\nThe `arun()` method returns a `CrawlResult` object with several useful properties. Here's a quick overview (see [CrawlResult](../api/crawl-result.md) for complete details):\n\n```python\nresult = await crawler.arun(url=\"https://example.com\")\n\n# Different content formats\nprint(result.html)         # Raw HTML\nprint(result.cleaned_html) # Cleaned HTML\nprint(result.markdown)     # Markdown version\nprint(result.fit_markdown) # Most relevant content in markdown\n\n# Check success status\nprint(result.success)      # True if crawl succeeded\nprint(result.status_code)  # HTTP status code (e.g., 200, 404)\n\n# Access extracted media and links\nprint(result.media)        # Dictionary of found media (images, videos, audio)\nprint(result.links)        # Dictionary of internal and external links\n```",
      "document_location": "docs/md_v2/basic/simple-crawling.md",
      "artifact_title": "AsyncWebCrawler",
      "ground_truth_relationship": "The `arun()` method returns a CrawlResult object containing the documented properties like html, cleaned_html, markdown, fit_markdown, success, status_code, media and links, which are populated during the web crawling and processing pipeline.",
      "ground_truth_trace_chain": "simple-crawling.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "False Negative",
      "predicted_relationship": null,
      "relationship_type": null,
      "relationship_explanation": null,
      "predicted_trace_chain": null,
      "predicted_trace_chain_explanation": null,
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false,
        "missed_by_llm": true
      }
    },
    {
      "sent_document_text": "## Understanding Session-Based Crawling\n\nSession-based crawling allows you to maintain a persistent browser session across multiple requests. This is crucial when:\n\n1. The content changes dynamically without URL changes\n2. You need to interact with the page (e.g., clicking buttons) between requests\n3. The site requires authentication or maintains state across pages\n\nCrawl4AI's `AsyncWebCrawler` class supports session-based crawling through the `session_id` parameter and related methods.\n\n## Basic Concepts\n\nBefore diving into examples, let's review some key concepts:\n\n- **Session ID**: A unique identifier for a browsing session. Use the same `session_id` across multiple `arun` calls to maintain state.\n- **JavaScript Execution**: Use the `js_code` parameter to execute JavaScript on the page, such as clicking a \"Load More\" button.\n- **CSS Selectors**: Use these to target specific elements for extraction or interaction.\n- **Extraction Strategy**: Define how to extract structured data from the page.\n- **Wait Conditions**: Specify conditions to wait for before considering the page loaded.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 4,
      "artifact_title": "AsyncWebCrawler",
      "predicted_relationship": "explicit",
      "relationship_type": "class implementation",
      "relationship_explanation": "The documentation explicitly states that 'Crawl4AI's AsyncWebCrawler class supports session-based crawling', directly naming this class as providing persistent browser session functionality through the session_id parameter.",
      "predicted_trace_chain": "session-management-advanced.md -> AsyncWebCrawler",
      "predicted_trace_chain_explanation": "The documentation snippet from 'session-management-advanced.md' directly references AsyncWebCrawler to illustrate session-based crawling.",
      "ground_truth_relationship": "The AsyncWebCrawler class implements session-based crawling through the session_id parameter in its arun method, which allows maintaining persistent browser sessions across multiple requests as documented.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncWebCrawler",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Understanding Session-Based Crawling\n\nSession-based crawling allows you to maintain a persistent browser session across multiple requests. This is crucial when:\n\n1. The content changes dynamically without URL changes\n2. You need to interact with the page (e.g., clicking buttons) between requests\n3. The site requires authentication or maintains state across pages\n\nCrawl4AI's `AsyncWebCrawler` class supports session-based crawling through the `session_id` parameter and related methods.\n\n## Basic Concepts\n\nBefore diving into examples, let's review some key concepts:\n\n- **Session ID**: A unique identifier for a browsing session. Use the same `session_id` across multiple `arun` calls to maintain state.\n- **JavaScript Execution**: Use the `js_code` parameter to execute JavaScript on the page, such as clicking a \"Load More\" button.\n- **CSS Selectors**: Use these to target specific elements for extraction or interaction.\n- **Extraction Strategy**: Define how to extract structured data from the page.\n- **Wait Conditions**: Specify conditions to wait for before considering the page loaded.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 1,
      "artifact_title": "AsyncPlaywrightCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "implements session management support",
      "relationship_explanation": "AsyncWebCrawler uses AsyncPlaywrightCrawlerStrategy as its default crawler strategy. Within its crawl() method, it checks for a session_id to reuse browser sessions, thus indirectly enabling session-based crawling as described in the documentation.",
      "predicted_trace_chain": "session-management-advanced.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy",
      "predicted_trace_chain_explanation": "AsyncWebCrawler instantiates AsyncPlaywrightCrawlerStrategy when no alternative is provided. This strategy implements the session_id handling functionality essential for session-based crawling.",
      "ground_truth_relationship": "The AsyncPlaywrightCrawlerStrategy class implements session-based crawling through its sessions dictionary and associated methods like kill_session(), which maintain browser contexts and pages across multiple requests as described in the documentation.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncCrawlerStrategy -> AsyncPlaywrightCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Understanding Session-Based Crawling\n\nSession-based crawling allows you to maintain a persistent browser session across multiple requests. This is crucial when:\n\n1. The content changes dynamically without URL changes\n2. You need to interact with the page (e.g., clicking buttons) between requests\n3. The site requires authentication or maintains state across pages\n\nCrawl4AI's `AsyncWebCrawler` class supports session-based crawling through the `session_id` parameter and related methods.\n\n## Basic Concepts\n\nBefore diving into examples, let's review some key concepts:\n\n- **Session ID**: A unique identifier for a browsing session. Use the same `session_id` across multiple `arun` calls to maintain state.\n- **JavaScript Execution**: Use the `js_code` parameter to execute JavaScript on the page, such as clicking a \"Load More\" button.\n- **CSS Selectors**: Use these to target specific elements for extraction or interaction.\n- **Extraction Strategy**: Define how to extract structured data from the page.\n- **Wait Conditions**: Specify conditions to wait for before considering the page loaded.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 0,
      "artifact_title": "AsyncCrawlerStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "base class",
      "relationship_explanation": "AsyncPlaywrightCrawlerStrategy extends AsyncCrawlerStrategy. Although not directly handling sessions, it defines the abstract interface that supports methods such as crawl() which are implemented in its subclass to manage sessions.",
      "predicted_trace_chain": "session-management-advanced.md -> AsyncWebCrawler -> AsyncPlaywrightCrawlerStrategy -> AsyncCrawlerStrategy",
      "predicted_trace_chain_explanation": "The session-based crawling functionality is built on the abstract contract provided by AsyncCrawlerStrategy, inherited by AsyncPlaywrightCrawlerStrategy, and ultimately utilized by AsyncWebCrawler.",
      "ground_truth_relationship": "The AsyncCrawlerStrategy abstract base class defines the core interface for session-based crawling through abstract methods like crawl() and crawl_many() that implement the documented session maintenance and page interaction capabilities.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncCrawlerStrategy",
      "traceability_granularity": "Class",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Understanding Session-Based Crawling\n\nSession-based crawling allows you to maintain a persistent browser session across multiple requests. This is crucial when:\n\n1. The content changes dynamically without URL changes\n2. You need to interact with the page (e.g., clicking buttons) between requests\n3. The site requires authentication or maintains state across pages\n\nCrawl4AI's `AsyncWebCrawler` class supports session-based crawling through the `session_id` parameter and related methods.\n\n## Basic Concepts\n\nBefore diving into examples, let's review some key concepts:\n\n- **Session ID**: A unique identifier for a browsing session. Use the same `session_id` across multiple `arun` calls to maintain state.\n- **JavaScript Execution**: Use the `js_code` parameter to execute JavaScript on the page, such as clicking a \"Load More\" button.\n- **CSS Selectors**: Use these to target specific elements for extraction or interaction.\n- **Extraction Strategy**: Define how to extract structured data from the page.\n- **Wait Conditions**: Specify conditions to wait for before considering the page loaded.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 5,
      "artifact_title": "AsyncWebCrawler.arun()",
      "predicted_relationship": "explicit",
      "relationship_type": "method interface",
      "relationship_explanation": "The documentation instructs users to keep using the same session_id across multiple arun calls to maintain state. The arun() method of AsyncWebCrawler accepts a session_id parameter and incorporates it into its logic, fulfilling this requirement.",
      "predicted_trace_chain": "session-management-advanced.md -> AsyncWebCrawler -> AsyncWebCrawler.arun()",
      "predicted_trace_chain_explanation": "The explicit recommendation in the documentation to use the same session_id across arun calls is directly implemented in the arun() method of AsyncWebCrawler.",
      "ground_truth_relationship": "The `arun()` method implements session-based crawling by accepting a `session_id` parameter through kwargs and storing it in the CrawlResult object, enabling state persistence across multiple crawl requests.",
      "ground_truth_trace_chain": "session-management-advanced.md -> AsyncWebCrawler.arun()",
      "traceability_granularity": "Method",
      "confusion_metrics": "True Positive",
      "prediction_details": {
        "matches_ground_truth": true,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Understanding Session-Based Crawling\n\nSession-based crawling allows you to maintain a persistent browser session across multiple requests. This is crucial when:\n\n1. The content changes dynamically without URL changes\n2. You need to interact with the page (e.g., clicking buttons) between requests\n3. The site requires authentication or maintains state across pages\n\nCrawl4AI's `AsyncWebCrawler` class supports session-based crawling through the `session_id` parameter and related methods.\n\n## Basic Concepts\n\nBefore diving into examples, let's review some key concepts:\n\n- **Session ID**: A unique identifier for a browsing session. Use the same `session_id` across multiple `arun` calls to maintain state.\n- **JavaScript Execution**: Use the `js_code` parameter to execute JavaScript on the page, such as clicking a \"Load More\" button.\n- **CSS Selectors**: Use these to target specific elements for extraction or interaction.\n- **Extraction Strategy**: Define how to extract structured data from the page.\n- **Wait Conditions**: Specify conditions to wait for before considering the page loaded.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 21,
      "artifact_title": "ExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "abstract base class",
      "relationship_explanation": "The documentation lists 'Extraction Strategy' as a concept for retrieving structured data. The ExtractionStrategy abstract base class defines the interface for extraction strategies used by AsyncWebCrawler.",
      "predicted_trace_chain": "session-management-advanced.md -> AsyncWebCrawler -> ExtractionStrategy",
      "predicted_trace_chain_explanation": "AsyncWebCrawler accepts an extraction_strategy parameter based on the ExtractionStrategy interface, aligning with the documentation's discussion of extraction strategies.",
      "ground_truth_relationship": null,
      "ground_truth_trace_chain": null,
      "traceability_granularity": "Method",
      "confusion_metrics": "False Positive",
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false
      }
    },
    {
      "sent_document_text": "## Understanding Session-Based Crawling\n\nSession-based crawling allows you to maintain a persistent browser session across multiple requests. This is crucial when:\n\n1. The content changes dynamically without URL changes\n2. You need to interact with the page (e.g., clicking buttons) between requests\n3. The site requires authentication or maintains state across pages\n\nCrawl4AI's `AsyncWebCrawler` class supports session-based crawling through the `session_id` parameter and related methods.\n\n## Basic Concepts\n\nBefore diving into examples, let's review some key concepts:\n\n- **Session ID**: A unique identifier for a browsing session. Use the same `session_id` across multiple `arun` calls to maintain state.\n- **JavaScript Execution**: Use the `js_code` parameter to execute JavaScript on the page, such as clicking a \"Load More\" button.\n- **CSS Selectors**: Use these to target specific elements for extraction or interaction.\n- **Extraction Strategy**: Define how to extract structured data from the page.\n- **Wait Conditions**: Specify conditions to wait for before considering the page loaded.",
      "document_location": "docs/md_v2/advanced/session-management-advanced.md",
      "artifact_id": 23,
      "artifact_title": "JsonCssExtractionStrategy",
      "predicted_relationship": "implicit",
      "relationship_type": "concrete implementation",
      "relationship_explanation": "The documentation mentions the use of CSS selectors for targeting elements. JsonCssExtractionStrategy is a concrete implementation that uses CSS selectors to extract structured data from a webpage based on a schema.",
      "predicted_trace_chain": "session-management-advanced.md -> AsyncWebCrawler -> ExtractionStrategy -> JsonCssExtractionStrategy",
      "predicted_trace_chain_explanation": "In the chain of extraction strategy implementations utilized by AsyncWebCrawler, JsonCssExtractionStrategy specifically leverages CSS selectors, which aligns with the documentation's emphasis on targeting elements for extraction.",
      "ground_truth_relationship": null,
      "ground_truth_trace_chain": null,
      "traceability_granularity": "Method",
      "confusion_metrics": "False Positive",
      "prediction_details": {
        "matches_ground_truth": false,
        "relationship_match": false
      }
    }
  ]
}