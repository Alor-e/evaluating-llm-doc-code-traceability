[
  {
    "document_text": "# **listVolumes**\n> ListVolumesResponseContent listVolumes(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList Volumes\n\n    Gets an array of available volumes under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| The identifier of the catalog | [default to null] |\n| **schema\\_name** | **String**| The identifier of the schema | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of volumes to return (page length).  If not set, the page length is set to a server configured value. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  Note: this parameter controls only the maximum number of volumes to return. The actual number of volumes returned in a page may be smaller than this value, including 0, even if there are more pages.   | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token returned by a previous request. It must be included in the request to retrieve the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListVolumesResponseContent**](../Models/ListVolumesResponseContent.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.listVolumes",
    "predicted_relationship": "The VolumeRepository.listVolumes method directly implements the listVolumes functionality described in the documentation. It takes the same parameters (catalogName, schemaName, maxResults, pageToken) and returns a ListVolumesResponseContent object as specified in the API documentation.",
    "ground_truth_relationship": "The code implements the documented listVolumes API by querying volumes from a database using Hibernate, enforcing the documented parameters (catalog_name, schema_name, max_results, page_token) and returning a ListVolumesResponseContent object containing the filtered volume list.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core functionality - implementing the documented listVolumes API with the same parameters and return type. While it doesn't mention the database/Hibernate specifics, this omission doesn't change the fundamental relationship being described.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **listVolumes**\n> ListVolumesResponseContent listVolumes(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList Volumes\n\n    Gets an array of available volumes under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| The identifier of the catalog | [default to null] |\n| **schema\\_name** | **String**| The identifier of the schema | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of volumes to return (page length).  If not set, the page length is set to a server configured value. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  Note: this parameter controls only the maximum number of volumes to return. The actual number of volumes returned in a page may be smaller than this value, including 0, even if there are more pages.   | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token returned by a previous request. It must be included in the request to retrieve the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListVolumesResponseContent**](../Models/ListVolumesResponseContent.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeService.listVolumes",
    "predicted_relationship": "The VolumeService.listVolumes method directly implements the HTTP GET endpoint for listing volumes as described in the documentation. It takes the same parameters (catalogName, schemaName, maxResults, pageToken) and returns an HttpResponse containing the ListVolumesResponseContent.",
    "ground_truth_relationship": "The code implements the documented listVolumes API endpoint as a GET HTTP method that accepts the specified catalog_name, schema_name, max_results, and page_token parameters, though it includes an additional undocumented include_browse parameter, and returns a JSON response from the volume repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the core API functionality but fails to mention the additional include_browse parameter that exists in the code but not the documentation",
      "error_type": "missing_parameter"
    }
  },
  {
    "document_text": "<a name=\"getFunction\"></a>\n# **getFunction**\n> FunctionInfo getFunction(name)\n\nGet a function\n\n    Gets a function from within a parent catalog and schema.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.getFunction",
    "predicted_relationship": "The FunctionRepository.getFunction method likely implements the core functionality described in the documentation. It takes a fully-qualified function name as input and returns a FunctionInfo object, which aligns with the documented behavior.",
    "ground_truth_relationship": "The code implements the documented function retrieval by parsing a fully-qualified three-part function name (catalog.schema.function), querying a database session for the function details, and returning a FunctionInfo object as specified in the documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core functionality of taking a qualified function name as input and returning FunctionInfo, which aligns with the ground truth's description of the relationship between the code and documentation",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getFunction\"></a>\n# **getFunction**\n> FunctionInfo getFunction(name)\n\nGet a function\n\n    Gets a function from within a parent catalog and schema.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionService.getFunction",
    "predicted_relationship": "The FunctionService.getFunction method directly implements the API endpoint described in the documentation. It takes a 'name' parameter, which matches the documented 'name' parameter for the fully-qualified function name.",
    "ground_truth_relationship": "The code implements a REST GET endpoint that accepts a fully-qualified function name as a path parameter and returns a JSON response containing the function details, directly mapping to the documented API endpoint specification and its expected FunctionInfo return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - a GET endpoint that takes a name parameter and retrieves function details, which aligns with the ground truth's description of the API endpoint functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getFunction\"></a>\n# **getFunction**\n> FunctionInfo getFunction(name)\n\nGet a function\n\n    Gets a function from within a parent catalog and schema.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionInfoDAO",
    "predicted_relationship": "The FunctionInfoDAO is likely used internally to represent the function data in the database. The documentation mentions returning a FunctionInfo object, which would be created from the FunctionInfoDAO data.",
    "ground_truth_relationship": "The FunctionInfoDAO class provides the data persistence layer that enables the documented getFunction endpoint by mapping database records to FunctionInfo objects through JPA annotations and conversion methods toFunctionInfo() and from().",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies FunctionInfoDAO as an internal database representation that maps to FunctionInfo objects, which aligns with the ground truth's explanation of it being a data persistence layer for the endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createSchema\"></a>\n# **createSchema**\n> SchemaInfo createSchema(CreateSchema)\n\nCreate a schema\n\n    Creates a new schema in the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateSchema** | [**CreateSchema**](../Models/CreateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.createSchema",
    "predicted_relationship": "The documentation describes a 'createSchema' operation that creates a new schema in a specified catalog. This directly corresponds to the 'createSchema' method in the SchemaRepository class. The method signature matches the documented parameters (CreateSchema) and return type (SchemaInfo).",
    "ground_truth_relationship": "The code fully implements the documented API endpoint by validating the schema name, checking for existing schemas, persisting the new schema with its properties in a database transaction, and returning a SchemaInfo object as specified in the documentation's return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the core relationship between the documentation and code - a createSchema operation that takes CreateSchema input and returns SchemaInfo. While it omits implementation details like validation and persistence, these are minor details that don't change the fundamental relationship.",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"createSchema\"></a>\n# **createSchema**\n> SchemaInfo createSchema(CreateSchema)\n\nCreate a schema\n\n    Creates a new schema in the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateSchema** | [**CreateSchema**](../Models/CreateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaService.createSchema",
    "predicted_relationship": "While not explicitly mentioned, the SchemaService.createSchema method is likely the service layer implementation of the documented API endpoint. It would handle the HTTP request, delegate to the repository, and return the HTTP response.",
    "ground_truth_relationship": "The code implements the documented REST endpoint by accepting a CreateSchema object via POST request and returning a JSON HTTP response containing the schema created through the SCHEMA_REPOSITORY.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies this as an API endpoint implementation, but incorrectly assumes the use of SchemaService when the code actually uses SCHEMA_REPOSITORY directly",
      "error_type": "architectural_assumption"
    }
  },
  {
    "document_text": "<a name=\"createSchema\"></a>\n# **createSchema**\n> SchemaInfo createSchema(CreateSchema)\n\nCreate a schema\n\n    Creates a new schema in the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateSchema** | [**CreateSchema**](../Models/CreateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaInfoDAO",
    "predicted_relationship": "The SchemaInfoDAO is likely used internally to persist and retrieve schema information. The documentation mentions returning a SchemaInfo object, which would be converted from a SchemaInfoDAO instance.",
    "ground_truth_relationship": "The SchemaInfoDAO class provides the data persistence layer and conversion methods (from/toSchemaInfo) that enable storing and retrieving the SchemaInfo objects that are returned by the documented createSchema API endpoint.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core relationship that SchemaInfoDAO is used for persistence and handling of schema information, with conversion to/from SchemaInfo objects. While it's less detailed than the ground truth, it doesn't contradict or misunderstand the fundamental relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getTable\"></a>\n# **getTable**\n> TableInfo getTable(full\\_name)\n\nGet a table\n\n    Gets a table for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableRepository.getTable",
    "predicted_relationship": "The documentation describes a 'getTable' operation that takes a 'full_name' parameter and returns a TableInfo object. This directly corresponds to the TableRepository.getTable method, which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented getTable operation by parsing a fully qualified table name into catalog, schema, and table components, retrieving the table information from a database session, and returning a TableInfo object with attached properties, exactly matching the documented input parameter and return type specifications.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship that the code implements a getTable operation taking a full_name parameter and returning TableInfo, which aligns with the ground truth functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getTable\"></a>\n# **getTable**\n> TableInfo getTable(full\\_name)\n\nGet a table\n\n    Gets a table for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableService.getTable",
    "predicted_relationship": "While not explicitly mentioned, the TableService.getTable method is likely the service-layer implementation of the getTable operation described in the documentation. It would handle the HTTP request and delegate to the repository layer.",
    "ground_truth_relationship": "The code implements a REST endpoint annotated with @Get that takes a full_name parameter, validates it's not null, retrieves table information via TABLE_REPOSITORY, and returns it as JSON - matching the documented API endpoint behavior, parameter requirements, and TableInfo return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies this as a getTable implementation but incorrectly assumes it's a service layer method rather than recognizing it's a direct REST controller endpoint",
      "error_type": "architectural_misunderstanding"
    }
  },
  {
    "document_text": "<a name=\"getTable\"></a>\n# **getTable**\n> TableInfo getTable(full\\_name)\n\nGet a table\n\n    Gets a table for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableInfoDAO",
    "predicted_relationship": "The documentation mentions returning a TableInfo object. TableInfoDAO is likely used internally to represent the table data before converting to the TableInfo response object.",
    "ground_truth_relationship": "The TableInfoDAO class provides the data persistence layer and model conversion methods that enable the documented getTable API endpoint to retrieve and return table information in the expected TableInfo format.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that TableInfoDAO is used as an internal representation that gets converted to TableInfo for API responses, which aligns with the ground truth's description of TableInfoDAO providing the persistence layer and conversion methods for the getTable API endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listTables\"></a>\n# **listTables**\n> ListTablesResponse listTables(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList tables\n\n    Gets the list of all available tables under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for tables of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of tables. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of tables to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token to send for the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListTablesResponse**](../Models/ListTablesResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableService.listTables",
    "predicted_relationship": "The documentation directly describes the 'listTables' operation, which is implemented by the TableService.listTables method. The method signature matches the documented parameters: catalogName, schemaName, maxResults, and pageToken. It also returns a ListTablesResponse object as specified in the documentation.",
    "ground_truth_relationship": "The code implements the documented API endpoint by accepting the same catalog_name, schema_name, max_results, and page_token parameters, while also including two additional optional parameters (omit_properties and omit_columns) that are not mentioned in the documentation, then delegates the actual table listing to TABLE_REPOSITORY and returns the result as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the core API functionality but misses the important detail about the additional omit_properties and omit_columns parameters that are present in the code but not in the documentation",
      "error_type": "omission_of_key_parameters"
    }
  },
  {
    "document_text": "<a name=\"listTables\"></a>\n# **listTables**\n> ListTablesResponse listTables(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList tables\n\n    Gets the list of all available tables under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for tables of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of tables. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of tables to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token to send for the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListTablesResponse**](../Models/ListTablesResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableRepository.listTables",
    "predicted_relationship": "While not explicitly mentioned, the TableService.listTables method likely delegates the actual listing of tables to the TableRepository.listTables method. This repository method handles the database interaction to retrieve the list of tables based on the provided parameters.",
    "ground_truth_relationship": "The code implements the documented listTables endpoint by querying a database session for table records matching the given catalog and schema names, handling pagination through maxResults and pageToken parameters, and returning a ListTablesResponse object containing the table list and next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "While the predicted description correctly identifies that the code handles listing tables, it incorrectly assumes delegation to a TableRepository class that doesn't exist in the code. The core listing functionality is implemented directly using a session and LISTING_HELPER.",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeService.createVolume",
    "predicted_relationship": "The documentation directly describes the 'createVolume' operation, which is implemented by the VolumeService.createVolume method. The method signature matches the documented operation, taking a CreateVolumeRequestContent parameter and returning a VolumeInfo object.",
    "ground_truth_relationship": "The code implements the documented API endpoint by accepting a CreateVolumeRequestContent parameter and returning a JSON HTTP response containing the created volume information, matching the documented input/output specifications and HTTP headers.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship between the code and documentation - it correctly identifies that this is a volume creation endpoint taking CreateVolumeRequestContent and returning volume information, which aligns with the ground truth's description of the input/output and HTTP endpoint functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.createVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.createVolume method is likely called by VolumeService.createVolume to perform the actual volume creation in the data store.",
    "ground_truth_relationship": "The code implements the documented createVolume operation by validating inputs, creating a VolumeInfo object with a UUID, validating volume type and storage location, and persisting it to the database within a transaction while enforcing schema existence and volume uniqueness constraints.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction mentions a VolumeService calling VolumeRepository but this layering is not evident in the code. However, it correctly identifies that this is about volume creation persistence, just with an incorrect architectural assumption.",
      "error_type": "incorrect_architecture"
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeInfoDAO",
    "predicted_relationship": "The VolumeInfoDAO is likely used internally to represent the volume data in the database. It's implicitly related as it would be used to create the VolumeInfo object returned by the createVolume operation.",
    "ground_truth_relationship": "The VolumeInfoDAO class provides the data persistence layer and mapping functionality for the createVolume API endpoint by defining the database schema and conversion methods between the API's VolumeInfo model and the database representation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies VolumeInfoDAO as an internal database representation, but misses the crucial aspect of it being the persistence layer that maps between API and database representations for the createVolume endpoint",
      "error_type": "omission_of_key_functionality"
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeCli.createVolume",
    "predicted_relationship": "While not mentioned in the API documentation, VolumeCli.createVolume is likely a command-line interface that uses this API operation to create volumes, providing an alternative way to invoke the functionality.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createVolume endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a CLI wrapper/interface for the documented createVolume API operation, which matches the ground truth's core meaning.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listCatalogs\"></a>\n# **listCatalogs**\n> ListCatalogsResponse listCatalogs(page\\_token, max\\_results)\n\nList catalogs\n\n    Lists the available catalogs. There is no guarantee of a specific ordering of the elements in the list. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n| **max\\_results** | **Integer**| Maximum number of catalogs to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n\n### Return type\n\n[**ListCatalogsResponse**](../Models/ListCatalogsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.listCatalogs",
    "predicted_relationship": "The CatalogCli.listCatalogs method implements the functionality described in the documentation. It handles the 'max_results' parameter, which corresponds to the optional 'max_results' parameter mentioned in the API documentation. The method also returns a JSON string representation of the catalog list, which aligns with the ListCatalogsResponse return type mentioned in the documentation.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listCatalogs endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a wrapper implementation of the documented listCatalogs API endpoint, covering the key parameter handling and return type conversion to JSON. The minor additional details do not contradict the ground truth.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listCatalogs\"></a>\n# **listCatalogs**\n> ListCatalogsResponse listCatalogs(page\\_token, max\\_results)\n\nList catalogs\n\n    Lists the available catalogs. There is no guarantee of a specific ordering of the elements in the list. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n| **max\\_results** | **Integer**| Maximum number of catalogs to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n\n### Return type\n\n[**ListCatalogsResponse**](../Models/ListCatalogsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.listCatalogs",
    "predicted_relationship": "The CatalogRepository.listCatalogs method likely implements the core functionality of listing catalogs. It handles both the 'maxResults' and 'pageToken' parameters, which correspond to the 'max_results' and 'page_token' parameters described in the API documentation. The method returns a ListCatalogsResponse object, which matches the return type specified in the documentation.",
    "ground_truth_relationship": "The code implements the documented listCatalogs endpoint by using database transactions and pagination logic to retrieve catalog records from storage, transform them into CatalogInfo objects with attached properties, and return them in a ListCatalogsResponse with the next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core functionality of listing catalogs with pagination support and correct return type, which aligns with the ground truth's description of retrieving and transforming catalog records with pagination",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listCatalogs\"></a>\n# **listCatalogs**\n> ListCatalogsResponse listCatalogs(page\\_token, max\\_results)\n\nList catalogs\n\n    Lists the available catalogs. There is no guarantee of a specific ordering of the elements in the list. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n| **max\\_results** | **Integer**| Maximum number of catalogs to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n\n### Return type\n\n[**ListCatalogsResponse**](../Models/ListCatalogsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogService.listCatalogs",
    "predicted_relationship": "The CatalogService.listCatalogs method directly implements the API endpoint described in the documentation. It takes 'maxResults' and 'pageToken' as optional parameters, which exactly match the 'max_results' and 'page_token' parameters described in the API documentation. The method returns an HttpResponse containing the result of CATALOG_REPOSITORY.listCatalogs, which corresponds to the ListCatalogsResponse return type mentioned in the documentation.",
    "ground_truth_relationship": "The code implements the documented REST endpoint by accepting optional maxResults and pageToken parameters, making a repository call, and returning a JSON response containing the list of catalogs in the format specified by ListCatalogsResponse.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that the code implements the documented REST endpoint with optional maxResults/pageToken parameters and returns a JSON response via the catalog repository. All key elements align with the ground truth.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **updateVolume**\n> VolumeInfo updateVolume(name, UpdateVolumeRequestContent)\n\nUpdate a Volume\n\n    Updates the specified volume under the specified parent catalog and schema.  Currently only the name or the comment of the volume could be updated. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n| **UpdateVolumeRequestContent** | [**UpdateVolumeRequestContent**](../Models/UpdateVolumeRequestContent.md)|  | [optional] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeService.updateVolume",
    "predicted_relationship": "The documentation directly describes the 'updateVolume' operation, which is implemented by the VolumeService.updateVolume method. The method signature matches the documented parameters: a String for the volume name and an UpdateVolumeRequestContent object. It also returns a VolumeInfo object as specified in the documentation.",
    "ground_truth_relationship": "The code implements a PATCH endpoint that takes a fully qualified volume name and UpdateVolumeRequestContent object as specified in the documentation, delegating the actual update operation to VOLUME_REPOSITORY and wrapping the returned VolumeInfo in an HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic update operation and parameters correctly, but misses the key architectural aspect that this is a REST endpoint (PATCH) implementation and that the response is wrapped in an HTTP response format.",
      "error_type": "missing_architectural_context"
    }
  },
  {
    "document_text": "# **updateVolume**\n> VolumeInfo updateVolume(name, UpdateVolumeRequestContent)\n\nUpdate a Volume\n\n    Updates the specified volume under the specified parent catalog and schema.  Currently only the name or the comment of the volume could be updated. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n| **UpdateVolumeRequestContent** | [**UpdateVolumeRequestContent**](../Models/UpdateVolumeRequestContent.md)|  | [optional] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.updateVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.updateVolume method is likely used by VolumeService.updateVolume to perform the actual update operation on the volume data. This method takes the same parameters (name and UpdateVolumeRequestContent) and returns a VolumeInfo object.",
    "ground_truth_relationship": "The code implements the documented volume update functionality by validating the new name if provided, handling the three-level namespace split, and using database transactions to modify either the volume's name or comment while preventing duplicate names and handling non-existent volumes as specified in the documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction captures that this is an update operation returning VolumeInfo, but incorrectly assumes a VolumeRepository/VolumeService architecture when the code shows direct database interaction using Session/Transaction",
      "error_type": "architectural_assumption"
    }
  },
  {
    "document_text": "# **updateVolume**\n> VolumeInfo updateVolume(name, UpdateVolumeRequestContent)\n\nUpdate a Volume\n\n    Updates the specified volume under the specified parent catalog and schema.  Currently only the name or the comment of the volume could be updated. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n| **UpdateVolumeRequestContent** | [**UpdateVolumeRequestContent**](../Models/UpdateVolumeRequestContent.md)|  | [optional] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeInfoDAO",
    "predicted_relationship": "The VolumeInfoDAO class is likely used internally to represent and manipulate the volume data. While not explicitly mentioned in the documentation, it's an essential part of the update process, handling the conversion between the API model (VolumeInfo) and the database representation.",
    "ground_truth_relationship": "The VolumeInfoDAO class implements the data persistence layer for volumes, with fields and conversion methods that match the VolumeInfo structure referenced in the updateVolume API documentation, particularly supporting the comment and name fields that are marked as updatable in the documentation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies VolumeInfoDAO as an internal representation for volume data that handles conversions between API and database models, which aligns with the ground truth's explanation of it implementing data persistence and supporting the documented update functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.getCatalog",
    "predicted_relationship": "The documentation explicitly describes a 'getCatalog' operation that takes a 'name' parameter and returns a CatalogInfo object. This directly corresponds to the CatalogCli.getCatalog method, which implements this functionality.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented getCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "While the predicted description correctly identifies the getCatalog operation and its parameters/return type, it misses the key point that this is a CLI wrapper implementation rather than the core API functionality",
      "error_type": "missing_crucial_context"
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogService.getCatalog",
    "predicted_relationship": "While not explicitly mentioned, the CatalogService.getCatalog method likely implements the server-side logic for the getCatalog operation described in the documentation.",
    "ground_truth_relationship": "The code implements the documented REST GET endpoint by accepting a name parameter and returning a JSON response containing catalog information, exactly matching the API specification's path parameter and response format requirements.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship that the code implements the documented getCatalog operation, even though it's less specific about the details like path parameters and JSON response format",
      "error_type": "none"
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.getCatalog",
    "predicted_relationship": "The getCatalog operation likely uses the CatalogRepository.getCatalog method to retrieve the catalog information from the data store.",
    "ground_truth_relationship": "The code directly implements the documented getCatalog operation by querying the database for a CatalogInfoDAO entity matching the specified name parameter using Hibernate's query language and returning a single result.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures that it retrieves catalog information but incorrectly suggests it uses a CatalogRepository.getCatalog method when it actually uses direct Hibernate querying",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogInfoDAO",
    "predicted_relationship": "The CatalogInfo return type mentioned in the documentation is likely represented by the CatalogInfoDAO class in the data access layer.",
    "ground_truth_relationship": "The CatalogInfoDAO class provides the data persistence layer and mapping functionality for the CatalogInfo objects that are returned by the documented getCatalog endpoint through its toCatalogInfo() conversion method.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that CatalogInfoDAO represents/maps to CatalogInfo at the data layer, which aligns with the ground truth's explanation of CatalogInfoDAO providing persistence and mapping for CatalogInfo objects.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteCatalog\"></a>\n# **deleteCatalog**\n> oas_any_type_not_mapped deleteCatalog(name, force)\n\nDelete a catalog\n\n    Deletes the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.deleteCatalog",
    "predicted_relationship": "This method directly implements the 'deleteCatalog' operation described in the documentation. It takes the required 'name' parameter and the optional 'force' parameter, matching the documentation's description of the API endpoint.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures that this implements the deleteCatalog API operation, but misses the crucial aspect that it's a CLI wrapper rather than a direct implementation",
      "error_type": "missing_key_role"
    }
  },
  {
    "document_text": "<a name=\"deleteCatalog\"></a>\n# **deleteCatalog**\n> oas_any_type_not_mapped deleteCatalog(name, force)\n\nDelete a catalog\n\n    Deletes the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.deleteCatalog",
    "predicted_relationship": "This method likely implements the core logic for deleting a catalog, including the 'force' option mentioned in the documentation. It's implicitly related as it's likely called by the CLI or service layer to perform the actual deletion.",
    "ground_truth_relationship": "The code implements the documented deleteCatalog operation by handling catalog deletion with optional force removal of schemas, throwing appropriate exceptions if the catalog is not found (ErrorCode.NOT_FOUND) or contains schemas without force flag (ErrorCode.FAILED_PRECONDITION), and managing the transaction across catalog, schema, and property deletions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the core purpose of deleting a catalog and mentions the force option, but misses crucial aspects about schema handling, error conditions, and property management that are essential to the implementation's behavior",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"deleteCatalog\"></a>\n# **deleteCatalog**\n> oas_any_type_not_mapped deleteCatalog(name, force)\n\nDelete a catalog\n\n    Deletes the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogService.deleteCatalog",
    "predicted_relationship": "This service method likely implements the API endpoint for deleting a catalog. It matches the documentation by taking a 'name' parameter and an optional 'force' parameter, aligning with the described functionality.",
    "ground_truth_relationship": "The code implements a DELETE endpoint that directly mirrors the documented API behavior by accepting a required 'name' parameter and optional 'force' parameter, invoking the catalog repository's deletion logic, and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship between the code and documentation - it identifies the endpoint's purpose (deleting a catalog) and correctly notes the key parameters (name and optional force), matching the ground truth's understanding.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"updateSchema\"></a>\n# **updateSchema**\n> SchemaInfo updateSchema(full\\_name, UpdateSchema)\n\nUpdate a schema\n\n    Updates the specified schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **UpdateSchema** | [**UpdateSchema**](../Models/UpdateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.updateSchema",
    "predicted_relationship": "The SchemaRepository.updateSchema method directly implements the updateSchema operation described in the documentation. The method signature matches the documented parameters, taking a 'fullName' string and an 'UpdateSchema' object. It also returns a SchemaInfo object as specified in the documentation.",
    "ground_truth_relationship": "The code implements the documented schema update endpoint by validating the new schema name, managing database transactions to update the schema's name, comment, and properties, and handling errors according to the API specification's parameters and return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship between the code and documentation - that this is an implementation of the updateSchema operation with matching parameters and return type. While it's less detailed than the ground truth about validation and transaction handling, it captures the essential relationship correctly.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"updateSchema\"></a>\n# **updateSchema**\n> SchemaInfo updateSchema(full\\_name, UpdateSchema)\n\nUpdate a schema\n\n    Updates the specified schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **UpdateSchema** | [**UpdateSchema**](../Models/UpdateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaService.updateSchema",
    "predicted_relationship": "The SchemaService.updateSchema method directly implements the API endpoint described in the documentation. It takes the 'full_name' parameter and 'UpdateSchema' object as input, matching the documented API signature. It also returns an HttpResponse containing the updated SchemaInfo.",
    "ground_truth_relationship": "The code implements a PATCH endpoint that directly matches the documented API endpoint, accepting a fullName path parameter and UpdateSchema body parameter, and returning a JSON response through HttpResponse.ofJson from the schema repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - a PATCH endpoint that takes fullName and UpdateSchema parameters and returns a JSON response. While using slightly different wording, it conveys the same essential functionality as the ground truth.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"updateSchema\"></a>\n# **updateSchema**\n> SchemaInfo updateSchema(full\\_name, UpdateSchema)\n\nUpdate a schema\n\n    Updates the specified schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **UpdateSchema** | [**UpdateSchema**](../Models/UpdateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaInfoDAO",
    "predicted_relationship": "While not explicitly mentioned, the SchemaInfoDAO is likely used internally to represent and persist the updated schema information. The documentation mentions returning a SchemaInfo object, which is likely converted from a SchemaInfoDAO instance.",
    "ground_truth_relationship": "The SchemaInfoDAO class provides the data persistence layer and object mapping functionality needed to support the updateSchema API endpoint by managing schema metadata in the database and converting between SchemaInfo API objects and database entities.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core understanding that SchemaInfoDAO handles internal persistence and representation of schema data, with conversion to/from SchemaInfo objects, which aligns with the ground truth's description of it serving as the data persistence layer with object mapping functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.createVolume",
    "predicted_relationship": "The documentation explicitly mentions a 'createVolume' POST endpoint under the VolumesApi. This directly corresponds to the 'createVolume' method in the VolumeService class, which implements this API endpoint.",
    "ground_truth_relationship": "The code implements the POST /volumes endpoint documented in the API table by defining a method that accepts a CreateVolumeRequestContent object and delegates to VOLUME_REPOSITORY to create a new volume, returning the result as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented POST /volumes endpoint for creating volumes. Both descriptions capture the core relationship between the API documentation and implementation.",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.deleteVolume",
    "predicted_relationship": "The documentation explicitly mentions a 'deleteVolume' DELETE endpoint under the VolumesApi. This directly corresponds to the 'deleteVolume' method in the VolumeService class, which implements this API endpoint.",
    "ground_truth_relationship": "The code implements the documented DELETE /volumes/{name} endpoint by accepting a volume's full name as a path parameter, delegating the deletion to VOLUME_REPOSITORY, and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented DELETE endpoint for volumes from the API spec, even though it doesn't detail the specific HTTP response and repository usage",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.getVolume",
    "predicted_relationship": "The documentation explicitly mentions a 'getVolume' GET endpoint under the VolumesApi. This directly corresponds to the 'getVolume' method in the VolumeService class, which implements this API endpoint.",
    "ground_truth_relationship": "The code implements the documented GET /volumes/{name} endpoint by providing a method that retrieves volume information based on a full name parameter and returns it as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions accurately capture that the code implements a GET endpoint for retrieving volume information by name, returning JSON data. The predicted description correctly identifies the API-to-implementation relationship.",
      "error_type": "none"
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.listVolumes",
    "predicted_relationship": "The documentation explicitly mentions a 'listVolumes' GET endpoint under the VolumesApi. This directly corresponds to the 'listVolumes' method in the VolumeService class, which implements this API endpoint.",
    "ground_truth_relationship": "The code implements the 'listVolumes' API endpoint documented in the table by defining a GET handler that accepts query parameters for catalog_name, schema_name, pagination controls, and browse options, returning the results as JSON.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the relationship between the code and documentation - that this is a GET endpoint for listing volumes as documented in the API table. While it doesn't mention all the parameters, it captures the core relationship accurately.",
      "error_type": null
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.updateVolume",
    "predicted_relationship": "The documentation explicitly mentions an 'updateVolume' PATCH endpoint under the VolumesApi. This directly corresponds to the 'updateVolume' method in the VolumeService class, which implements this API endpoint.",
    "ground_truth_relationship": "The code implements the documented PATCH /volumes/{name} API endpoint by defining an updateVolume method that accepts a volume name and update request content, returning the updated volume data as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately identifies that the code implements the documented PATCH /volumes endpoint through the updateVolume method. While it omits some implementation details about parameters and return type, it captures the core relationship between the code and documentation.",
      "error_type": null
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeRepository.createVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.createVolume method is likely used by the VolumeService.createVolume method to implement the create volume functionality.",
    "ground_truth_relationship": "The VolumeRepository.createVolume method implements the POST /volumes API endpoint by validating the request, creating a new volume record with generated UUID and metadata, and persisting it to the database while enforcing schema existence and volume uniqueness constraints.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies this as volume creation functionality but implies an incorrect architecture by suggesting VolumeRepository.createVolume is called by VolumeService.createVolume, when the code actually directly implements the API endpoint.",
      "error_type": "architectural_misunderstanding"
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeRepository.deleteVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.deleteVolume method is likely used by the VolumeService.deleteVolume method to implement the delete volume functionality.",
    "ground_truth_relationship": "The deleteVolume method in VolumeRepository implements the DELETE /volumes/{name} API endpoint by parsing the three-part volume name (catalog.schema.volume), validating the schema exists, and removing both the volume's metadata from the database and its storage directory if it's a managed volume.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies a connection between deleteVolume methods but gets the relationship backwards and misses key implementation details about volume deletion. The ground truth explains that this method actually implements the DELETE API endpoint directly, rather than being used by another service.",
      "error_type": "incorrect_component_relationship"
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeRepository.getVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.getVolume method is likely used by the VolumeService.getVolume method to implement the get volume functionality.",
    "ground_truth_relationship": "The VolumeRepository.getVolume method implements the GET /volumes/{name} endpoint by parsing a three-part volume name (catalog.schema.volume), retrieving the volume data from a database session, and returning a VolumeInfo object that represents the requested volume.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description gets the basic function right that it's related to getting volume info, but introduces uncertainty with 'likely used by VolumeService' when the code directly implements the GET endpoint functionality",
      "error_type": "architectural_uncertainty"
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeRepository.listVolumes",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.listVolumes method is likely used by the VolumeService.listVolumes method to implement the list volumes functionality.",
    "ground_truth_relationship": "The listVolumes method implements the GET /volumes API endpoint by querying the database for volumes within a specified schema, supporting pagination through maxResults and pageToken parameters, and returning the results as a ListVolumesResponseContent object.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly suggests this is part of volume listing functionality but incorrectly assumes intermediary VolumeRepository/VolumeService classes that don't exist in the code. The core list volumes functionality is correctly identified but the implementation details are misrepresented.",
      "error_type": "incorrect_implementation_assumption"
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeRepository.updateVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.updateVolume method is likely used by the VolumeService.updateVolume method to implement the update volume functionality.",
    "ground_truth_relationship": "The VolumeRepository.updateVolume method implements the PATCH /volumes/{name} API endpoint by validating input parameters, managing database transactions, and performing volume updates including name and comment changes while handling potential conflicts and exceptions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies this as being related to volume updates, but incorrectly assumes it's a repository method used by a service layer when it's actually directly implementing the PATCH API endpoint",
      "error_type": "incorrect_architectural_layer"
    }
  },
  {
    "document_text": "<a name=\"deleteFunction\"></a>\n# **deleteFunction**\n> oas_any_type_not_mapped deleteFunction(name)\n\nDelete a function\n\n    Deletes the function that matches the supplied name.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionCli.deleteFunction",
    "predicted_relationship": "The documentation explicitly describes a 'deleteFunction' operation that deletes a function matching a supplied name. This directly corresponds to the 'FunctionCli.deleteFunction' method in the code, which implements this functionality.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the core delete function relationship but misses that this is specifically a CLI wrapper implementation rather than the main deletion function itself",
      "error_type": "missing_architectural_context"
    }
  },
  {
    "document_text": "<a name=\"deleteFunction\"></a>\n# **deleteFunction**\n> oas_any_type_not_mapped deleteFunction(name)\n\nDelete a function\n\n    Deletes the function that matches the supplied name.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.deleteFunction",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the FunctionRepository.deleteFunction method is likely used by the FunctionCli.deleteFunction to perform the actual deletion of the function from the repository.",
    "ground_truth_relationship": "The code implements the documented deleteFunction API endpoint by validating and parsing a fully-qualified function name (catalog.schema.function), managing a database transaction to delete the corresponding FunctionInfoDAO record, and throwing appropriate exceptions for invalid names or missing functions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "While the prediction correctly identifies that the code handles function deletion, it incorrectly assumes a FunctionCli/FunctionRepository architecture when the code actually shows direct database transaction management with Session/Transaction objects and DAO patterns",
      "error_type": "architectural_misunderstanding"
    }
  },
  {
    "document_text": "<a name=\"deleteFunction\"></a>\n# **deleteFunction**\n> oas_any_type_not_mapped deleteFunction(name)\n\nDelete a function\n\n    Deletes the function that matches the supplied name.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionService.deleteFunction",
    "predicted_relationship": "The FunctionService.deleteFunction method likely implements the server-side handling of the delete function request described in the documentation. It would be called when the API receives a delete function request.",
    "ground_truth_relationship": "The code implements the documented DELETE endpoint by accepting a name parameter and an optional force parameter (not mentioned in docs), calling FUNCTION_REPOSITORY.deleteFunction(), and returning an HTTP 200 OK response as specified in the OpenAPI documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this code implements server-side handling of the delete function API endpoint described in the documentation, which is the core relationship between code and docs.",
      "error_type": null
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.createTable",
    "predicted_relationship": "The documentation explicitly mentions a 'createTable' API endpoint with a POST request to '/tables'. This directly corresponds to the TableService.createTable method, which is annotated with @Post(\"\") and implements the creation of a table.",
    "ground_truth_relationship": "The createTable code method implements the POST /tables API endpoint documented in TablesApi by accepting a CreateTable request object, delegating to TABLE_REPOSITORY for table creation, and returning the response as JSON.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented POST /tables API endpoint for table creation, with the same core functionality of handling table creation requests and responses",
      "error_type": ""
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.deleteTable",
    "predicted_relationship": "The documentation explicitly mentions a 'deleteTable' API endpoint with a DELETE request to '/tables/{full_name}'. This directly corresponds to the TableService.deleteTable method, which is annotated with @Delete(\"/{full_name}\") and implements the deletion of a table.",
    "ground_truth_relationship": "The code implements the documented DELETE /tables/{full_name} endpoint by creating a method annotated with @Delete that takes a full_name parameter, deletes the corresponding table through the repository, and returns an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that this is a DELETE endpoint implementation for deleting tables that matches the documented API. Both descriptions cover the core relationship between the code and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.getTable",
    "predicted_relationship": "The documentation explicitly mentions a 'getTable' API endpoint with a GET request to '/tables/{full_name}'. This directly corresponds to the TableService.getTable method, which is annotated with @Get(\"/{full_name}\") and implements retrieving a table.",
    "ground_truth_relationship": "The code implements the documented GET /tables/{full_name} endpoint by creating a method that retrieves a TableInfo object based on the full_name path parameter and returns it as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship between the code and documentation - that it implements a GET endpoint for retrieving a table using the full_name path parameter. While it omits the JSON response detail, this is a minor omission that doesn't affect the main relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.listTables",
    "predicted_relationship": "The documentation explicitly mentions a 'listTables' API endpoint with a GET request to '/tables'. This directly corresponds to the TableService.listTables method, which is annotated with @Get(\"\") and implements listing tables.",
    "ground_truth_relationship": "The document is an API endpoint summary table that lists the methods available and their description under the TablesApi. Each code is related to one of the methods.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the listTables GET endpoint, but misses that this is part of a larger API documentation showing multiple available methods/endpoints (create, delete, get, list). The narrow focus on just one method misses the broader context.",
      "error_type": "incomplete_scope"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableRepository.createTable",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableRepository.createTable method is likely used by the TableService.createTable method to perform the actual table creation in the database.",
    "ground_truth_relationship": "The TableRepository.createTable method implements the backend logic for the experimental POST /tables API endpoint, handling table creation with validations for SQL object names, schema existence, and storage location requirements while preventing creation of managed tables.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies this as a table creation method but incorrectly assumes it's called by TableService when it actually implements the POST /tables API endpoint directly. The core table creation concept is right but the architectural relationship is misunderstood.",
      "error_type": "architectural_misunderstanding"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableRepository.deleteTable",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableRepository.deleteTable method is likely used by the TableService.deleteTable method to perform the actual table deletion in the database.",
    "ground_truth_relationship": "The deleteTable method implements the DELETE /tables/{full_name} API endpoint's backend logic by removing the table's metadata from the session, cleaning up associated properties, and deleting the physical directory for managed tables.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies this as being related to table deletion functionality, but incorrectly suggests it's a TableService calling a TableRepository method, when the code shows it's actually implementing the deletion logic directly",
      "error_type": "incorrect_architecture_assumption"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableRepository.getTable",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableRepository.getTable method is likely used by the TableService.getTable method to retrieve the actual table information from the database.",
    "ground_truth_relationship": "The TableRepository.getTable method implements the backend database logic for the GET /tables/{full_name} API endpoint, retrieving a table's details from the database by parsing the full_name parameter into catalog, schema and table components and returning a TableInfo object with attached properties.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this is a method for retrieving table information, but fails to recognize its direct connection to the GET /tables API endpoint and introduces uncertainty by saying it's 'likely used by TableService' when it's actually implementing the API endpoint directly",
      "error_type": "missing_key_relationship"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableRepository.listTables",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableRepository.listTables method is likely used by the TableService.listTables method to retrieve the list of tables from the database.",
    "ground_truth_relationship": "The TableRepository.listTables code implements the GET /tables REST API endpoint by querying tables from a database session, applying pagination through maxResults and pageToken parameters, and returning a ListTablesResponse containing table information with optional properties and columns.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is about listing tables through a repository/database layer, which aligns with the ground truth's core functionality of implementing the GET /tables endpoint to query and return table data.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteTable\"></a>\n# **deleteTable**\n> oas_any_type_not_mapped deleteTable(full\\_name)\n\nDelete a table\n\n    Deletes a table from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableCli.deleteTable",
    "predicted_relationship": "The TableCli.deleteTable method implements the deleteTable operation described in the documentation. It takes a full name parameter and calls the deleteTable method on the TablesApi, which aligns with the documentation's description of deleting a table using its full name.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteTable endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that this is an implementation of the documented deleteTable operation, handling the full name parameter and making the appropriate API call. While it doesn't explicitly use the term 'CLI wrapper', it describes the same core functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteTable\"></a>\n# **deleteTable**\n> oas_any_type_not_mapped deleteTable(full\\_name)\n\nDelete a table\n\n    Deletes a table from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableService.deleteTable",
    "predicted_relationship": "The TableService.deleteTable method directly implements the deleteTable operation described in the documentation. It takes a 'full_name' parameter as specified in the documentation and returns an HTTP response, which aligns with the API description.",
    "ground_truth_relationship": "The code implements a REST DELETE endpoint that matches the documented API specification by accepting a full_name parameter, invoking TABLE_REPOSITORY.deleteTable(), and returning a 200 OK response with no content body.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship between the code and documentation - it identifies that this is a deleteTable operation that takes a full_name parameter and returns an HTTP response, which aligns with the documented API specification.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteTable\"></a>\n# **deleteTable**\n> oas_any_type_not_mapped deleteTable(full\\_name)\n\nDelete a table\n\n    Deletes a table from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableRepository.deleteTable",
    "predicted_relationship": "The TableRepository.deleteTable method is likely called by the TableService to perform the actual deletion of the table from the database. While not explicitly mentioned in the documentation, it's a crucial part of the deletion process.",
    "ground_truth_relationship": "The code implements the documented table deletion operation by removing the table's database entry, deleting its physical files (for managed tables), and cleaning up associated properties, while the documentation describes the API endpoint that exposes this functionality with a 'full_name' parameter.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies this as table deletion functionality but incorrectly suggests it's a TableService calling TableRepository, when the code shows it's a standalone deletion method. However, it does understand the core purpose.",
      "error_type": "architectural_misunderstanding"
    }
  },
  {
    "document_text": "# **getVolume**\n> VolumeInfo getVolume(name)\n\nGet a Volume\n\n    Gets a volume for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeService.getVolume",
    "predicted_relationship": "The documentation directly describes a 'getVolume' operation that takes a 'name' parameter and returns a 'VolumeInfo' object. This closely matches the signature and functionality of the VolumeService.getVolume method.",
    "ground_truth_relationship": "The code implements the documented GET endpoint by accepting a required 'full_name' path parameter and an optional 'include_browse' query parameter, returning a JSON response containing volume information from the repository, though the documentation doesn't mention the optional parameter.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the core GET endpoint functionality but misses mentioning the optional 'include_browse' parameter and describes the return type as a specific 'VolumeInfo' object when the code shows a more generic JSON response",
      "error_type": "omitted_parameters_and_details"
    }
  },
  {
    "document_text": "# **getVolume**\n> VolumeInfo getVolume(name)\n\nGet a Volume\n\n    Gets a volume for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.getVolume",
    "predicted_relationship": "While not explicitly mentioned, the VolumeService.getVolume method likely uses the VolumeRepository.getVolume method to retrieve the volume information from the data store.",
    "ground_truth_relationship": "The code implements the documented getVolume operation by splitting a three-level name parameter into catalog, schema, and volume components, validating the format, and returning a VolumeInfo object retrieved from the database through a DAO pattern.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly mentions that the method retrieves volume information from a data store, but it makes assumptions about specific components (VolumeService, VolumeRepository) that aren't shown and misses the crucial parsing/validation of the three-level name parameter.",
      "error_type": "incomplete_understanding"
    }
  },
  {
    "document_text": "# **getVolume**\n> VolumeInfo getVolume(name)\n\nGet a Volume\n\n    Gets a volume for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeInfoDAO",
    "predicted_relationship": "The VolumeInfoDAO is likely used internally to represent the volume data in the database, which is then converted to the VolumeInfo object mentioned in the return type.",
    "ground_truth_relationship": "The VolumeInfoDAO class provides the data persistence layer and model conversion methods (toVolumeInfo/from) needed to support the documented getVolume API endpoint by mapping between the database representation and the VolumeInfo response type.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies VolumeInfoDAO as an internal database representation that converts to VolumeInfo, but misses the crucial aspect that this class specifically supports the getVolume API endpoint and its persistence layer functionality",
      "error_type": "incomplete_understanding"
    }
  },
  {
    "document_text": "<a name=\"listFunctions\"></a>\n# **listFunctions**\n> ListFunctionsResponse listFunctions(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList functions\n\n    List functions within the specified parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for functions of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of functions. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of functions to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query. | [optional] [default to null] |\n\n### Return type\n\n[**ListFunctionsResponse**](../Models/ListFunctionsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionCli.listFunctions",
    "predicted_relationship": "This method implements the client-side functionality for listing functions as described in the API documentation. It uses the same parameters (catalog_name, schema_name, max_results) and returns a list of functions, which aligns with the ListFunctionsResponse mentioned in the documentation.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listFunctions endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the core functionality of listing functions and parameters, but misses that this is specifically a CLI wrapper implementation for the API endpoint, which is a key architectural aspect noted in the ground truth.",
      "error_type": "missing_key_context"
    }
  },
  {
    "document_text": "<a name=\"listFunctions\"></a>\n# **listFunctions**\n> ListFunctionsResponse listFunctions(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList functions\n\n    List functions within the specified parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for functions of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of functions. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of functions to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query. | [optional] [default to null] |\n\n### Return type\n\n[**ListFunctionsResponse**](../Models/ListFunctionsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionService.listFunctions",
    "predicted_relationship": "This method directly implements the listFunctions API endpoint described in the documentation. It takes the same parameters (catalog_name, schema_name, max_results, page_token) and returns a ListFunctionsResponse, exactly matching the API specification.",
    "ground_truth_relationship": "The code implements a REST GET endpoint that takes the exact parameters specified in the documentation (catalog_name, schema_name, optional max_results, and optional page_token) and delegates the actual function listing to a repository layer, returning the results as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship that this is a REST endpoint implementing the listFunctions API with matching parameters and return type as specified in the documentation. While it doesn't mention the repository layer delegation, this is a minor implementation detail that doesn't affect the fundamental relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listFunctions\"></a>\n# **listFunctions**\n> ListFunctionsResponse listFunctions(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList functions\n\n    List functions within the specified parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for functions of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of functions. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of functions to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query. | [optional] [default to null] |\n\n### Return type\n\n[**ListFunctionsResponse**](../Models/ListFunctionsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.listFunctions",
    "predicted_relationship": "This repository method likely implements the data access logic for listing functions. It takes similar parameters (catalogName, schemaName, maxResults, pageToken) and is responsible for retrieving the function data that will be returned in the ListFunctionsResponse.",
    "ground_truth_relationship": "The code implements the documented behavior by retrieving function records from a database within a read-only transaction, transforming FunctionInfoDAO objects to FunctionInfo objects with attached properties, and returning them in a ListFunctionsResponse with pagination support through maxResults and pageToken parameters.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core relationship that this is a data access method for listing functions with pagination support, matching the ground truth's high-level purpose. While it omits some implementation details like transactions and property attachment, these are minor details that don't change the fundamental relationship.",
      "error_type": "none"
    }
  },
  {
    "document_text": "<a name=\"createCatalog\"></a>\n# **createCatalog**\n> CatalogInfo createCatalog(CreateCatalog)\n\nCreate a catalog\n\n    Creates a new catalog instance. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateCatalog** | [**CreateCatalog**](../Models/CreateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.addCatalog",
    "predicted_relationship": "The CatalogRepository.addCatalog method likely implements the core functionality of creating a new catalog. While not explicitly mentioned in the documentation, it's the logical backend implementation for the createCatalog operation described in the API documentation.",
    "ground_truth_relationship": "The addCatalog implementation validates SQL object names, creates a CatalogInfo instance with a UUID and properties, and persists it to the database in a transaction, fulfilling the documented createCatalog API endpoint's purpose of creating a new catalog instance.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the core relationship that addCatalog implements the catalog creation functionality described in the API documentation. While it's less detailed than the ground truth, it captures the essential relationship without any contradictions.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createCatalog\"></a>\n# **createCatalog**\n> CatalogInfo createCatalog(CreateCatalog)\n\nCreate a catalog\n\n    Creates a new catalog instance. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateCatalog** | [**CreateCatalog**](../Models/CreateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogService.createCatalog",
    "predicted_relationship": "The CatalogService.createCatalog method is likely the direct implementation of the createCatalog API operation described in the documentation. It would handle the HTTP request, process the CreateCatalog input, and return the CatalogInfo response.",
    "ground_truth_relationship": "The code implements the documented API endpoint by accepting a CreateCatalog object via POST, persisting it through CATALOG_REPOSITORY, and returning a JSON response matching the documented CatalogInfo return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that the code implements the documented API endpoint for creating catalogs. While it omits specific details about CATALOG_REPOSITORY and JSON handling, it correctly identifies the main purpose and flow.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createCatalog\"></a>\n# **createCatalog**\n> CatalogInfo createCatalog(CreateCatalog)\n\nCreate a catalog\n\n    Creates a new catalog instance. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateCatalog** | [**CreateCatalog**](../Models/CreateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogInfoDAO",
    "predicted_relationship": "The CatalogInfoDAO is likely used to map between the database representation and the CatalogInfo object mentioned in the API documentation as the return type.",
    "ground_truth_relationship": "The CatalogInfoDAO class provides the data persistence layer and mapping functionality for the CatalogInfo objects that are returned by the documented createCatalog API endpoint, with methods to convert between the DAO and API model representations.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core mapping functionality between the database (DAO) and CatalogInfo objects, which is the main relationship described in the ground truth. While it omits some details about the API endpoint, the fundamental data mapping relationship is correctly identified.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionCli.createFunction",
    "predicted_relationship": "The FunctionCli.createFunction method likely implements the client-side functionality for creating a function as described in the API documentation. While not explicitly mentioned, it's the client-side counterpart to the server operation.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a client-side implementation related to the documented createFunction API endpoint. While the ground truth is more specific in calling it a CLI wrapper, the core relationship understanding is the same.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.createFunction",
    "predicted_relationship": "This method likely implements the core logic for creating a function in the repository. It's implicitly related as it would handle the persistence of the new function based on the CreateFunctionRequest.",
    "ground_truth_relationship": "The code implements the documented createFunction API endpoint by validating the input function name, constructing a FunctionInfo object with all required properties, and persisting it in a database transaction while handling schema validation and duplicate function checks.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - creating and persisting a function based on the CreateFunctionRequest. While it omits implementation details like validation and transaction handling, it correctly identifies the main purpose and relationship between the code and API.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionService.createFunction",
    "predicted_relationship": "This method directly implements the createFunction operation described in the API documentation. It takes a CreateFunctionRequest as input and returns a FunctionInfo object, matching the API specification.",
    "ground_truth_relationship": "The code implements the documented REST API endpoint by exposing a POST method that accepts a CreateFunctionRequest object, delegates to FUNCTION_REPOSITORY for function creation, and returns the result wrapped in an HTTP JSON response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic function purpose and parameters but misses the crucial HTTP POST aspect and omits that the response is wrapped in an HTTP JSON response format",
      "error_type": "missing_crucial_details"
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionInfoDAO",
    "predicted_relationship": "While not explicitly mentioned, FunctionInfoDAO is likely used to persist and retrieve function information, corresponding to the FunctionInfo return type mentioned in the API.",
    "ground_truth_relationship": "The FunctionInfoDAO class provides the database persistence layer and object mapping functionality that enables the createFunction API endpoint to store and retrieve function metadata in the uc_functions table, converting between the API's FunctionInfo model and its database representation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - that FunctionInfoDAO handles persistence and mappings between FunctionInfo and the database. While it omits some implementation details, it correctly identifies the main purpose and relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"generateTemporaryVolumeCredentials\"></a>\n# **generateTemporaryVolumeCredentials**\n> GenerateTemporaryVolumeCredentialResponse generateTemporaryVolumeCredentials(GenerateTemporaryVolumeCredential)\n\nGenerate temporary volume credentials.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **GenerateTemporaryVolumeCredential** | [**GenerateTemporaryVolumeCredential**](../Models/GenerateTemporaryVolumeCredential.md)|  | [optional] |\n\n### Return type\n\n[**GenerateTemporaryVolumeCredentialResponse**](../Models/GenerateTemporaryVolumeCredentialResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json\n",
    "artifact_title": "TemporaryVolumeCredentialsService.generateTemporaryVolumeCredentials",
    "predicted_relationship": "This method directly implements the generateTemporaryVolumeCredentials functionality described in the documentation. The method signature matches the documented API, taking a GenerateTemporaryVolumeCredential parameter and returning a GenerateTemporaryVolumeCredentialResponse.",
    "ground_truth_relationship": "The code implements the documented API endpoint by validating the volume ID, retrieving storage location information, and returning temporary AWS S3 credentials for S3 volumes or empty credentials for local storage, while matching the specified request/response types and HTTP POST behavior.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic API structure but misses the crucial functionality of credential generation based on storage type (S3 vs local) which is a key aspect of the implementation",
      "error_type": "missing_core_functionality"
    }
  },
  {
    "document_text": "<a name=\"getSchema\"></a>\n# **getSchema**\n> SchemaInfo getSchema(full\\_name)\n\nGet a schema\n\n    Gets the specified schema for a catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.getSchema",
    "predicted_relationship": "The SchemaRepository.getSchema method directly implements the getSchema operation described in the documentation. It takes a 'fullName' parameter, which corresponds to the 'full_name' parameter in the API documentation. The method returns a SchemaInfo object, matching the return type specified in the documentation.",
    "ground_truth_relationship": "The code implements the documented getSchema operation by retrieving a schema from a database session, converting it from DAO format to SchemaInfo, and attaching properties, while handling the specified error case for when the schema is not found.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic functionality of getting a schema and returning SchemaInfo, but misses crucial implementation details about database session handling, DAO conversion, and property attachment that are core to how the relationship actually works",
      "error_type": "important_omissions"
    }
  },
  {
    "document_text": "<a name=\"getSchema\"></a>\n# **getSchema**\n> SchemaInfo getSchema(full\\_name)\n\nGet a schema\n\n    Gets the specified schema for a catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaService.getSchema",
    "predicted_relationship": "The SchemaService.getSchema method directly implements the API endpoint described in the documentation. It takes a 'fullName' parameter, matching the 'full_name' parameter in the API documentation. This service method would typically call the repository method to retrieve the schema information.",
    "ground_truth_relationship": "The code implements the documented GET endpoint with path parameter 'full_name' by returning a JSON HTTP response containing schema information retrieved from SCHEMA_REPOSITORY.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - the implementation of a GET endpoint that takes a fullName parameter and returns schema information via the repository. The minor implementation details differ but the fundamental relationship is the same.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getSchema\"></a>\n# **getSchema**\n> SchemaInfo getSchema(full\\_name)\n\nGet a schema\n\n    Gets the specified schema for a catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaInfoDAO",
    "predicted_relationship": "While not explicitly mentioned, the SchemaInfoDAO is likely used internally to represent the schema data in the database. The getSchema operation would retrieve data using this DAO to construct the SchemaInfo object returned to the client.",
    "ground_truth_relationship": "The SchemaInfoDAO class provides the data persistence and transformation layer for the SchemaInfo object that is returned by the documented getSchema endpoint, handling the mapping between database records and the API response model.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core function of SchemaInfoDAO as an internal database representation layer for schema data, which aligns with the ground truth's description of it serving as a data persistence and transformation layer between database and API response model.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "TableService.createTable",
    "predicted_relationship": "The documentation describes a 'createTable' operation that takes a CreateTable object and returns a TableInfo object. This directly corresponds to the TableService.createTable method, which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented POST endpoint by accepting a CreateTable request object, validating it's not null, delegating to the TABLE_REPOSITORY to create the table, and returning a TableInfo response wrapped in an HTTP JSON response, matching the documented input/output types and content types.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic input/output types but misses key implementation details about HTTP response wrapping and null validation. It also incorrectly references 'TableService' instead of 'TABLE_REPOSITORY'.",
      "error_type": "missing_key_details_and_incorrect_reference"
    }
  },
  {
    "document_text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "TableRepository.createTable",
    "predicted_relationship": "While not explicitly mentioned, the TableService.createTable method likely uses TableRepository.createTable to perform the actual table creation in the database.",
    "ground_truth_relationship": "The code implements the documented createTable API by validating the table name, creating a new TableInfo object with the specified properties, checking for existing tables, rejecting MANAGED table types, requiring storage locations for external tables, and persisting the table data in a database transaction while handling errors as specified in the API documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly notes this is about table creation but incorrectly suggests it uses a TableRepository.createTable method when the code shows direct database persistence using a Session. While the core concept of table creation is right, the implementation mechanism is misrepresented.",
      "error_type": "implementation_mechanism_mismatch"
    }
  },
  {
    "document_text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "TableInfoDAO",
    "predicted_relationship": "The documentation mentions returning a TableInfo object. TableInfoDAO is likely used internally to convert between database and API representations of table information.",
    "ground_truth_relationship": "The TableInfoDAO class provides the persistence layer mapping and conversion logic for the TableInfo objects returned by the documented createTable API endpoint, handling the storage and retrieval of table metadata in the 'uc_tables' database table.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the core relationship - that TableInfoDAO handles conversion between database and API (TableInfo) representations. While it doesn't mention specific database details, it captures the essential data mapping functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listSchemas\"></a>\n# **listSchemas**\n> ListSchemasResponse listSchemas(catalog\\_name, max\\_results, page\\_token)\n\nList schemas\n\n    Gets an array of schemas for a catalog. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Parent catalog for schemas of interest. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of schemas to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n\n### Return type\n\n[**ListSchemasResponse**](../Models/ListSchemasResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaService.listSchemas",
    "predicted_relationship": "The documentation directly describes the 'listSchemas' operation, which is implemented by the SchemaService.listSchemas method. The method signature matches the documented parameters: catalog_name, max_results, and page_token. It also returns a ListSchemasResponse as specified in the documentation.",
    "ground_truth_relationship": "The code implements a GET endpoint that takes a catalog name and optional pagination parameters (max_results and page_token) to retrieve a list of schemas from SCHEMA_REPOSITORY, exactly matching the documented API endpoint's parameters and functionality.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the main relationship - a GET endpoint that retrieves schemas using catalog_name and optional pagination parameters, matching the documented functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listSchemas\"></a>\n# **listSchemas**\n> ListSchemasResponse listSchemas(catalog\\_name, max\\_results, page\\_token)\n\nList schemas\n\n    Gets an array of schemas for a catalog. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Parent catalog for schemas of interest. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of schemas to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n\n### Return type\n\n[**ListSchemasResponse**](../Models/ListSchemasResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.listSchemas",
    "predicted_relationship": "While not explicitly mentioned, the SchemaService.listSchemas method likely delegates the actual schema listing operation to SchemaRepository.listSchemas. This repository method would handle the database interaction to retrieve the list of schemas based on the provided parameters.",
    "ground_truth_relationship": "The code implements the documented listSchemas API endpoint by querying a database session for schemas matching the given catalog ID, converting the results from DAOs to SchemaInfo objects, handling pagination through maxResults and pageToken parameters, and returning a ListSchemasResponse containing the schema list and next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly notes that the method handles schema listing, but incorrectly suggests it delegates to a SchemaRepository class when the code actually directly implements the database interaction using Session objects and DAOs",
      "error_type": "architectural_assumption"
    }
  },
  {
    "document_text": "<a name=\"generateTemporaryTableCredentials\"></a>\n# **generateTemporaryTableCredentials**\n> GenerateTemporaryTableCredentialResponse generateTemporaryTableCredentials(GenerateTemporaryTableCredential)\n\nGenerate temporary table credentials.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **GenerateTemporaryTableCredential** | [**GenerateTemporaryTableCredential**](../Models/GenerateTemporaryTableCredential.md)|  | [optional] |\n\n### Return type\n\n[**GenerateTemporaryTableCredentialResponse**](../Models/GenerateTemporaryTableCredentialResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json\n",
    "artifact_title": "TemporaryTableCredentialsService.generateTemporaryTableCredentials",
    "predicted_relationship": "This method directly implements the generateTemporaryTableCredentials functionality described in the documentation. The method signature matches the documented API call, taking a GenerateTemporaryTableCredential parameter and returning a GenerateTemporaryTableCredentialResponse.",
    "ground_truth_relationship": "The code implements the documented API endpoint by checking if a table exists at a storage location, then either generating AWS S3 temporary credentials or returning empty credentials for local filesystems, matching the documented GenerateTemporaryTableCredentialResponse return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures that the method implements the documented API endpoint and matches the signature/return type, but misses the key functionality of handling different storage locations (S3 vs local) and credential generation logic which is central to the relationship.",
      "error_type": "missing_key_functionality"
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.updateCatalog",
    "predicted_relationship": "The method CatalogCli.updateCatalog directly implements the updateCatalog operation described in the documentation. It takes the catalog name and UpdateCatalog object as parameters, matching the documented API. The method also returns a CatalogInfo object, which aligns with the documented return type.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented updateCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the basic relationship with the updateCatalog API operation, but misses the crucial aspect that this is a CLI wrapper layer rather than a direct implementation",
      "error_type": "omitted_abstraction_layer"
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.updateCatalog",
    "predicted_relationship": "While not explicitly mentioned, CatalogRepository.updateCatalog is likely responsible for the actual database operations to update the catalog. It would handle the logic described in the documentation, such as updating the catalog name, comment, and properties.",
    "ground_truth_relationship": "The code implements the documented API endpoint by validating the new catalog name, managing a database transaction to update the catalog's properties, name, and comment in a CatalogInfoDAO object, and handling error cases like NOT_FOUND and ALREADY_EXISTS as specified in the documentation's parameters and return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this code handles database operations for updating catalogs, but incorrectly suggests CatalogRepository.updateCatalog is a separate component rather than recognizing this is the implementation itself.",
      "error_type": "incorrect_component_assumption"
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogService.updateCatalog",
    "predicted_relationship": "CatalogService.updateCatalog is likely the service-layer implementation of the updateCatalog operation described in the documentation. It would handle the HTTP request, validate input, and coordinate with the repository layer.",
    "ground_truth_relationship": "The code implements a PATCH endpoint that matches the documented API specifications by accepting a catalog name and UpdateCatalog object as parameters, invoking the repository layer, and returning a JSON HTTP response containing the updated CatalogInfo.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship by correctly identifying this as a service-level implementation of the updateCatalog operation with repository interaction, which aligns with the ground truth's description of a PATCH endpoint that processes catalog updates via the repository layer.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogInfoDAO",
    "predicted_relationship": "CatalogInfoDAO is likely used to represent the catalog data in the database. The updateCatalog operation would involve updating a CatalogInfoDAO object with the new information provided in the UpdateCatalog request.",
    "ground_truth_relationship": "The CatalogInfoDAO class supports the updateCatalog endpoint by providing the data persistence layer and mapping functions (from/toCatalogInfo) that convert between the API's CatalogInfo model and the database entity representation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies CatalogInfoDAO as the database representation and its role in catalog updates, which aligns with the ground truth's explanation of it being the data persistence layer for the updateCatalog endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **deleteVolume**\n> oas_any_type_not_mapped deleteVolume(name)\n\nDelete a Volume\n\n    Deletes a volume from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeCli.deleteVolume",
    "predicted_relationship": "This method implements the deleteVolume functionality described in the documentation. It takes a 'volumeFullName' parameter, which corresponds to the 'name' parameter in the API documentation. The method calls the volumesApi.deleteVolume() method, which aligns with the documented API endpoint.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteVolume endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that this is a method implementing the deleteVolume functionality as specified in the API documentation, even though it doesn't explicitly mention it's a CLI wrapper",
      "error_type": "none"
    }
  },
  {
    "document_text": "# **deleteVolume**\n> oas_any_type_not_mapped deleteVolume(name)\n\nDelete a Volume\n\n    Deletes a volume from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeService.deleteVolume",
    "predicted_relationship": "This method directly implements the deleteVolume API endpoint described in the documentation. It takes a 'fullName' parameter, which corresponds to the 'name' parameter in the API documentation. The method returns an HttpResponse with OK status, which aligns with the documented behavior.",
    "ground_truth_relationship": "The code directly implements the documented DELETE endpoint by accepting a fully qualified volume name parameter, delegating the deletion to VOLUME_REPOSITORY, and returning an HTTP 200 OK response as specified in the OpenAPI documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship between the code and documentation - it implements a DELETE endpoint that takes a volume name parameter and returns an OK response, which matches the ground truth's description.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **deleteVolume**\n> oas_any_type_not_mapped deleteVolume(name)\n\nDelete a Volume\n\n    Deletes a volume from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.deleteVolume",
    "predicted_relationship": "This method implements the core logic for deleting a volume as described in the API documentation. It takes a 'name' parameter, which corresponds to the 'name' parameter in the API documentation. The method handles the actual deletion of the volume from the repository.",
    "ground_truth_relationship": "The code implements a documented Volume deletion operation by validating a three-part volume name, managing database transactions to remove the volume record, and cleaning up storage directories for managed volumes.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic purpose of volume deletion but misses crucial implementation details about validation, transaction management, and storage cleanup that are key to understanding the relationship between code and documentation",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "# TemporaryTableCredentialsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**generateTemporaryTableCredentials**](TemporaryTableCredentialsApi.md#generateTemporaryTableCredentials) | **POST** /temporary-table-credentials | Generate temporary table credentials. |",
    "artifact_title": "TemporaryTableCredentialsService.generateTemporaryTableCredentials",
    "predicted_relationship": "This method directly implements the 'generateTemporaryTableCredentials' API endpoint described in the documentation. The documentation specifies a POST request to '/temporary-table-credentials' for generating temporary table credentials, which is exactly what this method does.",
    "ground_truth_relationship": "The code implements the documented POST endpoint /temporary-table-credentials by validating the table location and returning AWS temporary credentials for S3 storage or empty credentials for local storage.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the correct API endpoint mapping but misses the key functionality of validating table location and conditionally returning AWS credentials vs empty credentials based on storage type",
      "error_type": "incomplete_functionality"
    }
  },
  {
    "document_text": "# TemporaryVolumeCredentialsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**generateTemporaryVolumeCredentials**](TemporaryVolumeCredentialsApi.md#generateTemporaryVolumeCredentials) | **POST** /temporary-volume-credentials | Generate temporary volume credentials. |",
    "artifact_title": "TemporaryVolumeCredentialsService.generateTemporaryVolumeCredentials",
    "predicted_relationship": "This method directly implements the API endpoint described in the documentation. The documentation explicitly mentions 'generateTemporaryVolumeCredentials' as a POST method for generating temporary volume credentials, which is exactly what this service method does.",
    "ground_truth_relationship": "The code implements the documented POST endpoint '/temporary-volume-credentials' by handling volume credential generation requests, validating the volume ID, and returning temporary AWS credentials for S3 volumes or empty credentials for local filesystems.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that this code implements the documented POST endpoint for generating temporary volume credentials. While it doesn't detail the specific validation and credential generation logic, it correctly identifies the main relationship between the code and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.createFunction",
    "predicted_relationship": "The documentation explicitly mentions a 'createFunction' API endpoint with a POST request to '/functions'. This directly corresponds to the 'FunctionCli.createFunction' method, which implements the client-side logic for creating a function.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements functionality for the documented createFunction API endpoint, just using slightly different wording than the ground truth's description of it as a CLI wrapper.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.deleteFunction",
    "predicted_relationship": "The documentation explicitly mentions a 'deleteFunction' API endpoint with a DELETE request to '/functions/{name}'. This directly corresponds to the 'FunctionCli.deleteFunction' method, which implements the client-side logic for deleting a function.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements client-side functionality for the documented deleteFunction API endpoint. Both descriptions capture the core relationship between the code and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.getFunction",
    "predicted_relationship": "The documentation explicitly mentions a 'getFunction' API endpoint with a GET request to '/functions/{name}'. This directly corresponds to the 'FunctionCli.getFunction' method, which implements the client-side logic for retrieving a function.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented getFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the relationship between the code and documentation - that the code implements client-side logic for the documented getFunction API endpoint",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.listFunctions",
    "predicted_relationship": "The documentation explicitly mentions a 'listFunctions' API endpoint with a GET request to '/functions'. This directly corresponds to the 'FunctionCli.listFunctions' method, which implements the client-side logic for listing functions.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listFunctions endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the listFunctions API endpoint functionality, aligning with the ground truth's statement about it being a CLI wrapper for the listFunctions endpoint",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.createFunction",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the 'FunctionService.createFunction' method is implicitly related as it likely implements the server-side logic for the 'createFunction' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the experimental POST /functions endpoint documented in the API table by defining a createFunction method that accepts a CreateFunctionRequest and returns an HTTP response containing the newly created function data from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this is about implementing the createFunction API endpoint, but incorrectly refers to 'FunctionService.createFunction' instead of recognizing it's a direct controller endpoint implementation using FUNCTION_REPOSITORY",
      "error_type": "implementation_details_mismatch"
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.deleteFunction",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the 'FunctionService.deleteFunction' method is implicitly related as it likely implements the server-side logic for the 'deleteFunction' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the documented DELETE /functions/{name} endpoint by providing a method that accepts a function name and optional force parameter, deleting the specified function through the repository and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented DELETE endpoint for functions, even though it uses more abstract terminology and doesn't mention specific details like parameters and response codes",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.getFunction",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the 'FunctionService.getFunction' method is implicitly related as it likely implements the server-side logic for the 'getFunction' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the documented GET /functions/{name} endpoint by creating a controller method that accepts a name parameter and returns a JSON response containing the function details from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - that the code implements the documented GET /functions/{name} endpoint functionality, even though it uses more cautious language ('likely implements') and focuses on the service layer rather than controller specifics.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.listFunctions",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the 'FunctionService.listFunctions' method is implicitly related as it likely implements the server-side logic for the 'listFunctions' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the documented GET /functions endpoint by defining a listFunctions method that accepts catalog name, schema name, pagination parameters, and returns an HTTP response containing the list of functions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that the code implements the documented listFunctions API endpoint, even though it's less specific about the parameters and return type.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.createSchema",
    "predicted_relationship": "The documentation explicitly mentions 'createSchema' under the HTTP POST method, which directly corresponds to the SchemaService.createSchema method. This method implements the API endpoint for creating a schema as described in the documentation.",
    "ground_truth_relationship": "The code implements the documented POST /schemas API endpoint by defining a createSchema method that accepts a CreateSchema object and returns a JSON HTTP response containing the newly created schema from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that this is a POST endpoint for creating schemas, matching the implementation shown in the code and described in the ground truth. Minor implementation details are omitted but the core relationship is correct.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.deleteSchema",
    "predicted_relationship": "The documentation explicitly mentions 'deleteSchema' under the HTTP DELETE method, which directly corresponds to the SchemaService.deleteSchema method. This method implements the API endpoint for deleting a schema as described in the documentation.",
    "ground_truth_relationship": "The code implements the documented DELETE /schemas/{full_name} endpoint by providing a method that accepts a schema's full name and an optional force parameter, deletes the specified schema from the repository, and returns an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a DELETE endpoint implementation for schemas that matches the documentation, capturing the core relationship between code and documentation.",
      "error_type": "none"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.getSchema",
    "predicted_relationship": "The documentation explicitly mentions 'getSchema' under the HTTP GET method, which directly corresponds to the SchemaService.getSchema method. This method implements the API endpoint for retrieving a schema as described in the documentation.",
    "ground_truth_relationship": "The code implements the GET /schemas/{full_name} endpoint documented in the API table by defining a method that retrieves a schema using the full_name path parameter and returns it as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures that this code implements the GET /schemas/{full_name} endpoint from the documentation, with the core functionality of retrieving a schema. While it's slightly less detailed than the ground truth, it conveys the same essential relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.listSchemas",
    "predicted_relationship": "The documentation explicitly mentions 'listSchemas' under the HTTP GET method, which directly corresponds to the SchemaService.listSchemas method. This method implements the API endpoint for listing schemas as described in the documentation.",
    "ground_truth_relationship": "The listSchemas method implements the '/schemas' GET endpoint documented in the API table by accepting catalog_name, max_results, and page_token parameters and returning schema listings as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the listSchemas method implements the documented GET /schemas endpoint, capturing the core relationship between code and documentation",
      "error_type": "none"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.updateSchema",
    "predicted_relationship": "The documentation explicitly mentions 'updateSchema' under the HTTP PATCH method, which directly corresponds to the SchemaService.updateSchema method. This method implements the API endpoint for updating a schema as described in the documentation.",
    "ground_truth_relationship": "The code implements the updateSchema API endpoint documented in the table by creating a PATCH handler at '/schemas/{full_name}' that accepts a schema name and update payload, passing them to the schema repository for processing.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions identify that this is a PATCH endpoint for updating schemas and correctly note the mapping between the documentation and code implementation. The predicted description captures the core relationship without any significant omissions or contradictions.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.createSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.createSchema method is likely used by the SchemaService.createSchema to perform the actual creation of the schema in the database.",
    "ground_truth_relationship": "The SchemaRepository.createSchema method implements the backend logic for the POST /schemas endpoint by validating the schema name, checking for duplicates, creating a new SchemaInfo object with a UUID, persisting it to the database within a transaction, and returning the created schema details.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this is related to schema creation, but introduces uncertainty ('likely used') and misses key aspects of the direct implementation relationship with the POST /schemas endpoint. It incorrectly suggests an additional service layer that isn't shown in the code.",
      "error_type": "architectural_misunderstanding"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.deleteSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.deleteSchema method is likely used by the SchemaService.deleteSchema to perform the actual deletion of the schema from the database.",
    "ground_truth_relationship": "The SchemaRepository.deleteSchema method implements the DELETE /schemas/{full_name} API endpoint by handling schema deletion logic, including processing child tables, volumes, and functions, and removing associated properties from the database session.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures that the method is involved in schema deletion but misses the key implementation details about processing child elements and introduces uncertainty by saying 'likely used' when the code clearly shows the direct implementation.",
      "error_type": "incomplete_understanding"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.getSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.getSchema method is likely used by the SchemaService.getSchema to retrieve the schema information from the database.",
    "ground_truth_relationship": "The SchemaRepository.getSchema method implements the GET /schemas/{full_name} API endpoint by retrieving schema information from a database, converting it from DAO format, and attaching properties while managing database transactions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction correctly identifies that the method retrieves schema information from a database, but misses the crucial fact that it directly implements a REST API endpoint rather than just being used by another service.",
      "error_type": "missing_key_role"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.listSchemas",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.listSchemas method is likely used by the SchemaService.listSchemas to retrieve the list of schemas from the database.",
    "ground_truth_relationship": "The code implements the GET /schemas endpoint by retrieving schemas from a database session, supporting pagination through maxResults and pageToken parameters, and returning a ListSchemasResponse containing schema information and a next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "While the predicted description correctly identifies that the code retrieves schemas from a database, it misses key aspects like pagination support and the fact that this implements a specific GET /schemas API endpoint. The mention of SchemaService is also speculative and not shown in the code.",
      "error_type": "significant_omissions"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.updateSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.updateSchema method is likely used by the SchemaService.updateSchema to perform the actual update of the schema in the database.",
    "ground_truth_relationship": "The SchemaRepository.updateSchema method implements the PATCH /schemas/{full_name} API endpoint by handling the validation, modification, and persistence of schema updates including name changes, comments, and properties within a database transaction.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that the method handles schema updates, but incorrectly suggests it's used by a SchemaService rather than directly implementing the PATCH API endpoint. It also misses the key validation and transaction management aspects.",
      "error_type": "missing_key_functionality"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.createCatalog",
    "predicted_relationship": "The document explicitly mentions 'createCatalog' as a POST method for creating a catalog. This method implements the API functionality described in the documentation.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this involves the createCatalog API endpoint, but misses that it's specifically a CLI wrapper implementation rather than the core API functionality itself",
      "error_type": "missing_key_context"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.deleteCatalog",
    "predicted_relationship": "The document explicitly mentions 'deleteCatalog' as a DELETE method for deleting a catalog. This method implements the API functionality described in the documentation.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the correct API method but misses the key fact that this is a CLI wrapper around the API, not the direct API implementation",
      "error_type": "missing_architectural_layer"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.getCatalog",
    "predicted_relationship": "The document explicitly mentions 'getCatalog' as a GET method for retrieving a catalog. This method implements the API functionality described in the documentation.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented getCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the getCatalog functionality but misses that this is specifically a CLI wrapper implementation rather than the direct API implementation",
      "error_type": "missing_key_context"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.listCatalogs",
    "predicted_relationship": "The document explicitly mentions 'listCatalogs' as a GET method for listing catalogs. This method implements the API functionality described in the documentation.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listCatalogs endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the listCatalogs GET method but misses that this is specifically a CLI wrapper implementation around that API endpoint",
      "error_type": "missing_key_context"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.updateCatalog",
    "predicted_relationship": "The document explicitly mentions 'updateCatalog' as a PATCH method for updating a catalog. This method implements the API functionality described in the documentation.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented updateCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the updateCatalog PATCH functionality but misses that this is specifically a CLI wrapper implementation of that endpoint rather than the endpoint itself",
      "error_type": "incomplete_context"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.createCatalog",
    "predicted_relationship": "While not explicitly mentioned in the document, this service method likely implements the createCatalog API functionality described in the documentation.",
    "ground_truth_relationship": "The code implements the documented POST /catalogs endpoint through a @Post-annotated method that accepts a CreateCatalog object and returns a JSON response from the catalog repository's add operation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship between the code and documentation - that the method implements the createCatalog API functionality described in the documentation. While it's more tentative and less detailed than the ground truth, it conveys the same essential mapping.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.deleteCatalog",
    "predicted_relationship": "While not explicitly mentioned in the document, this service method likely implements the deleteCatalog API functionality described in the documentation.",
    "ground_truth_relationship": "Rep handler method that accepts a catalog name parameter and an optional force parameter, and returns a 200 OK response after delegating the deletion to a repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the method as implementing the deleteCatalog API functionality, but misses key implementation details about the force parameter and 200 OK response that are central to the ground truth's description of the relationship.",
      "error_type": "incomplete_coverage"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.getCatalog",
    "predicted_relationship": "While not explicitly mentioned in the document, this service method likely implements the getCatalog API functionality described in the documentation.",
    "ground_truth_relationship": "The code implements the documented GET /catalogs/{name} endpoint by creating a method annotated with @Get that takes a name parameter and returns a catalog object as JSON via the repository layer.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the getCatalog API functionality documented in the API spec, even though it doesn't detail the specific parameters and return format.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.listCatalogs",
    "predicted_relationship": "While not explicitly mentioned in the document, this service method likely implements the listCatalogs API functionality described in the documentation.",
    "ground_truth_relationship": "The listCatalogs code implements the documented GET /catalogs endpoint by accepting optional pagination parameters (max_results and page_token) and returning a JSON response of catalogs from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the listCatalogs API functionality documented in the API reference, which is the key relationship. While it doesn't mention the pagination parameters or JSON response format, these are minor implementation details that don't affect the core relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.updateCatalog",
    "predicted_relationship": "While not explicitly mentioned in the document, this service method likely implements the updateCatalog API functionality described in the documentation.",
    "ground_truth_relationship": "The code implements the documented PATCH /catalogs/{name} endpoint by providing a method that accepts a catalog name parameter and update payload, returning the updated catalog as JSON via HttpResponse.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented updateCatalog API functionality, which is the core relationship. While it's more tentative and less detailed than the ground truth, it captures the essential relationship without any contradictions.",
      "error_type": "none"
    }
  },
  {
    "document_text": "<a name=\"deleteSchema\"></a>\n# **deleteSchema**\n> oas_any_type_not_mapped deleteSchema(full\\_name, force)\n\nDelete a schema\n\n    Deletes the specified schema from the parent catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaService.deleteSchema",
    "predicted_relationship": "The documentation directly describes the 'deleteSchema' operation, which is implemented by the SchemaService.deleteSchema method. The method signature matches the documented parameters 'full_name' and 'force'.",
    "ground_truth_relationship": "The code implements the documented DELETE endpoint by accepting a required fullName path parameter and optional force parameter, delegating schema deletion to SCHEMA_REPOSITORY, and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic operation but incorrectly refers to 'SchemaService.deleteSchema' when the code shows 'SCHEMA_REPOSITORY.deleteSchema'. Also misses mentioning the HTTP response aspect.",
      "error_type": "incorrect_component_reference"
    }
  },
  {
    "document_text": "<a name=\"deleteSchema\"></a>\n# **deleteSchema**\n> oas_any_type_not_mapped deleteSchema(full\\_name, force)\n\nDelete a schema\n\n    Deletes the specified schema from the parent catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.deleteSchema",
    "predicted_relationship": "While not explicitly mentioned, the SchemaRepository.deleteSchema method is likely used by SchemaService to perform the actual deletion of the schema from the database.",
    "ground_truth_relationship": "The code implements the documented schema deletion endpoint by recursively removing child tables, volumes, and functions before deleting the schema itself, while respecting the 'force' parameter and throwing a NOT_FOUND exception when the schema doesn't exist.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures that this is about schema deletion but incorrectly suggests it's implemented through a SchemaRepository class, while the actual code directly implements the deletion logic with recursive child element removal",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "<a name=\"listTables\"></a>\n# **listTables**\n> ListTablesResponse listTables(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList tables\n\n    Gets the list of all available tables under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for tables of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of tables. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of tables to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token to send for the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListTablesResponse**](../Models/ListTablesResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableService.listTables",
    "predicted_relationship": "The documentation directly describes the 'listTables' operation, which is implemented by the TableService.listTables method. The method signature matches the documented parameters: catalog_name, schema_name, max_results, and page_token. It also returns a ListTablesResponse object as specified in the documentation.",
    "ground_truth_relationship": "The code implements the documented API endpoint by accepting the same catalog_name, schema_name, max_results, and page_token parameters, while also including two additional optional parameters (omit_properties and omit_columns) that are not mentioned in the documentation, then delegates the actual table listing to TABLE_REPOSITORY and returns the result as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the core API functionality but misses the important detail about two additional parameters (omit_properties and omit_columns) that exist in the code but not in the documentation",
      "error_type": "missing_key_parameters"
    }
  },
  {
    "document_text": "<a name=\"listTables\"></a>\n# **listTables**\n> ListTablesResponse listTables(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList tables\n\n    Gets the list of all available tables under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for tables of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of tables. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of tables to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token to send for the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListTablesResponse**](../Models/ListTablesResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableRepository.listTables",
    "predicted_relationship": "While not explicitly mentioned, the TableService.listTables method likely delegates the actual table listing operation to TableRepository.listTables. This repository method handles the database interaction to retrieve the list of tables based on the provided parameters.",
    "ground_truth_relationship": "The code implements the documented listTables endpoint by querying a database session for table records matching the given catalog and schema names, handling pagination through maxResults and pageToken parameters, and returning a ListTablesResponse object containing the table list and next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that the method handles table listing through a repository layer, but incorrectly assumes/speculates about TableService and TableRepository classes that don't exist in the actual implementation. The core database interaction and listing functionality is present but described with incorrect specifics.",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.createCatalog",
    "predicted_relationship": "This method implements the createCatalog functionality described in the documentation. The documentation states 'POST /catalogs | Create a catalog', which directly corresponds to the createCatalog method in the CatalogCli class.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions accurately capture that the code implements the documented createCatalog API endpoint functionality, with the ground truth adding the CLI wrapper detail which doesn't contradict the prediction",
      "error_type": "none"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.deleteCatalog",
    "predicted_relationship": "This method implements the deleteCatalog functionality described in the documentation. The documentation states 'DELETE /catalogs/{name} | Delete a catalog', which directly corresponds to the deleteCatalog method in the CatalogCli class.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction correctly identifies that the code implements the deleteCatalog functionality from the documentation, but misses the crucial aspect that it's a CLI wrapper rather than the direct API implementation",
      "error_type": "missing_key_aspect"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.getCatalog",
    "predicted_relationship": "This method implements the getCatalog functionality described in the documentation. The documentation states 'GET /catalogs/{name} | Get a catalog', which directly corresponds to the getCatalog method in the CatalogCli class.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented getCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that the code implements functionality for the documented getCatalog endpoint, though it doesn't explicitly mention the CLI wrapper aspect.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.listCatalogs",
    "predicted_relationship": "This method implements the listCatalogs functionality described in the documentation. The documentation states 'GET /catalogs | List catalogs', which directly corresponds to the listCatalogs method in the CatalogCli class.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listCatalogs endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately identifies that the code implements the listCatalogs functionality from the documentation, matching the ground truth's statement that it's a CLI wrapper for the documented endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.updateCatalog",
    "predicted_relationship": "This method implements the updateCatalog functionality described in the documentation. The documentation states 'PATCH /catalogs/{name} | Update a catalog', which directly corresponds to the updateCatalog method in the CatalogCli class.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented updateCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this is related to the updateCatalog functionality, but misses the crucial aspect that this is a CLI wrapper layer on top of the API, not the direct API implementation itself",
      "error_type": "missing_key_context"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.createCatalog",
    "predicted_relationship": "This method implements the server-side logic for the createCatalog functionality described in the documentation. The documentation states 'POST /catalogs | Create a catalog', which directly corresponds to the createCatalog method in the CatalogService class.",
    "ground_truth_relationship": "The code implements the documented POST /catalogs endpoint through a @Post-annotated method that accepts a CreateCatalog object and returns a JSON response from the catalog repository's add operation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship between the code and documentation - that this is an implementation of the POST /catalogs endpoint for creating catalogs. Both descriptions identify this as a createCatalog POST endpoint that handles catalog creation.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.deleteCatalog",
    "predicted_relationship": "This method implements the server-side logic for the deleteCatalog functionality described in the documentation. The documentation states 'DELETE /catalogs/{name} | Delete a catalog', which directly corresponds to the deleteCatalog method in the CatalogService class.",
    "ground_truth_relationship": "Rep handler method that accepts a catalog name parameter and an optional force parameter, and returns a 200 OK response after delegating the deletion to a repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies this as the deleteCatalog functionality matching the documentation's DELETE endpoint, while the ground truth provides more implementation details. The core relationship is accurately captured.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.getCatalog",
    "predicted_relationship": "This method implements the server-side logic for the getCatalog functionality described in the documentation. The documentation states 'GET /catalogs/{name} | Get a catalog', which directly corresponds to the getCatalog method in the CatalogService class.",
    "ground_truth_relationship": "The code implements the documented GET /catalogs/{name} endpoint by creating a method annotated with @Get that takes a name parameter and returns a catalog object as JSON via the repository layer.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that this is an implementation of the documented GET /catalogs/{name} endpoint for retrieving a catalog. While it omits implementation details about JSON response and repository usage, it correctly identifies the main mapping between code and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.listCatalogs",
    "predicted_relationship": "This method implements the server-side logic for the listCatalogs functionality described in the documentation. The documentation states 'GET /catalogs | List catalogs', which directly corresponds to the listCatalogs method in the CatalogService class.",
    "ground_truth_relationship": "The listCatalogs code implements the documented GET /catalogs endpoint by accepting optional pagination parameters (max_results and page_token) and returning a JSON response of catalogs from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship between the code and documentation - that this is a GET endpoint implementation for listing catalogs. While it omits details about pagination parameters, this is a minor omission that doesn't affect the fundamental relationship being described.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.updateCatalog",
    "predicted_relationship": "This method implements the server-side logic for the updateCatalog functionality described in the documentation. The documentation states 'PATCH /catalogs/{name} | Update a catalog', which directly corresponds to the updateCatalog method in the CatalogService class.",
    "ground_truth_relationship": "The code implements the documented PATCH /catalogs/{name} endpoint by providing a method that accepts a catalog name parameter and update payload, returning the updated catalog as JSON via HttpResponse.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented PATCH /catalogs/{name} endpoint for updating catalogs, capturing the core relationship between the code and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"updateSchema\"></a>\n# **updateSchema**\n> SchemaInfo updateSchema(full\\_name, UpdateSchema)\n\nUpdate a schema\n\n    Updates the specified schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **UpdateSchema** | [**UpdateSchema**](../Models/UpdateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaService.updateSchema",
    "predicted_relationship": "The documentation directly describes the 'updateSchema' operation, which is implemented by the SchemaService.updateSchema method. The method signature matches the documented parameters: it takes a 'full_name' (String) and an 'UpdateSchema' object, and returns a SchemaInfo object.",
    "ground_truth_relationship": "The code implements a PATCH endpoint that directly matches the documented API endpoint, accepting a fullName path parameter and UpdateSchema body parameter, and returning a JSON response through HttpResponse.ofJson from the schema repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - it correctly identifies that this is an update schema operation that takes a full_name and UpdateSchema parameters and returns schema information. While it uses slightly different terminology (SchemaService vs repository), the fundamental API relationship is correctly described.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"updateSchema\"></a>\n# **updateSchema**\n> SchemaInfo updateSchema(full\\_name, UpdateSchema)\n\nUpdate a schema\n\n    Updates the specified schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **UpdateSchema** | [**UpdateSchema**](../Models/UpdateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.updateSchema",
    "predicted_relationship": "While not explicitly mentioned, the SchemaRepository.updateSchema method is likely used by SchemaService.updateSchema to perform the actual update operation on the schema data. This is inferred from the typical service-repository pattern in software architecture.",
    "ground_truth_relationship": "The code implements the documented schema update endpoint by validating the new schema name, managing database transactions to update the schema's name, comment, and properties, and handling errors according to the API specification's parameters and return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description imposes an assumed SchemaService-SchemaRepository pattern that is not evident in the code, though it correctly identifies this as being related to schema updates",
      "error_type": "unwarranted_assumption"
    }
  },
  {
    "document_text": "<a name=\"updateSchema\"></a>\n# **updateSchema**\n> SchemaInfo updateSchema(full\\_name, UpdateSchema)\n\nUpdate a schema\n\n    Updates the specified schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **UpdateSchema** | [**UpdateSchema**](../Models/UpdateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaInfoDAO",
    "predicted_relationship": "The SchemaInfoDAO is likely used in the process of updating the schema, as it represents the data access object for schema information. It's implicitly involved in the update process, though not directly mentioned in the documentation.",
    "ground_truth_relationship": "The SchemaInfoDAO class provides the data persistence layer and object mapping functionality needed to support the updateSchema API endpoint by managing schema metadata in the database and converting between SchemaInfo API objects and database entities.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted response correctly identifies that SchemaInfoDAO is used for schema updates through data access/persistence, which aligns with the ground truth's description of it providing data persistence and object mapping for the updateSchema endpoint",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "TableService.createTable",
    "predicted_relationship": "The documentation directly describes the 'createTable' operation, which is implemented by the TableService.createTable method. The method signature matches the documented API, taking a CreateTable object as input and returning a TableInfo object.",
    "ground_truth_relationship": "The code implements the documented POST endpoint by accepting a CreateTable request object, validating it's not null, delegating to the TABLE_REPOSITORY to create the table, and returning a TableInfo response wrapped in an HTTP JSON response, matching the documented input/output types and content types.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship between the code and documentation - it correctly identifies that this is a createTable operation matching the documented API signature with CreateTable input and TableInfo output types.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "TableRepository.createTable",
    "predicted_relationship": "While not explicitly mentioned in the documentation, TableRepository.createTable is likely used by TableService.createTable to perform the actual table creation operation in the database.",
    "ground_truth_relationship": "The code implements the documented createTable API by validating the table name, creating a new TableInfo object with the specified properties, checking for existing tables, rejecting MANAGED table types, requiring storage locations for external tables, and persisting the table data in a database transaction while handling errors as specified in the API documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction captures that this is a table creation operation but incorrectly suggests it's a helper method used by TableService rather than being the main API implementation itself. It misses the key validation and persistence logic described in the ground truth.",
      "error_type": "incorrect_architectural_assumption"
    }
  },
  {
    "document_text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "TableInfoDAO",
    "predicted_relationship": "The TableInfoDAO is likely used internally to convert between the TableInfo model and the database representation, though not explicitly mentioned in the documentation.",
    "ground_truth_relationship": "The TableInfoDAO class provides the persistence layer mapping and conversion logic for the TableInfo objects returned by the documented createTable API endpoint, handling the storage and retrieval of table metadata in the 'uc_tables' database table.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies TableInfoDAO's core purpose of converting between TableInfo model and database representation, which aligns with the ground truth's description of it providing persistence layer mapping and conversion for TableInfo objects. The prediction captures the essential relationship even though it doesn't mention specific details about the API endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "TableCli.createTable",
    "predicted_relationship": "While not mentioned in the server-side API documentation, TableCli.createTable likely provides a command-line interface that ultimately calls this API.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createTable endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions capture that this is a CLI wrapper/interface for an underlying createTable API endpoint. The predicted description correctly identifies that this is client-side code interfacing with a server API.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createCatalog\"></a>\n# **createCatalog**\n> CatalogInfo createCatalog(CreateCatalog)\n\nCreate a catalog\n\n    Creates a new catalog instance. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateCatalog** | [**CreateCatalog**](../Models/CreateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.addCatalog",
    "predicted_relationship": "The documentation describes creating a new catalog instance, which is likely implemented by the CatalogRepository.addCatalog method. This method takes a CreateCatalog object and returns a CatalogInfo object, matching the parameters and return type described in the documentation.",
    "ground_truth_relationship": "The addCatalog implementation validates SQL object names, creates a CatalogInfo instance with a UUID and properties, and persists it to the database in a transaction, fulfilling the documented createCatalog API endpoint's purpose of creating a new catalog instance.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements catalog creation functionality matching the documentation, with the right parameter and return types. While it omits implementation details like validation and persistence, these are minor details that don't affect the core relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createCatalog\"></a>\n# **createCatalog**\n> CatalogInfo createCatalog(CreateCatalog)\n\nCreate a catalog\n\n    Creates a new catalog instance. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateCatalog** | [**CreateCatalog**](../Models/CreateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogService.createCatalog",
    "predicted_relationship": "The documentation directly describes the createCatalog operation, which is explicitly implemented by this method. It takes a CreateCatalog object as a parameter and returns a CatalogInfo object, matching the documentation.",
    "ground_truth_relationship": "The code implements the documented API endpoint by accepting a CreateCatalog object via POST, persisting it through CATALOG_REPOSITORY, and returning a JSON response matching the documented CatalogInfo return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship between the code and documentation - that it implements a createCatalog endpoint taking CreateCatalog input and returning CatalogInfo, matching the documented API behavior.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createCatalog\"></a>\n# **createCatalog**\n> CatalogInfo createCatalog(CreateCatalog)\n\nCreate a catalog\n\n    Creates a new catalog instance. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateCatalog** | [**CreateCatalog**](../Models/CreateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogInfoDAO",
    "predicted_relationship": "The documentation mentions returning a CatalogInfo object, which is likely represented by the CatalogInfoDAO in the persistence layer. This DAO would be used to create and retrieve catalog information from the database.",
    "ground_truth_relationship": "The CatalogInfoDAO class provides the data persistence layer and mapping functionality for the CatalogInfo objects that are returned by the documented createCatalog API endpoint, with methods to convert between the DAO and API model representations.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the core relationship between CatalogInfoDAO and CatalogInfo as a persistence layer mapping, which aligns with the ground truth's explanation of the DAO providing data persistence and conversion functionality for the API model",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"deleteSchema\"></a>\n# **deleteSchema**\n> oas_any_type_not_mapped deleteSchema(full\\_name, force)\n\nDelete a schema\n\n    Deletes the specified schema from the parent catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaService.deleteSchema",
    "predicted_relationship": "This method directly implements the deleteSchema operation described in the documentation. It takes the same parameters 'full_name' and 'force' as mentioned in the API documentation.",
    "ground_truth_relationship": "The code implements the documented DELETE endpoint by accepting a required fullName path parameter and optional force parameter, delegating schema deletion to SCHEMA_REPOSITORY, and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic idea that this implements the documented deleteSchema operation and its parameters, but omits crucial implementation details about path parameter routing, repository delegation, and HTTP response handling that are central to the ground truth description",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"deleteSchema\"></a>\n# **deleteSchema**\n> oas_any_type_not_mapped deleteSchema(full\\_name, force)\n\nDelete a schema\n\n    Deletes the specified schema from the parent catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.deleteSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, this method is likely called by SchemaService.deleteSchema to perform the actual deletion of the schema from the repository.",
    "ground_truth_relationship": "The code implements the documented schema deletion endpoint by recursively removing child tables, volumes, and functions before deleting the schema itself, while respecting the 'force' parameter and throwing a NOT_FOUND exception when the schema doesn't exist.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted text correctly identifies this as a schema deletion method, but describes it as being called by SchemaService which is speculative and not mentioned in the code/docs. It also misses key aspects like handling child elements and the force parameter.",
      "error_type": "speculation_and_major_omissions"
    }
  },
  {
    "document_text": "# **getVolume**\n> VolumeInfo getVolume(name)\n\nGet a Volume\n\n    Gets a volume for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeService.getVolume",
    "predicted_relationship": "The documentation directly describes a 'getVolume' operation that takes a 'name' parameter and returns a 'VolumeInfo' object. This closely matches the signature and functionality of the VolumeService.getVolume method.",
    "ground_truth_relationship": "The code implements the documented GET endpoint by accepting a required 'full_name' path parameter and an optional 'include_browse' query parameter, returning a JSON response containing volume information from the repository, though the documentation doesn't mention the optional parameter.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the core functionality of getVolume but fails to mention the optional include_browse parameter which is a significant part of the endpoint's interface mentioned in the ground truth",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "# **getVolume**\n> VolumeInfo getVolume(name)\n\nGet a Volume\n\n    Gets a volume for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.getVolume",
    "predicted_relationship": "While not explicitly mentioned, the VolumeRepository.getVolume method is likely used by VolumeService.getVolume to retrieve the volume information from the data store.",
    "ground_truth_relationship": "The code implements the documented getVolume operation by splitting a three-level name parameter into catalog, schema, and volume components, validating the format, and returning a VolumeInfo object retrieved from the database through a DAO pattern.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies that the method retrieves volume information from a data store, but misses the core functionality of parsing the three-level name parameter and validation logic. It also incorrectly assumes a VolumeRepository/VolumeService architecture that isn't evident in the code.",
      "error_type": "incomplete_understanding_and_assumption"
    }
  },
  {
    "document_text": "# **getVolume**\n> VolumeInfo getVolume(name)\n\nGet a Volume\n\n    Gets a volume for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeInfoDAO",
    "predicted_relationship": "The VolumeInfoDAO class is likely used to represent the volume data in the repository layer, which is then converted to the VolumeInfo object mentioned in the documentation.",
    "ground_truth_relationship": "The VolumeInfoDAO class provides the data persistence layer and model conversion methods (toVolumeInfo/from) needed to support the documented getVolume API endpoint by mapping between the database representation and the VolumeInfo response type.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies VolumeInfoDAO as a database/repository layer representation, but misses the crucial aspect of its role in supporting the getVolume API endpoint and the conversion methods that map between database and API models",
      "error_type": "incomplete_functionality"
    }
  },
  {
    "document_text": "<a name=\"generateTemporaryTableCredentials\"></a>\n# **generateTemporaryTableCredentials**\n> GenerateTemporaryTableCredentialResponse generateTemporaryTableCredentials(GenerateTemporaryTableCredential)\n\nGenerate temporary table credentials.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **GenerateTemporaryTableCredential** | [**GenerateTemporaryTableCredential**](../Models/GenerateTemporaryTableCredential.md)|  | [optional] |\n\n### Return type\n\n[**GenerateTemporaryTableCredentialResponse**](../Models/GenerateTemporaryTableCredentialResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json\n",
    "artifact_title": "TemporaryTableCredentialsService.generateTemporaryTableCredentials",
    "predicted_relationship": "This artifact directly implements the generateTemporaryTableCredentials functionality described in the documentation. The method signature matches the documented API call, taking a GenerateTemporaryTableCredential parameter and returning a GenerateTemporaryTableCredentialResponse.",
    "ground_truth_relationship": "The code implements the documented API endpoint by checking if a table exists at a storage location, then either generating AWS S3 temporary credentials or returning empty credentials for local filesystems, matching the documented GenerateTemporaryTableCredentialResponse return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic API implementation but misses the crucial aspect of different credential generation logic based on storage location type (S3 vs local filesystem)",
      "error_type": "incomplete_core_functionality"
    }
  },
  {
    "document_text": "# **deleteVolume**\n> oas_any_type_not_mapped deleteVolume(name)\n\nDelete a Volume\n\n    Deletes a volume from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeService.deleteVolume",
    "predicted_relationship": "The documentation explicitly describes a 'deleteVolume' operation that takes a 'name' parameter, which directly corresponds to the 'VolumeService.deleteVolume' method. The method signature matches the described operation, taking a 'fullName' parameter which is described in the documentation as 'The three-level (fully qualified) name of the volume'.",
    "ground_truth_relationship": "The code directly implements the documented DELETE endpoint by accepting a fully qualified volume name parameter, delegating the deletion to VOLUME_REPOSITORY, and returning an HTTP 200 OK response as specified in the OpenAPI documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship between the code and documentation - both describe a deleteVolume operation that takes a volume name parameter and performs deletion. While the predicted omits mentioning the HTTP 200 response, this is a minor detail that doesn't affect the main relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **deleteVolume**\n> oas_any_type_not_mapped deleteVolume(name)\n\nDelete a Volume\n\n    Deletes a volume from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.deleteVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeService.deleteVolume method likely calls VolumeRepository.deleteVolume to perform the actual deletion of the volume from the data store. This is inferred from the typical service-repository pattern in software architecture.",
    "ground_truth_relationship": "The code implements a documented Volume deletion operation by validating a three-part volume name, managing database transactions to remove the volume record, and cleaning up storage directories for managed volumes.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures that this is a volume deletion operation but incorrectly assumes a service-repository pattern that isn't evident in the code. The code shows direct database operations and file system management rather than the described repository pattern.",
      "error_type": "incorrect_architectural_assumption"
    }
  },
  {
    "document_text": "# **deleteVolume**\n> oas_any_type_not_mapped deleteVolume(name)\n\nDelete a Volume\n\n    Deletes a volume from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeCli.deleteVolume",
    "predicted_relationship": "While not explicitly mentioned in the API documentation, the VolumeCli.deleteVolume method is likely the command-line interface implementation that would call the API described in this documentation. It's part of the client-side implementation that interacts with the server-side API.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteVolume endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a CLI implementation that interfaces with the documented API endpoint, which matches the ground truth's characterization of it being a CLI wrapper for the deleteVolume endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "# TemporaryTableCredentialsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**generateTemporaryTableCredentials**](TemporaryTableCredentialsApi.md#generateTemporaryTableCredentials) | **POST** /temporary-table-credentials | Generate temporary table credentials. |",
    "artifact_title": "TemporaryTableCredentialsService.generateTemporaryTableCredentials",
    "predicted_relationship": "This method directly implements the generateTemporaryTableCredentials functionality described in the API documentation. The documentation states 'Generate temporary table credentials.' which is exactly what this method does.",
    "ground_truth_relationship": "The code implements the documented POST endpoint /temporary-table-credentials by validating the table location and returning AWS temporary credentials for S3 storage or empty credentials for local storage.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the core purpose of generating credentials but omits the important distinction between S3 vs local storage and the validation steps",
      "error_type": "missing_key_details"
    }
  },
  {
    "document_text": "<a name=\"getFunction\"></a>\n# **getFunction**\n> FunctionInfo getFunction(name)\n\nGet a function\n\n    Gets a function from within a parent catalog and schema.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.getFunction",
    "predicted_relationship": "The documentation directly describes a 'getFunction' operation that takes a 'name' parameter and returns a 'FunctionInfo' object. This matches the signature and return type of the FunctionRepository.getFunction method.",
    "ground_truth_relationship": "The code implements the documented function retrieval by parsing a fully-qualified three-part function name (catalog.schema.function), querying a database session for the function details, and returning a FunctionInfo object as specified in the documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the basic signature and return type correctly but misses the crucial database interaction and three-part name parsing functionality that is core to how the function works",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"getFunction\"></a>\n# **getFunction**\n> FunctionInfo getFunction(name)\n\nGet a function\n\n    Gets a function from within a parent catalog and schema.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionService.getFunction",
    "predicted_relationship": "While not explicitly mentioned, the FunctionService.getFunction method would likely be the service layer implementation of the documented API endpoint, acting as an intermediary between the API and the repository.",
    "ground_truth_relationship": "The code implements a REST GET endpoint that accepts a fully-qualified function name as a path parameter and returns a JSON response containing the function details, directly mapping to the documented API endpoint specification and its expected FunctionInfo return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this is about function retrieval functionality, but incorrectly assumes the presence of a FunctionService layer that isn't evident in the code. The code shows direct repository-to-HTTP mapping without a service layer.",
      "error_type": "architectural_assumption"
    }
  },
  {
    "document_text": "<a name=\"getFunction\"></a>\n# **getFunction**\n> FunctionInfo getFunction(name)\n\nGet a function\n\n    Gets a function from within a parent catalog and schema.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionInfoDAO",
    "predicted_relationship": "The documentation mentions returning a FunctionInfo object. FunctionInfoDAO would likely be used internally to represent the function data before converting to the FunctionInfo return type.",
    "ground_truth_relationship": "The FunctionInfoDAO class provides the data persistence layer that enables the documented getFunction endpoint by mapping database records to FunctionInfo objects through JPA annotations and conversion methods toFunctionInfo() and from().",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies FunctionInfoDAO's role in FunctionInfo conversion but misses its core purpose as a persistence/database mapping layer with JPA annotations",
      "error_type": "incomplete_understanding"
    }
  },
  {
    "document_text": "<a name=\"deleteCatalog\"></a>\n# **deleteCatalog**\n> oas_any_type_not_mapped deleteCatalog(name, force)\n\nDelete a catalog\n\n    Deletes the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.deleteCatalog",
    "predicted_relationship": "This method directly implements the deleteCatalog operation described in the documentation. It takes the same parameters (name and force) and performs the deletion of a catalog.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the core deletion functionality but misses that this is a CLI wrapper around the API endpoint rather than the direct implementation",
      "error_type": "missing_wrapper_context"
    }
  },
  {
    "document_text": "<a name=\"deleteCatalog\"></a>\n# **deleteCatalog**\n> oas_any_type_not_mapped deleteCatalog(name, force)\n\nDelete a catalog\n\n    Deletes the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.deleteCatalog",
    "predicted_relationship": "While not explicitly mentioned, this method is likely used by CatalogCli.deleteCatalog to perform the actual deletion of the catalog in the repository.",
    "ground_truth_relationship": "The code implements the documented deleteCatalog operation by handling catalog deletion with optional force removal of schemas, throwing appropriate exceptions if the catalog is not found (ErrorCode.NOT_FOUND) or contains schemas without force flag (ErrorCode.FAILED_PRECONDITION), and managing the transaction across catalog, schema, and property deletions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction mentions CatalogCli usage which isn't evident in the code/docs, but correctly identifies the basic catalog deletion functionality. However, it misses crucial aspects like force deletion handling, schema checks, and exception behaviors that are central to the implementation.",
      "error_type": "incomplete_understanding"
    }
  },
  {
    "document_text": "<a name=\"deleteCatalog\"></a>\n# **deleteCatalog**\n> oas_any_type_not_mapped deleteCatalog(name, force)\n\nDelete a catalog\n\n    Deletes the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogService.deleteCatalog",
    "predicted_relationship": "This service method likely implements the HTTP endpoint for deleting a catalog, matching the documentation's description of the operation.",
    "ground_truth_relationship": "The code implements a DELETE endpoint that directly mirrors the documented API behavior by accepting a required 'name' parameter and optional 'force' parameter, invoking the catalog repository's deletion logic, and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core functionality of implementing a catalog deletion endpoint, which aligns with the ground truth's description of the DELETE operation. While less detailed, it conveys the same basic relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeService.createVolume",
    "predicted_relationship": "The documentation describes a 'createVolume' operation that takes a CreateVolumeRequestContent parameter and returns a VolumeInfo object. This directly corresponds to the VolumeService.createVolume method, which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented API endpoint by accepting a CreateVolumeRequestContent parameter and returning a JSON HTTP response containing the created volume information, matching the documented input/output specifications and HTTP headers.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic input/output relationship but refers to 'VolumeService.createVolume' rather than 'VOLUME_REPOSITORY.createVolume' and misses the HTTP response aspect",
      "error_type": "incorrect_implementation_detail"
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.createVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeService.createVolume method likely uses the VolumeRepository.createVolume method to persist the volume data.",
    "ground_truth_relationship": "The code implements the documented createVolume operation by validating inputs, creating a VolumeInfo object with a UUID, validating volume type and storage location, and persisting it to the database within a transaction while enforcing schema existence and volume uniqueness constraints.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description mentions persistence but misses key aspects like validation, type checking, schema validation, and transaction handling. The suggestion of using VolumeRepository is incorrect as the code directly uses Session/DAO.",
      "error_type": "oversimplified_and_incorrect_implementation"
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeInfoDAO",
    "predicted_relationship": "The VolumeInfoDAO is likely used internally to map between the VolumeInfo object (mentioned in the return type) and the database representation of a volume.",
    "ground_truth_relationship": "The VolumeInfoDAO class provides the data persistence layer and mapping functionality for the createVolume API endpoint by defining the database schema and conversion methods between the API's VolumeInfo model and the database representation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the core mapping functionality between VolumeInfo and database representation, but omits the crucial aspect that this is specifically the persistence layer for the createVolume API endpoint",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"listSchemas\"></a>\n# **listSchemas**\n> ListSchemasResponse listSchemas(catalog\\_name, max\\_results, page\\_token)\n\nList schemas\n\n    Gets an array of schemas for a catalog. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Parent catalog for schemas of interest. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of schemas to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n\n### Return type\n\n[**ListSchemasResponse**](../Models/ListSchemasResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaService.listSchemas",
    "predicted_relationship": "The SchemaService.listSchemas method directly implements the listSchemas operation described in the documentation. It takes the same parameters (catalog_name, max_results, page_token) and returns a ListSchemasResponse object as specified in the API documentation.",
    "ground_truth_relationship": "The code implements a GET endpoint that takes a catalog name and optional pagination parameters (max_results and page_token) to retrieve a list of schemas from SCHEMA_REPOSITORY, exactly matching the documented API endpoint's parameters and functionality.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that this is a GET endpoint for listing schemas, taking catalog_name and optional pagination parameters, matching the documented API functionality.",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"listSchemas\"></a>\n# **listSchemas**\n> ListSchemasResponse listSchemas(catalog\\_name, max\\_results, page\\_token)\n\nList schemas\n\n    Gets an array of schemas for a catalog. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Parent catalog for schemas of interest. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of schemas to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n\n### Return type\n\n[**ListSchemasResponse**](../Models/ListSchemasResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.listSchemas",
    "predicted_relationship": "The SchemaService.listSchemas method likely calls SchemaRepository.listSchemas to retrieve the actual schema data. This is inferred from the typical service-repository pattern, where the service delegates data retrieval to the repository.",
    "ground_truth_relationship": "The code implements the documented listSchemas API endpoint by querying a database session for schemas matching the given catalog ID, converting the results from DAOs to SchemaInfo objects, handling pagination through maxResults and pageToken parameters, and returning a ListSchemasResponse containing the schema list and next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic idea of delegation but incorrectly assumes a SchemaRepository layer that doesn't exist. The code actually works directly with database sessions and DAOs rather than through a repository pattern.",
      "error_type": "architectural_assumption"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.createTable",
    "predicted_relationship": "The documentation explicitly mentions a 'createTable' API endpoint with a POST request to '/tables'. This directly corresponds to the TableService.createTable method, which is annotated with @Post(\"\") and implements the creation of a table.",
    "ground_truth_relationship": "The createTable code method implements the POST /tables API endpoint documented in TablesApi by accepting a CreateTable request object, delegating to TABLE_REPOSITORY for table creation, and returning the response as JSON.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented POST /tables API endpoint via the @Post annotation and table creation functionality",
      "error_type": ""
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.deleteTable",
    "predicted_relationship": "The documentation explicitly mentions a 'deleteTable' API endpoint with a DELETE request to '/tables/{full_name}'. This directly corresponds to the TableService.deleteTable method, which is annotated with @Delete(\"/{full_name}\") and implements the deletion of a table.",
    "ground_truth_relationship": "The code implements the documented DELETE /tables/{full_name} endpoint by creating a method annotated with @Delete that takes a full_name parameter, deletes the corresponding table through the repository, and returns an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that the code implements a DELETE endpoint for table deletion matching the documented API, with the same path parameter structure.",
      "error_type": ""
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.getTable",
    "predicted_relationship": "The documentation explicitly mentions a 'getTable' API endpoint with a GET request to '/tables/{full_name}'. This directly corresponds to the TableService.getTable method, which is annotated with @Get(\"/{full_name}\") and implements the retrieval of a table.",
    "ground_truth_relationship": "The code implements the documented GET /tables/{full_name} endpoint by creating a method that retrieves a TableInfo object based on the full_name path parameter and returns it as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures that this is a GET endpoint for retrieving table info by full_name path parameter, matching the ground truth's explanation of the implementation.",
      "error_type": ""
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.listTables",
    "predicted_relationship": "The documentation explicitly mentions a 'listTables' API endpoint with a GET request to '/tables'. This directly corresponds to the TableService.listTables method, which is annotated with @Get(\"\") and implements the listing of tables.",
    "ground_truth_relationship": "The document is an API endpoint summary table that lists the methods available and their description under the TablesApi. Each code is related to one of the methods.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the listTables GET endpoint, but misses that this is part of a larger API documentation showing multiple endpoints including create, delete, and get operations.",
      "error_type": "incomplete_scope"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableRepository.createTable",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableService.createTable method likely uses TableRepository.createTable to perform the actual table creation in the database.",
    "ground_truth_relationship": "The TableRepository.createTable method implements the backend logic for the experimental POST /tables API endpoint, handling table creation with validations for SQL object names, schema existence, and storage location requirements while preventing creation of managed tables.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description gets the basic idea that this is about table creation, but incorrectly suggests it's done through TableRepository when it's actually implemented directly in the TableService class. It also misses key aspects like validations and restrictions mentioned in the ground truth.",
      "error_type": "missing_key_aspects_and_incorrect_implementation_detail"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableRepository.deleteTable",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableService.deleteTable method likely uses TableRepository.deleteTable to perform the actual table deletion in the database.",
    "ground_truth_relationship": "The deleteTable method implements the DELETE /tables/{full_name} API endpoint's backend logic by removing the table's metadata from the session, cleaning up associated properties, and deleting the physical directory for managed tables.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures that this is about table deletion but incorrectly suggests it uses TableRepository.deleteTable when the code shows direct session operations and file system cleanup",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableRepository.getTable",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableService.getTable method likely uses TableRepository.getTable to retrieve the actual table information from the database.",
    "ground_truth_relationship": "The TableRepository.getTable method implements the backend database logic for the GET /tables/{full_name} API endpoint, retrieving a table's details from the database by parsing the full_name parameter into catalog, schema and table components and returning a TableInfo object with attached properties.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic idea that the method retrieves table information, but introduces uncertainty by saying 'likely uses TableRepository.getTable' when the code directly shows the implementation. It also misses the key aspects of parsing the full name and attaching properties.",
      "error_type": "incomplete_understanding"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableRepository.listTables",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableService.listTables method likely uses TableRepository.listTables to retrieve the list of tables from the database.",
    "ground_truth_relationship": "The TableRepository.listTables code implements the GET /tables REST API endpoint by querying tables from a database session, applying pagination through maxResults and pageToken parameters, and returning a ListTablesResponse containing table information with optional properties and columns.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction correctly indicates that the code retrieves tables from a database, but introduces uncertainty ('likely uses') and references an incorrect class name (TableRepository.listTables instead of SESSION_FACTORY). It also misses key aspects like pagination and optional properties/columns handling.",
      "error_type": "incorrect_class_reference_and_missing_key_features"
    }
  },
  {
    "document_text": "<a name=\"deleteTable\"></a>\n# **deleteTable**\n> oas_any_type_not_mapped deleteTable(full\\_name)\n\nDelete a table\n\n    Deletes a table from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableCli.deleteTable",
    "predicted_relationship": "The TableCli.deleteTable method implements the deleteTable operation described in the documentation. While not explicitly mentioned, it matches the functionality of deleting a table using a full name parameter.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteTable endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that the code implements the documented table deletion functionality, even if it doesn't explicitly use the term 'CLI wrapper'",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"deleteTable\"></a>\n# **deleteTable**\n> oas_any_type_not_mapped deleteTable(full\\_name)\n\nDelete a table\n\n    Deletes a table from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableService.deleteTable",
    "predicted_relationship": "The TableService.deleteTable method directly implements the deleteTable operation described in the documentation. It matches the signature with a 'full_name' parameter and is annotated with @Delete, corresponding to the HTTP DELETE method mentioned in the doc.",
    "ground_truth_relationship": "The code implements a REST DELETE endpoint that matches the documented API specification by accepting a full_name parameter, invoking TABLE_REPOSITORY.deleteTable(), and returning a 200 OK response with no content body.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core relationship that the code implements a DELETE endpoint matching the API documentation, with matching parameter and functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteTable\"></a>\n# **deleteTable**\n> oas_any_type_not_mapped deleteTable(full\\_name)\n\nDelete a table\n\n    Deletes a table from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableRepository.deleteTable",
    "predicted_relationship": "The TableRepository.deleteTable method likely implements the core logic for deleting a table from the database. While not explicitly mentioned, it's a crucial part of the delete table operation.",
    "ground_truth_relationship": "The code implements the documented table deletion operation by removing the table's database entry, deleting its physical files (for managed tables), and cleaning up associated properties, while the documentation describes the API endpoint that exposes this functionality with a 'full_name' parameter.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies this as a table deletion operation but misses significant aspects like file deletion for managed tables and property cleanup, while implying it's mainly about database operations",
      "error_type": "incomplete_understanding"
    }
  },
  {
    "document_text": "<a name=\"listCatalogs\"></a>\n# **listCatalogs**\n> ListCatalogsResponse listCatalogs(page\\_token, max\\_results)\n\nList catalogs\n\n    Lists the available catalogs. There is no guarantee of a specific ordering of the elements in the list. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n| **max\\_results** | **Integer**| Maximum number of catalogs to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n\n### Return type\n\n[**ListCatalogsResponse**](../Models/ListCatalogsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.listCatalogs",
    "predicted_relationship": "The CatalogCli.listCatalogs method likely implements the listCatalogs functionality described in the documentation. The method signature in the code matches the parameters mentioned in the documentation (max_results and page_token).",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listCatalogs endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented listCatalogs functionality, even though it doesn't explicitly mention it's a CLI wrapper. The core relationship is accurately captured.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listCatalogs\"></a>\n# **listCatalogs**\n> ListCatalogsResponse listCatalogs(page\\_token, max\\_results)\n\nList catalogs\n\n    Lists the available catalogs. There is no guarantee of a specific ordering of the elements in the list. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n| **max\\_results** | **Integer**| Maximum number of catalogs to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n\n### Return type\n\n[**ListCatalogsResponse**](../Models/ListCatalogsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.listCatalogs",
    "predicted_relationship": "The CatalogRepository.listCatalogs method likely implements the core logic for listing catalogs as described in the documentation. It handles the maxResults and pageToken parameters mentioned in the API documentation.",
    "ground_truth_relationship": "The code implements the documented listCatalogs endpoint by using database transactions and pagination logic to retrieve catalog records from storage, transform them into CatalogInfo objects with attached properties, and return them in a ListCatalogsResponse with the next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic listing functionality and pagination parameters, but misses key aspects like the transaction handling, property attachment, and data transformation steps described in the ground truth",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"listCatalogs\"></a>\n# **listCatalogs**\n> ListCatalogsResponse listCatalogs(page\\_token, max\\_results)\n\nList catalogs\n\n    Lists the available catalogs. There is no guarantee of a specific ordering of the elements in the list. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n| **max\\_results** | **Integer**| Maximum number of catalogs to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n\n### Return type\n\n[**ListCatalogsResponse**](../Models/ListCatalogsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogService.listCatalogs",
    "predicted_relationship": "The CatalogService.listCatalogs method directly implements the listCatalogs API endpoint described in the documentation. It takes the maxResults and pageToken parameters as mentioned in the API spec.",
    "ground_truth_relationship": "The code implements the documented REST endpoint by accepting optional maxResults and pageToken parameters, making a repository call, and returning a JSON response containing the list of catalogs in the format specified by ListCatalogsResponse.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - that the code implements the documented listCatalogs API endpoint with the specified parameters. While it omits some implementation details about JSON response and repository calls, the high-level relationship understanding is accurate.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.getCatalog",
    "predicted_relationship": "The documentation describes a 'getCatalog' operation that takes a 'name' parameter and returns a CatalogInfo object. This directly corresponds to the CatalogCli.getCatalog method, which implements this functionality. The method signature in the code matches the documented API, taking a 'name' parameter and returning a JSON string representation of the catalog info.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented getCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - that the code implements the documented getCatalog API functionality by taking a name parameter and returning catalog info, just in a CLI wrapper context.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogService.getCatalog",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the CatalogService.getCatalog method is likely the server-side implementation of the getCatalog operation. It takes a 'name' parameter and returns an HttpResponse, which likely contains the CatalogInfo object mentioned in the documentation.",
    "ground_truth_relationship": "The code implements the documented REST GET endpoint by accepting a name parameter and returning a JSON response containing catalog information, exactly matching the API specification's path parameter and response format requirements.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the key relationship - that the code implements a GET endpoint taking a name parameter and returning catalog info via HTTP response. While more tentative in tone, it does not contradict the ground truth's core meaning.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.getCatalog",
    "predicted_relationship": "The CatalogRepository.getCatalog method is likely used to retrieve the catalog information from the database. While not explicitly mentioned in the documentation, it's an essential part of the implementation chain for the getCatalog operation.",
    "ground_truth_relationship": "The code directly implements the documented getCatalog operation by querying the database for a CatalogInfoDAO entity matching the specified name parameter using Hibernate's query language and returning a single result.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a method for retrieving catalog information from the database, which aligns with the ground truth's description of querying for a CatalogInfoDAO entity. While the predicted version is less detailed, it captures the core functionality accurately.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogInfoDAO",
    "predicted_relationship": "The CatalogInfoDAO class is likely used to represent the catalog information in the database. While not explicitly mentioned in the documentation, it's crucial for storing and retrieving the CatalogInfo object that the API returns.",
    "ground_truth_relationship": "The CatalogInfoDAO class provides the data persistence layer and mapping functionality for the CatalogInfo objects that are returned by the documented getCatalog endpoint through its toCatalogInfo() conversion method.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship that CatalogInfoDAO handles database representation of catalog information, which aligns with the ground truth's explanation of it being the data persistence layer for CatalogInfo objects. While the ground truth provides more detail about the toCatalogInfo() method, this omission doesn't change the fundamental understanding.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteFunction\"></a>\n# **deleteFunction**\n> oas_any_type_not_mapped deleteFunction(name)\n\nDelete a function\n\n    Deletes the function that matches the supplied name.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionCli.deleteFunction",
    "predicted_relationship": "The documentation describes a 'deleteFunction' operation that deletes a function matching a supplied name. This directly corresponds to the 'FunctionCli.deleteFunction' method, which implements this functionality in the CLI.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - both texts describe that this is an implementation of a function deletion operation through a CLI interface to the documented API endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteFunction\"></a>\n# **deleteFunction**\n> oas_any_type_not_mapped deleteFunction(name)\n\nDelete a function\n\n    Deletes the function that matches the supplied name.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.deleteFunction",
    "predicted_relationship": "While not explicitly mentioned, the FunctionRepository.deleteFunction method is likely called by the CLI to perform the actual deletion of the function in the database.",
    "ground_truth_relationship": "The code implements the documented deleteFunction API endpoint by validating and parsing a fully-qualified function name (catalog.schema.function), managing a database transaction to delete the corresponding FunctionInfoDAO record, and throwing appropriate exceptions for invalid names or missing functions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction identifies this as a function deletion operation but incorrectly assumes it's called by CLI and specifically mentions database operations, while the ground truth shows it's an API endpoint implementation for function deletion with name validation and transaction management",
      "error_type": "incorrect_context_assumption"
    }
  },
  {
    "document_text": "<a name=\"deleteFunction\"></a>\n# **deleteFunction**\n> oas_any_type_not_mapped deleteFunction(name)\n\nDelete a function\n\n    Deletes the function that matches the supplied name.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionService.deleteFunction",
    "predicted_relationship": "The FunctionService.deleteFunction method likely implements the server-side REST API endpoint for deleting a function, which corresponds to the documented deleteFunction operation.",
    "ground_truth_relationship": "The code implements the documented DELETE endpoint by accepting a name parameter and an optional force parameter (not mentioned in docs), calling FUNCTION_REPOSITORY.deleteFunction(), and returning an HTTP 200 OK response as specified in the OpenAPI documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented deleteFunction REST API endpoint. While it doesn't mention specific details like the force parameter or HTTP 200 response, it captures the core relationship between the code and documentation.",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"createSchema\"></a>\n# **createSchema**\n> SchemaInfo createSchema(CreateSchema)\n\nCreate a schema\n\n    Creates a new schema in the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateSchema** | [**CreateSchema**](../Models/CreateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaService.createSchema",
    "predicted_relationship": "The documentation describes a 'createSchema' operation that creates a new schema in a specified catalog. This directly corresponds to the 'SchemaService.createSchema' method, which implements this functionality on the server side.",
    "ground_truth_relationship": "The code implements the documented REST endpoint by accepting a CreateSchema object via POST request and returning a JSON HTTP response containing the schema created through the SCHEMA_REPOSITORY.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship that this is a schema creation endpoint, even though it uses slightly different terminology (SchemaService vs SCHEMA_REPOSITORY). Both descriptions convey that it's an API endpoint for creating schemas.",
      "error_type": "none"
    }
  },
  {
    "document_text": "<a name=\"createSchema\"></a>\n# **createSchema**\n> SchemaInfo createSchema(CreateSchema)\n\nCreate a schema\n\n    Creates a new schema in the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateSchema** | [**CreateSchema**](../Models/CreateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.createSchema",
    "predicted_relationship": "While not explicitly mentioned, the 'SchemaRepository.createSchema' method is likely called by the SchemaService to perform the actual creation of the schema in the database.",
    "ground_truth_relationship": "The code fully implements the documented API endpoint by validating the schema name, checking for existing schemas, persisting the new schema with its properties in a database transaction, and returning a SchemaInfo object as specified in the documentation's return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies schema creation but incorrectly suggests it's delegated to another class (SchemaRepository) when the code shows direct implementation. However, it does capture the core concept of schema creation.",
      "error_type": "architectural_misunderstanding"
    }
  },
  {
    "document_text": "<a name=\"createSchema\"></a>\n# **createSchema**\n> SchemaInfo createSchema(CreateSchema)\n\nCreate a schema\n\n    Creates a new schema in the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateSchema** | [**CreateSchema**](../Models/CreateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaInfoDAO",
    "predicted_relationship": "The SchemaInfoDAO is likely used to map the created schema data to the database entity. The documentation mentions returning a SchemaInfo object, which is probably converted from SchemaInfoDAO.",
    "ground_truth_relationship": "The SchemaInfoDAO class provides the data persistence layer and conversion methods (from/toSchemaInfo) that enable storing and retrieving the SchemaInfo objects that are returned by the documented createSchema API endpoint.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the core relationship - that SchemaInfoDAO handles database mapping/persistence for schema data and works with SchemaInfo objects. While it's less detailed than the ground truth, it captures the essential functionality without any contradictions.",
      "error_type": ""
    }
  },
  {
    "document_text": "# TemporaryVolumeCredentialsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**generateTemporaryVolumeCredentials**](TemporaryVolumeCredentialsApi.md#generateTemporaryVolumeCredentials) | **POST** /temporary-volume-credentials | Generate temporary volume credentials. |",
    "artifact_title": "TemporaryVolumeCredentialsService.generateTemporaryVolumeCredentials",
    "predicted_relationship": "This method directly implements the 'generateTemporaryVolumeCredentials' API endpoint described in the documentation. The documentation explicitly mentions 'generateTemporaryVolumeCredentials' as a POST method for generating temporary volume credentials, which is exactly what this service method does.",
    "ground_truth_relationship": "The code implements the documented POST endpoint '/temporary-volume-credentials' by handling volume credential generation requests, validating the volume ID, and returning temporary AWS credentials for S3 volumes or empty credentials for local filesystems.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this implements the generateTemporaryVolumeCredentials POST endpoint, but misses the crucial detail about different handling for S3 vs local volumes and the validation steps",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.updateCatalog",
    "predicted_relationship": "The CatalogCli.updateCatalog method directly implements the updateCatalog functionality described in the documentation. It takes the catalog name and UpdateCatalog object as parameters, matching the documented API. The method returns a CatalogInfo object, which aligns with the documented return type.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented updateCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction describes the relationship as a direct implementation of the API endpoint, but the ground truth correctly identifies it as a CLI wrapper around the API endpoint. While it gets the basic functionality right, it misses the crucial CLI wrapper aspect.",
      "error_type": "missing_architectural_layer"
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.updateCatalog",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the CatalogRepository.updateCatalog method is likely used to perform the actual update operation on the catalog data. It would handle the database interaction to update the catalog based on the provided UpdateCatalog object.",
    "ground_truth_relationship": "The code implements the documented API endpoint by validating the new catalog name, managing a database transaction to update the catalog's properties, name, and comment in a CatalogInfoDAO object, and handling error cases like NOT_FOUND and ALREADY_EXISTS as specified in the documentation's parameters and return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this is about updating catalog data, but incorrectly assumes a CatalogRepository.updateCatalog method when the code actually directly implements the update logic within this method. The core functionality is understood but the implementation details are mischaracterized.",
      "error_type": "implementation_misunderstanding"
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogService.updateCatalog",
    "predicted_relationship": "The CatalogService.updateCatalog method directly implements the API endpoint described in the documentation. It takes the catalog name and UpdateCatalog object as parameters, matching the documented API signature. The method returns a CatalogInfo object, aligning with the specified return type.",
    "ground_truth_relationship": "The code implements a PATCH endpoint that matches the documented API specifications by accepting a catalog name and UpdateCatalog object as parameters, invoking the repository layer, and returning a JSON HTTP response containing the updated CatalogInfo.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions capture the core relationship that this is a PATCH endpoint implementing the documented API to update a catalog by name, accepting UpdateCatalog input and returning CatalogInfo as JSON. Minor differences in wording and level of detail do not affect the fundamental alignment.",
      "error_type": "none"
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogInfoDAO",
    "predicted_relationship": "The CatalogInfoDAO is likely used to represent the catalog data in the database. While not explicitly mentioned in the documentation, it would be involved in the update process, particularly when converting between the API model (CatalogInfo) and the database model.",
    "ground_truth_relationship": "The CatalogInfoDAO class supports the updateCatalog endpoint by providing the data persistence layer and mapping functions (from/toCatalogInfo) that convert between the API's CatalogInfo model and the database entity representation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures that CatalogInfoDAO handles catalog data persistence and conversion between models, which aligns with the ground truth's description of it supporting the updateCatalog endpoint through persistence and mapping functions.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"generateTemporaryVolumeCredentials\"></a>\n# **generateTemporaryVolumeCredentials**\n> GenerateTemporaryVolumeCredentialResponse generateTemporaryVolumeCredentials(GenerateTemporaryVolumeCredential)\n\nGenerate temporary volume credentials.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **GenerateTemporaryVolumeCredential** | [**GenerateTemporaryVolumeCredential**](../Models/GenerateTemporaryVolumeCredential.md)|  | [optional] |\n\n### Return type\n\n[**GenerateTemporaryVolumeCredentialResponse**](../Models/GenerateTemporaryVolumeCredentialResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json\n",
    "artifact_title": "TemporaryVolumeCredentialsService.generateTemporaryVolumeCredentials",
    "predicted_relationship": "This method directly implements the generateTemporaryVolumeCredentials functionality described in the documentation. The method signature matches the documented API, taking a GenerateTemporaryVolumeCredential parameter and returning a GenerateTemporaryVolumeCredentialResponse.",
    "ground_truth_relationship": "The code implements the documented API endpoint by validating the volume ID, retrieving storage location information, and returning temporary AWS S3 credentials for S3 volumes or empty credentials for local storage, while matching the specified request/response types and HTTP POST behavior.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic API signature match but misses the crucial functionality of credential generation based on storage type (S3 vs local) and validation steps",
      "error_type": "major_omission"
    }
  },
  {
    "document_text": "<a name=\"getSchema\"></a>\n# **getSchema**\n> SchemaInfo getSchema(full\\_name)\n\nGet a schema\n\n    Gets the specified schema for a catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.getSchema",
    "predicted_relationship": "The document describes a 'getSchema' operation that takes a 'full_name' parameter and returns a SchemaInfo object. This directly corresponds to the SchemaRepository.getSchema method, which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented getSchema operation by retrieving a schema from a database session, converting it from DAO format to SchemaInfo, and attaching properties, while handling the specified error case for when the schema is not found.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic functionality of getSchema but misses crucial implementation aspects like database session handling, DAO conversion, and property attachment that are key parts of how the relationship works",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"getSchema\"></a>\n# **getSchema**\n> SchemaInfo getSchema(full\\_name)\n\nGet a schema\n\n    Gets the specified schema for a catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaService.getSchema",
    "predicted_relationship": "While not explicitly mentioned, the SchemaService.getSchema method would be the service layer implementation of the getSchema operation described in the API documentation.",
    "ground_truth_relationship": "The code implements the documented GET endpoint with path parameter 'full_name' by returning a JSON HTTP response containing schema information retrieved from SCHEMA_REPOSITORY.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction references a 'SchemaService.getSchema' which is not shown in the code and introduces an assumption about the service layer. While it correctly identifies this as a schema retrieval operation, it misses that the code directly uses SCHEMA_REPOSITORY and returns an HTTP JSON response.",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "<a name=\"getSchema\"></a>\n# **getSchema**\n> SchemaInfo getSchema(full\\_name)\n\nGet a schema\n\n    Gets the specified schema for a catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaInfoDAO",
    "predicted_relationship": "The documentation mentions returning a SchemaInfo object. SchemaInfoDAO would likely be used internally to represent this data in the database before converting to the SchemaInfo return type.",
    "ground_truth_relationship": "The SchemaInfoDAO class provides the data persistence and transformation layer for the SchemaInfo object that is returned by the documented getSchema endpoint, handling the mapping between database records and the API response model.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that SchemaInfoDAO is used to handle database persistence and converts to/from the SchemaInfo object used in the API. The main concept of internal data representation and conversion is consistent with the ground truth.",
      "error_type": null
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.createSchema",
    "predicted_relationship": "The documentation explicitly mentions 'createSchema' as a POST method for creating a schema. This directly corresponds to the SchemaService.createSchema method, which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented POST /schemas API endpoint by defining a createSchema method that accepts a CreateSchema object and returns a JSON HTTP response containing the newly created schema from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a POST endpoint for creating schemas, matching the ground truth's explanation of implementing the POST /schemas API endpoint. While it omits some implementation details about the return type and repository usage, it captures the core relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.deleteSchema",
    "predicted_relationship": "The documentation explicitly mentions 'deleteSchema' as a DELETE method for deleting a schema. This directly corresponds to the SchemaService.deleteSchema method, which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented DELETE /schemas/{full_name} endpoint by providing a method that accepts a schema's full name and an optional force parameter, deletes the specified schema from the repository, and returns an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - that the code implements the documented DELETE schema endpoint. While it's more concise than the ground truth and omits details about parameters and return values, it correctly identifies the fundamental relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.getSchema",
    "predicted_relationship": "The documentation explicitly mentions 'getSchema' as a GET method for retrieving a schema. This directly corresponds to the SchemaService.getSchema method, which implements this functionality.",
    "ground_truth_relationship": "The code implements the GET /schemas/{full_name} endpoint documented in the API table by defining a method that retrieves a schema using the full_name path parameter and returns it as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately identifies that this is the GET method for retrieving a schema as documented in the API table. While it's less detailed than the ground truth, it captures the core relationship between the code and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.listSchemas",
    "predicted_relationship": "The documentation explicitly mentions 'listSchemas' as a GET method for listing schemas. This directly corresponds to the SchemaService.listSchemas method, which implements this functionality.",
    "ground_truth_relationship": "The listSchemas method implements the '/schemas' GET endpoint documented in the API table by accepting catalog_name, max_results, and page_token parameters and returning schema listings as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - that the code implements the documented GET /schemas endpoint for listing schemas. While it's less detailed than the ground truth, it doesn't contain any contradictions or misunderstandings.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.updateSchema",
    "predicted_relationship": "The documentation explicitly mentions 'updateSchema' as a PATCH method for updating a schema. This directly corresponds to the SchemaService.updateSchema method, which implements this functionality.",
    "ground_truth_relationship": "The code implements the updateSchema API endpoint documented in the table by creating a PATCH handler at '/schemas/{full_name}' that accepts a schema name and update payload, passing them to the schema repository for processing.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this code implements the documented PATCH updateSchema API endpoint, even though it's less detailed than the ground truth",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.createSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.createSchema method is likely used by SchemaService.createSchema to perform the actual schema creation in the data layer.",
    "ground_truth_relationship": "The SchemaRepository.createSchema method implements the backend logic for the POST /schemas endpoint by validating the schema name, checking for duplicates, creating a new SchemaInfo object with a UUID, persisting it to the database within a transaction, and returning the created schema details.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies that this code is related to schema creation, but incorrectly suggests it's used by a SchemaService when it's actually implementing the POST /schemas endpoint directly. However, it correctly understands the basic purpose of schema creation.",
      "error_type": "architectural_misunderstanding"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.deleteSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.deleteSchema method is likely used by SchemaService.deleteSchema to perform the actual schema deletion in the data layer.",
    "ground_truth_relationship": "The SchemaRepository.deleteSchema method implements the DELETE /schemas/{full_name} API endpoint by handling schema deletion logic, including processing child tables, volumes, and functions, and removing associated properties from the database session.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures that the method is related to schema deletion but incorrectly suggests it's used by SchemaService rather than directly implementing the DELETE API endpoint. It also misses the key aspects of processing child elements and properties.",
      "error_type": "wrong_implementation_hierarchy"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.getSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.getSchema method is likely used by SchemaService.getSchema to retrieve the schema information from the data layer.",
    "ground_truth_relationship": "The SchemaRepository.getSchema method implements the GET /schemas/{full_name} API endpoint by retrieving schema information from a database, converting it from DAO format, and attaching properties while managing database transactions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that the method retrieves schema information but misses the key detail that it implements a specific REST API endpoint and includes important data transformation/transaction handling",
      "error_type": "incomplete_understanding"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.listSchemas",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.listSchemas method is likely used by SchemaService.listSchemas to retrieve the list of schemas from the data layer.",
    "ground_truth_relationship": "The code implements the GET /schemas endpoint by retrieving schemas from a database session, supporting pagination through maxResults and pageToken parameters, and returning a ListSchemasResponse containing schema information and a next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures that this is about listing schemas through a service layer, but misattributes it to SchemaRepository/SchemaService rather than recognizing it as the GET /schemas endpoint implementation. It also misses key aspects like pagination support.",
      "error_type": "incorrect_components_named"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.updateSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.updateSchema method is likely used by SchemaService.updateSchema to perform the actual schema update in the data layer.",
    "ground_truth_relationship": "The SchemaRepository.updateSchema method implements the PATCH /schemas/{full_name} API endpoint by handling the validation, modification, and persistence of schema updates including name changes, comments, and properties within a database transaction.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly connects the method to schema updates but incorrectly suggests it's used by a SchemaService rather than being the direct implementation of the PATCH API endpoint",
      "error_type": "incorrect_component_relationship"
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.createFunction",
    "predicted_relationship": "The documentation explicitly mentions a 'createFunction' API endpoint under the POST method. This method in FunctionCli likely implements the functionality to create a function as described in the API documentation.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that this code implements the createFunction API endpoint functionality, which matches the ground truth's statement that it's a CLI wrapper for the createFunction endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.deleteFunction",
    "predicted_relationship": "The documentation explicitly mentions a 'deleteFunction' API endpoint under the DELETE method. This method in FunctionCli likely implements the functionality to delete a function as described in the API documentation.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that the code implements the documented deleteFunction API endpoint functionality, just with slightly less specific terminology around it being a CLI wrapper",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.getFunction",
    "predicted_relationship": "The documentation explicitly mentions a 'getFunction' API endpoint under the GET method. This method in FunctionCli likely implements the functionality to retrieve a function as described in the API documentation.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented getFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the getFunction API endpoint functionality as documented, matching the ground truth's statement about it being a CLI wrapper for the documented endpoint",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.listFunctions",
    "predicted_relationship": "The documentation explicitly mentions a 'listFunctions' API endpoint under the GET method. This method in FunctionCli likely implements the functionality to list functions as described in the API documentation.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listFunctions endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this code implements the listFunctions API endpoint functionality, which aligns with the ground truth's statement about it being a CLI wrapper for the listFunctions endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.createFunction",
    "predicted_relationship": "While not explicitly mentioned in the documentation snippet, this service method likely implements the server-side logic for the 'createFunction' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the experimental POST /functions endpoint documented in the API table by defining a createFunction method that accepts a CreateFunctionRequest and returns an HTTP response containing the newly created function data from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - that the code implements the createFunction API endpoint documented in the API table. While it's more tentative in tone ('likely implements') and omits some implementation details, it correctly identifies the fundamental relationship between the code and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.deleteFunction",
    "predicted_relationship": "While not explicitly mentioned in the documentation snippet, this service method likely implements the server-side logic for the 'deleteFunction' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the documented DELETE /functions/{name} endpoint by providing a method that accepts a function name and optional force parameter, deleting the specified function through the repository and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented deleteFunction API endpoint, even though it omits specific details about parameters and response codes",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.getFunction",
    "predicted_relationship": "While not explicitly mentioned in the documentation snippet, this service method likely implements the server-side logic for the 'getFunction' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the documented GET /functions/{name} endpoint by creating a controller method that accepts a name parameter and returns a JSON response containing the function details from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is the server implementation of the getFunction API endpoint documented in the API spec, even though it doesn't detail the specific parameter and return types.",
      "error_type": null
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.listFunctions",
    "predicted_relationship": "While not explicitly mentioned in the documentation snippet, this service method likely implements the server-side logic for the 'listFunctions' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the documented GET /functions endpoint by defining a listFunctions method that accepts catalog name, schema name, pagination parameters, and returns an HTTP response containing the list of functions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this code implements the listFunctions API endpoint documented in the API spec, which is the core relationship. While it's more tentative in tone ('likely implements') and omits specifics about parameters, these are minor details that don't affect the fundamental relationship being described.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **updateVolume**\n> VolumeInfo updateVolume(name, UpdateVolumeRequestContent)\n\nUpdate a Volume\n\n    Updates the specified volume under the specified parent catalog and schema.  Currently only the name or the comment of the volume could be updated. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n| **UpdateVolumeRequestContent** | [**UpdateVolumeRequestContent**](../Models/UpdateVolumeRequestContent.md)|  | [optional] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeService.updateVolume",
    "predicted_relationship": "The documentation directly describes the 'updateVolume' operation, which is implemented by the VolumeService.updateVolume method. The method signature matches the documented parameters: a String for the volume name and an UpdateVolumeRequestContent object. It also returns a VolumeInfo object as specified in the documentation.",
    "ground_truth_relationship": "The code implements a PATCH endpoint that takes a fully qualified volume name and UpdateVolumeRequestContent object as specified in the documentation, delegating the actual update operation to VOLUME_REPOSITORY and wrapping the returned VolumeInfo in an HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic functionality but misses the HTTP aspect - it describes it as a direct method call rather than a REST endpoint with HTTP response wrapping",
      "error_type": "missing_key_context"
    }
  },
  {
    "document_text": "# **updateVolume**\n> VolumeInfo updateVolume(name, UpdateVolumeRequestContent)\n\nUpdate a Volume\n\n    Updates the specified volume under the specified parent catalog and schema.  Currently only the name or the comment of the volume could be updated. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n| **UpdateVolumeRequestContent** | [**UpdateVolumeRequestContent**](../Models/UpdateVolumeRequestContent.md)|  | [optional] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.updateVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeService.updateVolume method likely delegates the actual update operation to the VolumeRepository.updateVolume method, which handles the persistence logic.",
    "ground_truth_relationship": "The code implements the documented volume update functionality by validating the new name if provided, handling the three-level namespace split, and using database transactions to modify either the volume's name or comment while preventing duplicate names and handling non-existent volumes as specified in the documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly recognizes this is an update operation but incorrectly assumes delegation to a VolumeRepository when the code actually implements the update logic directly using Session/Transaction operations.",
      "error_type": "incorrect_implementation_assumption"
    }
  },
  {
    "document_text": "# **updateVolume**\n> VolumeInfo updateVolume(name, UpdateVolumeRequestContent)\n\nUpdate a Volume\n\n    Updates the specified volume under the specified parent catalog and schema.  Currently only the name or the comment of the volume could be updated. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n| **UpdateVolumeRequestContent** | [**UpdateVolumeRequestContent**](../Models/UpdateVolumeRequestContent.md)|  | [optional] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeInfoDAO",
    "predicted_relationship": "The VolumeInfoDAO is likely used internally by the VolumeRepository to map between the domain model (VolumeInfo) and the database representation. The documentation mentions returning a VolumeInfo object, which would be converted from a VolumeInfoDAO instance.",
    "ground_truth_relationship": "The VolumeInfoDAO class implements the data persistence layer for volumes, with fields and conversion methods that match the VolumeInfo structure referenced in the updateVolume API documentation, particularly supporting the comment and name fields that are marked as updatable in the documentation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies VolumeInfoDAO's role in mapping between domain and database, but misses the key point about supporting specific updatable fields (name and comment) that directly align with the documented API functionality.",
      "error_type": "incomplete_core_functionality"
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionService.createFunction",
    "predicted_relationship": "The documentation explicitly describes the 'createFunction' operation, which is directly implemented by the FunctionService.createFunction method. The method signature matches the documented API, taking a CreateFunctionRequest parameter and returning a FunctionInfo object.",
    "ground_truth_relationship": "The code implements the documented REST API endpoint by exposing a POST method that accepts a CreateFunctionRequest object, delegates to FUNCTION_REPOSITORY for function creation, and returns the result wrapped in an HTTP JSON response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core relationship between the code and documentation - it identifies this as a function creation endpoint that takes a CreateFunctionRequest and returns function information, which aligns with the ground truth's description of the POST endpoint implementation.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.createFunction",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the FunctionRepository.createFunction method is likely used by the FunctionService to persist the new function in the database. This is inferred from the typical service-repository pattern in the codebase.",
    "ground_truth_relationship": "The code implements the documented createFunction API endpoint by validating the input function name, constructing a FunctionInfo object with all required properties, and persisting it in a database transaction while handling schema validation and duplicate function checks.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that the function persists data to a database but it makes assumptions about a FunctionService/Repository pattern that isn't present in the code. The code shows direct database interaction without this abstraction layer.",
      "error_type": "architecture_assumption"
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionInfoDAO",
    "predicted_relationship": "The FunctionInfoDAO is likely used internally to persist and retrieve function information. While not explicitly mentioned in the documentation, it's a crucial part of the function creation process, mapping between the FunctionInfo model and the database representation.",
    "ground_truth_relationship": "The FunctionInfoDAO class provides the database persistence layer and object mapping functionality that enables the createFunction API endpoint to store and retrieve function metadata in the uc_functions table, converting between the API's FunctionInfo model and its database representation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core role of FunctionInfoDAO as the persistence/database mapping layer for function information, which aligns with the ground truth description. While the ground truth provides more specific details, the predicted version gets the essential relationship correct.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionCli.createFunction",
    "predicted_relationship": "While not mentioned in the server-side API documentation, the FunctionCli.createFunction method is likely the client-side implementation that calls this API. It would be responsible for constructing the CreateFunctionRequest and handling the returned FunctionInfo.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a client-side implementation calling the API endpoint, which aligns with the ground truth stating it's a CLI wrapper for the createFunction endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getTable\"></a>\n# **getTable**\n> TableInfo getTable(full\\_name)\n\nGet a table\n\n    Gets a table for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableRepository.getTable",
    "predicted_relationship": "The documentation describes a 'getTable' operation that takes a 'full_name' parameter and returns a TableInfo object. This directly corresponds to the TableRepository.getTable method, which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented getTable operation by parsing a fully qualified table name into catalog, schema, and table components, retrieving the table information from a database session, and returning a TableInfo object with attached properties, exactly matching the documented input parameter and return type specifications.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship between the documentation and code - a getTable operation that takes a full_name parameter and returns a TableInfo object. While it omits implementation details like parsing and property attachment, these are minor details that don't affect the fundamental relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getTable\"></a>\n# **getTable**\n> TableInfo getTable(full\\_name)\n\nGet a table\n\n    Gets a table for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableService.getTable",
    "predicted_relationship": "While not explicitly mentioned, the TableService.getTable method is likely the service-layer implementation of the documented API endpoint, acting as an intermediary between the API and the repository.",
    "ground_truth_relationship": "The code implements a REST endpoint annotated with @Get that takes a full_name parameter, validates it's not null, retrieves table information via TABLE_REPOSITORY, and returns it as JSON - matching the documented API endpoint behavior, parameter requirements, and TableInfo return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction correctly identifies this as a service layer implementation, but incorrectly assumes it's a 'TableService' when it's actually a direct REST endpoint implementation. It misses that this is the actual API controller code, not an intermediary service.",
      "error_type": "layer_misidentification"
    }
  },
  {
    "document_text": "<a name=\"getTable\"></a>\n# **getTable**\n> TableInfo getTable(full\\_name)\n\nGet a table\n\n    Gets a table for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableInfoDAO",
    "predicted_relationship": "The documentation mentions returning a TableInfo object. TableInfoDAO is likely used internally to represent the table data before converting it to the API response type.",
    "ground_truth_relationship": "The TableInfoDAO class provides the data persistence layer and model conversion methods that enable the documented getTable API endpoint to retrieve and return table information in the expected TableInfo format.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core idea that TableInfoDAO is used internally to handle table data before converting to the API response type (TableInfo). This aligns with the ground truth's explanation of TableInfoDAO serving as the data persistence layer for the getTable API endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **listVolumes**\n> ListVolumesResponseContent listVolumes(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList Volumes\n\n    Gets an array of available volumes under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| The identifier of the catalog | [default to null] |\n| **schema\\_name** | **String**| The identifier of the schema | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of volumes to return (page length).  If not set, the page length is set to a server configured value. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  Note: this parameter controls only the maximum number of volumes to return. The actual number of volumes returned in a page may be smaller than this value, including 0, even if there are more pages.   | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token returned by a previous request. It must be included in the request to retrieve the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListVolumesResponseContent**](../Models/ListVolumesResponseContent.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.listVolumes",
    "predicted_relationship": "The VolumeRepository.listVolumes method directly implements the listVolumes functionality described in the documentation. It takes the same parameters (catalogName, schemaName, maxResults, pageToken) and returns a ListVolumesResponseContent object as specified in the documentation.",
    "ground_truth_relationship": "The code implements the documented listVolumes API by querying volumes from a database using Hibernate, enforcing the documented parameters (catalog_name, schema_name, max_results, page_token) and returning a ListVolumesResponseContent object containing the filtered volume list.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic API parameters and return type correctly, but omits the crucial detail that it interacts with a database using Hibernate to retrieve the volumes, which is a key implementation aspect mentioned in the ground truth.",
      "error_type": "missing_key_implementation"
    }
  },
  {
    "document_text": "# **listVolumes**\n> ListVolumesResponseContent listVolumes(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList Volumes\n\n    Gets an array of available volumes under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| The identifier of the catalog | [default to null] |\n| **schema\\_name** | **String**| The identifier of the schema | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of volumes to return (page length).  If not set, the page length is set to a server configured value. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  Note: this parameter controls only the maximum number of volumes to return. The actual number of volumes returned in a page may be smaller than this value, including 0, even if there are more pages.   | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token returned by a previous request. It must be included in the request to retrieve the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListVolumesResponseContent**](../Models/ListVolumesResponseContent.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeService.listVolumes",
    "predicted_relationship": "The VolumeService.listVolumes method directly implements the API endpoint described in the documentation. It takes the same parameters (catalogName, schemaName, maxResults, pageToken) and likely calls the VolumeRepository to retrieve the data.",
    "ground_truth_relationship": "The code implements the documented listVolumes API endpoint as a GET HTTP method that accepts the specified catalog_name, schema_name, max_results, and page_token parameters, though it includes an additional undocumented include_browse parameter, and returns a JSON response from the volume repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship that this is a GET endpoint implementing the documented listVolumes API with the same main parameters, returning data from a volume repository. The omission of the include_browse parameter and HTTP specifics are minor details that don't affect the fundamental relationship.",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"listFunctions\"></a>\n# **listFunctions**\n> ListFunctionsResponse listFunctions(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList functions\n\n    List functions within the specified parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for functions of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of functions. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of functions to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query. | [optional] [default to null] |\n\n### Return type\n\n[**ListFunctionsResponse**](../Models/ListFunctionsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.listFunctions",
    "predicted_relationship": "This method directly implements the listFunctions API endpoint described in the documentation. It takes the same parameters (catalogName, schemaName, maxResults, pageToken) and returns a ListFunctionsResponse object as specified in the API documentation.",
    "ground_truth_relationship": "The code implements the documented behavior by retrieving function records from a database within a read-only transaction, transforming FunctionInfoDAO objects to FunctionInfo objects with attached properties, and returning them in a ListFunctionsResponse with pagination support through maxResults and pageToken parameters.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic API endpoint mapping but misses key implementation details about database transactions, data transformation, and pagination that are crucial to understanding how the method works.",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"listFunctions\"></a>\n# **listFunctions**\n> ListFunctionsResponse listFunctions(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList functions\n\n    List functions within the specified parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for functions of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of functions. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of functions to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query. | [optional] [default to null] |\n\n### Return type\n\n[**ListFunctionsResponse**](../Models/ListFunctionsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionService.listFunctions",
    "predicted_relationship": "This method directly implements the listFunctions API endpoint described in the documentation. It handles the HTTP GET request, processes the input parameters (catalogName, schemaName, maxResults, pageToken), and returns the ListFunctionsResponse as an HTTP response.",
    "ground_truth_relationship": "The code implements a REST GET endpoint that takes the exact parameters specified in the documentation (catalog_name, schema_name, optional max_results, and optional page_token) and delegates the actual function listing to a repository layer, returning the results as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - it's a GET endpoint that handles the documented parameters and returns function listing results as JSON. The minor difference in wording around delegation to repository vs direct implementation doesn't change the fundamental relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listFunctions\"></a>\n# **listFunctions**\n> ListFunctionsResponse listFunctions(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList functions\n\n    List functions within the specified parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for functions of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of functions. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of functions to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query. | [optional] [default to null] |\n\n### Return type\n\n[**ListFunctionsResponse**](../Models/ListFunctionsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionCli.listFunctions",
    "predicted_relationship": "While not explicitly mentioned in the documentation, this CLI method likely uses the listFunctions API to provide a command-line interface for listing functions. It processes similar parameters (catalogName, schemaName, maxResults) and interacts with the FunctionsApi to retrieve the list of functions.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listFunctions endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a CLI wrapper method that uses the listFunctions API to provide command-line functionality, which aligns with the ground truth relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.createVolume",
    "predicted_relationship": "The documentation explicitly mentions 'createVolume' as a POST method for creating a Volume. This directly corresponds to the VolumeService.createVolume method which implements this functionality.",
    "ground_truth_relationship": "The code implements the POST /volumes endpoint documented in the API table by defining a method that accepts a CreateVolumeRequestContent object and delegates to VOLUME_REPOSITORY to create a new volume, returning the result as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the key relationship that this is a POST endpoint for creating volumes, matching both the code implementation and API documentation",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.deleteVolume",
    "predicted_relationship": "The documentation explicitly mentions 'deleteVolume' as a DELETE method for deleting a Volume. This directly corresponds to the VolumeService.deleteVolume method which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented DELETE /volumes/{name} endpoint by accepting a volume's full name as a path parameter, delegating the deletion to VOLUME_REPOSITORY, and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a DELETE endpoint for volumes that aligns with the documentation, even though it omits implementation details about HTTP response codes and parameters",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.getVolume",
    "predicted_relationship": "The documentation explicitly mentions 'getVolume' as a GET method for retrieving a Volume. This directly corresponds to the VolumeService.getVolume method which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented GET /volumes/{name} endpoint by providing a method that retrieves volume information based on a full name parameter and returns it as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted text correctly identifies the core relationship - that this is a GET endpoint for retrieving volume information, which aligns with the ground truth's description of implementing GET /volumes/{name}.",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.listVolumes",
    "predicted_relationship": "The documentation explicitly mentions 'listVolumes' as a GET method for listing Volumes. This directly corresponds to the VolumeService.listVolumes method which implements this functionality.",
    "ground_truth_relationship": "The code implements the 'listVolumes' API endpoint documented in the table by defining a GET handler that accepts query parameters for catalog_name, schema_name, pagination controls, and browse options, returning the results as JSON.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the key relationship - that this is the listVolumes GET endpoint implementation documented in the API table. While it omits some implementation details about parameters that the ground truth mentions, it captures the core relationship accurately.",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.updateVolume",
    "predicted_relationship": "The documentation explicitly mentions 'updateVolume' as a PATCH method for updating a Volume. This directly corresponds to the VolumeService.updateVolume method which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented PATCH /volumes/{name} API endpoint by defining an updateVolume method that accepts a volume name and update request content, returning the updated volume data as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented PATCH endpoint for updating volumes, capturing the core relationship between the code and documentation.",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionService.createFunction",
    "predicted_relationship": "The documentation directly describes the 'createFunction' operation, which is implemented by the FunctionService.createFunction method. The method signature matches the documented API, taking a CreateFunctionRequest parameter and returning a FunctionInfo object.",
    "ground_truth_relationship": "The code implements the documented REST API endpoint by exposing a POST method that accepts a CreateFunctionRequest object, delegates to FUNCTION_REPOSITORY for function creation, and returns the result wrapped in an HTTP JSON response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "While the predicted description correctly identifies the core functionality of creating a function and the request/response types, it misses the crucial HTTP/REST aspects and repository delegation pattern described in the ground truth",
      "error_type": "missing_key_aspects"
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.createFunction",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the FunctionRepository.createFunction method is likely used by the FunctionService to persist the new function data. This is inferred from the typical service-repository pattern in the codebase.",
    "ground_truth_relationship": "The code implements the documented createFunction API endpoint by validating the input function name, constructing a FunctionInfo object with all required properties, and persisting it in a database transaction while handling schema validation and duplicate function checks.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this is about persisting function data, but incorrectly assumes a FunctionRepository/FunctionService pattern that isn't present in the actual implementation, which uses direct database session handling and DAO objects.",
      "error_type": "architectural_assumption"
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionInfoDAO",
    "predicted_relationship": "The FunctionInfoDAO is likely used to map between the FunctionInfo object (mentioned in the return type) and the database representation. While not explicitly mentioned, it's a crucial part of the function creation process.",
    "ground_truth_relationship": "The FunctionInfoDAO class provides the database persistence layer and object mapping functionality that enables the createFunction API endpoint to store and retrieve function metadata in the uc_functions table, converting between the API's FunctionInfo model and its database representation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the core relationship that FunctionInfoDAO maps between FunctionInfo objects and database representation, which aligns with the ground truth's explanation of the persistence layer functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionCli.createFunction",
    "predicted_relationship": "While not mentioned in the server-side documentation, the FunctionCli.createFunction method is likely the client-side implementation that calls this API. It would construct the CreateFunctionRequest and process the returned FunctionInfo.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately identifies that this is a client-side wrapper for making calls to the documented createFunction API endpoint. While it's more tentative in its language ('likely'), the core relationship understanding is correct.",
      "error_type": "none"
    }
  },
  {
    "document_text": "<a name=\"updateSchema\"></a>\n# **updateSchema**\n> SchemaInfo updateSchema(full\\_name, UpdateSchema)\n\nUpdate a schema\n\n    Updates the specified schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **UpdateSchema** | [**UpdateSchema**](../Models/UpdateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.updateSchema",
    "predicted_relationship": "The SchemaRepository.updateSchema method directly implements the updateSchema operation described in the documentation. The method signature matches the documented parameters, taking a 'fullName' string and an 'UpdateSchema' object. It returns a SchemaInfo object as specified in the documentation.",
    "ground_truth_relationship": "The code implements the documented schema update endpoint by validating the new schema name, managing database transactions to update the schema's name, comment, and properties, and handling errors according to the API specification's parameters and return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship between the code and documentation - implementing a schema update operation with matching parameters and return type. While it's less detailed than the ground truth, it doesn't contain any contradictions or misunderstandings.",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"updateSchema\"></a>\n# **updateSchema**\n> SchemaInfo updateSchema(full\\_name, UpdateSchema)\n\nUpdate a schema\n\n    Updates the specified schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **UpdateSchema** | [**UpdateSchema**](../Models/UpdateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaService.updateSchema",
    "predicted_relationship": "The SchemaService.updateSchema method directly implements the REST API endpoint for updating a schema. It takes the 'full_name' parameter and 'UpdateSchema' object as described in the documentation, and returns a SchemaInfo object wrapped in an HttpResponse.",
    "ground_truth_relationship": "The code implements a PATCH endpoint that directly matches the documented API endpoint, accepting a fullName path parameter and UpdateSchema body parameter, and returning a JSON response through HttpResponse.ofJson from the schema repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that this is a schema update endpoint matching the API docs, with the correct parameters and return type. Minor differences in wording do not change the core relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"updateSchema\"></a>\n# **updateSchema**\n> SchemaInfo updateSchema(full\\_name, UpdateSchema)\n\nUpdate a schema\n\n    Updates the specified schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **UpdateSchema** | [**UpdateSchema**](../Models/UpdateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaInfoDAO",
    "predicted_relationship": "The SchemaInfoDAO class is likely used internally to represent and persist the updated schema information. While not explicitly mentioned in the documentation, it's an essential part of the update process, converting between the API model (SchemaInfo) and the database representation.",
    "ground_truth_relationship": "The SchemaInfoDAO class provides the data persistence layer and object mapping functionality needed to support the updateSchema API endpoint by managing schema metadata in the database and converting between SchemaInfo API objects and database entities.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the main relationship - that SchemaInfoDAO handles persistence and conversion between SchemaInfo API objects and database representation. While more concise than the ground truth, it conveys the same core functionality without any contradictions.",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.createVolume",
    "predicted_relationship": "The documentation explicitly mentions a 'createVolume' POST endpoint under the VolumesApi. This directly corresponds to the 'VolumeService.createVolume' method, which implements this API endpoint.",
    "ground_truth_relationship": "The code implements the POST /volumes endpoint documented in the API table by defining a method that accepts a CreateVolumeRequestContent object and delegates to VOLUME_REPOSITORY to create a new volume, returning the result as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented POST /volumes endpoint for creating volumes, capturing the core relationship between the API documentation and implementation.",
      "error_type": null
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.deleteVolume",
    "predicted_relationship": "The documentation explicitly mentions a 'deleteVolume' DELETE endpoint under the VolumesApi. This directly corresponds to the 'VolumeService.deleteVolume' method, which implements this API endpoint.",
    "ground_truth_relationship": "The code implements the documented DELETE /volumes/{name} endpoint by accepting a volume's full name as a path parameter, delegating the deletion to VOLUME_REPOSITORY, and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented DELETE /volumes endpoint with its deleteVolume functionality, even though it doesn't detail the specific HTTP response and repository usage.",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.getVolume",
    "predicted_relationship": "The documentation explicitly mentions a 'getVolume' GET endpoint under the VolumesApi. This directly corresponds to the 'VolumeService.getVolume' method, which implements this API endpoint.",
    "ground_truth_relationship": "The code implements the documented GET /volumes/{name} endpoint by providing a method that retrieves volume information based on a full name parameter and returns it as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented GET /volumes/{name} endpoint through the getVolume method, matching the ground truth's core meaning. While it's less detailed, it captures the essential relationship.",
      "error_type": null
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.listVolumes",
    "predicted_relationship": "The documentation explicitly mentions a 'listVolumes' GET endpoint under the VolumesApi. This directly corresponds to the 'VolumeService.listVolumes' method, which implements this API endpoint.",
    "ground_truth_relationship": "The code implements the 'listVolumes' API endpoint documented in the table by defining a GET handler that accepts query parameters for catalog_name, schema_name, pagination controls, and browse options, returning the results as JSON.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship between the code and documentation - both describe a GET endpoint for listing volumes. While the predicted version is more concise and omits parameter details, it correctly identifies the key relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.updateVolume",
    "predicted_relationship": "The documentation explicitly mentions an 'updateVolume' PATCH endpoint under the VolumesApi. This directly corresponds to the 'VolumeService.updateVolume' method, which implements this API endpoint.",
    "ground_truth_relationship": "The code implements the documented PATCH /volumes/{name} API endpoint by defining an updateVolume method that accepts a volume name and update request content, returning the updated volume data as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented PATCH /volumes endpoint for updating volumes. While it's more concise than the ground truth, it captures the core relationship between the code and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeRepository.createVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.createVolume method is likely used by the VolumeService.createVolume method to perform the actual volume creation operation.",
    "ground_truth_relationship": "The VolumeRepository.createVolume method implements the POST /volumes API endpoint by validating the request, creating a new volume record with generated UUID and metadata, and persisting it to the database while enforcing schema existence and volume uniqueness constraints.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description recognizes this is about volume creation but makes incorrect assumptions about service layers (VolumeService/VolumeRepository), while missing key aspects like validation, UUID generation, and constraint checks that are core to understanding the relationship.",
      "error_type": "incorrect_architecture_assumption"
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeRepository.deleteVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.deleteVolume method is likely used by the VolumeService.deleteVolume method to perform the actual volume deletion operation.",
    "ground_truth_relationship": "The deleteVolume method in VolumeRepository implements the DELETE /volumes/{name} API endpoint by parsing the three-part volume name (catalog.schema.volume), validating the schema exists, and removing both the volume's metadata from the database and its storage directory if it's a managed volume.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted describes a service-repository relationship that isn't evident in the code, while missing the key implementation details about volume deletion. However, it correctly identifies that this is about volume deletion functionality.",
      "error_type": "incorrect_architectural_assumption"
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeRepository.getVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.getVolume method is likely used by the VolumeService.getVolume method to retrieve the volume information.",
    "ground_truth_relationship": "The VolumeRepository.getVolume method implements the GET /volumes/{name} endpoint by parsing a three-part volume name (catalog.schema.volume), retrieving the volume data from a database session, and returning a VolumeInfo object that represents the requested volume.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies a relationship between getVolume and volume retrieval, but misses the key implementation details about processing the three-part name and doesn't connect it to the REST API endpoint",
      "error_type": "missing_key_functionality"
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeRepository.listVolumes",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.listVolumes method is likely used by the VolumeService.listVolumes method to retrieve the list of volumes.",
    "ground_truth_relationship": "The listVolumes method implements the GET /volumes API endpoint by querying the database for volumes within a specified schema, supporting pagination through maxResults and pageToken parameters, and returning the results as a ListVolumesResponseContent object.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies that this is about listing volumes but incorrectly assumes VolumeRepository/VolumeService classes that don't exist in the code. However, it correctly captures the core purpose of listing volumes.",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeRepository.updateVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.updateVolume method is likely used by the VolumeService.updateVolume method to perform the actual volume update operation.",
    "ground_truth_relationship": "The VolumeRepository.updateVolume method implements the PATCH /volumes/{name} API endpoint by validating input parameters, managing database transactions, and performing volume updates including name and comment changes while handling potential conflicts and exceptions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures that this is related to volume updates but introduces uncertainty by suggesting it's used by a VolumeService layer that isn't evident in the code. It also misses the core API implementation aspect.",
      "error_type": "architectural_misunderstanding"
    }
  },
  {
    "document_text": "<a name=\"deleteCatalog\"></a>\n# **deleteCatalog**\n> oas_any_type_not_mapped deleteCatalog(name, force)\n\nDelete a catalog\n\n    Deletes the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.deleteCatalog",
    "predicted_relationship": "This method directly implements the deleteCatalog functionality described in the documentation. The method signature matches the documented parameters 'name' and 'force'. It uses the CatalogsApi to perform the deletion, which aligns with the API documentation.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the deleteCatalog functionality but misses that this is specifically a CLI wrapper layer rather than the direct API implementation",
      "error_type": "missing_architectural_layer"
    }
  },
  {
    "document_text": "<a name=\"deleteCatalog\"></a>\n# **deleteCatalog**\n> oas_any_type_not_mapped deleteCatalog(name, force)\n\nDelete a catalog\n\n    Deletes the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.deleteCatalog",
    "predicted_relationship": "This method likely implements the core logic for deleting a catalog, including the 'force' option mentioned in the documentation. It handles the actual deletion process in the repository layer.",
    "ground_truth_relationship": "The code implements the documented deleteCatalog operation by handling catalog deletion with optional force removal of schemas, throwing appropriate exceptions if the catalog is not found (ErrorCode.NOT_FOUND) or contains schemas without force flag (ErrorCode.FAILED_PRECONDITION), and managing the transaction across catalog, schema, and property deletions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the core deletion functionality but misses key aspects about error handling conditions and schema management specified in the ground truth",
      "error_type": "incomplete_coverage"
    }
  },
  {
    "document_text": "<a name=\"deleteCatalog\"></a>\n# **deleteCatalog**\n> oas_any_type_not_mapped deleteCatalog(name, force)\n\nDelete a catalog\n\n    Deletes the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogService.deleteCatalog",
    "predicted_relationship": "This service method likely acts as an intermediary between the API and the repository, implementing the deleteCatalog operation at the service layer. It probably handles the 'force' parameter as described in the documentation.",
    "ground_truth_relationship": "The code implements a DELETE endpoint that directly mirrors the documented API behavior by accepting a required 'name' parameter and optional 'force' parameter, invoking the catalog repository's deletion logic, and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the main functionality of the code as handling catalog deletion through a service layer, even though it doesn't mention specific HTTP details. The core relationship between the API, parameters, and deletion operation is preserved.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.createCatalog",
    "predicted_relationship": "The documentation explicitly mentions a 'createCatalog' operation with a POST /catalogs HTTP request. This directly corresponds to the CatalogCli.createCatalog method, which implements this functionality on the client side.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions accurately capture that the code implements client-side functionality for the documented createCatalog API endpoint",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.deleteCatalog",
    "predicted_relationship": "The documentation explicitly mentions a 'deleteCatalog' operation with a DELETE /catalogs/{name} HTTP request. This directly corresponds to the CatalogCli.deleteCatalog method, which implements this functionality on the client side.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented deleteCatalog endpoint functionality, recognizing it as a client-side implementation of the DELETE /catalogs/{name} operation",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.getCatalog",
    "predicted_relationship": "The documentation explicitly mentions a 'getCatalog' operation with a GET /catalogs/{name} HTTP request. This directly corresponds to the CatalogCli.getCatalog method, which implements this functionality on the client side.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented getCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions identify that the code implements/wraps the documented getCatalog API endpoint functionality. The predicted description correctly notes the GET /catalogs/{name} endpoint mapping to the getCatalog method.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.listCatalogs",
    "predicted_relationship": "The documentation explicitly mentions a 'listCatalogs' operation with a GET /catalogs HTTP request. This directly corresponds to the CatalogCli.listCatalogs method, which implements this functionality on the client side.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listCatalogs endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that the code implements a client-side call to the documented listCatalogs GET endpoint, which matches the ground truth's description of it being a CLI wrapper for that endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.updateCatalog",
    "predicted_relationship": "The documentation explicitly mentions an 'updateCatalog' operation with a PATCH /catalogs/{name} HTTP request. This directly corresponds to the CatalogCli.updateCatalog method, which implements this functionality on the client side.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented updateCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that the code implements a client-side wrapper for the documented updateCatalog PATCH endpoint.",
      "error_type": "none"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.createCatalog",
    "predicted_relationship": "The documentation explicitly mentions a 'createCatalog' operation with a POST /catalogs HTTP request. This directly corresponds to the CatalogService.createCatalog method, which implements this functionality on the server side.",
    "ground_truth_relationship": "The code implements the documented POST /catalogs endpoint through a @Post-annotated method that accepts a CreateCatalog object and returns a JSON response from the catalog repository's add operation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions identify that the code implements the documented POST /catalogs endpoint for catalog creation through a POST-annotated method, with the predicted focusing on the API documentation alignment and the ground truth providing more implementation details.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.deleteCatalog",
    "predicted_relationship": "The documentation explicitly mentions a 'deleteCatalog' operation with a DELETE /catalogs/{name} HTTP request. This directly corresponds to the CatalogService.deleteCatalog method, which implements this functionality on the server side.",
    "ground_truth_relationship": "Rep handler method that accepts a catalog name parameter and an optional force parameter, and returns a 200 OK response after delegating the deletion to a repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the DELETE operation and endpoint mapping, but misses the key aspects of the force parameter and repository delegation mentioned in the ground truth.",
      "error_type": "incomplete_relationship"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.getCatalog",
    "predicted_relationship": "The documentation explicitly mentions a 'getCatalog' operation with a GET /catalogs/{name} HTTP request. This directly corresponds to the CatalogService.getCatalog method, which implements this functionality on the server side.",
    "ground_truth_relationship": "The code implements the documented GET /catalogs/{name} endpoint by creating a method annotated with @Get that takes a name parameter and returns a catalog object as JSON via the repository layer.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented GET /catalogs/{name} endpoint as described in the documentation. Both descriptions capture the same core relationship between the code and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.listCatalogs",
    "predicted_relationship": "The documentation explicitly mentions a 'listCatalogs' operation with a GET /catalogs HTTP request. This directly corresponds to the CatalogService.listCatalogs method, which implements this functionality on the server side.",
    "ground_truth_relationship": "The listCatalogs code implements the documented GET /catalogs endpoint by accepting optional pagination parameters (max_results and page_token) and returning a JSON response of catalogs from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship between the code and documentation - that the listCatalogs method implements the GET /catalogs endpoint. While it omits details about pagination parameters, this is a minor detail that doesn't affect the fundamental relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.updateCatalog",
    "predicted_relationship": "The documentation explicitly mentions an 'updateCatalog' operation with a PATCH /catalogs/{name} HTTP request. This directly corresponds to the CatalogService.updateCatalog method, which implements this functionality on the server side.",
    "ground_truth_relationship": "The code implements the documented PATCH /catalogs/{name} endpoint by providing a method that accepts a catalog name parameter and update payload, returning the updated catalog as JSON via HttpResponse.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented PATCH endpoint for updating a catalog, capturing the core relationship between the documentation and implementation.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteFunction\"></a>\n# **deleteFunction**\n> oas_any_type_not_mapped deleteFunction(name)\n\nDelete a function\n\n    Deletes the function that matches the supplied name.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionCli.deleteFunction",
    "predicted_relationship": "The documentation describes a 'deleteFunction' operation that deletes a function matching a supplied name. This directly corresponds to the 'FunctionCli.deleteFunction' method, which implements this functionality in the CLI.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code is implementing the documented deleteFunction endpoint, capturing the core relationship that this is a CLI wrapper for the deletion functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteFunction\"></a>\n# **deleteFunction**\n> oas_any_type_not_mapped deleteFunction(name)\n\nDelete a function\n\n    Deletes the function that matches the supplied name.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.deleteFunction",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the FunctionRepository.deleteFunction method likely implements the backend logic for deleting a function, which is described in the API documentation.",
    "ground_truth_relationship": "The code implements the documented deleteFunction API endpoint by validating and parsing a fully-qualified function name (catalog.schema.function), managing a database transaction to delete the corresponding FunctionInfoDAO record, and throwing appropriate exceptions for invalid names or missing functions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the backend logic for the documented function deletion API, even though it doesn't detail all the implementation specifics",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteFunction\"></a>\n# **deleteFunction**\n> oas_any_type_not_mapped deleteFunction(name)\n\nDelete a function\n\n    Deletes the function that matches the supplied name.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionService.deleteFunction",
    "predicted_relationship": "The FunctionService.deleteFunction method likely implements the service layer logic for the delete function operation described in the API documentation, acting as an intermediary between the API and the repository.",
    "ground_truth_relationship": "The code implements the documented DELETE endpoint by accepting a name parameter and an optional force parameter (not mentioned in docs), calling FUNCTION_REPOSITORY.deleteFunction(), and returning an HTTP 200 OK response as specified in the OpenAPI documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a function deletion operation with repository interaction, which aligns with the ground truth's description of implementing a DELETE endpoint that calls the repository layer",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"generateTemporaryTableCredentials\"></a>\n# **generateTemporaryTableCredentials**\n> GenerateTemporaryTableCredentialResponse generateTemporaryTableCredentials(GenerateTemporaryTableCredential)\n\nGenerate temporary table credentials.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **GenerateTemporaryTableCredential** | [**GenerateTemporaryTableCredential**](../Models/GenerateTemporaryTableCredential.md)|  | [optional] |\n\n### Return type\n\n[**GenerateTemporaryTableCredentialResponse**](../Models/GenerateTemporaryTableCredentialResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json\n",
    "artifact_title": "TemporaryTableCredentialsService.generateTemporaryTableCredentials",
    "predicted_relationship": "This method directly implements the generateTemporaryTableCredentials functionality described in the documentation. The method signature matches the documented API call, taking a GenerateTemporaryTableCredential parameter and returning a GenerateTemporaryTableCredentialResponse.",
    "ground_truth_relationship": "The code implements the documented API endpoint by checking if a table exists at a storage location, then either generating AWS S3 temporary credentials or returning empty credentials for local filesystems, matching the documented GenerateTemporaryTableCredentialResponse return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the basic API implementation and parameters, but misses the key functionality of checking storage location and generating different credentials based on S3 vs local filesystem which is a crucial aspect mentioned in the ground truth",
      "error_type": "missing_core_functionality"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.createSchema",
    "predicted_relationship": "The documentation explicitly mentions 'createSchema' as a POST method for creating a schema. This directly corresponds to the SchemaService.createSchema method which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented POST /schemas API endpoint by defining a createSchema method that accepts a CreateSchema object and returns a JSON HTTP response containing the newly created schema from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented POST /schemas endpoint through a createSchema method, matching the key relationship in the ground truth",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.deleteSchema",
    "predicted_relationship": "The documentation explicitly mentions 'deleteSchema' as a DELETE method for deleting a schema. This directly corresponds to the SchemaService.deleteSchema method which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented DELETE /schemas/{full_name} endpoint by providing a method that accepts a schema's full name and an optional force parameter, deletes the specified schema from the repository, and returns an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted text captures the core relationship between the code and documentation - both clearly identify this as implementing the DELETE schema endpoint from the API documentation. While the prediction omits implementation details like parameters and response codes, it correctly identifies the main relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.getSchema",
    "predicted_relationship": "The documentation explicitly mentions 'getSchema' as a GET method for retrieving a schema. This directly corresponds to the SchemaService.getSchema method which implements this functionality.",
    "ground_truth_relationship": "The code implements the GET /schemas/{full_name} endpoint documented in the API table by defining a method that retrieves a schema using the full_name path parameter and returns it as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship between the code and documentation - it correctly identifies that this implements the documented GET /schemas/{full_name} endpoint for retrieving a schema",
      "error_type": null
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.listSchemas",
    "predicted_relationship": "The documentation explicitly mentions 'listSchemas' as a GET method for listing schemas. This directly corresponds to the SchemaService.listSchemas method which implements this functionality.",
    "ground_truth_relationship": "The listSchemas method implements the '/schemas' GET endpoint documented in the API table by accepting catalog_name, max_results, and page_token parameters and returning schema listings as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a GET method for listing schemas that aligns with the API documentation, even though it omits parameter details",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.updateSchema",
    "predicted_relationship": "The documentation explicitly mentions 'updateSchema' as a PATCH method for updating a schema. This directly corresponds to the SchemaService.updateSchema method which implements this functionality.",
    "ground_truth_relationship": "The code implements the updateSchema API endpoint documented in the table by creating a PATCH handler at '/schemas/{full_name}' that accepts a schema name and update payload, passing them to the schema repository for processing.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the main relationship - that this is the implementation of the documented updateSchema PATCH endpoint. Both descriptions agree on the core functionality of updating schemas via a PATCH method.",
      "error_type": null
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.createSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.createSchema method is likely used by the SchemaService to perform the actual creation of the schema in the database.",
    "ground_truth_relationship": "The SchemaRepository.createSchema method implements the backend logic for the POST /schemas endpoint by validating the schema name, checking for duplicates, creating a new SchemaInfo object with a UUID, persisting it to the database within a transaction, and returning the created schema details.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this is a schema creation method, but oversimplifies it as just being 'used by SchemaService' when it's actually the direct implementation of the POST /schemas endpoint with specific validation and persistence logic",
      "error_type": "oversimplification_and_missing_core_functionality"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.deleteSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.deleteSchema method is likely used by the SchemaService to perform the actual deletion of the schema from the database.",
    "ground_truth_relationship": "The SchemaRepository.deleteSchema method implements the DELETE /schemas/{full_name} API endpoint by handling schema deletion logic, including processing child tables, volumes, and functions, and removing associated properties from the database session.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that the method is used for schema deletion, but incorrectly suggests uncertainty about its role ('likely used') when the code clearly shows it is the implementation of the DELETE endpoint. It also misses mentioning key functionality like processing child elements.",
      "error_type": "imprecise_understanding"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.getSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.getSchema method is likely used by the SchemaService to retrieve the schema information from the database.",
    "ground_truth_relationship": "The SchemaRepository.getSchema method implements the GET /schemas/{full_name} API endpoint by retrieving schema information from a database, converting it from DAO format, and attaching properties while managing database transactions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the method retrieves schema information from the database, which aligns with the ground truth's core functionality. While it omits implementation details about DAO conversion and transaction management, it captures the essential relationship between the method and its purpose.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.listSchemas",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.listSchemas method is likely used by the SchemaService to retrieve the list of schemas from the database.",
    "ground_truth_relationship": "The code implements the GET /schemas endpoint by retrieving schemas from a database session, supporting pagination through maxResults and pageToken parameters, and returning a ListSchemasResponse containing schema information and a next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core functionality - retrieving schemas from the database through the repository layer. While it omits details about pagination and response format, it gets the fundamental relationship correct.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.updateSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.updateSchema method is likely used by the SchemaService to perform the actual update of the schema in the database.",
    "ground_truth_relationship": "The SchemaRepository.updateSchema method implements the PATCH /schemas/{full_name} API endpoint by handling the validation, modification, and persistence of schema updates including name changes, comments, and properties within a database transaction.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that the method handles schema updates in the database, but incorrectly suggests it is used by a separate SchemaService rather than directly implementing the PATCH API endpoint.",
      "error_type": "incorrect_architectural_relationship"
    }
  },
  {
    "document_text": "<a name=\"createSchema\"></a>\n# **createSchema**\n> SchemaInfo createSchema(CreateSchema)\n\nCreate a schema\n\n    Creates a new schema in the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateSchema** | [**CreateSchema**](../Models/CreateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaService.createSchema",
    "predicted_relationship": "The documentation explicitly describes the 'createSchema' operation, which is directly implemented by the SchemaService.createSchema method. The method signature matches the documented parameters (CreateSchema) and return type (SchemaInfo).",
    "ground_truth_relationship": "The code implements the documented REST endpoint by accepting a CreateSchema object via POST request and returning a JSON HTTP response containing the schema created through the SCHEMA_REPOSITORY.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies that it's about the createSchema operation but incorrectly refers to SchemaService.createSchema instead of SCHEMA_REPOSITORY.createSchema and misses mentioning the HTTP POST aspect and JSON response format",
      "error_type": "incorrect_service_name_and_missing_http_details"
    }
  },
  {
    "document_text": "<a name=\"createSchema\"></a>\n# **createSchema**\n> SchemaInfo createSchema(CreateSchema)\n\nCreate a schema\n\n    Creates a new schema in the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateSchema** | [**CreateSchema**](../Models/CreateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.createSchema",
    "predicted_relationship": "While not explicitly mentioned, the SchemaRepository.createSchema method is likely used by SchemaService.createSchema to perform the actual creation of the schema in the database.",
    "ground_truth_relationship": "The code fully implements the documented API endpoint by validating the schema name, checking for existing schemas, persisting the new schema with its properties in a database transaction, and returning a SchemaInfo object as specified in the documentation's return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description suggests this is a delegate method used by SchemaService when in fact the code shows it is the main implementation. However, it correctly identifies that it handles schema creation in the database.",
      "error_type": "incorrect_assumption_about_delegation"
    }
  },
  {
    "document_text": "<a name=\"createSchema\"></a>\n# **createSchema**\n> SchemaInfo createSchema(CreateSchema)\n\nCreate a schema\n\n    Creates a new schema in the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateSchema** | [**CreateSchema**](../Models/CreateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaInfoDAO",
    "predicted_relationship": "The SchemaInfoDAO is likely used to map the created schema to the database representation, as the documentation mentions returning a SchemaInfo object.",
    "ground_truth_relationship": "The SchemaInfoDAO class provides the data persistence layer and conversion methods (from/toSchemaInfo) that enable storing and retrieving the SchemaInfo objects that are returned by the documented createSchema API endpoint.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that SchemaInfoDAO handles database mapping for schemas, but misses the crucial aspect of the bi-directional conversion methods (from/toSchemaInfo) and its role as a data persistence layer for the API endpoint.",
      "error_type": "incomplete_understanding"
    }
  },
  {
    "document_text": "<a name=\"generateTemporaryVolumeCredentials\"></a>\n# **generateTemporaryVolumeCredentials**\n> GenerateTemporaryVolumeCredentialResponse generateTemporaryVolumeCredentials(GenerateTemporaryVolumeCredential)\n\nGenerate temporary volume credentials.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **GenerateTemporaryVolumeCredential** | [**GenerateTemporaryVolumeCredential**](../Models/GenerateTemporaryVolumeCredential.md)|  | [optional] |\n\n### Return type\n\n[**GenerateTemporaryVolumeCredentialResponse**](../Models/GenerateTemporaryVolumeCredentialResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json\n",
    "artifact_title": "TemporaryVolumeCredentialsService.generateTemporaryVolumeCredentials",
    "predicted_relationship": "This method directly implements the generateTemporaryVolumeCredentials functionality described in the documentation. The method signature matches the documented API call, taking a GenerateTemporaryVolumeCredential parameter and returning a GenerateTemporaryVolumeCredentialResponse.",
    "ground_truth_relationship": "The code implements the documented API endpoint by validating the volume ID, retrieving storage location information, and returning temporary AWS S3 credentials for S3 volumes or empty credentials for local storage, while matching the specified request/response types and HTTP POST behavior.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic API signature match but misses crucial functionality around credential generation based on storage type (S3 vs local) and validation steps",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"listTables\"></a>\n# **listTables**\n> ListTablesResponse listTables(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList tables\n\n    Gets the list of all available tables under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for tables of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of tables. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of tables to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token to send for the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListTablesResponse**](../Models/ListTablesResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableService.listTables",
    "predicted_relationship": "The documentation directly describes the 'listTables' operation, which is implemented by the TableService.listTables method. The method signature matches the documented parameters: catalogName, schemaName, maxResults, and pageToken. It also returns a ListTablesResponse object as specified in the documentation.",
    "ground_truth_relationship": "The code implements the documented API endpoint by accepting the same catalog_name, schema_name, max_results, and page_token parameters, while also including two additional optional parameters (omit_properties and omit_columns) that are not mentioned in the documentation, then delegates the actual table listing to TABLE_REPOSITORY and returns the result as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic functionality of listTables and its core parameters, but misses the important detail about the two additional optional parameters (omit_properties and omit_columns) that are present in the code but not in the documentation",
      "error_type": "major_omission"
    }
  },
  {
    "document_text": "<a name=\"listTables\"></a>\n# **listTables**\n> ListTablesResponse listTables(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList tables\n\n    Gets the list of all available tables under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for tables of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of tables. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of tables to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token to send for the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListTablesResponse**](../Models/ListTablesResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableRepository.listTables",
    "predicted_relationship": "While not explicitly mentioned, the TableService.listTables method likely delegates the actual table listing operation to TableRepository.listTables. This repository method handles the database interaction to retrieve the list of tables based on the provided parameters.",
    "ground_truth_relationship": "The code implements the documented listTables endpoint by querying a database session for table records matching the given catalog and schema names, handling pagination through maxResults and pageToken parameters, and returning a ListTablesResponse object containing the table list and next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core functionality of listTables method - fetching tables from a database through repository/service layer interaction. While it doesn't mention all implementation details like pagination and response formatting, it correctly identifies the main relationship and data flow.",
      "error_type": "none"
    }
  },
  {
    "document_text": "<a name=\"listTables\"></a>\n# **listTables**\n> ListTablesResponse listTables(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList tables\n\n    Gets the list of all available tables under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for tables of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of tables. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of tables to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token to send for the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListTablesResponse**](../Models/ListTablesResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableCli.listTables",
    "predicted_relationship": "While not explicitly mentioned in the documentation, TableCli.listTables is likely the CLI implementation that interacts with the listTables API. It would use the same parameters (catalogName, schemaName, maxResults) to call the API and process the ListTablesResponse.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listTables endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a CLI wrapper implementation that interacts with the listTables API endpoint, even though it expresses some uncertainty ('likely'). The core relationship between the code and documentation is accurately captured.",
      "error_type": "none"
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeService.createVolume",
    "predicted_relationship": "The documentation directly describes the 'createVolume' operation, which is implemented by the VolumeService.createVolume method. The method signature matches the documented parameters (CreateVolumeRequestContent) and return type (VolumeInfo).",
    "ground_truth_relationship": "The code implements the documented API endpoint by accepting a CreateVolumeRequestContent parameter and returning a JSON HTTP response containing the created volume information, matching the documented input/output specifications and HTTP headers.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core relationship - that the code implements the documented API endpoint with matching input parameter (CreateVolumeRequestContent) and output (volume info via JSON response). While it references 'VolumeService' instead of 'VOLUME_REPOSITORY', this is a minor implementation detail that doesn't affect the core relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.createVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeService.createVolume method likely uses the VolumeRepository.createVolume method to persist the volume data.",
    "ground_truth_relationship": "The code implements the documented createVolume operation by validating inputs, creating a VolumeInfo object with a UUID, validating volume type and storage location, and persisting it to the database within a transaction while enforcing schema existence and volume uniqueness constraints.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description gets the basic persistence aspect right but incorrectly states it uses VolumeRepository.createVolume when the code actually uses direct database session operations and VolumeInfoDAO. It also misses key aspects like validation, type checking, and transaction handling.",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeInfoDAO",
    "predicted_relationship": "The VolumeInfoDAO is likely used internally to map between the VolumeInfo model and the database representation of a volume.",
    "ground_truth_relationship": "The VolumeInfoDAO class provides the data persistence layer and mapping functionality for the createVolume API endpoint by defining the database schema and conversion methods between the API's VolumeInfo model and the database representation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the basic mapping functionality between VolumeInfo and database representation, but misses the crucial context that this DAO specifically supports the createVolume API endpoint and serves as its persistence layer",
      "error_type": "incomplete_context"
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeCli.createVolume",
    "predicted_relationship": "While not directly mentioned in the API documentation, the VolumeCli.createVolume method likely provides a command-line interface that internally uses the VolumeService to create volumes.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createVolume endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a CLI wrapper/interface for the underlying volume creation functionality, which matches the ground truth. While it references 'VolumeService' instead of the specific 'createVolume endpoint', this is a minor implementation detail that doesn't change the core relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getTable\"></a>\n# **getTable**\n> TableInfo getTable(full\\_name)\n\nGet a table\n\n    Gets a table for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableService.getTable",
    "predicted_relationship": "The documentation describes a 'getTable' operation that takes a 'full_name' parameter and returns a TableInfo object. This directly corresponds to the TableService.getTable method, which implements this functionality.",
    "ground_truth_relationship": "The code implements a REST endpoint annotated with @Get that takes a full_name parameter, validates it's not null, retrieves table information via TABLE_REPOSITORY, and returns it as JSON - matching the documented API endpoint behavior, parameter requirements, and TableInfo return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic functionality of getting table info, but misnames it as 'TableService.getTable' when the code actually uses 'TABLE_REPOSITORY.getTable'. It also omits the HTTP endpoint and JSON response aspects.",
      "error_type": "naming_error_and_missing_context"
    }
  },
  {
    "document_text": "<a name=\"getTable\"></a>\n# **getTable**\n> TableInfo getTable(full\\_name)\n\nGet a table\n\n    Gets a table for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableRepository.getTable",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableService.getTable method likely uses TableRepository.getTable to retrieve the table information from the database.",
    "ground_truth_relationship": "The code implements the documented getTable operation by parsing a fully qualified table name into catalog, schema, and table components, retrieving the table information from a database session, and returning a TableInfo object with attached properties, exactly matching the documented input parameter and return type specifications.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that the method retrieves table information from a database, but incorrectly assumes it uses TableRepository.getTable when it actually uses a Session and TableInfoDAO directly. It also misses key aspects like parsing the full name and property attachment.",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "<a name=\"getTable\"></a>\n# **getTable**\n> TableInfo getTable(full\\_name)\n\nGet a table\n\n    Gets a table for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableInfoDAO",
    "predicted_relationship": "The TableInfoDAO is likely used internally to represent the table data in the database, which is then converted to the TableInfo object returned by the API.",
    "ground_truth_relationship": "The TableInfoDAO class provides the data persistence layer and model conversion methods that enable the documented getTable API endpoint to retrieve and return table information in the expected TableInfo format.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures that TableInfoDAO is an internal database representation that converts to TableInfo objects, which aligns with the ground truth's explanation of it being the persistence layer that enables the getTable API to return TableInfo format.",
      "error_type": null
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.createFunction",
    "predicted_relationship": "The documentation explicitly mentions a 'createFunction' API endpoint with a POST request to '/functions'. This directly corresponds to the 'FunctionCli.createFunction' method, which is likely the CLI implementation of this API endpoint.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a CLI implementation of the documented createFunction API endpoint, which matches the ground truth's statement about it being a CLI wrapper for that endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.deleteFunction",
    "predicted_relationship": "The documentation explicitly mentions a 'deleteFunction' API endpoint with a DELETE request to '/functions/{name}'. This directly corresponds to the 'FunctionCli.deleteFunction' method, which is likely the CLI implementation of this API endpoint.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code is implementing functionality corresponding to the documented deleteFunction API endpoint, which matches the ground truth's statement about it being a CLI wrapper for that endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.getFunction",
    "predicted_relationship": "The documentation explicitly mentions a 'getFunction' API endpoint with a GET request to '/functions/{name}'. This directly corresponds to the 'FunctionCli.getFunction' method, which is likely the CLI implementation of this API endpoint.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented getFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that the code implements a wrapper for the documented getFunction API endpoint, which matches the ground truth. The minor additional details about HTTP methods don't contradict the core relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.listFunctions",
    "predicted_relationship": "The documentation explicitly mentions a 'listFunctions' API endpoint with a GET request to '/functions'. This directly corresponds to the 'FunctionCli.listFunctions' method, which is likely the CLI implementation of this API endpoint.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listFunctions endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately identifies that the code implements a CLI interface to the documented listFunctions API endpoint, which matches the ground truth's core meaning.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.createFunction",
    "predicted_relationship": "While not explicitly mentioned, the 'FunctionService.createFunction' method is likely the server-side implementation of the 'createFunction' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the experimental POST /functions endpoint documented in the API table by defining a createFunction method that accepts a CreateFunctionRequest and returns an HTTP response containing the newly created function data from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies this as a createFunction API endpoint implementation, but incorrectly speculates about 'FunctionService' when the code shows FUNCTION_REPOSITORY",
      "error_type": "incorrect_component_reference"
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.deleteFunction",
    "predicted_relationship": "While not explicitly mentioned, the 'FunctionService.deleteFunction' method is likely the server-side implementation of the 'deleteFunction' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the documented DELETE /functions/{name} endpoint by providing a method that accepts a function name and optional force parameter, deleting the specified function through the repository and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented DELETE function endpoint, even though it uses more general terms and omits specific details about parameters and response codes",
      "error_type": "none"
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.getFunction",
    "predicted_relationship": "While not explicitly mentioned, the 'FunctionService.getFunction' method is likely the server-side implementation of the 'getFunction' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the documented GET /functions/{name} endpoint by creating a controller method that accepts a name parameter and returns a JSON response containing the function details from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is the server-side implementation of the getFunction API endpoint, which matches the ground truth's explanation of how the code implements the GET /functions/{name} endpoint. While the ground truth provides more implementation details, the core relationship is accurately captured.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.listFunctions",
    "predicted_relationship": "While not explicitly mentioned, the 'FunctionService.listFunctions' method is likely the server-side implementation of the 'listFunctions' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the documented GET /functions endpoint by defining a listFunctions method that accepts catalog name, schema name, pagination parameters, and returns an HTTP response containing the list of functions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this code implements the documented listFunctions API endpoint, even though it's more concise and omits implementation details like the parameters.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **listVolumes**\n> ListVolumesResponseContent listVolumes(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList Volumes\n\n    Gets an array of available volumes under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| The identifier of the catalog | [default to null] |\n| **schema\\_name** | **String**| The identifier of the schema | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of volumes to return (page length).  If not set, the page length is set to a server configured value. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  Note: this parameter controls only the maximum number of volumes to return. The actual number of volumes returned in a page may be smaller than this value, including 0, even if there are more pages.   | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token returned by a previous request. It must be included in the request to retrieve the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListVolumesResponseContent**](../Models/ListVolumesResponseContent.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.listVolumes",
    "predicted_relationship": "The VolumeRepository.listVolumes method directly implements the listVolumes functionality described in the documentation. It takes the same parameters (catalogName, schemaName, maxResults, pageToken) and returns a ListVolumesResponseContent object, which matches the documented return type.",
    "ground_truth_relationship": "The code implements the documented listVolumes API by querying volumes from a database using Hibernate, enforcing the documented parameters (catalog_name, schema_name, max_results, page_token) and returning a ListVolumesResponseContent object containing the filtered volume list.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic API implementation but omits a crucial aspect about database interaction via Hibernate/Session that is central to how the functionality works according to the ground truth",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "# **listVolumes**\n> ListVolumesResponseContent listVolumes(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList Volumes\n\n    Gets an array of available volumes under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| The identifier of the catalog | [default to null] |\n| **schema\\_name** | **String**| The identifier of the schema | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of volumes to return (page length).  If not set, the page length is set to a server configured value. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  Note: this parameter controls only the maximum number of volumes to return. The actual number of volumes returned in a page may be smaller than this value, including 0, even if there are more pages.   | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token returned by a previous request. It must be included in the request to retrieve the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListVolumesResponseContent**](../Models/ListVolumesResponseContent.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeService.listVolumes",
    "predicted_relationship": "The VolumeService.listVolumes method directly implements the API endpoint described in the documentation. It takes the same parameters (catalogName, schemaName, maxResults, pageToken) and likely calls the VolumeRepository to retrieve the data.",
    "ground_truth_relationship": "The code implements the documented listVolumes API endpoint as a GET HTTP method that accepts the specified catalog_name, schema_name, max_results, and page_token parameters, though it includes an additional undocumented include_browse parameter, and returns a JSON response from the volume repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core relationship - that this implements the documented listVolumes API endpoint with the specified parameters and returns repository data.",
      "error_type": null
    }
  },
  {
    "document_text": "# TemporaryTableCredentialsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**generateTemporaryTableCredentials**](TemporaryTableCredentialsApi.md#generateTemporaryTableCredentials) | **POST** /temporary-table-credentials | Generate temporary table credentials. |",
    "artifact_title": "TemporaryTableCredentialsService.generateTemporaryTableCredentials",
    "predicted_relationship": "This method directly implements the 'generateTemporaryTableCredentials' API endpoint described in the documentation. The documentation states 'Generate temporary table credentials.' which is exactly what this method does.",
    "ground_truth_relationship": "The code implements the documented POST endpoint /temporary-table-credentials by validating the table location and returning AWS temporary credentials for S3 storage or empty credentials for local storage.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core relationship that this is a method implementing the documented temporary table credentials API endpoint. While it omits implementation details about S3/local storage handling, these are minor technical details that don't change the fundamental relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "# TemporaryVolumeCredentialsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**generateTemporaryVolumeCredentials**](TemporaryVolumeCredentialsApi.md#generateTemporaryVolumeCredentials) | **POST** /temporary-volume-credentials | Generate temporary volume credentials. |",
    "artifact_title": "TemporaryVolumeCredentialsService.generateTemporaryVolumeCredentials",
    "predicted_relationship": "This method directly implements the 'generateTemporaryVolumeCredentials' API endpoint described in the documentation. The documentation specifies a POST request to '/temporary-volume-credentials' for generating temporary volume credentials, which is exactly what this method does.",
    "ground_truth_relationship": "The code implements the documented POST endpoint '/temporary-volume-credentials' by handling volume credential generation requests, validating the volume ID, and returning temporary AWS credentials for S3 volumes or empty credentials for local filesystems.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures that this implements the documented POST endpoint, but omits the crucial functionality of handling different volume types (S3 vs local) and the credential generation logic which is a key part of the implementation",
      "error_type": "important_omission"
    }
  },
  {
    "document_text": "# **deleteVolume**\n> oas_any_type_not_mapped deleteVolume(name)\n\nDelete a Volume\n\n    Deletes a volume from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeService.deleteVolume",
    "predicted_relationship": "This method directly implements the deleteVolume operation described in the documentation. The method signature matches the documented parameters, taking a 'fullName' parameter which corresponds to the 'name' parameter in the documentation. The documentation states 'Deletes a volume from the specified parent catalog and schema', which is exactly what this method is designed to do.",
    "ground_truth_relationship": "The code directly implements the documented DELETE endpoint by accepting a fully qualified volume name parameter, delegating the deletion to VOLUME_REPOSITORY, and returning an HTTP 200 OK response as specified in the OpenAPI documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that the code implements the documented DELETE endpoint by accepting a volume name parameter and performing the deletion. While it omits the specific HTTP 200 OK response detail, it correctly identifies the main functionality and parameter mapping.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **deleteVolume**\n> oas_any_type_not_mapped deleteVolume(name)\n\nDelete a Volume\n\n    Deletes a volume from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.deleteVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, this method is likely called by VolumeService.deleteVolume to perform the actual deletion of the volume from the repository. The documentation states that the operation 'Deletes a volume from the specified parent catalog and schema', which is the responsibility of this repository method.",
    "ground_truth_relationship": "The code implements a documented Volume deletion operation by validating a three-part volume name, managing database transactions to remove the volume record, and cleaning up storage directories for managed volumes.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions capture the core functionality of deleting a volume from the repository, including validation and cleanup. While the predicted description frames it more as an implementation detail of VolumeService, this doesn't contradict the fundamental relationship described in the ground truth.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createCatalog\"></a>\n# **createCatalog**\n> CatalogInfo createCatalog(CreateCatalog)\n\nCreate a catalog\n\n    Creates a new catalog instance. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateCatalog** | [**CreateCatalog**](../Models/CreateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.addCatalog",
    "predicted_relationship": "The CatalogRepository.addCatalog method likely implements the core functionality of creating a new catalog as described in the documentation. While not explicitly mentioned, it matches the described behavior of creating a new catalog instance and returning a CatalogInfo object.",
    "ground_truth_relationship": "The addCatalog implementation validates SQL object names, creates a CatalogInfo instance with a UUID and properties, and persists it to the database in a transaction, fulfilling the documented createCatalog API endpoint's purpose of creating a new catalog instance.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core functionality of creating a new catalog instance and returning CatalogInfo, which aligns with the ground truth's description of the implementation. While it omits implementation details like validation and persistence, these are minor details that don't affect the high-level relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createCatalog\"></a>\n# **createCatalog**\n> CatalogInfo createCatalog(CreateCatalog)\n\nCreate a catalog\n\n    Creates a new catalog instance. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateCatalog** | [**CreateCatalog**](../Models/CreateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogService.createCatalog",
    "predicted_relationship": "This method directly implements the createCatalog operation described in the documentation. It takes a CreateCatalog object as input and returns a CatalogInfo object, matching the API specification.",
    "ground_truth_relationship": "The code implements the documented API endpoint by accepting a CreateCatalog object via POST, persisting it through CATALOG_REPOSITORY, and returning a JSON response matching the documented CatalogInfo return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core functionality of the code implementing a createCatalog API endpoint that takes CreateCatalog input and returns CatalogInfo, matching the documentation's specifications",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"createCatalog\"></a>\n# **createCatalog**\n> CatalogInfo createCatalog(CreateCatalog)\n\nCreate a catalog\n\n    Creates a new catalog instance. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateCatalog** | [**CreateCatalog**](../Models/CreateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogInfoDAO",
    "predicted_relationship": "While not explicitly mentioned, the CatalogInfoDAO is likely used to persist and retrieve the catalog information that is returned as part of the CatalogInfo object specified in the API documentation.",
    "ground_truth_relationship": "The CatalogInfoDAO class provides the data persistence layer and mapping functionality for the CatalogInfo objects that are returned by the documented createCatalog API endpoint, with methods to convert between the DAO and API model representations.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that CatalogInfoDAO is used for persistence and handling of CatalogInfo objects, which aligns with the ground truth's core message about the DAO providing data persistence and mapping between DAO and API model representations.",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.getCatalog",
    "predicted_relationship": "The getCatalog method in CatalogCli directly implements the functionality described in the documentation. The documentation specifies a 'getCatalog' operation that takes a 'name' parameter and returns a CatalogInfo object, which is exactly what this method does. The method signature 'private static String getCatalog(CatalogsApi catalogsApi, JSONObject json)' matches the described operation, where the 'name' parameter is extracted from the JSON object.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented getCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the core functionality of getCatalog but misses that this is specifically a CLI wrapper implementation rather than the direct API implementation",
      "error_type": "missing_crucial_context"
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogService.getCatalog",
    "predicted_relationship": "The getCatalog method in CatalogService implements the server-side functionality for retrieving a catalog as described in the documentation. It takes a 'name' parameter and returns a HttpResponse containing the catalog information, which aligns with the documented API endpoint.",
    "ground_truth_relationship": "The code implements the documented REST GET endpoint by accepting a name parameter and returning a JSON response containing catalog information, exactly matching the API specification's path parameter and response format requirements.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the main relationship - that the code implements a GET endpoint taking a name parameter and returning catalog information as JSON, which matches the documented API specification.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.getCatalog",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the CatalogRepository.getCatalog method is likely used to retrieve the catalog information from the database. This method implements the data access layer for the getCatalog operation described in the documentation.",
    "ground_truth_relationship": "The code directly implements the documented getCatalog operation by querying the database for a CatalogInfoDAO entity matching the specified name parameter using Hibernate's query language and returning a single result.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a data access method implementing the documented getCatalog operation, retrieving catalog information from the database. While less detailed than the ground truth, it captures the core relationship accurately.",
      "error_type": "none"
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogInfoDAO",
    "predicted_relationship": "The CatalogInfoDAO class is implicitly related to the getCatalog operation as it likely represents the data structure used to store and retrieve catalog information from the database. The documentation mentions returning a CatalogInfo object, which is probably mapped from this DAO.",
    "ground_truth_relationship": "The CatalogInfoDAO class provides the data persistence layer and mapping functionality for the CatalogInfo objects that are returned by the documented getCatalog endpoint through its toCatalogInfo() conversion method.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that CatalogInfoDAO is used for database persistence and maps to CatalogInfo objects. While it doesn't explicitly mention the toCatalogInfo() method, it correctly identifies the key purpose and relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "TableService.createTable",
    "predicted_relationship": "The documentation directly describes the 'createTable' operation, which is implemented by the TableService.createTable method. The method signature matches the documented API, taking a CreateTable object as input and returning a TableInfo object.",
    "ground_truth_relationship": "The code implements the documented POST endpoint by accepting a CreateTable request object, validating it's not null, delegating to the TABLE_REPOSITORY to create the table, and returning a TableInfo response wrapped in an HTTP JSON response, matching the documented input/output types and content types.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship between the code and documentation - that it's a table creation endpoint taking CreateTable input and returning TableInfo, with matching types. While it omits details about HTTP wrapping and null validation, these are minor implementation details that don't affect the fundamental relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "TableInfoDAO",
    "predicted_relationship": "The TableInfoDAO is likely used internally to persist and retrieve table information. While not explicitly mentioned, it's integral to the creation process as it represents the data access object for table information.",
    "ground_truth_relationship": "The TableInfoDAO class provides the persistence layer mapping and conversion logic for the TableInfo objects returned by the documented createTable API endpoint, handling the storage and retrieval of table metadata in the 'uc_tables' database table.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies TableInfoDAO's core purpose as an internal persistence/data access layer for table information, which aligns with the ground truth's explanation of it providing persistence layer mapping and conversion for TableInfo objects.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "TableRepository.createTable",
    "predicted_relationship": "The TableRepository.createTable method is likely called by the TableService to perform the actual table creation operation. It's not explicitly mentioned but is a crucial part of the implementation chain.",
    "ground_truth_relationship": "The code implements the documented createTable API by validating the table name, creating a new TableInfo object with the specified properties, checking for existing tables, rejecting MANAGED table types, requiring storage locations for external tables, and persisting the table data in a database transaction while handling errors as specified in the API documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies this as a table creation method but incorrectly suggests it's called by TableService, which is not evidenced in the code or documentation. The core table creation functionality is understood but the implementation chain assumption introduces speculation not supported by the evidence.",
      "error_type": "unsubstantiated_assumption"
    }
  },
  {
    "document_text": "<a name=\"listCatalogs\"></a>\n# **listCatalogs**\n> ListCatalogsResponse listCatalogs(page\\_token, max\\_results)\n\nList catalogs\n\n    Lists the available catalogs. There is no guarantee of a specific ordering of the elements in the list. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n| **max\\_results** | **Integer**| Maximum number of catalogs to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n\n### Return type\n\n[**ListCatalogsResponse**](../Models/ListCatalogsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.listCatalogs",
    "predicted_relationship": "The CatalogCli.listCatalogs method implements the listCatalogs functionality described in the documentation. The method takes similar parameters (maxResults and pageToken) and returns a list of catalogs, which aligns with the documented behavior.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listCatalogs endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - that the code implements a CLI wrapper for the documented listCatalogs endpoint. While the predicted text provides more implementation details, it doesn't contradict the ground truth.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listCatalogs\"></a>\n# **listCatalogs**\n> ListCatalogsResponse listCatalogs(page\\_token, max\\_results)\n\nList catalogs\n\n    Lists the available catalogs. There is no guarantee of a specific ordering of the elements in the list. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n| **max\\_results** | **Integer**| Maximum number of catalogs to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n\n### Return type\n\n[**ListCatalogsResponse**](../Models/ListCatalogsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.listCatalogs",
    "predicted_relationship": "The CatalogRepository.listCatalogs method likely implements the core functionality of listing catalogs as described in the documentation. It handles the maxResults and pageToken parameters, which correspond to the documented max_results and page_token parameters.",
    "ground_truth_relationship": "The code implements the documented listCatalogs endpoint by using database transactions and pagination logic to retrieve catalog records from storage, transform them into CatalogInfo objects with attached properties, and return them in a ListCatalogsResponse with the next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic functionality of listing catalogs and handling pagination parameters, but misses key implementation details about database transactions, property attachment, and transformation of DAOs to CatalogInfo objects that are crucial to understanding how the endpoint works",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"listCatalogs\"></a>\n# **listCatalogs**\n> ListCatalogsResponse listCatalogs(page\\_token, max\\_results)\n\nList catalogs\n\n    Lists the available catalogs. There is no guarantee of a specific ordering of the elements in the list. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n| **max\\_results** | **Integer**| Maximum number of catalogs to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n\n### Return type\n\n[**ListCatalogsResponse**](../Models/ListCatalogsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogService.listCatalogs",
    "predicted_relationship": "The CatalogService.listCatalogs method directly implements the listCatalogs API endpoint described in the documentation. It takes the same parameters (maxResults and pageToken) and likely returns a ListCatalogsResponse as specified in the documentation.",
    "ground_truth_relationship": "The code implements the documented REST endpoint by accepting optional maxResults and pageToken parameters, making a repository call, and returning a JSON response containing the list of catalogs in the format specified by ListCatalogsResponse.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship between the code and documentation - a REST endpoint that handles catalog listing with optional maxResults and pageToken parameters, returning JSON response. While it omits some implementation details, the main functionality alignment is accurately described.",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"deleteSchema\"></a>\n# **deleteSchema**\n> oas_any_type_not_mapped deleteSchema(full\\_name, force)\n\nDelete a schema\n\n    Deletes the specified schema from the parent catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaService.deleteSchema",
    "predicted_relationship": "The document describes a 'deleteSchema' operation which is directly implemented by the SchemaService.deleteSchema method. The method signature matches the documented parameters: 'full_name' (String) and 'force' (Boolean).",
    "ground_truth_relationship": "The code implements the documented DELETE endpoint by accepting a required fullName path parameter and optional force parameter, delegating schema deletion to SCHEMA_REPOSITORY, and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic purpose of schema deletion but refers to 'SchemaService.deleteSchema' instead of the actual 'SCHEMA_REPOSITORY.deleteSchema' implementation and omits mentioning the HTTP response aspect",
      "error_type": "incorrect_implementation_detail"
    }
  },
  {
    "document_text": "<a name=\"deleteSchema\"></a>\n# **deleteSchema**\n> oas_any_type_not_mapped deleteSchema(full\\_name, force)\n\nDelete a schema\n\n    Deletes the specified schema from the parent catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.deleteSchema",
    "predicted_relationship": "While not explicitly mentioned, the SchemaRepository.deleteSchema method is likely used by the SchemaService to perform the actual deletion of the schema from the database.",
    "ground_truth_relationship": "The code implements the documented schema deletion endpoint by recursively removing child tables, volumes, and functions before deleting the schema itself, while respecting the 'force' parameter and throwing a NOT_FOUND exception when the schema doesn't exist.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies this as a schema deletion operation but incorrectly states it uses a SchemaRepository class and misses key aspects like the handling of child elements and force parameter",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "<a name=\"listFunctions\"></a>\n# **listFunctions**\n> ListFunctionsResponse listFunctions(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList functions\n\n    List functions within the specified parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for functions of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of functions. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of functions to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query. | [optional] [default to null] |\n\n### Return type\n\n[**ListFunctionsResponse**](../Models/ListFunctionsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionCli.listFunctions",
    "predicted_relationship": "This method implements the client-side functionality for listing functions as described in the API documentation. It takes similar parameters (catalogName, schemaName, maxResults) and returns a list of functions, which aligns with the API's ListFunctionsResponse.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listFunctions endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the function's core purpose of listing functions with similar parameters, but misses that this is specifically a CLI wrapper around the API endpoint rather than just a client-side implementation.",
      "error_type": "missing_key_context"
    }
  },
  {
    "document_text": "<a name=\"listFunctions\"></a>\n# **listFunctions**\n> ListFunctionsResponse listFunctions(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList functions\n\n    List functions within the specified parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for functions of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of functions. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of functions to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query. | [optional] [default to null] |\n\n### Return type\n\n[**ListFunctionsResponse**](../Models/ListFunctionsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionService.listFunctions",
    "predicted_relationship": "This method directly implements the listFunctions API endpoint described in the documentation. It takes the same parameters (catalogName, schemaName, maxResults, pageToken) and returns a HttpResponse, which likely contains the ListFunctionsResponse.",
    "ground_truth_relationship": "The code implements a REST GET endpoint that takes the exact parameters specified in the documentation (catalog_name, schema_name, optional max_results, and optional page_token) and delegates the actual function listing to a repository layer, returning the results as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that this is a GET endpoint implementing the documented listFunctions API with the same parameters, returning the response as JSON. While it doesn't mention the repository delegation specifically, this is a minor implementation detail that doesn't affect the main API relationship being described.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listFunctions\"></a>\n# **listFunctions**\n> ListFunctionsResponse listFunctions(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList functions\n\n    List functions within the specified parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for functions of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of functions. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of functions to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query. | [optional] [default to null] |\n\n### Return type\n\n[**ListFunctionsResponse**](../Models/ListFunctionsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.listFunctions",
    "predicted_relationship": "This repository method is likely called by the FunctionService to retrieve the list of functions. It takes similar parameters (catalogName, schemaName, maxResults, pageToken) and probably returns data that forms the ListFunctionsResponse.",
    "ground_truth_relationship": "The code implements the documented behavior by retrieving function records from a database within a read-only transaction, transforming FunctionInfoDAO objects to FunctionInfo objects with attached properties, and returning them in a ListFunctionsResponse with pagination support through maxResults and pageToken parameters.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies this as a function listing service method, but misses key aspects about the implementation like the database transaction, data transformation, and pagination functionality mentioned in the ground truth.",
      "error_type": "major_omission"
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.updateCatalog",
    "predicted_relationship": "This method directly implements the updateCatalog functionality described in the documentation. It takes the catalog name and UpdateCatalog object as parameters, which matches the documented API. It also returns a CatalogInfo object, as specified in the 'Return type' section.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented updateCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the core updateCatalog functionality but misses that this is a CLI wrapper layer around the API, not a direct implementation",
      "error_type": "omitted_abstraction_layer"
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.updateCatalog",
    "predicted_relationship": "While not explicitly mentioned, this method is likely used by the CatalogCli.updateCatalog to perform the actual database operation for updating a catalog. It takes the catalog name and UpdateCatalog object as parameters, matching the API signature.",
    "ground_truth_relationship": "The code implements the documented API endpoint by validating the new catalog name, managing a database transaction to update the catalog's properties, name, and comment in a CatalogInfoDAO object, and handling error cases like NOT_FOUND and ALREADY_EXISTS as specified in the documentation's parameters and return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies this as a database operation for updating catalogs but incorrectly specifies it as being used by CatalogCli.updateCatalog, which is not mentioned in the code or documentation. The core update functionality is understood but the specific relationship is misattributed.",
      "error_type": "incorrect_relationship_attribution"
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogService.updateCatalog",
    "predicted_relationship": "This service method likely implements the HTTP endpoint for updating a catalog, as described in the documentation. It takes the catalog name and UpdateCatalog object as parameters, matching the API signature.",
    "ground_truth_relationship": "The code implements a PATCH endpoint that matches the documented API specifications by accepting a catalog name and UpdateCatalog object as parameters, invoking the repository layer, and returning a JSON HTTP response containing the updated CatalogInfo.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that this is an endpoint for updating a catalog with the specified parameters. While it omits implementation details about HTTP PATCH and repository layer mentioned in ground truth, these are minor details that don't change the fundamental relationship.",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogInfoDAO",
    "predicted_relationship": "This DAO (Data Access Object) is likely used to represent and persist the updated catalog information. The documentation mentions returning a CatalogInfo object, which is probably mapped from this DAO.",
    "ground_truth_relationship": "The CatalogInfoDAO class supports the updateCatalog endpoint by providing the data persistence layer and mapping functions (from/toCatalogInfo) that convert between the API's CatalogInfo model and the database entity representation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this is a DAO for catalog information persistence, but misses the crucial aspect that it specifically supports the updateCatalog endpoint through bidirectional mapping functions (from/toCatalogInfo)",
      "error_type": "incomplete_core_functionality"
    }
  },
  {
    "document_text": "<a name=\"deleteTable\"></a>\n# **deleteTable**\n> oas_any_type_not_mapped deleteTable(full\\_name)\n\nDelete a table\n\n    Deletes a table from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableCli.deleteTable",
    "predicted_relationship": "The TableCli.deleteTable method implements the deleteTable operation described in the documentation. While not explicitly mentioned, it matches the functionality of deleting a table using a full name parameter.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteTable endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - that this is an implementation of the documented deleteTable functionality that deletes a table using a full name parameter. While the ground truth specifically mentions it's a CLI wrapper, this detail doesn't change the fundamental relationship being described.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteTable\"></a>\n# **deleteTable**\n> oas_any_type_not_mapped deleteTable(full\\_name)\n\nDelete a table\n\n    Deletes a table from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableService.deleteTable",
    "predicted_relationship": "The TableService.deleteTable method directly implements the deleteTable operation described in the documentation. It matches the signature with a 'full_name' parameter and is annotated with @Delete, corresponding to the HTTP DELETE method implied in the documentation.",
    "ground_truth_relationship": "The code implements a REST DELETE endpoint that matches the documented API specification by accepting a full_name parameter, invoking TABLE_REPOSITORY.deleteTable(), and returning a 200 OK response with no content body.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that the code implements a DELETE endpoint matching the API documentation with the full_name parameter. While it omits mentioning the specific 200 OK response, this is a minor detail that doesn't change the fundamental relationship.",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"deleteTable\"></a>\n# **deleteTable**\n> oas_any_type_not_mapped deleteTable(full\\_name)\n\nDelete a table\n\n    Deletes a table from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableRepository.deleteTable",
    "predicted_relationship": "While not explicitly mentioned, TableRepository.deleteTable is likely used to perform the actual deletion of the table from the database. It's a crucial part of the deletion process described in the documentation.",
    "ground_truth_relationship": "The code implements the documented table deletion operation by removing the table's database entry, deleting its physical files (for managed tables), and cleaning up associated properties, while the documentation describes the API endpoint that exposes this functionality with a 'full_name' parameter.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction incorrectly assumes TableRepository.deleteTable is used, when the code shows direct implementation. However, it correctly recognizes this is about table deletion functionality.",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "# **updateVolume**\n> VolumeInfo updateVolume(name, UpdateVolumeRequestContent)\n\nUpdate a Volume\n\n    Updates the specified volume under the specified parent catalog and schema.  Currently only the name or the comment of the volume could be updated. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n| **UpdateVolumeRequestContent** | [**UpdateVolumeRequestContent**](../Models/UpdateVolumeRequestContent.md)|  | [optional] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeService.updateVolume",
    "predicted_relationship": "This method directly implements the updateVolume operation described in the documentation. The method signature matches the documented parameters: '@Param(\"full_name\") String fullName' corresponds to the 'name' parameter, and 'UpdateVolumeRequestContent updateVolumeRequest' matches the UpdateVolumeRequestContent parameter. The return type HttpResponse.ofJson() likely contains the VolumeInfo object as specified in the documentation.",
    "ground_truth_relationship": "The code implements a PATCH endpoint that takes a fully qualified volume name and UpdateVolumeRequestContent object as specified in the documentation, delegating the actual update operation to VOLUME_REPOSITORY and wrapping the returned VolumeInfo in an HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - a method that implements the documented updateVolume operation, taking the same parameters and returning VolumeInfo wrapped in an HTTP response",
      "error_type": ""
    }
  },
  {
    "document_text": "# **updateVolume**\n> VolumeInfo updateVolume(name, UpdateVolumeRequestContent)\n\nUpdate a Volume\n\n    Updates the specified volume under the specified parent catalog and schema.  Currently only the name or the comment of the volume could be updated. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n| **UpdateVolumeRequestContent** | [**UpdateVolumeRequestContent**](../Models/UpdateVolumeRequestContent.md)|  | [optional] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.updateVolume",
    "predicted_relationship": "This method is likely called by VolumeService.updateVolume to perform the actual update operation. It matches the signature described in the documentation, taking a name (String) and UpdateVolumeRequestContent as parameters, and returning a VolumeInfo object.",
    "ground_truth_relationship": "The code implements the documented volume update functionality by validating the new name if provided, handling the three-level namespace split, and using database transactions to modify either the volume's name or comment while preventing duplicate names and handling non-existent volumes as specified in the documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the basic purpose (update operation) and signature correctly, but misses crucial functionality around validation, transaction handling, and the core update behaviors (name/comment updates) described in the ground truth. The claim about being 'called by VolumeService' is speculative and not supported by evidence.",
      "error_type": "incomplete_core_functionality"
    }
  },
  {
    "document_text": "# **updateVolume**\n> VolumeInfo updateVolume(name, UpdateVolumeRequestContent)\n\nUpdate a Volume\n\n    Updates the specified volume under the specified parent catalog and schema.  Currently only the name or the comment of the volume could be updated. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n| **UpdateVolumeRequestContent** | [**UpdateVolumeRequestContent**](../Models/UpdateVolumeRequestContent.md)|  | [optional] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeInfoDAO",
    "predicted_relationship": "This class is likely used by VolumeRepository.updateVolume to interact with the database. It represents the data access object for volume information and would be used to persist the updated volume data.",
    "ground_truth_relationship": "The VolumeInfoDAO class implements the data persistence layer for volumes, with fields and conversion methods that match the VolumeInfo structure referenced in the updateVolume API documentation, particularly supporting the comment and name fields that are marked as updatable in the documentation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies this class as a DAO used for volume data persistence and its relationship to volume updates, which aligns with the ground truth's explanation of it being the data persistence layer supporting volume operations.",
      "error_type": ""
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.createTable",
    "predicted_relationship": "The documentation explicitly mentions a 'createTable' API endpoint with a POST request to '/tables'. This directly corresponds to the TableService.createTable method, which is annotated with @Post(\"\") and creates a table based on the request.",
    "ground_truth_relationship": "The createTable code method implements the POST /tables API endpoint documented in TablesApi by accepting a CreateTable request object, delegating to TABLE_REPOSITORY for table creation, and returning the response as JSON.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core relationship that this is a POST /tables endpoint implementation for table creation, matching the ground truth's description of mapping the API endpoint to the code functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.deleteTable",
    "predicted_relationship": "The documentation explicitly mentions a 'deleteTable' API endpoint with a DELETE request to '/tables/{full_name}'. This directly corresponds to the TableService.deleteTable method, which is annotated with @Delete(\"/{full_name}\") and deletes a table based on the full name.",
    "ground_truth_relationship": "The code implements the documented DELETE /tables/{full_name} endpoint by creating a method annotated with @Delete that takes a full_name parameter, deletes the corresponding table through the repository, and returns an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the main relationship between the code and documentation - both describe a DELETE endpoint at /tables/{full_name} that deletes a table by its full name.",
      "error_type": ""
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.getTable",
    "predicted_relationship": "The documentation explicitly mentions a 'getTable' API endpoint with a GET request to '/tables/{full_name}'. This directly corresponds to the TableService.getTable method, which is annotated with Get(\"/{full_name}\") and retrieves a table based on the full name.",
    "ground_truth_relationship": "The code implements the documented GET /tables/{full_name} endpoint by creating a method that retrieves a TableInfo object based on the full_name path parameter and returns it as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that this is a GET endpoint for /tables/{full_name} that retrieves table information. While it doesn't mention the JSON response specifically, it correctly identifies the main functionality and API mapping.",
      "error_type": ""
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.listTables",
    "predicted_relationship": "The documentation explicitly mentions a 'listTables' API endpoint with a GET request to '/tables'. This directly corresponds to the TableService.listTables method, which is annotated with @Get(\"\") and lists tables based on the provided parameters.",
    "ground_truth_relationship": "The document is an API endpoint summary table that lists the methods available and their description under the TablesApi. Each code is related to one of the methods.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the listTables GET endpoint, but focuses only on one method while the ground truth indicates this is a broader documentation of all available TableApi methods including create, delete, and get operations.",
      "error_type": "scope_too_narrow"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableRepository.createTable",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableRepository.createTable method is likely used by the TableService.createTable method to perform the actual table creation in the database.",
    "ground_truth_relationship": "The TableRepository.createTable method implements the backend logic for the experimental POST /tables API endpoint, handling table creation with validations for SQL object names, schema existence, and storage location requirements while preventing creation of managed tables.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures that this is a table creation method, but incorrectly assumes it's used by a TableService rather than directly implementing the POST /tables API endpoint. It misses the key validation and constraint aspects.",
      "error_type": "incorrect_architecture_assumption"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableRepository.deleteTable",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableRepository.deleteTable method is likely used by the TableService.deleteTable method to perform the actual table deletion in the database.",
    "ground_truth_relationship": "The deleteTable method implements the DELETE /tables/{full_name} API endpoint's backend logic by removing the table's metadata from the session, cleaning up associated properties, and deleting the physical directory for managed tables.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies this as a table deletion operation but incorrectly assumes it's a TableRepository method used by TableService, when it's actually implementing the DELETE API endpoint directly",
      "error_type": "incorrect_class_relationship"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableRepository.getTable",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableRepository.getTable method is likely used by the TableService.getTable method to retrieve the actual table information from the database.",
    "ground_truth_relationship": "The TableRepository.getTable method implements the backend database logic for the GET /tables/{full_name} API endpoint, retrieving a table's details from the database by parsing the full_name parameter into catalog, schema and table components and returning a TableInfo object with attached properties.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that the method retrieves table information, but assumes it's used by TableService rather than directly implementing the GET API endpoint. It misses the key detail about parsing the full_name parameter.",
      "error_type": "indirect_relationship_assumption"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableRepository.listTables",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableRepository.listTables method is likely used by the TableService.listTables method to retrieve the list of tables from the database.",
    "ground_truth_relationship": "The TableRepository.listTables code implements the GET /tables REST API endpoint by querying tables from a database session, applying pagination through maxResults and pageToken parameters, and returning a ListTablesResponse containing table information with optional properties and columns.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction correctly identifies that the code handles listing tables from a database, but presents it as a speculative relationship ('likely used by') when the code directly shows it implementing the GET /tables endpoint. It also misses key aspects like pagination and optional properties/columns.",
      "error_type": "incomplete_understanding"
    }
  },
  {
    "document_text": "<a name=\"listSchemas\"></a>\n# **listSchemas**\n> ListSchemasResponse listSchemas(catalog\\_name, max\\_results, page\\_token)\n\nList schemas\n\n    Gets an array of schemas for a catalog. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Parent catalog for schemas of interest. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of schemas to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n\n### Return type\n\n[**ListSchemasResponse**](../Models/ListSchemasResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaService.listSchemas",
    "predicted_relationship": "The SchemaService.listSchemas method directly implements the listSchemas operation described in the documentation. The method signature matches the documented parameters: catalog_name, max_results, and page_token. It returns a ListSchemasResponse object as specified in the documentation.",
    "ground_truth_relationship": "The code implements a GET endpoint that takes a catalog name and optional pagination parameters (max_results and page_token) to retrieve a list of schemas from SCHEMA_REPOSITORY, exactly matching the documented API endpoint's parameters and functionality.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core functionality of the code as a GET endpoint for listing schemas with matching parameters and return type, aligned with the documented API specification.",
      "error_type": "none"
    }
  },
  {
    "document_text": "<a name=\"listSchemas\"></a>\n# **listSchemas**\n> ListSchemasResponse listSchemas(catalog\\_name, max\\_results, page\\_token)\n\nList schemas\n\n    Gets an array of schemas for a catalog. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Parent catalog for schemas of interest. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of schemas to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n\n### Return type\n\n[**ListSchemasResponse**](../Models/ListSchemasResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.listSchemas",
    "predicted_relationship": "The SchemaService.listSchemas method likely uses SchemaRepository.listSchemas to fetch the actual schema data. This is inferred from the typical service-repository pattern, where the service delegates data access to a repository.",
    "ground_truth_relationship": "The code implements the documented listSchemas API endpoint by querying a database session for schemas matching the given catalog ID, converting the results from DAOs to SchemaInfo objects, handling pagination through maxResults and pageToken parameters, and returning a ListSchemasResponse containing the schema list and next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description suggests a service-repository pattern that isn't evident in the code. While it correctly implies data access functionality, the actual implementation uses direct database session handling rather than a repository pattern.",
      "error_type": "architectural_assumption"
    }
  },
  {
    "document_text": "# **getVolume**\n> VolumeInfo getVolume(name)\n\nGet a Volume\n\n    Gets a volume for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeService.getVolume",
    "predicted_relationship": "The documentation directly describes the 'getVolume' operation, which is implemented by the VolumeService.getVolume method. The method signature matches the documented parameters (name as a String) and return type (VolumeInfo).",
    "ground_truth_relationship": "The code implements the documented GET endpoint by accepting a required 'full_name' path parameter and an optional 'include_browse' query parameter, returning a JSON response containing volume information from the repository, though the documentation doesn't mention the optional parameter.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic functionality of getting volume information, but misses the optional 'include_browse' parameter and overstates the direct match with documentation by not acknowledging this discrepancy",
      "error_type": "omission_of_key_detail"
    }
  },
  {
    "document_text": "# **getVolume**\n> VolumeInfo getVolume(name)\n\nGet a Volume\n\n    Gets a volume for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.getVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.getVolume method is likely used by VolumeService.getVolume to retrieve the volume information from the repository.",
    "ground_truth_relationship": "The code implements the documented getVolume operation by splitting a three-level name parameter into catalog, schema, and volume components, validating the format, and returning a VolumeInfo object retrieved from the database through a DAO pattern.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that the method retrieves volume information, but introduces speculation about VolumeRepository/VolumeService layers that aren't evident in the code or documentation, while missing the core three-level name parsing functionality.",
      "error_type": "added_speculation_and_missing_core_functionality"
    }
  },
  {
    "document_text": "# **getVolume**\n> VolumeInfo getVolume(name)\n\nGet a Volume\n\n    Gets a volume for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeInfoDAO",
    "predicted_relationship": "The VolumeInfoDAO is likely used internally to represent the volume data in the database. It's not explicitly mentioned in the documentation but is crucial for the getVolume operation.",
    "ground_truth_relationship": "The VolumeInfoDAO class provides the data persistence layer and model conversion methods (toVolumeInfo/from) needed to support the documented getVolume API endpoint by mapping between the database representation and the VolumeInfo response type.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies VolumeInfoDAO's role in database representation but misses its crucial role in model conversion (toVolumeInfo/from methods) that directly supports the API endpoint",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"getFunction\"></a>\n# **getFunction**\n> FunctionInfo getFunction(name)\n\nGet a function\n\n    Gets a function from within a parent catalog and schema.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.getFunction",
    "predicted_relationship": "The documentation describes a 'getFunction' operation that retrieves a function given its fully-qualified name. This directly corresponds to the FunctionRepository.getFunction method, which implements this functionality on the server side.",
    "ground_truth_relationship": "The code implements the documented function retrieval by parsing a fully-qualified three-part function name (catalog.schema.function), querying a database session for the function details, and returning a FunctionInfo object as specified in the documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core functionality - retrieving a function by its fully-qualified name. While it's less detailed than the ground truth, it accurately represents the relationship between the documentation and code.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getFunction\"></a>\n# **getFunction**\n> FunctionInfo getFunction(name)\n\nGet a function\n\n    Gets a function from within a parent catalog and schema.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionService.getFunction",
    "predicted_relationship": "While not explicitly mentioned, the FunctionService.getFunction method is likely the service layer implementation that handles the API request described in the documentation. It would use the FunctionRepository to retrieve the function data.",
    "ground_truth_relationship": "The code implements a REST GET endpoint that accepts a fully-qualified function name as a path parameter and returns a JSON response containing the function details, directly mapping to the documented API endpoint specification and its expected FunctionInfo return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies that the code relates to function retrieval functionality but incorrectly speculates about a service layer implementation that isn't shown. The ground truth more accurately describes the actual REST endpoint implementation visible in the code.",
      "error_type": "unsubstantiated_speculation"
    }
  },
  {
    "document_text": "<a name=\"getFunction\"></a>\n# **getFunction**\n> FunctionInfo getFunction(name)\n\nGet a function\n\n    Gets a function from within a parent catalog and schema.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionInfoDAO",
    "predicted_relationship": "The documentation mentions returning a FunctionInfo object. FunctionInfoDAO likely represents the database entity for function information, which is converted to the FunctionInfo model returned by the API.",
    "ground_truth_relationship": "The FunctionInfoDAO class provides the data persistence layer that enables the documented getFunction endpoint by mapping database records to FunctionInfo objects through JPA annotations and conversion methods toFunctionInfo() and from().",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that FunctionInfoDAO represents the database entity mapping and converts to/from FunctionInfo objects returned by the API, which aligns with the core relationship described in the ground truth.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getSchema\"></a>\n# **getSchema**\n> SchemaInfo getSchema(full\\_name)\n\nGet a schema\n\n    Gets the specified schema for a catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.getSchema",
    "predicted_relationship": "The SchemaRepository.getSchema method directly implements the getSchema operation described in the documentation. It takes a 'fullName' parameter, which corresponds to the 'full_name' parameter in the API documentation. The method returns a SchemaInfo object, matching the return type specified in the documentation.",
    "ground_truth_relationship": "The code implements the documented getSchema operation by retrieving a schema from a database session, converting it from DAO format to SchemaInfo, and attaching properties, while handling the specified error case for when the schema is not found.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship between the code and documentation - that it implements the getSchema operation with matching parameter and return type. While it omits implementation details about database sessions and property attachment mentioned in the ground truth, these are minor technical details that don't change the fundamental relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getSchema\"></a>\n# **getSchema**\n> SchemaInfo getSchema(full\\_name)\n\nGet a schema\n\n    Gets the specified schema for a catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaService.getSchema",
    "predicted_relationship": "The SchemaService.getSchema method directly implements the getSchema operation described in the API documentation. It takes a 'fullName' parameter, matching the 'full_name' parameter in the documentation. The method likely returns a HttpResponse containing a SchemaInfo object, as specified in the API return type.",
    "ground_truth_relationship": "The code implements the documented GET endpoint with path parameter 'full_name' by returning a JSON HTTP response containing schema information retrieved from SCHEMA_REPOSITORY.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - implementing a GET endpoint that takes a full_name parameter and returns schema information as JSON. While it uses slightly different terminology, the fundamental understanding matches the ground truth.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getSchema\"></a>\n# **getSchema**\n> SchemaInfo getSchema(full\\_name)\n\nGet a schema\n\n    Gets the specified schema for a catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaInfoDAO",
    "predicted_relationship": "The SchemaInfoDAO class is likely used internally to represent the schema data in the database. While not explicitly mentioned in the documentation, it's implicitly needed to store and retrieve the schema information that is returned as SchemaInfo.",
    "ground_truth_relationship": "The SchemaInfoDAO class provides the data persistence and transformation layer for the SchemaInfo object that is returned by the documented getSchema endpoint, handling the mapping between database records and the API response model.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the key role of SchemaInfoDAO as an internal database representation class, which aligns with the ground truth's explanation of it being a data persistence/transformation layer. Both convey the same core relationship between database storage and SchemaInfo objects.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **listVolumes**\n> ListVolumesResponseContent listVolumes(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList Volumes\n\n    Gets an array of available volumes under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| The identifier of the catalog | [default to null] |\n| **schema\\_name** | **String**| The identifier of the schema | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of volumes to return (page length).  If not set, the page length is set to a server configured value. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  Note: this parameter controls only the maximum number of volumes to return. The actual number of volumes returned in a page may be smaller than this value, including 0, even if there are more pages.   | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token returned by a previous request. It must be included in the request to retrieve the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListVolumesResponseContent**](../Models/ListVolumesResponseContent.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.listVolumes",
    "predicted_relationship": "The VolumeRepository.listVolumes method directly implements the listVolumes functionality described in the documentation. It takes the same parameters (catalogName, schemaName, maxResults, pageToken) and returns a ListVolumesResponseContent object as specified in the API documentation.",
    "ground_truth_relationship": "The code implements the documented listVolumes API by querying volumes from a database using Hibernate, enforcing the documented parameters (catalog_name, schema_name, max_results, page_token) and returning a ListVolumesResponseContent object containing the filtered volume list.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core relationship - that the code implements the documented listVolumes API with the same parameters and return type. While it doesn't mention the database/Hibernate implementation details, this omission doesn't change the fundamental relationship being described.",
      "error_type": "none"
    }
  },
  {
    "document_text": "# **listVolumes**\n> ListVolumesResponseContent listVolumes(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList Volumes\n\n    Gets an array of available volumes under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| The identifier of the catalog | [default to null] |\n| **schema\\_name** | **String**| The identifier of the schema | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of volumes to return (page length).  If not set, the page length is set to a server configured value. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  Note: this parameter controls only the maximum number of volumes to return. The actual number of volumes returned in a page may be smaller than this value, including 0, even if there are more pages.   | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token returned by a previous request. It must be included in the request to retrieve the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListVolumesResponseContent**](../Models/ListVolumesResponseContent.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeService.listVolumes",
    "predicted_relationship": "The VolumeService.listVolumes method directly implements the API endpoint described in the documentation. It takes the same parameters (catalogName, schemaName, maxResults, pageToken) and likely calls the VolumeRepository to fetch the data.",
    "ground_truth_relationship": "The code implements the documented listVolumes API endpoint as a GET HTTP method that accepts the specified catalog_name, schema_name, max_results, and page_token parameters, though it includes an additional undocumented include_browse parameter, and returns a JSON response from the volume repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - that this is an API endpoint implementation of listVolumes with the documented parameters that uses a repository to fetch data. The omission of the include_browse parameter and HTTP GET specifics are minor details that don't change the fundamental relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getTable\"></a>\n# **getTable**\n> TableInfo getTable(full\\_name)\n\nGet a table\n\n    Gets a table for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableRepository.getTable",
    "predicted_relationship": "The documentation describes a 'getTable' operation that takes a 'full_name' parameter and returns a TableInfo object. This directly corresponds to the TableRepository.getTable method, which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented getTable operation by parsing a fully qualified table name into catalog, schema, and table components, retrieving the table information from a database session, and returning a TableInfo object with attached properties, exactly matching the documented input parameter and return type specifications.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship between the documentation and code - that it's a getTable operation taking a full_name parameter and returning TableInfo. While it omits implementation details, the high-level relationship is correctly identified.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getTable\"></a>\n# **getTable**\n> TableInfo getTable(full\\_name)\n\nGet a table\n\n    Gets a table for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableService.getTable",
    "predicted_relationship": "While not explicitly mentioned, the TableService.getTable method is likely the service-layer implementation of the documented API endpoint, acting as an intermediary between the API and the repository.",
    "ground_truth_relationship": "The code implements a REST endpoint annotated with @Get that takes a full_name parameter, validates it's not null, retrieves table information via TABLE_REPOSITORY, and returns it as JSON - matching the documented API endpoint behavior, parameter requirements, and TableInfo return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction correctly identifies this as a table retrieval service method, but incorrectly assumes it's a service layer implementation when it's actually a REST endpoint controller method directly handling the HTTP request.",
      "error_type": "architectural_misunderstanding"
    }
  },
  {
    "document_text": "<a name=\"getTable\"></a>\n# **getTable**\n> TableInfo getTable(full\\_name)\n\nGet a table\n\n    Gets a table for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableInfoDAO",
    "predicted_relationship": "The documentation mentions returning a TableInfo object. TableInfoDAO is likely used internally to represent the table data before converting to the API response.",
    "ground_truth_relationship": "The TableInfoDAO class provides the data persistence layer and model conversion methods that enable the documented getTable API endpoint to retrieve and return table information in the expected TableInfo format.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures that TableInfoDAO is used internally to represent table data before converting to the TableInfo API response format, which aligns with the ground truth's explanation of it being the data persistence layer that enables the getTable API endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listCatalogs\"></a>\n# **listCatalogs**\n> ListCatalogsResponse listCatalogs(page\\_token, max\\_results)\n\nList catalogs\n\n    Lists the available catalogs. There is no guarantee of a specific ordering of the elements in the list. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n| **max\\_results** | **Integer**| Maximum number of catalogs to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n\n### Return type\n\n[**ListCatalogsResponse**](../Models/ListCatalogsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.listCatalogs",
    "predicted_relationship": "The CatalogCli.listCatalogs method likely implements the functionality described in the documentation. The documentation specifies a 'listCatalogs' operation with optional 'page_token' and 'max_results' parameters, which aligns with the method signature in the code artifact.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listCatalogs endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - that this implements the documented listCatalogs functionality. While it doesn't explicitly mention the CLI wrapper aspect, it correctly identifies the alignment between the code and documented API endpoint.",
      "error_type": "none"
    }
  },
  {
    "document_text": "<a name=\"listCatalogs\"></a>\n# **listCatalogs**\n> ListCatalogsResponse listCatalogs(page\\_token, max\\_results)\n\nList catalogs\n\n    Lists the available catalogs. There is no guarantee of a specific ordering of the elements in the list. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n| **max\\_results** | **Integer**| Maximum number of catalogs to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n\n### Return type\n\n[**ListCatalogsResponse**](../Models/ListCatalogsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.listCatalogs",
    "predicted_relationship": "The CatalogRepository.listCatalogs method likely implements the core logic for listing catalogs as described in the documentation. It handles the optional 'maxResults' and 'pageToken' parameters, which correspond to the 'max_results' and 'page_token' parameters in the API documentation.",
    "ground_truth_relationship": "The code implements the documented listCatalogs endpoint by using database transactions and pagination logic to retrieve catalog records from storage, transform them into CatalogInfo objects with attached properties, and return them in a ListCatalogsResponse with the next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the core listing functionality and pagination parameters, but misses crucial aspects like transaction handling, database storage, property attachment, and the transformation of DAOs to CatalogInfo objects described in the ground truth",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"listCatalogs\"></a>\n# **listCatalogs**\n> ListCatalogsResponse listCatalogs(page\\_token, max\\_results)\n\nList catalogs\n\n    Lists the available catalogs. There is no guarantee of a specific ordering of the elements in the list. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n| **max\\_results** | **Integer**| Maximum number of catalogs to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n\n### Return type\n\n[**ListCatalogsResponse**](../Models/ListCatalogsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogService.listCatalogs",
    "predicted_relationship": "The CatalogService.listCatalogs method directly implements the listCatalogs operation described in the documentation. It takes the same parameters (maxResults and pageToken) as optional, matching the API specification.",
    "ground_truth_relationship": "The code implements the documented REST endpoint by accepting optional maxResults and pageToken parameters, making a repository call, and returning a JSON response containing the list of catalogs in the format specified by ListCatalogsResponse.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that the code implements the documented endpoint with matching optional parameters and returns catalog listings. While it doesn't mention the specific return format or repository call, these are minor details that don't change the fundamental relationship.",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"deleteCatalog\"></a>\n# **deleteCatalog**\n> oas_any_type_not_mapped deleteCatalog(name, force)\n\nDelete a catalog\n\n    Deletes the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.deleteCatalog",
    "predicted_relationship": "This method directly implements the deleteCatalog functionality described in the documentation. It takes the same parameters 'name' and 'force' as mentioned in the documentation, and performs the deletion of a catalog.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the deleteCatalog functionality and parameters, but misses the crucial aspect that this is a CLI wrapper around the API endpoint rather than a direct implementation",
      "error_type": "omission_of_wrapper_nature"
    }
  },
  {
    "document_text": "<a name=\"deleteCatalog\"></a>\n# **deleteCatalog**\n> oas_any_type_not_mapped deleteCatalog(name, force)\n\nDelete a catalog\n\n    Deletes the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.deleteCatalog",
    "predicted_relationship": "While not explicitly mentioned in the documentation, this method is likely used by the CatalogCli.deleteCatalog to perform the actual deletion of the catalog in the repository.",
    "ground_truth_relationship": "The code implements the documented deleteCatalog operation by handling catalog deletion with optional force removal of schemas, throwing appropriate exceptions if the catalog is not found (ErrorCode.NOT_FOUND) or contains schemas without force flag (ErrorCode.FAILED_PRECONDITION), and managing the transaction across catalog, schema, and property deletions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction identifies this as a deletion method but overly narrows its usage to CatalogCli.deleteCatalog and misses key functionality around force deletion, schema handling, and error conditions that are central to the method's behavior.",
      "error_type": "incomplete_core_functionality"
    }
  },
  {
    "document_text": "<a name=\"deleteCatalog\"></a>\n# **deleteCatalog**\n> oas_any_type_not_mapped deleteCatalog(name, force)\n\nDelete a catalog\n\n    Deletes the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogService.deleteCatalog",
    "predicted_relationship": "This service method is likely used to handle the HTTP request for deleting a catalog, as mentioned in the documentation's 'HTTP request headers' section.",
    "ground_truth_relationship": "The code implements a DELETE endpoint that directly mirrors the documented API behavior by accepting a required 'name' parameter and optional 'force' parameter, invoking the catalog repository's deletion logic, and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "While the predicted description correctly identifies this as a service method for handling catalog deletion, it omits crucial aspects of the functionality like the parameters and response behavior that are central to understanding the relationship between code and documentation.",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"listSchemas\"></a>\n# **listSchemas**\n> ListSchemasResponse listSchemas(catalog\\_name, max\\_results, page\\_token)\n\nList schemas\n\n    Gets an array of schemas for a catalog. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Parent catalog for schemas of interest. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of schemas to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n\n### Return type\n\n[**ListSchemasResponse**](../Models/ListSchemasResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaService.listSchemas",
    "predicted_relationship": "The documentation directly describes the 'listSchemas' operation, which is implemented by the SchemaService.listSchemas method. The method signature matches the documented parameters: catalog_name, max_results, and page_token. It also returns a ListSchemasResponse object as specified in the documentation.",
    "ground_truth_relationship": "The code implements a GET endpoint that takes a catalog name and optional pagination parameters (max_results and page_token) to retrieve a list of schemas from SCHEMA_REPOSITORY, exactly matching the documented API endpoint's parameters and functionality.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions accurately capture the core function of a GET endpoint that lists schemas using a catalog name and pagination parameters, returning schema data through the SCHEMA_REPOSITORY. The predicted description aligns with the ground truth's main points about parameters and functionality.",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"listSchemas\"></a>\n# **listSchemas**\n> ListSchemasResponse listSchemas(catalog\\_name, max\\_results, page\\_token)\n\nList schemas\n\n    Gets an array of schemas for a catalog. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Parent catalog for schemas of interest. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of schemas to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n\n### Return type\n\n[**ListSchemasResponse**](../Models/ListSchemasResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.listSchemas",
    "predicted_relationship": "While not explicitly mentioned, the SchemaService.listSchemas method likely delegates the actual schema listing operation to SchemaRepository.listSchemas. This repository method would handle the database interaction to retrieve the schema list based on the provided parameters.",
    "ground_truth_relationship": "The code implements the documented listSchemas API endpoint by querying a database session for schemas matching the given catalog ID, converting the results from DAOs to SchemaInfo objects, handling pagination through maxResults and pageToken parameters, and returning a ListSchemasResponse containing the schema list and next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that listSchemas involves database interaction, but incorrectly assumes there's a separate SchemaRepository class delegation when the code shows direct database interaction within the service method itself",
      "error_type": "incorrect_implementation_assumption"
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionCli.createFunction",
    "predicted_relationship": "The FunctionCli.createFunction method likely implements the createFunction operation described in the documentation. The documentation specifies a CreateFunctionRequest parameter and returns a FunctionInfo object, which aligns with the method signature in the code.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures that it implements the documented createFunction operation, but misses that it's specifically a CLI wrapper layer rather than the direct implementation",
      "error_type": "incomplete_understanding"
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.createFunction",
    "predicted_relationship": "The FunctionRepository.createFunction method likely implements the core logic for creating a function as described in the API documentation. It would handle the persistence of the new function based on the CreateFunctionRequest data.",
    "ground_truth_relationship": "The code implements the documented createFunction API endpoint by validating the input function name, constructing a FunctionInfo object with all required properties, and persisting it in a database transaction while handling schema validation and duplicate function checks.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the core purpose and relationship - that the method handles creating and persisting a function based on the CreateFunctionRequest. While it omits implementation details like validation and transaction handling, it captures the main functionality accurately.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionService.createFunction",
    "predicted_relationship": "The FunctionService.createFunction method directly implements the createFunction operation described in the API documentation. It takes a CreateFunctionRequest parameter and returns a FunctionInfo object, matching the documented interface.",
    "ground_truth_relationship": "The code implements the documented REST API endpoint by exposing a POST method that accepts a CreateFunctionRequest object, delegates to FUNCTION_REPOSITORY for function creation, and returns the result wrapped in an HTTP JSON response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the core function creation functionality but misses the key HTTP/REST aspects - that it's a POST endpoint returning an HTTP response with JSON",
      "error_type": "missing_key_aspects"
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionInfoDAO",
    "predicted_relationship": "The FunctionInfoDAO class is likely used to persist and retrieve the FunctionInfo data that is returned by the createFunction operation. It represents the data access object for function information.",
    "ground_truth_relationship": "The FunctionInfoDAO class provides the database persistence layer and object mapping functionality that enables the createFunction API endpoint to store and retrieve function metadata in the uc_functions table, converting between the API's FunctionInfo model and its database representation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core purpose of FunctionInfoDAO as a data access/persistence layer for FunctionInfo data, which aligns with the ground truth's description of its role in storing and retrieving function metadata.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.updateCatalog",
    "predicted_relationship": "The method CatalogCli.updateCatalog directly implements the updateCatalog operation described in the documentation. It takes the catalog name and UpdateCatalog object as parameters, which matches the documentation's description of the API endpoint.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented updateCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the relationship with the documented updateCatalog operation but misses that this is specifically a CLI wrapper implementation rather than a direct implementation",
      "error_type": "missing_abstraction_layer"
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.updateCatalog",
    "predicted_relationship": "While not explicitly mentioned, CatalogRepository.updateCatalog is likely the underlying implementation that performs the actual update operation on the catalog data. It would handle the database interaction based on the UpdateCatalog input.",
    "ground_truth_relationship": "The code implements the documented API endpoint by validating the new catalog name, managing a database transaction to update the catalog's properties, name, and comment in a CatalogInfoDAO object, and handling error cases like NOT_FOUND and ALREADY_EXISTS as specified in the documentation's parameters and return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction correctly identifies this as a catalog update operation, but incorrectly assumes it's using a CatalogRepository class when the code shows direct database interaction using Session/Transaction objects, CatalogInfoDAO and PropertyRepository",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogService.updateCatalog",
    "predicted_relationship": "CatalogService.updateCatalog directly implements the updateCatalog operation described in the documentation. It takes the name parameter and UpdateCatalog object, matching the API specification.",
    "ground_truth_relationship": "The code implements a PATCH endpoint that matches the documented API specifications by accepting a catalog name and UpdateCatalog object as parameters, invoking the repository layer, and returning a JSON HTTP response containing the updated CatalogInfo.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic functionality but omits key details about the HTTP PATCH endpoint, response format, and repository layer interaction that are central to the ground truth's description of the relationship",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogInfoDAO",
    "predicted_relationship": "While not explicitly mentioned, CatalogInfoDAO is likely used to represent the catalog data in the database. The updateCatalog operation would involve updating a CatalogInfoDAO object.",
    "ground_truth_relationship": "The CatalogInfoDAO class supports the updateCatalog endpoint by providing the data persistence layer and mapping functions (from/toCatalogInfo) that convert between the API's CatalogInfo model and the database entity representation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies CatalogInfoDAO's role in database representation but misses its crucial mapping functionality between API and database layers mentioned in the ground truth",
      "error_type": "major_omission"
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeService.createVolume",
    "predicted_relationship": "This artifact directly implements the createVolume operation described in the documentation. The method signature 'createVolume(CreateVolumeRequestContent createVolumeRequest)' matches the documented API, and it returns a VolumeInfo object as specified.",
    "ground_truth_relationship": "The code implements the documented API endpoint by accepting a CreateVolumeRequestContent parameter and returning a JSON HTTP response containing the created volume information, matching the documented input/output specifications and HTTP headers.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship that the code implements the documented API by accepting CreateVolumeRequestContent and returning volume information, even though it doesn't explicitly mention HTTP headers",
      "error_type": null
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.createVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, this artifact is likely used by VolumeService.createVolume to perform the actual volume creation operation. It handles the business logic and data persistence for creating a new volume.",
    "ground_truth_relationship": "The code implements the documented createVolume operation by validating inputs, creating a VolumeInfo object with a UUID, validating volume type and storage location, and persisting it to the database within a transaction while enforcing schema existence and volume uniqueness constraints.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that this is a volume creation operation that handles business logic and data persistence, which aligns with the ground truth's description of creating and persisting VolumeInfo objects. While the ground truth provides more implementation details, the core relationship and purpose is correctly identified.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeInfoDAO",
    "predicted_relationship": "This artifact is likely used to map between the VolumeInfo object (mentioned in the return type) and the database representation of a volume. It's not explicitly mentioned but is crucial for persisting and retrieving volume data.",
    "ground_truth_relationship": "The VolumeInfoDAO class provides the data persistence layer and mapping functionality for the createVolume API endpoint by defining the database schema and conversion methods between the API's VolumeInfo model and the database representation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a mapping/persistence layer between VolumeInfo objects and their database representation. While it doesn't explicitly mention the createVolume API endpoint, it captures the core functionality of data persistence and object mapping.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeCli.createVolume",
    "predicted_relationship": "While not directly mentioned in the server-side API documentation, this CLI method likely provides a command-line interface for creating volumes, utilizing the same CreateVolumeRequestContent structure mentioned in the API doc.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createVolume endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions identify that this code is a CLI wrapper/interface for the documented createVolume API endpoint. The predicted description captures the essential relationship even if it's less direct in its phrasing.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.createCatalog",
    "predicted_relationship": "The documentation explicitly mentions 'createCatalog' as a POST method for creating a catalog. This directly corresponds to the CatalogCli.createCatalog method which implements this functionality.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - that there is a correspondence between the code's createCatalog method and the documented POST /catalogs endpoint. Both descriptions recognize this is an implementation of the catalog creation API functionality.",
      "error_type": null
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.deleteCatalog",
    "predicted_relationship": "The documentation explicitly mentions 'deleteCatalog' as a DELETE method for deleting a catalog. This directly corresponds to the CatalogCli.deleteCatalog method which implements this functionality.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code relates to the documented deleteCatalog DELETE endpoint, even though it doesn't explicitly mention it being a CLI wrapper. This omission is minor as the core relationship is captured.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.getCatalog",
    "predicted_relationship": "The documentation explicitly mentions 'getCatalog' as a GET method for retrieving a catalog. This directly corresponds to the CatalogCli.getCatalog method which implements this functionality.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented getCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented getCatalog GET endpoint functionality, which aligns with the ground truth's statement about it being a CLI wrapper for the getCatalog endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.listCatalogs",
    "predicted_relationship": "The documentation explicitly mentions 'listCatalogs' as a GET method for listing catalogs. This directly corresponds to the CatalogCli.listCatalogs method which implements this functionality.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listCatalogs endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code relates to the documented listCatalogs GET endpoint, even though it doesn't explicitly mention it being a CLI wrapper.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.updateCatalog",
    "predicted_relationship": "The documentation explicitly mentions 'updateCatalog' as a PATCH method for updating a catalog. This directly corresponds to the CatalogCli.updateCatalog method which implements this functionality.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented updateCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented updateCatalog PATCH endpoint functionality, which aligns with the ground truth's statement about it being a CLI wrapper for the updateCatalog endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.createCatalog",
    "predicted_relationship": "While not explicitly mentioned in the documentation, CatalogService.createCatalog is implicitly related as it would be the service layer implementation of the createCatalog API endpoint.",
    "ground_truth_relationship": "The code implements the documented POST /catalogs endpoint through a @Post-annotated method that accepts a CreateCatalog object and returns a JSON response from the catalog repository's add operation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies this as related to the catalog creation functionality, but incorrectly assumes a CatalogService layer that isn't shown in the code. The code directly uses a repository pattern instead.",
      "error_type": "incorrect_implementation_assumption"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.deleteCatalog",
    "predicted_relationship": "While not explicitly mentioned in the documentation, CatalogService.deleteCatalog is implicitly related as it would be the service layer implementation of the deleteCatalog API endpoint.",
    "ground_truth_relationship": "Rep handler method that accepts a catalog name parameter and an optional force parameter, and returns a 200 OK response after delegating the deletion to a repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted text correctly indicates it's related to catalog deletion functionality but incorrectly assumes a service layer implementation when it's actually a repository pattern being used",
      "error_type": "architectural_misunderstanding"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.getCatalog",
    "predicted_relationship": "While not explicitly mentioned in the documentation, CatalogService.getCatalog is implicitly related as it would be the service layer implementation of the getCatalog API endpoint.",
    "ground_truth_relationship": "The code implements the documented GET /catalogs/{name} endpoint by creating a method annotated with @Get that takes a name parameter and returns a catalog object as JSON via the repository layer.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction correctly identifies that it relates to the getCatalog functionality but incorrectly assumes a service layer when the code shows direct repository usage",
      "error_type": "architectural_misunderstanding"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.listCatalogs",
    "predicted_relationship": "While not explicitly mentioned in the documentation, CatalogService.listCatalogs is implicitly related as it would be the service layer implementation of the listCatalogs API endpoint.",
    "ground_truth_relationship": "The listCatalogs code implements the documented GET /catalogs endpoint by accepting optional pagination parameters (max_results and page_token) and returning a JSON response of catalogs from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "While the predicted text correctly identifies a relationship between the code and API endpoint, it incorrectly assumes a service layer implementation when the code shows direct repository usage (CATALOG_REPOSITORY) instead.",
      "error_type": "architectural_assumption"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.updateCatalog",
    "predicted_relationship": "While not explicitly mentioned in the documentation, CatalogService.updateCatalog is implicitly related as it would be the service layer implementation of the updateCatalog API endpoint.",
    "ground_truth_relationship": "The code implements the documented PATCH /catalogs/{name} endpoint by providing a method that accepts a catalog name parameter and update payload, returning the updated catalog as JSON via HttpResponse.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies a relationship with the updateCatalog functionality but incorrectly assumes it's through a CatalogService layer rather than directly implementing the PATCH endpoint via HttpResponse",
      "error_type": "architectural_assumption"
    }
  },
  {
    "document_text": "# **updateVolume**\n> VolumeInfo updateVolume(name, UpdateVolumeRequestContent)\n\nUpdate a Volume\n\n    Updates the specified volume under the specified parent catalog and schema.  Currently only the name or the comment of the volume could be updated. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n| **UpdateVolumeRequestContent** | [**UpdateVolumeRequestContent**](../Models/UpdateVolumeRequestContent.md)|  | [optional] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeService.updateVolume",
    "predicted_relationship": "The documentation directly describes the 'updateVolume' operation, which is implemented by the VolumeService.updateVolume method. The method signature matches the documented parameters: a String for the volume name and an UpdateVolumeRequestContent object. It also returns a VolumeInfo object as specified in the documentation.",
    "ground_truth_relationship": "The code implements a PATCH endpoint that takes a fully qualified volume name and UpdateVolumeRequestContent object as specified in the documentation, delegating the actual update operation to VOLUME_REPOSITORY and wrapping the returned VolumeInfo in an HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the core update functionality and parameters but misses the HTTP-specific aspects (PATCH endpoint, HTTP response wrapping) that are central to the ground truth description",
      "error_type": "incomplete_context"
    }
  },
  {
    "document_text": "# **updateVolume**\n> VolumeInfo updateVolume(name, UpdateVolumeRequestContent)\n\nUpdate a Volume\n\n    Updates the specified volume under the specified parent catalog and schema.  Currently only the name or the comment of the volume could be updated. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n| **UpdateVolumeRequestContent** | [**UpdateVolumeRequestContent**](../Models/UpdateVolumeRequestContent.md)|  | [optional] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.updateVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.updateVolume method is likely used by VolumeService.updateVolume to perform the actual update operation on the volume data. This method takes the same parameters (name and UpdateVolumeRequestContent) and returns a VolumeInfo object, aligning with the documented behavior.",
    "ground_truth_relationship": "The code implements the documented volume update functionality by validating the new name if provided, handling the three-level namespace split, and using database transactions to modify either the volume's name or comment while preventing duplicate names and handling non-existent volumes as specified in the documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the basic update functionality and return types, but introduces speculation about VolumeRepository/VolumeService architecture that isn't present in the actual implementation, which directly handles the update logic",
      "error_type": "added_speculation"
    }
  },
  {
    "document_text": "# **updateVolume**\n> VolumeInfo updateVolume(name, UpdateVolumeRequestContent)\n\nUpdate a Volume\n\n    Updates the specified volume under the specified parent catalog and schema.  Currently only the name or the comment of the volume could be updated. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n| **UpdateVolumeRequestContent** | [**UpdateVolumeRequestContent**](../Models/UpdateVolumeRequestContent.md)|  | [optional] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeInfoDAO",
    "predicted_relationship": "The VolumeInfoDAO class is likely used internally to represent and manipulate the volume data. While not explicitly mentioned in the documentation, it's an essential part of the update process, converting between the VolumeInfo model and the database representation.",
    "ground_truth_relationship": "The VolumeInfoDAO class implements the data persistence layer for volumes, with fields and conversion methods that match the VolumeInfo structure referenced in the updateVolume API documentation, particularly supporting the comment and name fields that are marked as updatable in the documentation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies VolumeInfoDAO as an internal representation for volume data handling and conversion, which aligns with the ground truth's description of it implementing the data persistence layer and supporting the volume update functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.getCatalog",
    "predicted_relationship": "The documentation explicitly describes a 'getCatalog' operation, which is directly implemented by the CatalogCli.getCatalog method. The method signature matches the documented operation, taking a 'name' parameter and returning a CatalogInfo object.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented getCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the getCatalog operation but misses that this is a CLI wrapper layer over the API, presenting it as a direct implementation",
      "error_type": "omitted_architectural_layer"
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogService.getCatalog",
    "predicted_relationship": "While not explicitly mentioned in the documentation, CatalogService.getCatalog likely implements the server-side logic for the getCatalog operation. It matches the described functionality of retrieving a catalog by name.",
    "ground_truth_relationship": "The code implements the documented REST GET endpoint by accepting a name parameter and returning a JSON response containing catalog information, exactly matching the API specification's path parameter and response format requirements.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core functionality of a GET endpoint retrieving catalog information by name, which aligns with the ground truth's description of the REST endpoint implementation.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.getCatalog",
    "predicted_relationship": "Though not directly mentioned, CatalogRepository.getCatalog is likely used in the implementation chain to retrieve the catalog information from the data store.",
    "ground_truth_relationship": "The code directly implements the documented getCatalog operation by querying the database for a CatalogInfoDAO entity matching the specified name parameter using Hibernate's query language and returning a single result.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction correctly suggests this is about retrieving catalog information, but incorrectly assumes it uses a CatalogRepository intermediary when the code shows direct database querying via Hibernate",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogInfoDAO",
    "predicted_relationship": "CatalogInfoDAO is implicitly related as it likely represents the data access object for the CatalogInfo mentioned in the return type of the documentation.",
    "ground_truth_relationship": "The CatalogInfoDAO class provides the data persistence layer and mapping functionality for the CatalogInfo objects that are returned by the documented getCatalog endpoint through its toCatalogInfo() conversion method.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies CatalogInfoDAO as the data access object that represents/maps to CatalogInfo, which aligns with the ground truth's explanation of it being the persistence layer for CatalogInfo objects",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"getFunction\"></a>\n# **getFunction**\n> FunctionInfo getFunction(name)\n\nGet a function\n\n    Gets a function from within a parent catalog and schema.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.getFunction",
    "predicted_relationship": "The FunctionRepository.getFunction method likely implements the core functionality described in the documentation. The documentation specifies a 'getFunction' operation that retrieves a function given its fully-qualified name, which aligns with the method signature and purpose of FunctionRepository.getFunction.",
    "ground_truth_relationship": "The code implements the documented function retrieval by parsing a fully-qualified three-part function name (catalog.schema.function), querying a database session for the function details, and returning a FunctionInfo object as specified in the documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core functionality of retrieving a function by its fully-qualified name, which aligns with both the code implementation and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getFunction\"></a>\n# **getFunction**\n> FunctionInfo getFunction(name)\n\nGet a function\n\n    Gets a function from within a parent catalog and schema.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionService.getFunction",
    "predicted_relationship": "The FunctionService.getFunction method directly implements the API endpoint described in the documentation. It matches the operation name 'getFunction' and takes a 'name' parameter as specified in the documentation.",
    "ground_truth_relationship": "The code implements a REST GET endpoint that accepts a fully-qualified function name as a path parameter and returns a JSON response containing the function details, directly mapping to the documented API endpoint specification and its expected FunctionInfo return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that the code implements a GET endpoint taking a name parameter and returning function information, matching the documented API specification.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getFunction\"></a>\n# **getFunction**\n> FunctionInfo getFunction(name)\n\nGet a function\n\n    Gets a function from within a parent catalog and schema.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionInfoDAO",
    "predicted_relationship": "The FunctionInfoDAO is likely used to represent the function data in the database. The documentation mentions returning a FunctionInfo object, which would be created from the FunctionInfoDAO data.",
    "ground_truth_relationship": "The FunctionInfoDAO class provides the data persistence layer that enables the documented getFunction endpoint by mapping database records to FunctionInfo objects through JPA annotations and conversion methods toFunctionInfo() and from().",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that FunctionInfoDAO represents function data in the database and handles conversion to/from FunctionInfo objects, which aligns with the ground truth's explanation of it being a data persistence layer that maps database records to FunctionInfo objects.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createSchema\"></a>\n# **createSchema**\n> SchemaInfo createSchema(CreateSchema)\n\nCreate a schema\n\n    Creates a new schema in the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateSchema** | [**CreateSchema**](../Models/CreateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaService.createSchema",
    "predicted_relationship": "The documentation explicitly describes the 'createSchema' operation, which is directly implemented by the SchemaService.createSchema method. The method signature in the documentation matches the artifact, taking a CreateSchema object and returning a SchemaInfo object.",
    "ground_truth_relationship": "The code implements the documented REST endpoint by accepting a CreateSchema object via POST request and returning a JSON HTTP response containing the schema created through the SCHEMA_REPOSITORY.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the core operation but misses the HTTP/REST aspects and incorrectly references 'SchemaService' instead of 'SCHEMA_REPOSITORY'",
      "error_type": "missing_key_aspects"
    }
  },
  {
    "document_text": "<a name=\"createSchema\"></a>\n# **createSchema**\n> SchemaInfo createSchema(CreateSchema)\n\nCreate a schema\n\n    Creates a new schema in the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateSchema** | [**CreateSchema**](../Models/CreateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.createSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.createSchema method is likely used by the SchemaService to perform the actual schema creation operation in the database.",
    "ground_truth_relationship": "The code fully implements the documented API endpoint by validating the schema name, checking for existing schemas, persisting the new schema with its properties in a database transaction, and returning a SchemaInfo object as specified in the documentation's return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly notes this is schema creation functionality but incorrectly suggests it's part of a SchemaRepository used by SchemaService, when the code shows it's a standalone method directly implementing the documented API endpoint",
      "error_type": "incorrect_architectural_assumption"
    }
  },
  {
    "document_text": "<a name=\"createSchema\"></a>\n# **createSchema**\n> SchemaInfo createSchema(CreateSchema)\n\nCreate a schema\n\n    Creates a new schema in the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateSchema** | [**CreateSchema**](../Models/CreateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaInfoDAO",
    "predicted_relationship": "The SchemaInfoDAO is likely used internally to map between the SchemaInfo model and the database representation of a schema.",
    "ground_truth_relationship": "The SchemaInfoDAO class provides the data persistence layer and conversion methods (from/toSchemaInfo) that enable storing and retrieving the SchemaInfo objects that are returned by the documented createSchema API endpoint.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction captures the basic mapping functionality between SchemaInfo and database, but misses the crucial connection to the createSchema API endpoint and the persistence layer purpose",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "# TemporaryVolumeCredentialsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**generateTemporaryVolumeCredentials**](TemporaryVolumeCredentialsApi.md#generateTemporaryVolumeCredentials) | **POST** /temporary-volume-credentials | Generate temporary volume credentials. |",
    "artifact_title": "TemporaryVolumeCredentialsService.generateTemporaryVolumeCredentials",
    "predicted_relationship": "The documentation explicitly mentions the 'generateTemporaryVolumeCredentials' API endpoint, which is directly implemented by this method. The HTTP POST request to '/temporary-volume-credentials' described in the documentation corresponds to this service method.",
    "ground_truth_relationship": "The code implements the documented POST endpoint '/temporary-volume-credentials' by handling volume credential generation requests, validating the volume ID, and returning temporary AWS credentials for S3 volumes or empty credentials for local filesystems.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the correct API endpoint mapping but omits key functionality around credential generation and validation logic that is core to understanding the relationship",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"generateTemporaryTableCredentials\"></a>\n# **generateTemporaryTableCredentials**\n> GenerateTemporaryTableCredentialResponse generateTemporaryTableCredentials(GenerateTemporaryTableCredential)\n\nGenerate temporary table credentials.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **GenerateTemporaryTableCredential** | [**GenerateTemporaryTableCredential**](../Models/GenerateTemporaryTableCredential.md)|  | [optional] |\n\n### Return type\n\n[**GenerateTemporaryTableCredentialResponse**](../Models/GenerateTemporaryTableCredentialResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json\n",
    "artifact_title": "TemporaryTableCredentialsService.generateTemporaryTableCredentials",
    "predicted_relationship": "This method directly implements the generateTemporaryTableCredentials operation described in the API documentation. It takes a GenerateTemporaryTableCredential object as input and returns a GenerateTemporaryTableCredentialResponse, matching the signature specified in the documentation.",
    "ground_truth_relationship": "The code implements the documented API endpoint by checking if a table exists at a storage location, then either generating AWS S3 temporary credentials or returning empty credentials for local filesystems, matching the documented GenerateTemporaryTableCredentialResponse return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the correct method signature and return type, but misses the crucial logic of checking storage location and conditionally generating AWS S3 credentials vs empty credentials based on the storage type",
      "error_type": "major_omission"
    }
  },
  {
    "document_text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "TableService.createTable",
    "predicted_relationship": "The documentation explicitly describes the 'createTable' operation, which is directly implemented by the TableService.createTable method. The method signature matches the documented API, taking a CreateTable object as input and returning a TableInfo object.",
    "ground_truth_relationship": "The code implements the documented POST endpoint by accepting a CreateTable request object, validating it's not null, delegating to the TABLE_REPOSITORY to create the table, and returning a TableInfo response wrapped in an HTTP JSON response, matching the documented input/output types and content types.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship between the code and documentation - both describe a createTable operation that takes CreateTable input and returns TableInfo, matching the API contract.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "TableRepository.createTable",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableRepository.createTable method is likely called by TableService.createTable to perform the actual table creation operation in the data store.",
    "ground_truth_relationship": "The code implements the documented createTable API by validating the table name, creating a new TableInfo object with the specified properties, checking for existing tables, rejecting MANAGED table types, requiring storage locations for external tables, and persisting the table data in a database transaction while handling errors as specified in the API documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies that it's related to table creation but incorrectly suggests it's called by TableService.createTable, when the code shows it's a direct implementation of the documented API endpoint. However, it does understand the basic purpose of creating tables.",
      "error_type": "incorrect_dependency_assumption"
    }
  },
  {
    "document_text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "TableInfoDAO",
    "predicted_relationship": "The TableInfoDAO is likely used internally to persist and retrieve table information. It's implicitly related to the createTable operation as it represents the data structure for storing table metadata.",
    "ground_truth_relationship": "The TableInfoDAO class provides the persistence layer mapping and conversion logic for the TableInfo objects returned by the documented createTable API endpoint, handling the storage and retrieval of table metadata in the 'uc_tables' database table.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship that TableInfoDAO handles table metadata persistence, which aligns with the ground truth's explanation of it providing persistence layer mapping for TableInfo objects. While the ground truth is more specific about the database table and API endpoint, the predicted description correctly identifies the essential persistence role.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "TableCli.createTable",
    "predicted_relationship": "While not directly mentioned in the API documentation, the TableCli.createTable method likely provides a command-line interface for creating tables, utilizing the same underlying API.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createTable endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions accurately capture that this is a CLI wrapper/interface for the documented createTable API endpoint",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteSchema\"></a>\n# **deleteSchema**\n> oas_any_type_not_mapped deleteSchema(full\\_name, force)\n\nDelete a schema\n\n    Deletes the specified schema from the parent catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaService.deleteSchema",
    "predicted_relationship": "The documentation directly describes the deleteSchema operation, which is implemented by the SchemaService.deleteSchema method. The method signature matches the documented parameters 'full_name' and 'force'.",
    "ground_truth_relationship": "The code implements the documented DELETE endpoint by accepting a required fullName path parameter and optional force parameter, delegating schema deletion to SCHEMA_REPOSITORY, and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic relationship between the code and documentation, but incorrectly refers to 'SchemaService.deleteSchema' when the code actually uses 'SCHEMA_REPOSITORY.deleteSchema'",
      "error_type": "minor_implementation_detail_error"
    }
  },
  {
    "document_text": "<a name=\"deleteSchema\"></a>\n# **deleteSchema**\n> oas_any_type_not_mapped deleteSchema(full\\_name, force)\n\nDelete a schema\n\n    Deletes the specified schema from the parent catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.deleteSchema",
    "predicted_relationship": "While not explicitly mentioned, the SchemaRepository.deleteSchema method is likely used by SchemaService.deleteSchema to perform the actual deletion of the schema from the database.",
    "ground_truth_relationship": "The code implements the documented schema deletion endpoint by recursively removing child tables, volumes, and functions before deleting the schema itself, while respecting the 'force' parameter and throwing a NOT_FOUND exception when the schema doesn't exist.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description recognizes this is a schema deletion operation but incorrectly assumes it's part of a SchemaRepository/SchemaService architecture when the code shows a direct implementation that handles child entities and error cases",
      "error_type": "architectural_assumption"
    }
  },
  {
    "document_text": "# **getVolume**\n> VolumeInfo getVolume(name)\n\nGet a Volume\n\n    Gets a volume for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeService.getVolume",
    "predicted_relationship": "The documentation directly describes the 'getVolume' operation, which is implemented by the VolumeService.getVolume method. The method signature matches the documented parameters (name) and return type (VolumeInfo).",
    "ground_truth_relationship": "The code implements the documented GET endpoint by accepting a required 'full_name' path parameter and an optional 'include_browse' query parameter, returning a JSON response containing volume information from the repository, though the documentation doesn't mention the optional parameter.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core functionality - it describes a getVolume operation that takes a name parameter and returns volume info. While it doesn't mention the optional include_browse parameter, this is a minor detail that doesn't change the fundamental relationship.",
      "error_type": null
    }
  },
  {
    "document_text": "# **getVolume**\n> VolumeInfo getVolume(name)\n\nGet a Volume\n\n    Gets a volume for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.getVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.getVolume method is likely used by VolumeService.getVolume to retrieve the volume information from the database.",
    "ground_truth_relationship": "The code implements the documented getVolume operation by splitting a three-level name parameter into catalog, schema, and volume components, validating the format, and returning a VolumeInfo object retrieved from the database through a DAO pattern.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that the method retrieves volume information from a database, but inaccurately specifies the class relationships (VolumeRepository/VolumeService) that aren't shown in the code and misses the key functionality of parsing the three-level name parameter.",
      "error_type": "inaccurate_class_relationships"
    }
  },
  {
    "document_text": "# **getVolume**\n> VolumeInfo getVolume(name)\n\nGet a Volume\n\n    Gets a volume for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeInfoDAO",
    "predicted_relationship": "The VolumeInfoDAO class is likely used to map the database entity to the VolumeInfo object returned by the getVolume operation.",
    "ground_truth_relationship": "The VolumeInfoDAO class provides the data persistence layer and model conversion methods (toVolumeInfo/from) needed to support the documented getVolume API endpoint by mapping between the database representation and the VolumeInfo response type.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core functionality of VolumeInfoDAO as a database-to-object mapper for VolumeInfo, which aligns with the ground truth's explanation of its role in data persistence and model conversion.",
      "error_type": ""
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.createTable",
    "predicted_relationship": "The documentation explicitly mentions a 'createTable' API endpoint with a POST request to '/tables'. This directly corresponds to the TableService.createTable method, which is annotated with @Post(\"\") and creates a table based on the provided CreateTable object.",
    "ground_truth_relationship": "The createTable code method implements the POST /tables API endpoint documented in TablesApi by accepting a CreateTable request object, delegating to TABLE_REPOSITORY for table creation, and returning the response as JSON.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented POST /tables API endpoint for table creation, with the same core functionality of handling POST requests and creating tables",
      "error_type": ""
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.deleteTable",
    "predicted_relationship": "The documentation explicitly mentions a 'deleteTable' API endpoint with a DELETE request to '/tables/{full_name}'. This directly corresponds to the TableService.deleteTable method, which is annotated with @Delete(\"/{full_name}\") and deletes a table based on the provided full name.",
    "ground_truth_relationship": "The code implements the documented DELETE /tables/{full_name} endpoint by creating a method annotated with @Delete that takes a full_name parameter, deletes the corresponding table through the repository, and returns an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the core relationship between the code and documentation - that a DELETE endpoint for /tables/{full_name} is implemented to delete tables. Both descriptions align on the key functionality and endpoint mapping.",
      "error_type": ""
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.getTable",
    "predicted_relationship": "The documentation explicitly mentions a 'getTable' API endpoint with a GET request to '/tables/{full_name}'. This directly corresponds to the TableService.getTable method, which is annotated with @Get(\"/{full_name}\") and retrieves a table based on the provided full name.",
    "ground_truth_relationship": "The code implements the documented GET /tables/{full_name} endpoint by creating a method that retrieves a TableInfo object based on the full_name path parameter and returns it as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship between the code and documentation - both describe a GET endpoint for retrieving table information via /tables/{full_name}",
      "error_type": ""
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.listTables",
    "predicted_relationship": "The documentation explicitly mentions a 'listTables' API endpoint with a GET request to '/tables'. This directly corresponds to the TableService.listTables method, which is annotated with @Get(\"\") and lists tables based on the provided parameters.",
    "ground_truth_relationship": "The document is an API endpoint summary table that lists the methods available and their description under the TablesApi. Each code is related to one of the methods.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the listTables API endpoint and GET method, but misses the broader context that this is one of four available API endpoints shown in the documentation table. The ground truth emphasizes that this is part of a larger API documentation showing multiple methods.",
      "error_type": "incomplete_scope"
    }
  },
  {
    "document_text": "# **deleteVolume**\n> oas_any_type_not_mapped deleteVolume(name)\n\nDelete a Volume\n\n    Deletes a volume from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeService.deleteVolume",
    "predicted_relationship": "The documentation directly describes a 'deleteVolume' operation, which is explicitly implemented by the VolumeService.deleteVolume method. The method signature matches the documented parameter 'name' of type String, which is described as 'The three-level (fully qualified) name of the volume' in the documentation.",
    "ground_truth_relationship": "The code directly implements the documented DELETE endpoint by accepting a fully qualified volume name parameter, delegating the deletion to VOLUME_REPOSITORY, and returning an HTTP 200 OK response as specified in the OpenAPI documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship between the code and documentation - it identifies the deleteVolume operation with a string name parameter for deleting volumes. While it doesn't mention the HTTP response specifics, it captures the main functionality correctly.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **deleteVolume**\n> oas_any_type_not_mapped deleteVolume(name)\n\nDelete a Volume\n\n    Deletes a volume from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.deleteVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.deleteVolume method is likely used by the VolumeService to perform the actual deletion of the volume from the repository. This is inferred from the typical service-repository pattern in software architecture.",
    "ground_truth_relationship": "The code implements a documented Volume deletion operation by validating a three-part volume name, managing database transactions to remove the volume record, and cleaning up storage directories for managed volumes.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly suggests a deletion operation but incorrectly assumes a VolumeRepository/VolumeService pattern that isn't present in the actual code, which directly handles the deletion logic including transaction management and file cleanup.",
      "error_type": "architectural_assumption"
    }
  },
  {
    "document_text": "# **deleteVolume**\n> oas_any_type_not_mapped deleteVolume(name)\n\nDelete a Volume\n\n    Deletes a volume from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeCli.deleteVolume",
    "predicted_relationship": "While not explicitly mentioned in the API documentation, the VolumeCli.deleteVolume method is likely a command-line interface implementation that uses the deleteVolume API. It probably calls the API method described in the documentation to perform the volume deletion operation from a CLI context.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteVolume endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that the code is a CLI wrapper/implementation for the documented deleteVolume API endpoint. While the predicted text is more tentative ('likely'), it correctly identifies the main relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"generateTemporaryVolumeCredentials\"></a>\n# **generateTemporaryVolumeCredentials**\n> GenerateTemporaryVolumeCredentialResponse generateTemporaryVolumeCredentials(GenerateTemporaryVolumeCredential)\n\nGenerate temporary volume credentials.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **GenerateTemporaryVolumeCredential** | [**GenerateTemporaryVolumeCredential**](../Models/GenerateTemporaryVolumeCredential.md)|  | [optional] |\n\n### Return type\n\n[**GenerateTemporaryVolumeCredentialResponse**](../Models/GenerateTemporaryVolumeCredentialResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json\n",
    "artifact_title": "TemporaryVolumeCredentialsService.generateTemporaryVolumeCredentials",
    "predicted_relationship": "This method directly implements the 'generateTemporaryVolumeCredentials' operation described in the API documentation. It takes a GenerateTemporaryVolumeCredential object as input and returns a GenerateTemporaryVolumeCredentialResponse, matching the parameters and return type specified in the documentation.",
    "ground_truth_relationship": "The code implements the documented API endpoint by validating the volume ID, retrieving storage location information, and returning temporary AWS S3 credentials for S3 volumes or empty credentials for local storage, while matching the specified request/response types and HTTP POST behavior.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the basic API contract but misses crucial functional aspects about credential generation logic for S3 vs local storage and validation steps",
      "error_type": "major_omission"
    }
  },
  {
    "document_text": "<a name=\"updateSchema\"></a>\n# **updateSchema**\n> SchemaInfo updateSchema(full\\_name, UpdateSchema)\n\nUpdate a schema\n\n    Updates the specified schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **UpdateSchema** | [**UpdateSchema**](../Models/UpdateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.updateSchema",
    "predicted_relationship": "The SchemaRepository.updateSchema method directly implements the updateSchema operation described in the documentation. It takes the full name of the schema and an UpdateSchema object as parameters, which matches the documented API. The method returns a SchemaInfo object, which aligns with the documented return type.",
    "ground_truth_relationship": "The code implements the documented schema update endpoint by validating the new schema name, managing database transactions to update the schema's name, comment, and properties, and handling errors according to the API specification's parameters and return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic function and parameters correctly but omits the important validation and transaction management aspects mentioned in the ground truth",
      "error_type": "major_omission"
    }
  },
  {
    "document_text": "<a name=\"updateSchema\"></a>\n# **updateSchema**\n> SchemaInfo updateSchema(full\\_name, UpdateSchema)\n\nUpdate a schema\n\n    Updates the specified schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **UpdateSchema** | [**UpdateSchema**](../Models/UpdateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaService.updateSchema",
    "predicted_relationship": "The SchemaService.updateSchema method directly implements the API endpoint for updating a schema. It matches the documented HTTP PATCH method and takes the full name of the schema and an UpdateSchema object as parameters, aligning with the API specification.",
    "ground_truth_relationship": "The code implements a PATCH endpoint that directly matches the documented API endpoint, accepting a fullName path parameter and UpdateSchema body parameter, and returning a JSON response through HttpResponse.ofJson from the schema repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core functionality of a PATCH endpoint that updates a schema using the fullName and UpdateSchema parameters, matching the ground truth's description of the implementation.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"updateSchema\"></a>\n# **updateSchema**\n> SchemaInfo updateSchema(full\\_name, UpdateSchema)\n\nUpdate a schema\n\n    Updates the specified schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **UpdateSchema** | [**UpdateSchema**](../Models/UpdateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaInfoDAO",
    "predicted_relationship": "While not explicitly mentioned, the SchemaInfoDAO is likely used in the implementation of the updateSchema operation to interact with the database and persist the updated schema information.",
    "ground_truth_relationship": "The SchemaInfoDAO class provides the data persistence layer and object mapping functionality needed to support the updateSchema API endpoint by managing schema metadata in the database and converting between SchemaInfo API objects and database entities.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that SchemaInfoDAO is used for database persistence and schema information management in relation to the updateSchema operation, which aligns with the ground truth's description of its role in data persistence and object mapping.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createCatalog\"></a>\n# **createCatalog**\n> CatalogInfo createCatalog(CreateCatalog)\n\nCreate a catalog\n\n    Creates a new catalog instance. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateCatalog** | [**CreateCatalog**](../Models/CreateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.addCatalog",
    "predicted_relationship": "The CatalogRepository.addCatalog method likely implements the core functionality of creating a new catalog. The documentation describes the createCatalog operation, which takes a CreateCatalog object and returns a CatalogInfo object. This aligns with the method signature and return type of CatalogRepository.addCatalog.",
    "ground_truth_relationship": "The addCatalog implementation validates SQL object names, creates a CatalogInfo instance with a UUID and properties, and persists it to the database in a transaction, fulfilling the documented createCatalog API endpoint's purpose of creating a new catalog instance.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that addCatalog implements the createCatalog operation functionality by taking a CreateCatalog object and returning CatalogInfo. While it omits implementation details about validation and persistence, it captures the core relationship accurately.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createCatalog\"></a>\n# **createCatalog**\n> CatalogInfo createCatalog(CreateCatalog)\n\nCreate a catalog\n\n    Creates a new catalog instance. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateCatalog** | [**CreateCatalog**](../Models/CreateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogService.createCatalog",
    "predicted_relationship": "The CatalogService.createCatalog method likely implements the HTTP POST endpoint for creating a catalog. The documentation describes a POST operation that takes a CreateCatalog object and returns a CatalogInfo object, which aligns with this method's signature and return type.",
    "ground_truth_relationship": "The code implements the documented API endpoint by accepting a CreateCatalog object via POST, persisting it through CATALOG_REPOSITORY, and returning a JSON response matching the documented CatalogInfo return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship between the code and documentation - that it implements a POST endpoint for catalog creation taking CreateCatalog input and returning catalog info as JSON.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createCatalog\"></a>\n# **createCatalog**\n> CatalogInfo createCatalog(CreateCatalog)\n\nCreate a catalog\n\n    Creates a new catalog instance. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateCatalog** | [**CreateCatalog**](../Models/CreateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogInfoDAO",
    "predicted_relationship": "The CatalogInfoDAO class is likely used to persist and retrieve catalog information. The documentation mentions returning a CatalogInfo object, which would be converted from a CatalogInfoDAO instance after the catalog is created.",
    "ground_truth_relationship": "The CatalogInfoDAO class provides the data persistence layer and mapping functionality for the CatalogInfo objects that are returned by the documented createCatalog API endpoint, with methods to convert between the DAO and API model representations.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core relationship - that CatalogInfoDAO handles persistence and data mapping for CatalogInfo objects, which aligns with the ground truth's description of it serving as the data persistence layer and providing conversion between DAO and API model representations.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.createFunction",
    "predicted_relationship": "The documentation explicitly mentions a 'createFunction' API endpoint with a POST request to '/functions'. This directly corresponds to the 'FunctionCli.createFunction' method, which implements the client-side logic for creating a function.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that the code implements functionality for the documented createFunction API endpoint, just expressing it slightly differently than the ground truth's CLI wrapper framing",
      "error_type": null
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.deleteFunction",
    "predicted_relationship": "The documentation explicitly mentions a 'deleteFunction' API endpoint with a DELETE request to '/functions/{name}'. This directly corresponds to the 'FunctionCli.deleteFunction' method, which implements the client-side logic for deleting a function.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements functionality for the documented deleteFunction API endpoint. Both descriptions recognize this is a client-side implementation for deleting functions.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.getFunction",
    "predicted_relationship": "The documentation explicitly mentions a 'getFunction' API endpoint with a GET request to '/functions/{name}'. This directly corresponds to the 'FunctionCli.getFunction' method, which implements the client-side logic for retrieving a function.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented getFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that this code implements the documented getFunction API endpoint, even if it doesn't specifically use the term 'CLI wrapper'",
      "error_type": null
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.listFunctions",
    "predicted_relationship": "The documentation explicitly mentions a 'listFunctions' API endpoint with a GET request to '/functions'. This directly corresponds to the 'FunctionCli.listFunctions' method, which implements the client-side logic for listing functions.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listFunctions endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - that this is an implementation of the documented listFunctions API endpoint. Both describe the same basic functionality of listing functions via the API, even though the predicted version doesn't explicitly mention the CLI wrapper aspect.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.createFunction",
    "predicted_relationship": "While not explicitly mentioned in the documentation snippet, the 'FunctionService.createFunction' method is likely the server-side implementation of the 'createFunction' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the experimental POST /functions endpoint documented in the API table by defining a createFunction method that accepts a CreateFunctionRequest and returns an HTTP response containing the newly created function data from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions indicate this is an implementation of the POST /functions API endpoint for creating functions, with the predicted version being more cautious but capturing the core relationship",
      "error_type": "none"
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.deleteFunction",
    "predicted_relationship": "While not explicitly mentioned in the documentation snippet, the 'FunctionService.deleteFunction' method is likely the server-side implementation of the 'deleteFunction' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the documented DELETE /functions/{name} endpoint by providing a method that accepts a function name and optional force parameter, deleting the specified function through the repository and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented deleteFunction API endpoint, even though it uses less specific language and omits implementation details.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.getFunction",
    "predicted_relationship": "While not explicitly mentioned in the documentation snippet, the 'FunctionService.getFunction' method is likely the server-side implementation of the 'getFunction' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the documented GET /functions/{name} endpoint by creating a controller method that accepts a name parameter and returns a JSON response containing the function details from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions identify that the code implements the documented GET /functions/{name} endpoint, with the predicted description accurately noting it's a server-side implementation of the getFunction API endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.listFunctions",
    "predicted_relationship": "While not explicitly mentioned in the documentation snippet, the 'FunctionService.listFunctions' method is likely the server-side implementation of the 'listFunctions' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the documented GET /functions endpoint by defining a listFunctions method that accepts catalog name, schema name, pagination parameters, and returns an HTTP response containing the list of functions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is an implementation of the documented listFunctions API endpoint, even though it's less detailed than the ground truth",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.createVolume",
    "predicted_relationship": "The documentation explicitly mentions 'createVolume' as a POST method for creating a Volume. This directly corresponds to the VolumeService.createVolume method which implements this functionality.",
    "ground_truth_relationship": "The code implements the POST /volumes endpoint documented in the API table by defining a method that accepts a CreateVolumeRequestContent object and delegates to VOLUME_REPOSITORY to create a new volume, returning the result as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions accurately identify that this is a POST endpoint for creating volumes, with the predicted description capturing the core relationship between the API documentation and implementation",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.deleteVolume",
    "predicted_relationship": "The documentation explicitly mentions 'deleteVolume' as a DELETE method for deleting a Volume. This directly corresponds to the VolumeService.deleteVolume method which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented DELETE /volumes/{name} endpoint by accepting a volume's full name as a path parameter, delegating the deletion to VOLUME_REPOSITORY, and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented DELETE endpoint for deleting volumes, even though it omits implementation details about HTTP response and repository usage",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.getVolume",
    "predicted_relationship": "The documentation explicitly mentions 'getVolume' as a GET method for retrieving a Volume. This directly corresponds to the VolumeService.getVolume method which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented GET /volumes/{name} endpoint by providing a method that retrieves volume information based on a full name parameter and returns it as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a GET endpoint for retrieving a Volume, matching the implementation shown in the code and documented API endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.listVolumes",
    "predicted_relationship": "The documentation explicitly mentions 'listVolumes' as a GET method for listing Volumes. This directly corresponds to the VolumeService.listVolumes method which implements this functionality.",
    "ground_truth_relationship": "The code implements the 'listVolumes' API endpoint documented in the table by defining a GET handler that accepts query parameters for catalog_name, schema_name, pagination controls, and browse options, returning the results as JSON.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions convey that the code implements a GET endpoint for listing volumes as documented. The predicted description captures this core relationship correctly, even though it omits parameter details.",
      "error_type": "none"
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.updateVolume",
    "predicted_relationship": "The documentation explicitly mentions 'updateVolume' as a PATCH method for updating a Volume. This directly corresponds to the VolumeService.updateVolume method which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented PATCH /volumes/{name} API endpoint by defining an updateVolume method that accepts a volume name and update request content, returning the updated volume data as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented PATCH /volumes API endpoint for updating volumes, capturing the core relationship between the code and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "# TemporaryTableCredentialsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**generateTemporaryTableCredentials**](TemporaryTableCredentialsApi.md#generateTemporaryTableCredentials) | **POST** /temporary-table-credentials | Generate temporary table credentials. |",
    "artifact_title": "TemporaryTableCredentialsService.generateTemporaryTableCredentials",
    "predicted_relationship": "The documentation explicitly mentions 'generateTemporaryTableCredentials' as a POST method for generating temporary table credentials. This directly corresponds to the 'generateTemporaryTableCredentials' method in the TemporaryTableCredentialsService class.",
    "ground_truth_relationship": "The code implements the documented POST endpoint /temporary-table-credentials by validating the table location and returning AWS temporary credentials for S3 storage or empty credentials for local storage.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic idea that this is a POST endpoint for generating temporary credentials, but misses the key functionality of validating table location and returning different types of credentials based on storage type (S3 vs local)",
      "error_type": "missing_key_functionality"
    }
  },
  {
    "document_text": "<a name=\"deleteTable\"></a>\n# **deleteTable**\n> oas_any_type_not_mapped deleteTable(full\\_name)\n\nDelete a table\n\n    Deletes a table from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableService.deleteTable",
    "predicted_relationship": "The documentation directly describes the 'deleteTable' operation, which is implemented by the TableService.deleteTable method. The method signature matches the documented parameters, taking a 'full_name' parameter of type String.",
    "ground_truth_relationship": "The code implements a REST DELETE endpoint that matches the documented API specification by accepting a full_name parameter, invoking TABLE_REPOSITORY.deleteTable(), and returning a 200 OK response with no content body.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the deleteTable operation and parameter matching, but misses key aspects about it being a REST DELETE endpoint and the HTTP response behavior that the ground truth emphasizes",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"deleteTable\"></a>\n# **deleteTable**\n> oas_any_type_not_mapped deleteTable(full\\_name)\n\nDelete a table\n\n    Deletes a table from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableRepository.deleteTable",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableService.deleteTable method likely calls TableRepository.deleteTable to perform the actual deletion operation in the database.",
    "ground_truth_relationship": "The code implements the documented table deletion operation by removing the table's database entry, deleting its physical files (for managed tables), and cleaning up associated properties, while the documentation describes the API endpoint that exposes this functionality with a 'full_name' parameter.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies a deletion operation but incorrectly suggests it's done through a TableRepository call, while the code shows direct deletion via Session operations and file system cleanup",
      "error_type": "architectural_misunderstanding"
    }
  },
  {
    "document_text": "<a name=\"deleteTable\"></a>\n# **deleteTable**\n> oas_any_type_not_mapped deleteTable(full\\_name)\n\nDelete a table\n\n    Deletes a table from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableCli.deleteTable",
    "predicted_relationship": "The CLI implementation for deleteTable is likely to use the same API endpoint described in this documentation, forming a usage relationship.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteTable endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that this is an API implementation/wrapper relationship, where the code uses the documented deleteTable endpoint",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listFunctions\"></a>\n# **listFunctions**\n> ListFunctionsResponse listFunctions(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList functions\n\n    List functions within the specified parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for functions of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of functions. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of functions to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query. | [optional] [default to null] |\n\n### Return type\n\n[**ListFunctionsResponse**](../Models/ListFunctionsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionService.listFunctions",
    "predicted_relationship": "The documentation directly describes the 'listFunctions' operation, which is implemented by the FunctionService.listFunctions method. The method signature matches the documented parameters: catalogName, schemaName, maxResults, and pageToken. It also returns a ListFunctionsResponse as specified in the documentation.",
    "ground_truth_relationship": "The code implements a REST GET endpoint that takes the exact parameters specified in the documentation (catalog_name, schema_name, optional max_results, and optional page_token) and delegates the actual function listing to a repository layer, returning the results as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - it identifies the listFunctions operation that takes the documented parameters and returns function listing results. The minor difference in describing it as a 'FunctionService' vs 'repository layer' doesn't change the fundamental relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listFunctions\"></a>\n# **listFunctions**\n> ListFunctionsResponse listFunctions(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList functions\n\n    List functions within the specified parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for functions of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of functions. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of functions to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query. | [optional] [default to null] |\n\n### Return type\n\n[**ListFunctionsResponse**](../Models/ListFunctionsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.listFunctions",
    "predicted_relationship": "While not explicitly mentioned, the FunctionService.listFunctions method likely delegates the actual function listing operation to FunctionRepository.listFunctions. This repository method would handle the database query and pagination logic described in the API documentation.",
    "ground_truth_relationship": "The code implements the documented behavior by retrieving function records from a database within a read-only transaction, transforming FunctionInfoDAO objects to FunctionInfo objects with attached properties, and returning them in a ListFunctionsResponse with pagination support through maxResults and pageToken parameters.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly recognizes delegation of functionality but incorrectly assumes a FunctionRepository class that isn't shown. The core listing and pagination functionality is correct, but the specific implementation details differ from what's predicted.",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.createSchema",
    "predicted_relationship": "The documentation explicitly mentions 'createSchema' with a POST request to '/schemas', which directly corresponds to the SchemaService.createSchema method that implements this API endpoint.",
    "ground_truth_relationship": "The code implements the documented POST /schemas API endpoint by defining a createSchema method that accepts a CreateSchema object and returns a JSON HTTP response containing the newly created schema from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented POST /schemas endpoint for schema creation. Both descriptions identify the core relationship between the API documentation and code implementation.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.deleteSchema",
    "predicted_relationship": "The documentation explicitly mentions 'deleteSchema' with a DELETE request to '/schemas/{full_name}', which directly corresponds to the SchemaService.deleteSchema method that implements this API endpoint.",
    "ground_truth_relationship": "The code implements the documented DELETE /schemas/{full_name} endpoint by providing a method that accepts a schema's full name and an optional force parameter, deletes the specified schema from the repository, and returns an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the core relationship between the code and documentation - that this is an implementation of the documented DELETE /schemas/{full_name} endpoint",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.getSchema",
    "predicted_relationship": "The documentation explicitly mentions 'getSchema' with a GET request to '/schemas/{full_name}', which directly corresponds to the SchemaService.getSchema method that implements this API endpoint.",
    "ground_truth_relationship": "The code implements the GET /schemas/{full_name} endpoint documented in the API table by defining a method that retrieves a schema using the full_name path parameter and returns it as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions correctly identify that the code implements a GET endpoint for retrieving a schema using a full_name parameter and returning it as JSON, matching the documented API endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.listSchemas",
    "predicted_relationship": "The documentation explicitly mentions 'listSchemas' with a GET request to '/schemas', which directly corresponds to the SchemaService.listSchemas method that implements this API endpoint.",
    "ground_truth_relationship": "The listSchemas method implements the '/schemas' GET endpoint documented in the API table by accepting catalog_name, max_results, and page_token parameters and returning schema listings as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is the implementation of the GET /schemas endpoint as documented in the API table, which is the core relationship. While it omits details about parameters and response format mentioned in the ground truth, these are minor details that don't affect the core relationship.",
      "error_type": "none"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.updateSchema",
    "predicted_relationship": "The documentation explicitly mentions 'updateSchema' with a PATCH request to '/schemas/{full_name}', which directly corresponds to the SchemaService.updateSchema method that implements this API endpoint.",
    "ground_truth_relationship": "The code implements the updateSchema API endpoint documented in the table by creating a PATCH handler at '/schemas/{full_name}' that accepts a schema name and update payload, passing them to the schema repository for processing.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions correctly identify that this is a PATCH endpoint at '/schemas/{full_name}' that implements the updateSchema API functionality documented in the table. The predicted description captures the core relationship between the code and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.createSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.createSchema method is likely used by the SchemaService to implement the createSchema functionality.",
    "ground_truth_relationship": "The SchemaRepository.createSchema method implements the backend logic for the POST /schemas endpoint by validating the schema name, checking for duplicates, creating a new SchemaInfo object with a UUID, persisting it to the database within a transaction, and returning the created schema details.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the method's role in schema creation but introduces uncertainty ('likely used') and incorrectly attributes it to SchemaService rather than recognizing it as the direct implementation of the POST /schemas endpoint",
      "error_type": "architectural_misunderstanding"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.deleteSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.deleteSchema method is likely used by the SchemaService to implement the deleteSchema functionality.",
    "ground_truth_relationship": "The SchemaRepository.deleteSchema method implements the DELETE /schemas/{full_name} API endpoint by handling schema deletion logic, including processing child tables, volumes, and functions, and removing associated properties from the database session.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the SchemaRepository.deleteSchema method is used to implement the schema deletion functionality exposed through the API, even though it lacks implementation details about child processing.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.getSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.getSchema method is likely used by the SchemaService to implement the getSchema functionality.",
    "ground_truth_relationship": "The SchemaRepository.getSchema method implements the GET /schemas/{full_name} API endpoint by retrieving schema information from a database, converting it from DAO format, and attaching properties while managing database transactions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the getSchema method is used to implement schema retrieval functionality, which aligns with the ground truth that it implements the GET /schemas endpoint. While the ground truth provides more implementation details, the core relationship is captured.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.listSchemas",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.listSchemas method is likely used by the SchemaService to implement the listSchemas functionality.",
    "ground_truth_relationship": "The code implements the GET /schemas endpoint by retrieving schemas from a database session, supporting pagination through maxResults and pageToken parameters, and returning a ListSchemasResponse containing schema information and a next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that the code relates to listSchemas functionality, but introduces uncertainty ('likely used') and references SchemaService which isn't shown. The ground truth more accurately describes the actual implementation details of retrieving schemas with pagination.",
      "error_type": "imprecise_implementation_details"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.updateSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.updateSchema method is likely used by the SchemaService to implement the updateSchema functionality.",
    "ground_truth_relationship": "The SchemaRepository.updateSchema method implements the PATCH /schemas/{full_name} API endpoint by handling the validation, modification, and persistence of schema updates including name changes, comments, and properties within a database transaction.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that the method is related to schema updates, but introduces uncertainty by saying it's 'likely' used by SchemaService when the code shows it directly implements the PATCH endpoint. It also misses mentioning the key functionality of handling validation and database transactions.",
      "error_type": "major_omissions_and_uncertainty"
    }
  },
  {
    "document_text": "<a name=\"listTables\"></a>\n# **listTables**\n> ListTablesResponse listTables(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList tables\n\n    Gets the list of all available tables under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for tables of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of tables. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of tables to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token to send for the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListTablesResponse**](../Models/ListTablesResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableService.listTables",
    "predicted_relationship": "The documentation directly describes the 'listTables' operation, which is implemented by the TableService.listTables method. The method signature matches the documented parameters: catalog_name, schema_name, max_results, and page_token. It also returns a ListTablesResponse object as specified in the documentation.",
    "ground_truth_relationship": "The code implements the documented API endpoint by accepting the same catalog_name, schema_name, max_results, and page_token parameters, while also including two additional optional parameters (omit_properties and omit_columns) that are not mentioned in the documentation, then delegates the actual table listing to TABLE_REPOSITORY and returns the result as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the core functionality of listing tables with matching parameters, but misses the additional omit_properties and omit_columns parameters that are present in the code but not in the documentation.",
      "error_type": "omitted_parameters"
    }
  },
  {
    "document_text": "<a name=\"listTables\"></a>\n# **listTables**\n> ListTablesResponse listTables(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList tables\n\n    Gets the list of all available tables under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for tables of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of tables. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of tables to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token to send for the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListTablesResponse**](../Models/ListTablesResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableRepository.listTables",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableService.listTables method likely uses TableRepository.listTables to fetch the actual data. This repository method handles the database interaction and implements the pagination logic described in the documentation.",
    "ground_truth_relationship": "The code implements the documented listTables endpoint by querying a database session for table records matching the given catalog and schema names, handling pagination through maxResults and pageToken parameters, and returning a ListTablesResponse object containing the table list and next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core functionality of the listTables method - database interaction and pagination handling - which aligns with the ground truth. While it uses slightly different terminology (TableRepository vs database session), the fundamental relationship and purpose is correctly identified.",
      "error_type": "none"
    }
  },
  {
    "document_text": "<a name=\"getSchema\"></a>\n# **getSchema**\n> SchemaInfo getSchema(full\\_name)\n\nGet a schema\n\n    Gets the specified schema for a catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.getSchema",
    "predicted_relationship": "The getSchema method in SchemaRepository directly implements the functionality described in the documentation. The method signature matches the documented API, taking a 'fullName' parameter and returning a SchemaInfo object. This is evidenced by the text 'SchemaInfo getSchema(full_name)' in the documentation.",
    "ground_truth_relationship": "The code implements the documented getSchema operation by retrieving a schema from a database session, converting it from DAO format to SchemaInfo, and attaching properties, while handling the specified error case for when the schema is not found.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the basic API signature match but misses key implementation details like database interaction, DAO conversion, and error handling that are central to how the code fulfills the documented functionality",
      "error_type": "incomplete_coverage"
    }
  },
  {
    "document_text": "<a name=\"getSchema\"></a>\n# **getSchema**\n> SchemaInfo getSchema(full\\_name)\n\nGet a schema\n\n    Gets the specified schema for a catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaService.getSchema",
    "predicted_relationship": "The SchemaService.getSchema method likely implements the API endpoint described in the documentation. It matches the signature of taking a 'fullName' parameter and returning a SchemaInfo object. This is evidenced by the API description 'SchemaInfo getSchema(full_name)' in the documentation.",
    "ground_truth_relationship": "The code implements the documented GET endpoint with path parameter 'full_name' by returning a JSON HTTP response containing schema information retrieved from SCHEMA_REPOSITORY.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship that this is an API endpoint for getting schema information based on a fullName parameter, which aligns with the ground truth's description of implementing a GET endpoint that returns schema data via HTTP response.",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"getSchema\"></a>\n# **getSchema**\n> SchemaInfo getSchema(full\\_name)\n\nGet a schema\n\n    Gets the specified schema for a catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaInfoDAO",
    "predicted_relationship": "The SchemaInfoDAO class is likely used internally to represent the schema data in the database. While not explicitly mentioned, it's implied by the return type SchemaInfo, which suggests a data access object is used to retrieve and construct the returned information.",
    "ground_truth_relationship": "The SchemaInfoDAO class provides the data persistence and transformation layer for the SchemaInfo object that is returned by the documented getSchema endpoint, handling the mapping between database records and the API response model.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies SchemaInfoDAO as an internal database representation class, which aligns with the ground truth's description of it being a data persistence/transformation layer. While less detailed, it captures the core relationship between SchemaInfoDAO and SchemaInfo.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteFunction\"></a>\n# **deleteFunction**\n> oas_any_type_not_mapped deleteFunction(name)\n\nDelete a function\n\n    Deletes the function that matches the supplied name.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionCli.deleteFunction",
    "predicted_relationship": "The documentation directly describes a 'deleteFunction' operation, which is implemented by the FunctionCli.deleteFunction method. The method signature matches the described operation, taking a 'name' parameter which corresponds to the 'fully-qualified name of the function' mentioned in the documentation.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "While the predicted text correctly identifies the deleteFunction operation and its parameter, it misses the key point that this is a CLI wrapper implementation rather than the direct API implementation",
      "error_type": "missing_architectural_context"
    }
  },
  {
    "document_text": "<a name=\"deleteFunction\"></a>\n# **deleteFunction**\n> oas_any_type_not_mapped deleteFunction(name)\n\nDelete a function\n\n    Deletes the function that matches the supplied name.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.deleteFunction",
    "predicted_relationship": "While not explicitly mentioned, the FunctionRepository.deleteFunction method is likely used to perform the actual deletion of the function from the database. This aligns with the documentation's description of deleting 'the function that matches the supplied name'.",
    "ground_truth_relationship": "The code implements the documented deleteFunction API endpoint by validating and parsing a fully-qualified function name (catalog.schema.function), managing a database transaction to delete the corresponding FunctionInfoDAO record, and throwing appropriate exceptions for invalid names or missing functions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the deletion functionality but incorrectly assumes a FunctionRepository is used, when the code actually uses direct Session operations and FunctionInfoDAO",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "<a name=\"deleteFunction\"></a>\n# **deleteFunction**\n> oas_any_type_not_mapped deleteFunction(name)\n\nDelete a function\n\n    Deletes the function that matches the supplied name.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionService.deleteFunction",
    "predicted_relationship": "The FunctionService.deleteFunction method is likely an intermediate step between the CLI and the repository, handling the HTTP request described in the documentation ('HTTP request headers'). It would process the 'name' parameter and invoke the repository method.",
    "ground_truth_relationship": "The code implements the documented DELETE endpoint by accepting a name parameter and an optional force parameter (not mentioned in docs), calling FUNCTION_REPOSITORY.deleteFunction(), and returning an HTTP 200 OK response as specified in the OpenAPI documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core functionality of a DELETE endpoint that processes a name parameter and invokes repository methods, which aligns with the ground truth implementation. Minor omissions like the force parameter and specific HTTP status code don't affect the main relationship.",
      "error_type": "none"
    }
  },
  {
    "document_text": "<a name=\"generateTemporaryVolumeCredentials\"></a>\n# **generateTemporaryVolumeCredentials**\n> GenerateTemporaryVolumeCredentialResponse generateTemporaryVolumeCredentials(GenerateTemporaryVolumeCredential)\n\nGenerate temporary volume credentials.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **GenerateTemporaryVolumeCredential** | [**GenerateTemporaryVolumeCredential**](../Models/GenerateTemporaryVolumeCredential.md)|  | [optional] |\n\n### Return type\n\n[**GenerateTemporaryVolumeCredentialResponse**](../Models/GenerateTemporaryVolumeCredentialResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json\n",
    "artifact_title": "TemporaryVolumeCredentialsService.generateTemporaryVolumeCredentials",
    "predicted_relationship": "This method directly implements the generateTemporaryVolumeCredentials functionality described in the documentation. The method signature matches the documented API, taking a GenerateTemporaryVolumeCredential parameter and returning a GenerateTemporaryVolumeCredentialResponse.",
    "ground_truth_relationship": "The code implements the documented API endpoint by validating the volume ID, retrieving storage location information, and returning temporary AWS S3 credentials for S3 volumes or empty credentials for local storage, while matching the specified request/response types and HTTP POST behavior.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic API signature matching but misses the core functionality around credential generation for S3 vs local storage, which is a significant part of the implementation's purpose",
      "error_type": "incomplete_core_functionality"
    }
  },
  {
    "document_text": "# **deleteVolume**\n> oas_any_type_not_mapped deleteVolume(name)\n\nDelete a Volume\n\n    Deletes a volume from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeService.deleteVolume",
    "predicted_relationship": "The documentation explicitly describes a 'deleteVolume' operation that takes a 'name' parameter, which directly corresponds to the 'VolumeService.deleteVolume' method. The method signature matches the described operation, taking a 'fullName' parameter which is described in the documentation as 'The three-level (fully qualified) name of the volume'.",
    "ground_truth_relationship": "The code directly implements the documented DELETE endpoint by accepting a fully qualified volume name parameter, delegating the deletion to VOLUME_REPOSITORY, and returning an HTTP 200 OK response as specified in the OpenAPI documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship between the code and documentation - a DELETE endpoint that takes a volume name parameter and performs volume deletion. While it doesn't mention the HTTP 200 response, this is a minor detail that doesn't affect the main relationship.",
      "error_type": "none"
    }
  },
  {
    "document_text": "# **deleteVolume**\n> oas_any_type_not_mapped deleteVolume(name)\n\nDelete a Volume\n\n    Deletes a volume from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.deleteVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.deleteVolume method is likely called by VolumeService.deleteVolume to perform the actual deletion of the volume from the repository.",
    "ground_truth_relationship": "The code implements a documented Volume deletion operation by validating a three-part volume name, managing database transactions to remove the volume record, and cleaning up storage directories for managed volumes.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description suggests this is a repository method called by a service layer, but the code shows it's a self-contained implementation that directly handles validation, transactions, and storage cleanup.",
      "error_type": "architectural_misunderstanding"
    }
  },
  {
    "document_text": "# **deleteVolume**\n> oas_any_type_not_mapped deleteVolume(name)\n\nDelete a Volume\n\n    Deletes a volume from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeCli.deleteVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeCli.deleteVolume method likely provides a command-line interface for the delete volume operation, which would internally use the VolumeService to perform the deletion.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteVolume endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a command-line interface wrapper for the delete volume operation, which matches the ground truth. The mention of VolumeService doesn't contradict the core relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteFunction\"></a>\n# **deleteFunction**\n> oas_any_type_not_mapped deleteFunction(name)\n\nDelete a function\n\n    Deletes the function that matches the supplied name.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionCli.deleteFunction",
    "predicted_relationship": "The documentation directly describes a 'deleteFunction' operation, which is implemented by the FunctionCli.deleteFunction method. The method signature matches the documented parameters, taking a 'name' parameter which is described as 'The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__)'.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the deleteFunction operation and parameter matching, but misses that this is specifically a CLI wrapper implementation of the API endpoint rather than the core functionality itself",
      "error_type": "missing_key_context"
    }
  },
  {
    "document_text": "<a name=\"deleteFunction\"></a>\n# **deleteFunction**\n> oas_any_type_not_mapped deleteFunction(name)\n\nDelete a function\n\n    Deletes the function that matches the supplied name.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.deleteFunction",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the FunctionRepository.deleteFunction method is likely used to perform the actual deletion of the function from the repository. This is inferred from the operation described in the documentation to delete a function.",
    "ground_truth_relationship": "The code implements the documented deleteFunction API endpoint by validating and parsing a fully-qualified function name (catalog.schema.function), managing a database transaction to delete the corresponding FunctionInfoDAO record, and throwing appropriate exceptions for invalid names or missing functions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the basic function deletion concept but misattributes it to a 'FunctionRepository' which isn't present in the code. The actual implementation uses Session/DAO pattern with transaction management.",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "<a name=\"deleteFunction\"></a>\n# **deleteFunction**\n> oas_any_type_not_mapped deleteFunction(name)\n\nDelete a function\n\n    Deletes the function that matches the supplied name.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionService.deleteFunction",
    "predicted_relationship": "The FunctionService.deleteFunction method is likely an intermediate step between the CLI and the repository, handling the HTTP request described in the documentation. This is inferred from the HTTP request headers and return type mentioned in the documentation.",
    "ground_truth_relationship": "The code implements the documented DELETE endpoint by accepting a name parameter and an optional force parameter (not mentioned in docs), calling FUNCTION_REPOSITORY.deleteFunction(), and returning an HTTP 200 OK response as specified in the OpenAPI documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies this as a service-level component but misses the key point that this is the actual endpoint implementation matching the OpenAPI spec. It focuses too much on being an 'intermediate step' rather than recognizing it as the direct API endpoint handler.",
      "error_type": "mischaracterized_role"
    }
  },
  {
    "document_text": "<a name=\"listSchemas\"></a>\n# **listSchemas**\n> ListSchemasResponse listSchemas(catalog\\_name, max\\_results, page\\_token)\n\nList schemas\n\n    Gets an array of schemas for a catalog. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Parent catalog for schemas of interest. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of schemas to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n\n### Return type\n\n[**ListSchemasResponse**](../Models/ListSchemasResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaService.listSchemas",
    "predicted_relationship": "The SchemaService.listSchemas method directly implements the listSchemas API functionality described in the documentation. The method signature matches the documented parameters: catalog_name, max_results, and page_token. It returns a ListSchemasResponse object as specified in the documentation.",
    "ground_truth_relationship": "The code implements a GET endpoint that takes a catalog name and optional pagination parameters (max_results and page_token) to retrieve a list of schemas from SCHEMA_REPOSITORY, exactly matching the documented API endpoint's parameters and functionality.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core functionality of the listSchemas endpoint, matching the ground truth's description of parameters and purpose.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listSchemas\"></a>\n# **listSchemas**\n> ListSchemasResponse listSchemas(catalog\\_name, max\\_results, page\\_token)\n\nList schemas\n\n    Gets an array of schemas for a catalog. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Parent catalog for schemas of interest. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of schemas to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n\n### Return type\n\n[**ListSchemasResponse**](../Models/ListSchemasResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.listSchemas",
    "predicted_relationship": "The SchemaService.listSchemas method likely uses SchemaRepository.listSchemas to retrieve the actual schema data. This is inferred from the typical service-repository pattern and the matching method name and parameters.",
    "ground_truth_relationship": "The code implements the documented listSchemas API endpoint by querying a database session for schemas matching the given catalog ID, converting the results from DAOs to SchemaInfo objects, handling pagination through maxResults and pageToken parameters, and returning a ListSchemasResponse containing the schema list and next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description assumes a service-repository pattern that isn't present in the actual code. However, it correctly identifies that the method retrieves schema data, though it misses the actual implementation details involving database sessions, pagination, and DAO conversion.",
      "error_type": "architectural_assumption"
    }
  },
  {
    "document_text": "<a name=\"deleteCatalog\"></a>\n# **deleteCatalog**\n> oas_any_type_not_mapped deleteCatalog(name, force)\n\nDelete a catalog\n\n    Deletes the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.deleteCatalog",
    "predicted_relationship": "This method directly implements the deleteCatalog functionality described in the API documentation. It takes the required 'name' parameter and the optional 'force' parameter, matching the documented method signature.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the deleteCatalog functionality but misses that this is specifically a CLI wrapper around the API endpoint, not a direct implementation",
      "error_type": "missing_architectural_layer"
    }
  },
  {
    "document_text": "<a name=\"deleteCatalog\"></a>\n# **deleteCatalog**\n> oas_any_type_not_mapped deleteCatalog(name, force)\n\nDelete a catalog\n\n    Deletes the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.deleteCatalog",
    "predicted_relationship": "This method likely implements the actual deletion of the catalog in the repository. It's implicitly related as it would be called by the CatalogCli.deleteCatalog method to perform the deletion operation.",
    "ground_truth_relationship": "The code implements the documented deleteCatalog operation by handling catalog deletion with optional force removal of schemas, throwing appropriate exceptions if the catalog is not found (ErrorCode.NOT_FOUND) or contains schemas without force flag (ErrorCode.FAILED_PRECONDITION), and managing the transaction across catalog, schema, and property deletions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic function (catalog deletion) but misses key aspects about force deletion handling, schema checks, and error conditions that are central to the relationship between code and documentation.",
      "error_type": "major_omission"
    }
  },
  {
    "document_text": "<a name=\"deleteCatalog\"></a>\n# **deleteCatalog**\n> oas_any_type_not_mapped deleteCatalog(name, force)\n\nDelete a catalog\n\n    Deletes the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogService.deleteCatalog",
    "predicted_relationship": "This service method likely implements the HTTP endpoint for deleting a catalog. It would handle the REST API call described in the documentation and delegate to the repository for actual deletion.",
    "ground_truth_relationship": "The code implements a DELETE endpoint that directly mirrors the documented API behavior by accepting a required 'name' parameter and optional 'force' parameter, invoking the catalog repository's deletion logic, and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that this is a service method implementing a DELETE endpoint for catalog deletion, with correct repository delegation. While it omits specific parameter details and response code, these are minor omissions that don't affect the main functional relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteSchema\"></a>\n# **deleteSchema**\n> oas_any_type_not_mapped deleteSchema(full\\_name, force)\n\nDelete a schema\n\n    Deletes the specified schema from the parent catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaService.deleteSchema",
    "predicted_relationship": "The documentation explicitly describes the 'deleteSchema' operation, which is directly implemented by the SchemaService.deleteSchema method. The method signature matches the documented parameters 'full_name' and 'force'.",
    "ground_truth_relationship": "The code implements the documented DELETE endpoint by accepting a required fullName path parameter and optional force parameter, delegating schema deletion to SCHEMA_REPOSITORY, and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - it correctly identifies that this is a schema deletion endpoint matching the documentation with fullName and force parameters. The omission of HTTP response details is minor.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteSchema\"></a>\n# **deleteSchema**\n> oas_any_type_not_mapped deleteSchema(full\\_name, force)\n\nDelete a schema\n\n    Deletes the specified schema from the parent catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.deleteSchema",
    "predicted_relationship": "While not explicitly mentioned, the SchemaRepository.deleteSchema method is likely used by the SchemaService to perform the actual deletion of the schema from the database.",
    "ground_truth_relationship": "The code implements the documented schema deletion endpoint by recursively removing child tables, volumes, and functions before deleting the schema itself, while respecting the 'force' parameter and throwing a NOT_FOUND exception when the schema doesn't exist.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "While the prediction correctly identifies this as schema deletion functionality, it incorrectly assumes it's part of a SchemaRepository/SchemaService pattern rather than recognizing the actual implementation that handles child elements deletion and exception handling",
      "error_type": "architectural_assumption"
    }
  },
  {
    "document_text": "# **listVolumes**\n> ListVolumesResponseContent listVolumes(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList Volumes\n\n    Gets an array of available volumes under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| The identifier of the catalog | [default to null] |\n| **schema\\_name** | **String**| The identifier of the schema | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of volumes to return (page length).  If not set, the page length is set to a server configured value. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  Note: this parameter controls only the maximum number of volumes to return. The actual number of volumes returned in a page may be smaller than this value, including 0, even if there are more pages.   | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token returned by a previous request. It must be included in the request to retrieve the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListVolumesResponseContent**](../Models/ListVolumesResponseContent.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.listVolumes",
    "predicted_relationship": "The VolumeRepository.listVolumes method directly implements the listVolumes functionality described in the documentation. It takes the same parameters (catalogName, schemaName, maxResults, pageToken) and returns a ListVolumesResponseContent object, which matches the documented return type.",
    "ground_truth_relationship": "The code implements the documented listVolumes API by querying volumes from a database using Hibernate, enforcing the documented parameters (catalog_name, schema_name, max_results, page_token) and returning a ListVolumesResponseContent object containing the filtered volume list.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core functionality of the listVolumes method, matching the documented parameters and return type, even though it doesn't explicitly mention the database/Hibernate implementation details",
      "error_type": "none"
    }
  },
  {
    "document_text": "# **listVolumes**\n> ListVolumesResponseContent listVolumes(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList Volumes\n\n    Gets an array of available volumes under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| The identifier of the catalog | [default to null] |\n| **schema\\_name** | **String**| The identifier of the schema | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of volumes to return (page length).  If not set, the page length is set to a server configured value. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  Note: this parameter controls only the maximum number of volumes to return. The actual number of volumes returned in a page may be smaller than this value, including 0, even if there are more pages.   | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token returned by a previous request. It must be included in the request to retrieve the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListVolumesResponseContent**](../Models/ListVolumesResponseContent.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeService.listVolumes",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeService.listVolumes method is likely the service layer implementation of the listVolumes API endpoint. It matches the parameter structure (catalogName, schemaName, maxResults, pageToken) and would typically call the repository method to fetch the data.",
    "ground_truth_relationship": "The code implements the documented listVolumes API endpoint as a GET HTTP method that accepts the specified catalog_name, schema_name, max_results, and page_token parameters, though it includes an additional undocumented include_browse parameter, and returns a JSON response from the volume repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this is a listVolumes API implementation, but incorrectly assumes it's a service layer component calling a repository when it's actually a controller endpoint that directly calls the repository",
      "error_type": "architectural_misunderstanding"
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeService.createVolume",
    "predicted_relationship": "This method directly implements the createVolume functionality described in the documentation. The method signature matches the documented API, taking a CreateVolumeRequestContent parameter and returning a VolumeInfo object. This is evidenced by the text 'VolumeInfo createVolume(CreateVolumeRequestContent)' in the documentation.",
    "ground_truth_relationship": "The code implements the documented API endpoint by accepting a CreateVolumeRequestContent parameter and returning a JSON HTTP response containing the created volume information, matching the documented input/output specifications and HTTP headers.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship that the code implements the documented API by accepting CreateVolumeRequestContent and returning volume information, even though it omits HTTP-specific details",
      "error_type": ""
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.createVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, this method is likely called by VolumeService.createVolume to perform the actual creation of the volume in the repository. It takes a CreateVolumeRequestContent parameter, which aligns with the documented API.",
    "ground_truth_relationship": "The code implements the documented createVolume operation by validating inputs, creating a VolumeInfo object with a UUID, validating volume type and storage location, and persisting it to the database within a transaction while enforcing schema existence and volume uniqueness constraints.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction identifies that this is a volume creation method, but mischaracterizes it as being called by VolumeService when no such relationship is evident in the code or documentation. The core volume creation functionality is correctly identified though.",
      "error_type": "unsubstantiated_assumption"
    }
  },
  {
    "document_text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeInfoDAO",
    "predicted_relationship": "This class is likely used to convert between the VolumeInfo object (mentioned in the return type of the API) and the database representation of a volume. It's not explicitly mentioned in the documentation but is crucial for implementing the createVolume functionality.",
    "ground_truth_relationship": "The VolumeInfoDAO class provides the data persistence layer and mapping functionality for the createVolume API endpoint by defining the database schema and conversion methods between the API's VolumeInfo model and the database representation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the core purpose of the class as handling conversion between VolumeInfo objects and their database representation, which aligns with the ground truth's description of the data persistence layer and mapping functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteTable\"></a>\n# **deleteTable**\n> oas_any_type_not_mapped deleteTable(full\\_name)\n\nDelete a table\n\n    Deletes a table from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableCli.deleteTable",
    "predicted_relationship": "The TableCli.deleteTable method implements the deleteTable operation described in the documentation. While not explicitly mentioned, it's implicitly related as it handles the CLI side of deleting a table using the full name parameter.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteTable endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions indicate the code implements a CLI wrapper/method for the documented deleteTable API endpoint, with the predicted description accurately capturing this core relationship while adding some implicit details",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteTable\"></a>\n# **deleteTable**\n> oas_any_type_not_mapped deleteTable(full\\_name)\n\nDelete a table\n\n    Deletes a table from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableService.deleteTable",
    "predicted_relationship": "The TableService.deleteTable method directly implements the deleteTable operation described in the documentation. It takes a 'fullName' parameter as mentioned in the API spec ('full_name' in the documentation).",
    "ground_truth_relationship": "The code implements a REST DELETE endpoint that matches the documented API specification by accepting a full_name parameter, invoking TABLE_REPOSITORY.deleteTable(), and returning a 200 OK response with no content body.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that the code implements the documented deleteTable operation with the specified full_name parameter. While it doesn't mention the HTTP status code or repository details, these are minor omissions that don't change the fundamental relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"deleteTable\"></a>\n# **deleteTable**\n> oas_any_type_not_mapped deleteTable(full\\_name)\n\nDelete a table\n\n    Deletes a table from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableRepository.deleteTable",
    "predicted_relationship": "The TableRepository.deleteTable method is implicitly related as it likely implements the actual deletion of the table from the repository. While not explicitly mentioned in the documentation, it's a crucial part of the deletion process.",
    "ground_truth_relationship": "The code implements the documented table deletion operation by removing the table's database entry, deleting its physical files (for managed tables), and cleaning up associated properties, while the documentation describes the API endpoint that exposes this functionality with a 'full_name' parameter.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies this as a table deletion operation but incorrectly assumes a TableRepository class and focuses on repository implementation details rather than recognizing this as the main deletion method that handles both database and file system operations.",
      "error_type": "missing_key_aspects"
    }
  },
  {
    "document_text": "<a name=\"listFunctions\"></a>\n# **listFunctions**\n> ListFunctionsResponse listFunctions(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList functions\n\n    List functions within the specified parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for functions of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of functions. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of functions to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query. | [optional] [default to null] |\n\n### Return type\n\n[**ListFunctionsResponse**](../Models/ListFunctionsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionCli.listFunctions",
    "predicted_relationship": "This method implements the client-side functionality for listing functions, which corresponds to the documented API endpoint. It takes similar parameters (catalogName, schemaName, maxResults) and uses the FunctionsApi to make the request.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listFunctions endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures that this is a client implementation of the listFunctions API, but misses that it specifically implements a CLI wrapper layer rather than just general client functionality",
      "error_type": "missing_key_aspect"
    }
  },
  {
    "document_text": "<a name=\"listFunctions\"></a>\n# **listFunctions**\n> ListFunctionsResponse listFunctions(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList functions\n\n    List functions within the specified parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for functions of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of functions. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of functions to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query. | [optional] [default to null] |\n\n### Return type\n\n[**ListFunctionsResponse**](../Models/ListFunctionsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionService.listFunctions",
    "predicted_relationship": "This method directly implements the documented API endpoint for listing functions. It takes the same parameters (catalogName, schemaName, maxResults, pageToken) as described in the documentation.",
    "ground_truth_relationship": "The code implements a REST GET endpoint that takes the exact parameters specified in the documentation (catalog_name, schema_name, optional max_results, and optional page_token) and delegates the actual function listing to a repository layer, returning the results as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that this is an API endpoint for listing functions that takes the documented parameters. While it doesn't mention the repository layer or JSON response format, these are minor implementation details that don't change the fundamental relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listFunctions\"></a>\n# **listFunctions**\n> ListFunctionsResponse listFunctions(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList functions\n\n    List functions within the specified parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for functions of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of functions. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of functions to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query. | [optional] [default to null] |\n\n### Return type\n\n[**ListFunctionsResponse**](../Models/ListFunctionsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.listFunctions",
    "predicted_relationship": "This method likely implements the data access layer for listing functions, corresponding to the documented API. It takes similar parameters (catalogName, schemaName, maxResults, pageToken) and is probably called by the FunctionService.",
    "ground_truth_relationship": "The code implements the documented behavior by retrieving function records from a database within a read-only transaction, transforming FunctionInfoDAO objects to FunctionInfo objects with attached properties, and returning them in a ListFunctionsResponse with pagination support through maxResults and pageToken parameters.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies this as a data access layer method for listing functions that corresponds to the documented API, with matching parameters. While it omits implementation details about transactions and object transformations, it captures the core relationship between the code and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listCatalogs\"></a>\n# **listCatalogs**\n> ListCatalogsResponse listCatalogs(page\\_token, max\\_results)\n\nList catalogs\n\n    Lists the available catalogs. There is no guarantee of a specific ordering of the elements in the list. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n| **max\\_results** | **Integer**| Maximum number of catalogs to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n\n### Return type\n\n[**ListCatalogsResponse**](../Models/ListCatalogsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.listCatalogs",
    "predicted_relationship": "The CatalogCli.listCatalogs method likely implements the functionality described in the documentation. The method signature in the code artifact matches the parameters described in the documentation (max_results and page_token).",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listCatalogs endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented listCatalogs functionality, including parameter matching. While it's less specific about it being a CLI wrapper, the core relationship is accurately captured.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listCatalogs\"></a>\n# **listCatalogs**\n> ListCatalogsResponse listCatalogs(page\\_token, max\\_results)\n\nList catalogs\n\n    Lists the available catalogs. There is no guarantee of a specific ordering of the elements in the list. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n| **max\\_results** | **Integer**| Maximum number of catalogs to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n\n### Return type\n\n[**ListCatalogsResponse**](../Models/ListCatalogsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogService.listCatalogs",
    "predicted_relationship": "The CatalogService.listCatalogs method directly implements the API endpoint described in the documentation. It takes the same parameters (maxResults and pageToken) as mentioned in the documentation.",
    "ground_truth_relationship": "The code implements the documented REST endpoint by accepting optional maxResults and pageToken parameters, making a repository call, and returning a JSON response containing the list of catalogs in the format specified by ListCatalogsResponse.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - that the code implements the documented API endpoint with matching parameters. While it omits implementation details about the repository call and response format mentioned in the ground truth, these are minor details that don't change the fundamental relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"listCatalogs\"></a>\n# **listCatalogs**\n> ListCatalogsResponse listCatalogs(page\\_token, max\\_results)\n\nList catalogs\n\n    Lists the available catalogs. There is no guarantee of a specific ordering of the elements in the list. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n| **max\\_results** | **Integer**| Maximum number of catalogs to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n\n### Return type\n\n[**ListCatalogsResponse**](../Models/ListCatalogsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.listCatalogs",
    "predicted_relationship": "The CatalogRepository.listCatalogs method likely implements the data access layer for listing catalogs. It takes the same parameters (maxResults and pageToken) as mentioned in the documentation.",
    "ground_truth_relationship": "The code implements the documented listCatalogs endpoint by using database transactions and pagination logic to retrieve catalog records from storage, transform them into CatalogInfo objects with attached properties, and return them in a ListCatalogsResponse with the next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies that it's a data access implementation of listCatalogs with matching parameters, but misses crucial aspects like transaction handling, pagination implementation, and property attachment that are key parts of the relationship",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"updateSchema\"></a>\n# **updateSchema**\n> SchemaInfo updateSchema(full\\_name, UpdateSchema)\n\nUpdate a schema\n\n    Updates the specified schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **UpdateSchema** | [**UpdateSchema**](../Models/UpdateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.updateSchema",
    "predicted_relationship": "The SchemaRepository.updateSchema method directly implements the updateSchema operation described in the documentation. It takes the full name of the schema and an UpdateSchema object as parameters, which matches the documented API. The method returns a SchemaInfo object, which aligns with the documented return type.",
    "ground_truth_relationship": "The code implements the documented schema update endpoint by validating the new schema name, managing database transactions to update the schema's name, comment, and properties, and handling errors according to the API specification's parameters and return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core relationship between the code and documentation - that this is an implementation of a schema update endpoint with matching parameters and return type.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"updateSchema\"></a>\n# **updateSchema**\n> SchemaInfo updateSchema(full\\_name, UpdateSchema)\n\nUpdate a schema\n\n    Updates the specified schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **UpdateSchema** | [**UpdateSchema**](../Models/UpdateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaService.updateSchema",
    "predicted_relationship": "The SchemaService.updateSchema method directly implements the API endpoint described in the documentation. It takes the full name of the schema and an UpdateSchema object as parameters, matching the documented API. The method likely calls SchemaRepository.updateSchema to perform the actual update operation.",
    "ground_truth_relationship": "The code implements a PATCH endpoint that directly matches the documented API endpoint, accepting a fullName path parameter and UpdateSchema body parameter, and returning a JSON response through HttpResponse.ofJson from the schema repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - that this is an endpoint implementation matching the API documentation, taking fullName and UpdateSchema parameters, and returning a response via the schema repository.",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"updateSchema\"></a>\n# **updateSchema**\n> SchemaInfo updateSchema(full\\_name, UpdateSchema)\n\nUpdate a schema\n\n    Updates the specified schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **UpdateSchema** | [**UpdateSchema**](../Models/UpdateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaInfoDAO",
    "predicted_relationship": "The SchemaInfoDAO class is likely used internally to represent and persist the updated schema information. While not explicitly mentioned in the documentation, it's an essential part of the update process, as it would be used to convert between the API model (SchemaInfo) and the database representation.",
    "ground_truth_relationship": "The SchemaInfoDAO class provides the data persistence layer and object mapping functionality needed to support the updateSchema API endpoint by managing schema metadata in the database and converting between SchemaInfo API objects and database entities.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies SchemaInfoDAO's core role in persistence and data conversion between API and database, even if it doesn't spell out all details mentioned in the ground truth",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.updateCatalog",
    "predicted_relationship": "The CatalogCli.updateCatalog method implements the functionality described in the documentation. It takes a catalog name and an UpdateCatalog object as parameters, which aligns with the documented API endpoint.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented updateCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the basic relationship with the documented API endpoint, but misses the crucial aspect that this is a CLI wrapper layer rather than the direct API implementation",
      "error_type": "missing_key_aspect"
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.updateCatalog",
    "predicted_relationship": "The CatalogRepository.updateCatalog method likely implements the core logic for updating a catalog as described in the documentation. It takes a name and UpdateCatalog object as parameters, matching the documented API.",
    "ground_truth_relationship": "The code implements the documented API endpoint by validating the new catalog name, managing a database transaction to update the catalog's properties, name, and comment in a CatalogInfoDAO object, and handling error cases like NOT_FOUND and ALREADY_EXISTS as specified in the documentation's parameters and return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a method for updating a catalog based on name and UpdateCatalog parameters, matching the documented API relationship. While less detailed than the ground truth, it captures the core functionality without contradictions.",
      "error_type": "none"
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogService.updateCatalog",
    "predicted_relationship": "The CatalogService.updateCatalog method directly implements the API endpoint described in the documentation. It takes a name parameter and an UpdateCatalog object, matching the documented interface.",
    "ground_truth_relationship": "The code implements a PATCH endpoint that matches the documented API specifications by accepting a catalog name and UpdateCatalog object as parameters, invoking the repository layer, and returning a JSON HTTP response containing the updated CatalogInfo.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic functionality of accepting name and UpdateCatalog parameters, but misses key aspects like the PATCH HTTP method, repository layer interaction, and JSON response format mentioned in the ground truth",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogInfoDAO",
    "predicted_relationship": "The CatalogInfoDAO is likely used to represent and persist the updated catalog information. The documentation mentions returning a CatalogInfo object, which is probably mapped from this DAO.",
    "ground_truth_relationship": "The CatalogInfoDAO class supports the updateCatalog endpoint by providing the data persistence layer and mapping functions (from/toCatalogInfo) that convert between the API's CatalogInfo model and the database entity representation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core concept that CatalogInfoDAO handles persistence and mapping of catalog data, which aligns with the ground truth's explanation of it supporting the updateCatalog endpoint through persistence and mapping functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getFunction\"></a>\n# **getFunction**\n> FunctionInfo getFunction(name)\n\nGet a function\n\n    Gets a function from within a parent catalog and schema.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.getFunction",
    "predicted_relationship": "The documentation describes a 'getFunction' operation that retrieves a function given its fully-qualified name. This directly corresponds to the 'getFunction' method in the FunctionRepository class. The method signature matches the described parameters, taking a String name as input and returning a FunctionInfo object.",
    "ground_truth_relationship": "The code implements the documented function retrieval by parsing a fully-qualified three-part function name (catalog.schema.function), querying a database session for the function details, and returning a FunctionInfo object as specified in the documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core functionality of retrieving a function using a fully-qualified name and returning a FunctionInfo object, matching the ground truth implementation",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getFunction\"></a>\n# **getFunction**\n> FunctionInfo getFunction(name)\n\nGet a function\n\n    Gets a function from within a parent catalog and schema.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionService.getFunction",
    "predicted_relationship": "While not explicitly mentioned, the FunctionService.getFunction method is likely the service layer implementation of the documented API endpoint. It would handle the HTTP request, delegate to the repository, and return the HTTP response.",
    "ground_truth_relationship": "The code implements a REST GET endpoint that accepts a fully-qualified function name as a path parameter and returns a JSON response containing the function details, directly mapping to the documented API endpoint specification and its expected FunctionInfo return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the core service-repository pattern but introduces uncertainty ('likely') and misses the direct REST API mapping explicitly shown in the code. However, it correctly identifies the general data flow.",
      "error_type": "hedged_description_and_omission"
    }
  },
  {
    "document_text": "<a name=\"getFunction\"></a>\n# **getFunction**\n> FunctionInfo getFunction(name)\n\nGet a function\n\n    Gets a function from within a parent catalog and schema.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "FunctionInfoDAO",
    "predicted_relationship": "The documentation mentions returning a FunctionInfo object. FunctionInfoDAO is likely used internally to represent the function data in the database, which is then converted to a FunctionInfo object for the API response.",
    "ground_truth_relationship": "The FunctionInfoDAO class provides the data persistence layer that enables the documented getFunction endpoint by mapping database records to FunctionInfo objects through JPA annotations and conversion methods toFunctionInfo() and from().",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the core relationship - that FunctionInfoDAO handles database persistence and converts to/from FunctionInfo objects for the API. While it doesn't mention all implementation details like JPA annotations, it captures the essential relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **getVolume**\n> VolumeInfo getVolume(name)\n\nGet a Volume\n\n    Gets a volume for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeService.getVolume",
    "predicted_relationship": "The documentation directly describes a 'getVolume' operation, which is implemented by the VolumeService.getVolume method. The method signature matches the documented parameters (name as a String) and return type (VolumeInfo).",
    "ground_truth_relationship": "The code implements the documented GET endpoint by accepting a required 'full_name' path parameter and an optional 'include_browse' query parameter, returning a JSON response containing volume information from the repository, though the documentation doesn't mention the optional parameter.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship that this is a getVolume operation matching the documentation with a String parameter that returns volume information. The omission of the optional include_browse parameter is a minor detail.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **getVolume**\n> VolumeInfo getVolume(name)\n\nGet a Volume\n\n    Gets a volume for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.getVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeRepository.getVolume method is likely used by VolumeService.getVolume to retrieve the volume information from the database.",
    "ground_truth_relationship": "The code implements the documented getVolume operation by splitting a three-level name parameter into catalog, schema, and volume components, validating the format, and returning a VolumeInfo object retrieved from the database through a DAO pattern.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that the method retrieves volume information from a database, but incorrectly assumes specific repository/service class relationships that aren't evident in the code or documentation. The core database retrieval concept is right but the architectural assumptions introduce uncertainty.",
      "error_type": "architectural_assumption"
    }
  },
  {
    "document_text": "# **getVolume**\n> VolumeInfo getVolume(name)\n\nGet a Volume\n\n    Gets a volume for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "VolumeInfoDAO",
    "predicted_relationship": "The VolumeInfoDAO class is likely used to map the database entity to the VolumeInfo object returned by the getVolume operation.",
    "ground_truth_relationship": "The VolumeInfoDAO class provides the data persistence layer and model conversion methods (toVolumeInfo/from) needed to support the documented getVolume API endpoint by mapping between the database representation and the VolumeInfo response type.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship that VolumeInfoDAO maps between database entities and VolumeInfo objects, which aligns with the ground truth's description of the data persistence and model conversion functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "# **updateVolume**\n> VolumeInfo updateVolume(name, UpdateVolumeRequestContent)\n\nUpdate a Volume\n\n    Updates the specified volume under the specified parent catalog and schema.  Currently only the name or the comment of the volume could be updated. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n| **UpdateVolumeRequestContent** | [**UpdateVolumeRequestContent**](../Models/UpdateVolumeRequestContent.md)|  | [optional] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeService.updateVolume",
    "predicted_relationship": "The documentation directly describes the updateVolume operation, which is implemented by the VolumeService.updateVolume method. The method signature matches the documented parameters: a String for the volume name and an UpdateVolumeRequestContent object. It also returns a VolumeInfo object as specified in the documentation.",
    "ground_truth_relationship": "The code implements a PATCH endpoint that takes a fully qualified volume name and UpdateVolumeRequestContent object as specified in the documentation, delegating the actual update operation to VOLUME_REPOSITORY and wrapping the returned VolumeInfo in an HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic operation and parameters but misses the HTTP endpoint nature of the code and incorrectly refers to 'VolumeService.updateVolume' instead of 'VOLUME_REPOSITORY.updateVolume'",
      "error_type": "implementation_detail_mismatch"
    }
  },
  {
    "document_text": "# **updateVolume**\n> VolumeInfo updateVolume(name, UpdateVolumeRequestContent)\n\nUpdate a Volume\n\n    Updates the specified volume under the specified parent catalog and schema.  Currently only the name or the comment of the volume could be updated. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n| **UpdateVolumeRequestContent** | [**UpdateVolumeRequestContent**](../Models/UpdateVolumeRequestContent.md)|  | [optional] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeRepository.updateVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeService.updateVolume method likely delegates the actual update operation to the VolumeRepository.updateVolume method, which handles the persistence layer operations.",
    "ground_truth_relationship": "The code implements the documented volume update functionality by validating the new name if provided, handling the three-level namespace split, and using database transactions to modify either the volume's name or comment while preventing duplicate names and handling non-existent volumes as specified in the documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description suggests delegation to VolumeRepository which is incorrect, but correctly implies database persistence operations. The ground truth shows direct database interaction using Session/Transaction rather than repository delegation.",
      "error_type": "incorrect_architectural_assumption"
    }
  },
  {
    "document_text": "# **updateVolume**\n> VolumeInfo updateVolume(name, UpdateVolumeRequestContent)\n\nUpdate a Volume\n\n    Updates the specified volume under the specified parent catalog and schema.  Currently only the name or the comment of the volume could be updated. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n| **UpdateVolumeRequestContent** | [**UpdateVolumeRequestContent**](../Models/UpdateVolumeRequestContent.md)|  | [optional] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "VolumeInfoDAO",
    "predicted_relationship": "The VolumeInfoDAO is likely used internally by the VolumeRepository.updateVolume method to persist the updated volume information. It represents the data access object for volume information.",
    "ground_truth_relationship": "The VolumeInfoDAO class implements the data persistence layer for volumes, with fields and conversion methods that match the VolumeInfo structure referenced in the updateVolume API documentation, particularly supporting the comment and name fields that are marked as updatable in the documentation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that VolumeInfoDAO is used for volume data persistence and is connected to volume updates, which aligns with the ground truth's description of it implementing the data persistence layer for volumes.",
      "error_type": null
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.createFunction",
    "predicted_relationship": "The documentation explicitly mentions a 'createFunction' API endpoint with a POST request to '/functions'. This directly corresponds to the FunctionCli.createFunction method, which implements the client-side logic for creating a function.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements functionality to interact with the documented createFunction API endpoint as a client-side wrapper. Both descriptions capture the core relationship between the code and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.deleteFunction",
    "predicted_relationship": "The documentation explicitly mentions a 'deleteFunction' API endpoint with a DELETE request to '/functions/{name}'. This directly corresponds to the FunctionCli.deleteFunction method, which implements the client-side logic for deleting a function.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented deleteFunction API endpoint functionality, matching the ground truth's assertion that it's a CLI wrapper for this endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.getFunction",
    "predicted_relationship": "The documentation explicitly mentions a 'getFunction' API endpoint with a GET request to '/functions/{name}'. This directly corresponds to the FunctionCli.getFunction method, which implements the client-side logic for retrieving a function.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented getFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that the code implements client functionality for the documented getFunction API endpoint, which matches the ground truth's description of it being a CLI wrapper for that endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionCli.listFunctions",
    "predicted_relationship": "The documentation explicitly mentions a 'listFunctions' API endpoint with a GET request to '/functions'. This directly corresponds to the FunctionCli.listFunctions method, which implements the client-side logic for listing functions.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listFunctions endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code relates to implementing the documented listFunctions API endpoint via a GET request, and captures the essential relationship between the code and documentation",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.createFunction",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the FunctionService.createFunction method is implicitly related as it would be the server-side implementation of the 'createFunction' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the experimental POST /functions endpoint documented in the API table by defining a createFunction method that accepts a CreateFunctionRequest and returns an HTTP response containing the newly created function data from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "While the prediction correctly identifies that the code relates to the createFunction API functionality, it introduces uncertainty by saying it's 'implicitly related' when the relationship is actually explicit and direct. It also mentions 'FunctionService' which isn't present in the code.",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.deleteFunction",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the FunctionService.deleteFunction method is implicitly related as it would be the server-side implementation of the 'deleteFunction' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the documented DELETE /functions/{name} endpoint by providing a method that accepts a function name and optional force parameter, deleting the specified function through the repository and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented DELETE function endpoint, even though it uses different wording focusing on the service layer rather than the specific parameters and response details.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.getFunction",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the FunctionService.getFunction method is implicitly related as it would be the server-side implementation of the 'getFunction' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the documented GET /functions/{name} endpoint by creating a controller method that accepts a name parameter and returns a JSON response containing the function details from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "Both descriptions identify that this is an implementation of the GET /functions/{name} endpoint that retrieves function details. The predicted text captures the core relationship between the code and documentation, even if it uses different wording.",
      "error_type": ""
    }
  },
  {
    "document_text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
    "artifact_title": "FunctionService.listFunctions",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the FunctionService.listFunctions method is implicitly related as it would be the server-side implementation of the 'listFunctions' API endpoint described in the documentation.",
    "ground_truth_relationship": "The code implements the documented GET /functions endpoint by defining a listFunctions method that accepts catalog name, schema name, pagination parameters, and returns an HTTP response containing the list of functions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the listFunctions API endpoint documented in the documentation, just with less detail about the specific parameters and return value.",
      "error_type": ""
    }
  },
  {
    "document_text": "# TemporaryVolumeCredentialsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**generateTemporaryVolumeCredentials**](TemporaryVolumeCredentialsApi.md#generateTemporaryVolumeCredentials) | **POST** /temporary-volume-credentials | Generate temporary volume credentials. |",
    "artifact_title": "TemporaryVolumeCredentialsService.generateTemporaryVolumeCredentials",
    "predicted_relationship": "This method directly implements the generateTemporaryVolumeCredentials API endpoint described in the documentation. The documentation specifies a POST request to '/temporary-volume-credentials' for generating temporary volume credentials, which is exactly what this method handles.",
    "ground_truth_relationship": "The code implements the documented POST endpoint '/temporary-volume-credentials' by handling volume credential generation requests, validating the volume ID, and returning temporary AWS credentials for S3 volumes or empty credentials for local filesystems.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic POST endpoint implementation but omits crucial functionality around S3 vs local filesystem credential handling and validation steps",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.createSchema",
    "predicted_relationship": "The documentation explicitly mentions 'createSchema' as a POST method for creating a schema. This directly corresponds to the SchemaService.createSchema method which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented POST /schemas API endpoint by defining a createSchema method that accepts a CreateSchema object and returns a JSON HTTP response containing the newly created schema from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship that this is a POST endpoint for creating schemas, which matches the ground truth's explanation of implementing the POST /schemas endpoint for schema creation",
      "error_type": "none"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.deleteSchema",
    "predicted_relationship": "The documentation explicitly mentions 'deleteSchema' as a DELETE method for deleting a schema. This directly corresponds to the SchemaService.deleteSchema method which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented DELETE /schemas/{full_name} endpoint by providing a method that accepts a schema's full name and an optional force parameter, deletes the specified schema from the repository, and returns an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the core relationship between the code and documentation - that it implements the DELETE /schemas/{full_name} endpoint for deleting schemas. While it omits details about parameters and response, these are minor details that don't affect the main relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.getSchema",
    "predicted_relationship": "The documentation explicitly mentions 'getSchema' as a GET method for retrieving a schema. This directly corresponds to the SchemaService.getSchema method which implements this functionality.",
    "ground_truth_relationship": "The code implements the GET /schemas/{full_name} endpoint documented in the API table by defining a method that retrieves a schema using the full_name path parameter and returns it as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies this as the GET /schemas/{full_name} endpoint implementation for retrieving a schema, which matches the ground truth's description of the relationship",
      "error_type": "none"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.listSchemas",
    "predicted_relationship": "The documentation explicitly mentions 'listSchemas' as a GET method for listing schemas. This directly corresponds to the SchemaService.listSchemas method which implements this functionality.",
    "ground_truth_relationship": "The listSchemas method implements the '/schemas' GET endpoint documented in the API table by accepting catalog_name, max_results, and page_token parameters and returning schema listings as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the listSchemas GET method corresponds to the documented API endpoint, capturing the core relationship between code and documentation, even though it omits parameter details.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaService.updateSchema",
    "predicted_relationship": "The documentation explicitly mentions 'updateSchema' as a PATCH method for updating a schema. This directly corresponds to the SchemaService.updateSchema method which implements this functionality.",
    "ground_truth_relationship": "The code implements the updateSchema API endpoint documented in the table by creating a PATCH handler at '/schemas/{full_name}' that accepts a schema name and update payload, passing them to the schema repository for processing.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented PATCH endpoint for updating schemas, capturing the core mapping between the documentation and implementation",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.createSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.createSchema method is likely used by SchemaService.createSchema to perform the actual schema creation in the database.",
    "ground_truth_relationship": "The SchemaRepository.createSchema method implements the backend logic for the POST /schemas endpoint by validating the schema name, checking for duplicates, creating a new SchemaInfo object with a UUID, persisting it to the database within a transaction, and returning the created schema details.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The prediction correctly identifies that the method is involved in schema creation but inaccurately suggests it's used by SchemaService rather than directly implementing the POST /schemas endpoint. It misses key aspects like validation, transaction handling, and persistence.",
      "error_type": "incorrect_architecture_assumption"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.deleteSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.deleteSchema method is likely used by SchemaService.deleteSchema to perform the actual schema deletion in the database.",
    "ground_truth_relationship": "The SchemaRepository.deleteSchema method implements the DELETE /schemas/{full_name} API endpoint by handling schema deletion logic, including processing child tables, volumes, and functions, and removing associated properties from the database session.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies this as a schema deletion method, but incorrectly suggests it's used by SchemaService when it actually implements the DELETE API endpoint directly. It also misses mentioning the key functionality of processing child elements.",
      "error_type": "incorrect_architectural_relationship"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.getSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.getSchema method is likely used by SchemaService.getSchema to retrieve the schema information from the database.",
    "ground_truth_relationship": "The SchemaRepository.getSchema method implements the GET /schemas/{full_name} API endpoint by retrieving schema information from a database, converting it from DAO format, and attaching properties while managing database transactions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that the method retrieves schema information from a database, but it incorrectly suggests it's used by SchemaService rather than directly implementing the GET API endpoint",
      "error_type": "incorrect_service_relationship"
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.listSchemas",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.listSchemas method is likely used by SchemaService.listSchemas to retrieve the list of schemas from the database.",
    "ground_truth_relationship": "The code implements the GET /schemas endpoint by retrieving schemas from a database session, supporting pagination through maxResults and pageToken parameters, and returning a ListSchemasResponse containing schema information and a next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the method retrieves schemas from a database, which aligns with the ground truth's core functionality of implementing a GET endpoint to retrieve schemas. While the ground truth provides more implementation details about pagination and response format, the predicted description captures the main relationship correctly.",
      "error_type": ""
    }
  },
  {
    "document_text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
    "artifact_title": "SchemaRepository.updateSchema",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the SchemaRepository.updateSchema method is likely used by SchemaService.updateSchema to perform the actual schema update in the database.",
    "ground_truth_relationship": "The SchemaRepository.updateSchema method implements the PATCH /schemas/{full_name} API endpoint by handling the validation, modification, and persistence of schema updates including name changes, comments, and properties within a database transaction.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this is a schema update method, but incorrectly suggests it's used by a SchemaService rather than directly implementing the PATCH endpoint. It also misses the key aspects of validation and transaction management.",
      "error_type": "incomplete_understanding"
    }
  },
  {
    "document_text": "<a name=\"generateTemporaryTableCredentials\"></a>\n# **generateTemporaryTableCredentials**\n> GenerateTemporaryTableCredentialResponse generateTemporaryTableCredentials(GenerateTemporaryTableCredential)\n\nGenerate temporary table credentials.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **GenerateTemporaryTableCredential** | [**GenerateTemporaryTableCredential**](../Models/GenerateTemporaryTableCredential.md)|  | [optional] |\n\n### Return type\n\n[**GenerateTemporaryTableCredentialResponse**](../Models/GenerateTemporaryTableCredentialResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json\n",
    "artifact_title": "TemporaryTableCredentialsService.generateTemporaryTableCredentials",
    "predicted_relationship": "This method directly implements the generateTemporaryTableCredentials functionality described in the documentation. The method signature matches the documented API call, taking a GenerateTemporaryTableCredential parameter and returning a GenerateTemporaryTableCredentialResponse.",
    "ground_truth_relationship": "The code implements the documented API endpoint by checking if a table exists at a storage location, then either generating AWS S3 temporary credentials or returning empty credentials for local filesystems, matching the documented GenerateTemporaryTableCredentialResponse return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the basic API structure but misses the core functionality of checking storage location and generating credentials specifically for S3 vs local filesystems",
      "error_type": "missing_core_functionality"
    }
  },
  {
    "document_text": "<a name=\"listTables\"></a>\n# **listTables**\n> ListTablesResponse listTables(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList tables\n\n    Gets the list of all available tables under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for tables of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of tables. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of tables to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token to send for the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListTablesResponse**](../Models/ListTablesResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableService.listTables",
    "predicted_relationship": "The documentation directly describes the 'listTables' operation, which is implemented by the TableService.listTables method. The method signature matches the documented parameters: catalog_name, schema_name, max_results, and page_token. It also returns a ListTablesResponse object as specified in the documentation.",
    "ground_truth_relationship": "The code implements the documented API endpoint by accepting the same catalog_name, schema_name, max_results, and page_token parameters, while also including two additional optional parameters (omit_properties and omit_columns) that are not mentioned in the documentation, then delegates the actual table listing to TABLE_REPOSITORY and returns the result as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the core API functionality but misses mentioning the two additional parameters (omit_properties and omit_columns) and the TABLE_REPOSITORY delegation, which are significant implementation details mentioned in the ground truth",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"listTables\"></a>\n# **listTables**\n> ListTablesResponse listTables(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList tables\n\n    Gets the list of all available tables under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for tables of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of tables. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of tables to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token to send for the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListTablesResponse**](../Models/ListTablesResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableRepository.listTables",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableService.listTables method likely uses TableRepository.listTables to retrieve the actual table data. This method also matches the parameter structure described in the documentation, including catalog_name, schema_name, maxResults, and pageToken.",
    "ground_truth_relationship": "The code implements the documented listTables endpoint by querying a database session for table records matching the given catalog and schema names, handling pagination through maxResults and pageToken parameters, and returning a ListTablesResponse object containing the table list and next page token.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this implements a listTables API endpoint with matching parameters, but incorrectly assumes it uses a TableRepository.listTables method when the code actually uses a database session directly with a LISTING_HELPER",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "<a name=\"getSchema\"></a>\n# **getSchema**\n> SchemaInfo getSchema(full\\_name)\n\nGet a schema\n\n    Gets the specified schema for a catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.getSchema",
    "predicted_relationship": "The SchemaRepository.getSchema method likely implements the core functionality described in the documentation. It takes a 'fullName' parameter, which corresponds to the 'full_name' parameter in the API documentation. The method is expected to return a SchemaInfo object, matching the documented return type.",
    "ground_truth_relationship": "The code implements the documented getSchema operation by retrieving a schema from a database session, converting it from DAO format to SchemaInfo, and attaching properties, while handling the specified error case for when the schema is not found.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures the basic functionality of getSchema and its parameters/return type, but misses key implementation details about database interactions, DAO conversion, and error handling that are crucial parts of how it works",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "<a name=\"getSchema\"></a>\n# **getSchema**\n> SchemaInfo getSchema(full\\_name)\n\nGet a schema\n\n    Gets the specified schema for a catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaService.getSchema",
    "predicted_relationship": "The SchemaService.getSchema method directly implements the API endpoint described in the documentation. It takes a 'fullName' parameter, matching the 'full_name' parameter in the API spec. The method is annotated with @Get(\"/{full_name}\"), indicating it handles GET requests for the schema endpoint.",
    "ground_truth_relationship": "The code implements the documented GET endpoint with path parameter 'full_name' by returning a JSON HTTP response containing schema information retrieved from SCHEMA_REPOSITORY.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - that the code implements a GET endpoint that takes a full_name parameter and returns schema information. While it doesn't explicitly mention SCHEMA_REPOSITORY or JSON response, these are minor details that don't change the fundamental relationship.",
      "error_type": "none"
    }
  },
  {
    "document_text": "<a name=\"getSchema\"></a>\n# **getSchema**\n> SchemaInfo getSchema(full\\_name)\n\nGet a schema\n\n    Gets the specified schema for a catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "SchemaInfoDAO",
    "predicted_relationship": "The SchemaInfoDAO class is likely used to represent the schema information in the database. It would be used by SchemaRepository.getSchema to retrieve and return the schema data. The toSchemaInfo() method in SchemaInfoDAO would convert the database representation to the SchemaInfo object returned by the API.",
    "ground_truth_relationship": "The SchemaInfoDAO class provides the data persistence and transformation layer for the SchemaInfo object that is returned by the documented getSchema endpoint, handling the mapping between database records and the API response model.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that SchemaInfoDAO handles database representation and transformation of schema data, serving as the persistence layer that works with SchemaInfo objects, which aligns with the ground truth's explanation of its role.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "TableService.createTable",
    "predicted_relationship": "The documentation describes a 'createTable' operation that takes a CreateTable object and returns a TableInfo object. This directly corresponds to the TableService.createTable method, which implements this functionality.",
    "ground_truth_relationship": "The code implements the documented POST endpoint by accepting a CreateTable request object, validating it's not null, delegating to the TABLE_REPOSITORY to create the table, and returning a TableInfo response wrapped in an HTTP JSON response, matching the documented input/output types and content types.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core relationship - that the code implements a createTable operation accepting CreateTable input and returning TableInfo output, matching the documentation. While it omits implementation details like null checks and HTTP wrapping, these are minor details that don't affect the core relationship.",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "TableRepository.createTable",
    "predicted_relationship": "While not explicitly mentioned, the TableService.createTable method likely delegates to TableRepository.createTable for the actual table creation logic.",
    "ground_truth_relationship": "The code implements the documented createTable API by validating the table name, creating a new TableInfo object with the specified properties, checking for existing tables, rejecting MANAGED table types, requiring storage locations for external tables, and persisting the table data in a database transaction while handling errors as specified in the API documentation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description oversimplifies the relationship by suggesting it merely delegates to a TableRepository, missing crucial aspects like validation, table type checking, storage location requirements, and transaction management. However, it correctly identifies that it's about table creation.",
      "error_type": "oversimplification_and_missing_core_logic"
    }
  },
  {
    "document_text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "TableInfoDAO",
    "predicted_relationship": "The TableInfo object returned by the createTable operation is likely based on or converted from a TableInfoDAO object used for database operations.",
    "ground_truth_relationship": "The TableInfoDAO class provides the persistence layer mapping and conversion logic for the TableInfo objects returned by the documented createTable API endpoint, handling the storage and retrieval of table metadata in the 'uc_tables' database table.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that TableInfo objects are based on/converted from TableInfoDAO objects, which aligns with the ground truth's explanation of TableInfoDAO providing persistence mapping and conversion for TableInfo objects.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogCli.getCatalog",
    "predicted_relationship": "The documentation directly describes a 'getCatalog' operation that takes a 'name' parameter and returns a CatalogInfo object. This matches exactly with the CatalogCli.getCatalog method, which implements this functionality on the client side.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented getCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the core getCatalog functionality but misses that this is specifically a CLI wrapper implementation of the documented API endpoint",
      "error_type": "missing_crucial_context"
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogService.getCatalog",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the CatalogService.getCatalog method is likely the server-side implementation of the getCatalog operation described in the API documentation. It would handle the actual retrieval of catalog information based on the provided name.",
    "ground_truth_relationship": "The code implements the documented REST GET endpoint by accepting a name parameter and returning a JSON response containing catalog information, exactly matching the API specification's path parameter and response format requirements.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a server-side implementation of the getCatalog operation that retrieves catalog information based on a name parameter, which aligns with the ground truth's description of a REST GET endpoint returning catalog data.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.getCatalog",
    "predicted_relationship": "Although not directly mentioned, the CatalogRepository.getCatalog method is likely used to retrieve the catalog information from the data store based on the name parameter described in the API documentation.",
    "ground_truth_relationship": "The code directly implements the documented getCatalog operation by querying the database for a CatalogInfoDAO entity matching the specified name parameter using Hibernate's query language and returning a single result.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core functionality - retrieving catalog information based on a name parameter from a data store, which aligns with the ground truth implementation of querying a database for CatalogInfoDAO by name",
      "error_type": "none"
    }
  },
  {
    "document_text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "CatalogInfoDAO",
    "predicted_relationship": "The CatalogInfoDAO class likely represents the data model for the CatalogInfo object mentioned in the API documentation as the return type. It would be used to map the database representation to the API response.",
    "ground_truth_relationship": "The CatalogInfoDAO class provides the data persistence layer and mapping functionality for the CatalogInfo objects that are returned by the documented getCatalog endpoint through its toCatalogInfo() conversion method.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies CatalogInfoDAO as representing the data model for CatalogInfo and its role in mapping between database and API representations, which aligns with the ground truth's core meaning about providing data persistence and mapping functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getTable\"></a>\n# **getTable**\n> TableInfo getTable(full\\_name)\n\nGet a table\n\n    Gets a table for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableRepository.getTable",
    "predicted_relationship": "The documentation describes a 'getTable' operation that takes a 'full_name' parameter and returns a TableInfo object. This directly corresponds to the TableRepository.getTable method, which implements this functionality. The method signature in the code matches the described API, taking a String fullName parameter and returning a TableInfo object.",
    "ground_truth_relationship": "The code implements the documented getTable operation by parsing a fully qualified table name into catalog, schema, and table components, retrieving the table information from a database session, and returning a TableInfo object with attached properties, exactly matching the documented input parameter and return type specifications.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship between the documentation and code - a getTable operation that takes a full_name string parameter and returns a TableInfo object. While it omits implementation details about parsing and database operations, these are secondary details that don't affect the main relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getTable\"></a>\n# **getTable**\n> TableInfo getTable(full\\_name)\n\nGet a table\n\n    Gets a table for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableService.getTable",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the TableService.getTable method is likely the service layer implementation of the documented API. It takes a 'fullName' parameter and returns an HttpResponse containing the TableInfo, which aligns with the API description.",
    "ground_truth_relationship": "The code implements a REST endpoint annotated with @Get that takes a full_name parameter, validates it's not null, retrieves table information via TABLE_REPOSITORY, and returns it as JSON - matching the documented API endpoint behavior, parameter requirements, and TableInfo return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures the core relationship that the code implements a documented API endpoint for retrieving table information via a fullName parameter and returning TableInfo, even though it doesn't mention some implementation details like the @Get annotation.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"getTable\"></a>\n# **getTable**\n> TableInfo getTable(full\\_name)\n\nGet a table\n\n    Gets a table for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
    "artifact_title": "TableInfoDAO",
    "predicted_relationship": "The documentation mentions returning a TableInfo object. TableInfoDAO is likely used internally to represent the table data in the database, which is then converted to the TableInfo object returned by the API.",
    "ground_truth_relationship": "The TableInfoDAO class provides the data persistence layer and model conversion methods that enable the documented getTable API endpoint to retrieve and return table information in the expected TableInfo format.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that TableInfoDAO is used for database representation and conversion to TableInfo objects which aligns with the ground truth's explanation of it being the data persistence layer that enables the getTable API endpoint functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.createCatalog",
    "predicted_relationship": "This method implements the 'createCatalog' API endpoint described in the documentation. The documentation explicitly mentions 'createCatalog' under the HTTP POST request for '/catalogs' to create a catalog.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that the code implements the createCatalog API endpoint, but misses the crucial aspect that it's specifically a CLI wrapper around that endpoint, which is a key part of the ground truth",
      "error_type": "missing_key_context"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.deleteCatalog",
    "predicted_relationship": "This method implements the 'deleteCatalog' API endpoint described in the documentation. The documentation explicitly mentions 'deleteCatalog' under the HTTP DELETE request for '/catalogs/{name}' to delete a catalog.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented deleteCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies that this relates to the deleteCatalog API endpoint, but misses that it's specifically a CLI wrapper around that endpoint rather than the endpoint implementation itself",
      "error_type": "missing_crucial_context"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.getCatalog",
    "predicted_relationship": "This method implements the 'getCatalog' API endpoint described in the documentation. The documentation explicitly mentions 'getCatalog' under the HTTP GET request for '/catalogs/{name}' to get a catalog.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented getCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the correct API endpoint relationship but misses that this is specifically a CLI wrapper implementation rather than the API endpoint itself",
      "error_type": "missing_crucial_context"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.listCatalogs",
    "predicted_relationship": "This method implements the 'listCatalogs' API endpoint described in the documentation. The documentation explicitly mentions 'listCatalogs' under the HTTP GET request for '/catalogs' to list catalogs.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented listCatalogs endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies this as implementing the listCatalogs API endpoint, but misses the crucial aspect that it's specifically a CLI wrapper implementation, not just a direct API implementation",
      "error_type": "incomplete_understanding"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogCli.updateCatalog",
    "predicted_relationship": "This method implements the 'updateCatalog' API endpoint described in the documentation. The documentation explicitly mentions 'updateCatalog' under the HTTP PATCH request for '/catalogs/{name}' to update a catalog.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented updateCatalog endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted text correctly identifies that the code relates to the updateCatalog API endpoint, but misses the crucial aspect that this is a CLI wrapper implementation rather than the direct API implementation",
      "error_type": "incomplete_understanding"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.createCatalog",
    "predicted_relationship": "This method directly implements the 'createCatalog' API endpoint described in the documentation. It handles the HTTP POST request for '/catalogs' to create a catalog.",
    "ground_truth_relationship": "The code implements the documented POST /catalogs endpoint through a @Post-annotated method that accepts a CreateCatalog object and returns a JSON response from the catalog repository's add operation.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that this is a POST endpoint implementation for creating catalogs as documented. Both descriptions align on the key aspects of the HTTP method, endpoint purpose, and basic functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.deleteCatalog",
    "predicted_relationship": "This method directly implements the 'deleteCatalog' API endpoint described in the documentation. It handles the HTTP DELETE request for '/catalogs/{name}' to delete a catalog.",
    "ground_truth_relationship": "Rep handler method that accepts a catalog name parameter and an optional force parameter, and returns a 200 OK response after delegating the deletion to a repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures that this is a DELETE endpoint handler for deleting catalogs, which aligns with the ground truth's description of it being a request handler for catalog deletion. While the ground truth includes more implementation details about parameters and repository delegation, the core relationship is the same.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.getCatalog",
    "predicted_relationship": "This method directly implements the 'getCatalog' API endpoint described in the documentation. It handles the HTTP GET request for '/catalogs/{name}' to get a catalog.",
    "ground_truth_relationship": "The code implements the documented GET /catalogs/{name} endpoint by creating a method annotated with @Get that takes a name parameter and returns a catalog object as JSON via the repository layer.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that this method implements the documented GET /catalogs/{name} endpoint. While it doesn't mention the repository layer or JSON response details from the ground truth, these are minor implementation details that don't affect the main relationship.",
      "error_type": "none"
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.listCatalogs",
    "predicted_relationship": "This method directly implements the 'listCatalogs' API endpoint described in the documentation. It handles the HTTP GET request for '/catalogs' to list catalogs.",
    "ground_truth_relationship": "The listCatalogs code implements the documented GET /catalogs endpoint by accepting optional pagination parameters (max_results and page_token) and returning a JSON response of catalogs from the repository.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description captures the core relationship - that this implements the GET /catalogs endpoint for listing catalogs. While it doesn't mention the pagination parameters, this omission doesn't change the fundamental understanding of the relationship.",
      "error_type": ""
    }
  },
  {
    "document_text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
    "artifact_title": "CatalogService.updateCatalog",
    "predicted_relationship": "This method directly implements the 'updateCatalog' API endpoint described in the documentation. It handles the HTTP PATCH request for '/catalogs/{name}' to update a catalog.",
    "ground_truth_relationship": "The code implements the documented PATCH /catalogs/{name} endpoint by providing a method that accepts a catalog name parameter and update payload, returning the updated catalog as JSON via HttpResponse.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship between the code and documentation - both describe implementing a PATCH endpoint for updating catalogs at '/catalogs/{name}'",
      "error_type": null
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionService.createFunction",
    "predicted_relationship": "The documentation explicitly describes the 'createFunction' operation, which is implemented by the FunctionService.createFunction method. The method signature matches the documented API, taking a CreateFunctionRequest parameter and returning a FunctionInfo object.",
    "ground_truth_relationship": "The code implements the documented REST API endpoint by exposing a POST method that accepts a CreateFunctionRequest object, delegates to FUNCTION_REPOSITORY for function creation, and returns the result wrapped in an HTTP JSON response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly captures that this is a function creation endpoint that takes CreateFunctionRequest and returns function info, matching the ground truth's implementation of a POST endpoint that handles function creation.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionInfoDAO",
    "predicted_relationship": "The FunctionInfoDAO is likely used internally to persist the created function's information. While not explicitly mentioned in the documentation, it's a necessary component for storing the FunctionInfo returned by the createFunction operation.",
    "ground_truth_relationship": "The FunctionInfoDAO class provides the database persistence layer and object mapping functionality that enables the createFunction API endpoint to store and retrieve function metadata in the uc_functions table, converting between the API's FunctionInfo model and its database representation.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies FunctionInfoDAO as an internal persistence component for storing function information, which aligns with the ground truth's description of it being the database persistence layer for the createFunction API",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionRepository.createFunction",
    "predicted_relationship": "The FunctionRepository.createFunction method is likely called by the FunctionService to handle the actual creation and persistence of the function. While not explicitly mentioned, it's a crucial part of the implementation of the createFunction operation.",
    "ground_truth_relationship": "The code implements the documented createFunction API endpoint by validating the input function name, constructing a FunctionInfo object with all required properties, and persisting it in a database transaction while handling schema validation and duplicate function checks.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description identifies the core function creation purpose but incorrectly assumes FunctionRepository/FunctionService involvement when the code shows direct implementation within the method itself",
      "error_type": "incorrect_architecture_assumption"
    }
  },
  {
    "document_text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "FunctionCli.createFunction",
    "predicted_relationship": "While not directly mentioned in the API documentation, the FunctionCli.createFunction method likely provides a command-line interface for creating functions, utilizing the same underlying API described in the documentation.",
    "ground_truth_relationship": "The code implements a CLI wrapper for the documented createFunction endpoint.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is a CLI wrapper/interface for the documented createFunction API endpoint, which is the core relationship between the code and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createCatalog\"></a>\n# **createCatalog**\n> CatalogInfo createCatalog(CreateCatalog)\n\nCreate a catalog\n\n    Creates a new catalog instance. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateCatalog** | [**CreateCatalog**](../Models/CreateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogRepository.addCatalog",
    "predicted_relationship": "The CatalogRepository.addCatalog method likely implements the core functionality of creating a new catalog. While not explicitly mentioned, it's implicitly required to fulfill the documented 'Create a catalog' operation. The method signature matches the expected input (CreateCatalog) and output (CatalogInfo) types mentioned in the documentation.",
    "ground_truth_relationship": "The addCatalog implementation validates SQL object names, creates a CatalogInfo instance with a UUID and properties, and persists it to the database in a transaction, fulfilling the documented createCatalog API endpoint's purpose of creating a new catalog instance.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the method implements catalog creation functionality and matches the documented API's input/output types. While it omits implementation details like validation and persistence, it captures the core relationship between the code and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createCatalog\"></a>\n# **createCatalog**\n> CatalogInfo createCatalog(CreateCatalog)\n\nCreate a catalog\n\n    Creates a new catalog instance. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateCatalog** | [**CreateCatalog**](../Models/CreateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogService.createCatalog",
    "predicted_relationship": "This method directly implements the createCatalog operation described in the documentation. It takes a CreateCatalog object as input and returns an HttpResponse containing a CatalogInfo object, matching the documented API signature.",
    "ground_truth_relationship": "The code implements the documented API endpoint by accepting a CreateCatalog object via POST, persisting it through CATALOG_REPOSITORY, and returning a JSON response matching the documented CatalogInfo return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that the method implements the documented API endpoint, takes a CreateCatalog input, and returns a response containing the catalog information. While it doesn't mention CATALOG_REPOSITORY specifically, this is a minor implementation detail.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createCatalog\"></a>\n# **createCatalog**\n> CatalogInfo createCatalog(CreateCatalog)\n\nCreate a catalog\n\n    Creates a new catalog instance. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateCatalog** | [**CreateCatalog**](../Models/CreateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "CatalogInfoDAO",
    "predicted_relationship": "While not explicitly mentioned, the CatalogInfoDAO is likely used to persist and retrieve catalog information. The documentation mentions returning a CatalogInfo object, which would be converted from a CatalogInfoDAO instance.",
    "ground_truth_relationship": "The CatalogInfoDAO class provides the data persistence layer and mapping functionality for the CatalogInfo objects that are returned by the documented createCatalog API endpoint, with methods to convert between the DAO and API model representations.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies CatalogInfoDAO's core purpose as persisting and retrieving catalog information, and mentions the conversion relationship with CatalogInfo objects, which aligns with the ground truth's description of it serving as a data persistence layer with mapping functionality.",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.createVolume",
    "predicted_relationship": "The documentation explicitly mentions 'createVolume' under the POST method, which corresponds to the VolumeService.createVolume method. This method implements the API endpoint for creating a new volume.",
    "ground_truth_relationship": "The code implements the POST /volumes endpoint documented in the API table by defining a method that accepts a CreateVolumeRequestContent object and delegates to VOLUME_REPOSITORY to create a new volume, returning the result as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is an implementation of the POST /volumes endpoint for creating volumes, which aligns with the ground truth's explanation of the code implementing the documented API endpoint",
      "error_type": "none"
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.deleteVolume",
    "predicted_relationship": "The documentation explicitly mentions 'deleteVolume' under the DELETE method, which corresponds to the VolumeService.deleteVolume method. This method implements the API endpoint for deleting a volume.",
    "ground_truth_relationship": "The code implements the documented DELETE /volumes/{name} endpoint by accepting a volume's full name as a path parameter, delegating the deletion to VOLUME_REPOSITORY, and returning an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the core relationship - that the code implements the documented DELETE /volumes endpoint for deleting volumes. While it's less detailed than the ground truth, it captures the essential functionality without any contradictions.",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.getVolume",
    "predicted_relationship": "The documentation explicitly mentions 'getVolume' under the GET method, which corresponds to the VolumeService.getVolume method. This method implements the API endpoint for retrieving a volume's information.",
    "ground_truth_relationship": "The code implements the documented GET /volumes/{name} endpoint by providing a method that retrieves volume information based on a full name parameter and returns it as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship - that this is a GET endpoint implementation for retrieving volume information, which aligns with the ground truth's description of implementing the GET /volumes/{name} endpoint.",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.listVolumes",
    "predicted_relationship": "The documentation explicitly mentions 'listVolumes' under the GET method, which corresponds to the VolumeService.listVolumes method. This method implements the API endpoint for listing volumes.",
    "ground_truth_relationship": "The code implements the 'listVolumes' API endpoint documented in the table by defining a GET handler that accepts query parameters for catalog_name, schema_name, pagination controls, and browse options, returning the results as JSON.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the core relationship - that this implements the documented GET /volumes listVolumes API endpoint. While it omits details about parameters and return format, it captures the essential mapping between code and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeService.updateVolume",
    "predicted_relationship": "The documentation explicitly mentions 'updateVolume' under the PATCH method, which corresponds to the VolumeService.updateVolume method. This method implements the API endpoint for updating a volume's information.",
    "ground_truth_relationship": "The code implements the documented PATCH /volumes/{name} API endpoint by defining an updateVolume method that accepts a volume name and update request content, returning the updated volume data as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that the code implements the documented PATCH /volumes endpoint for updating volumes, matching the core relationship described in the ground truth",
      "error_type": null
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeRepository.createVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeService.createVolume method likely uses VolumeRepository.createVolume to perform the actual creation of the volume in the database.",
    "ground_truth_relationship": "The VolumeRepository.createVolume method implements the POST /volumes API endpoint by validating the request, creating a new volume record with generated UUID and metadata, and persisting it to the database while enforcing schema existence and volume uniqueness constraints.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this is about volume creation and database persistence, but incorrectly suggests it uses a VolumeRepository class when the code shows direct database interaction using Session/Transaction",
      "error_type": "incorrect_implementation_details"
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeRepository.deleteVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeService.deleteVolume method likely uses VolumeRepository.deleteVolume to perform the actual deletion of the volume from the database.",
    "ground_truth_relationship": "The deleteVolume method in VolumeRepository implements the DELETE /volumes/{name} API endpoint by parsing the three-part volume name (catalog.schema.volume), validating the schema exists, and removing both the volume's metadata from the database and its storage directory if it's a managed volume.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly mentions that deleteVolume performs volume deletion, but misses key implementation details like validating the three-part name, schema validation, and handling of managed volume storage. It also incorrectly suggests a VolumeService layer that isn't shown in the code.",
      "error_type": "missing_core_functionality"
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeRepository.getVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeService.getVolume method likely uses VolumeRepository.getVolume to retrieve the volume information from the database.",
    "ground_truth_relationship": "The VolumeRepository.getVolume method implements the GET /volumes/{name} endpoint by parsing a three-part volume name (catalog.schema.volume), retrieving the volume data from a database session, and returning a VolumeInfo object that represents the requested volume.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that the method retrieves volume information from a database, but misses the key aspects of name parsing into three parts and endpoint implementation details",
      "error_type": "significant_omission"
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeRepository.listVolumes",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeService.listVolumes method likely uses VolumeRepository.listVolumes to retrieve the list of volumes from the database.",
    "ground_truth_relationship": "The listVolumes method implements the GET /volumes API endpoint by querying the database for volumes within a specified schema, supporting pagination through maxResults and pageToken parameters, and returning the results as a ListVolumesResponseContent object.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that listVolumes retrieves volumes from a database, but introduces uncertainty ('likely uses') and references incorrect components (VolumeRepository) rather than describing the actual implementation which queries VolumeInfoDAO directly with pagination support",
      "error_type": "incorrect_components"
    }
  },
  {
    "document_text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
    "artifact_title": "VolumeRepository.updateVolume",
    "predicted_relationship": "While not explicitly mentioned in the documentation, the VolumeService.updateVolume method likely uses VolumeRepository.updateVolume to perform the actual update of the volume information in the database.",
    "ground_truth_relationship": "The VolumeRepository.updateVolume method implements the PATCH /volumes/{name} API endpoint by validating input parameters, managing database transactions, and performing volume updates including name and comment changes while handling potential conflicts and exceptions.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this is about updating volume information in a database, but introduces uncertainty by suggesting it 'likely uses VolumeRepository.updateVolume' when the code shows direct implementation. It also misses key aspects like validation, transaction management, and conflict handling.",
      "error_type": "incomplete_understanding"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.createTable",
    "predicted_relationship": "The documentation explicitly mentions a 'createTable' operation under the HTTP POST method. This directly corresponds to the TableService.createTable method, which implements the server-side logic for creating a table.",
    "ground_truth_relationship": "The createTable code method implements the POST /tables API endpoint documented in TablesApi by accepting a CreateTable request object, delegating to TABLE_REPOSITORY for table creation, and returning the response as JSON.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies the core relationship between the code and documentation - that this implements the POST /tables API endpoint for creating tables. While it omits some implementation details like returning JSON response, the main relationship is accurately captured.",
      "error_type": ""
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.deleteTable",
    "predicted_relationship": "The documentation explicitly mentions a 'deleteTable' operation under the HTTP DELETE method. This directly corresponds to the TableService.deleteTable method, which implements the server-side logic for deleting a table.",
    "ground_truth_relationship": "The code implements the documented DELETE /tables/{full_name} endpoint by creating a method annotated with @Delete that takes a full_name parameter, deletes the corresponding table through the repository, and returns an HTTP 200 OK response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this implements the documented DELETE operation for tables, matching the ground truth's core explanation of the relationship between the code and documentation.",
      "error_type": ""
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.getTable",
    "predicted_relationship": "The documentation explicitly mentions a 'getTable' operation under the HTTP GET method. This directly corresponds to the TableService.getTable method, which implements the server-side logic for retrieving a table.",
    "ground_truth_relationship": "The code implements the documented GET /tables/{full_name} endpoint by creating a method that retrieves a TableInfo object based on the full_name path parameter and returns it as a JSON HTTP response.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this is the getTable operation using HTTP GET, which matches the ground truth's explanation of implementing the GET /tables/{full_name} endpoint to retrieve table information",
      "error_type": ""
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableService.listTables",
    "predicted_relationship": "The documentation explicitly mentions a 'listTables' operation under the HTTP GET method. This directly corresponds to the TableService.listTables method, which implements the server-side logic for listing tables.",
    "ground_truth_relationship": "The document is an API endpoint summary table that lists the methods available and their description under the TablesApi. Each code is related to one of the methods.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies the listTables GET operation, but misses that this is part of a broader API endpoint summary that includes other methods like createTable, deleteTable, and getTable",
      "error_type": "incomplete_coverage"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableRepository.createTable",
    "predicted_relationship": "While not explicitly mentioned in the documentation, TableRepository.createTable is likely used by TableService.createTable to perform the actual table creation in the database.",
    "ground_truth_relationship": "The TableRepository.createTable method implements the backend logic for the experimental POST /tables API endpoint, handling table creation with validations for SQL object names, schema existence, and storage location requirements while preventing creation of managed tables.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly connects the method to table creation functionality but incorrectly suggests it's used by TableService rather than being the direct implementation of the POST /tables API endpoint",
      "error_type": "architectural_misunderstanding"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableRepository.deleteTable",
    "predicted_relationship": "While not explicitly mentioned in the documentation, TableRepository.deleteTable is likely used by TableService.deleteTable to perform the actual table deletion in the database.",
    "ground_truth_relationship": "The deleteTable method implements the DELETE /tables/{full_name} API endpoint's backend logic by removing the table's metadata from the session, cleaning up associated properties, and deleting the physical directory for managed tables.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies this as table deletion functionality but incorrectly suggests it is used by TableService rather than being the direct implementation of the DELETE API endpoint. It also misses the crucial aspects of property cleanup and physical directory deletion.",
      "error_type": "incorrect_component_relationship"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableRepository.getTable",
    "predicted_relationship": "While not explicitly mentioned in the documentation, TableRepository.getTable is likely used by TableService.getTable to retrieve the actual table information from the database.",
    "ground_truth_relationship": "The TableRepository.getTable method implements the backend database logic for the GET /tables/{full_name} API endpoint, retrieving a table's details from the database by parsing the full_name parameter into catalog, schema and table components and returning a TableInfo object with attached properties.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description correctly identifies that this is about table retrieval functionality but incorrectly suggests it's used by TableService.getTable rather than recognizing it as the direct implementation of the GET /tables/{full_name} API endpoint",
      "error_type": "incorrect_component_relationship"
    }
  },
  {
    "document_text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
    "artifact_title": "TableRepository.listTables",
    "predicted_relationship": "While not explicitly mentioned in the documentation, TableRepository.listTables is likely used by TableService.listTables to retrieve the list of tables from the database.",
    "ground_truth_relationship": "The TableRepository.listTables code implements the GET /tables REST API endpoint by querying tables from a database session, applying pagination through maxResults and pageToken parameters, and returning a ListTablesResponse containing table information with optional properties and columns.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "partially_correct",
      "justification": "The predicted description captures that TableRepository.listTables retrieves tables from a database, but fails to acknowledge its role as implementing the GET /tables REST API endpoint and omits key functionality around pagination and response formatting",
      "error_type": "major_omission"
    }
  },
  {
    "document_text": "# TemporaryTableCredentialsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**generateTemporaryTableCredentials**](TemporaryTableCredentialsApi.md#generateTemporaryTableCredentials) | **POST** /temporary-table-credentials | Generate temporary table credentials. |",
    "artifact_title": "TemporaryTableCredentialsService.generateTemporaryTableCredentials",
    "predicted_relationship": "This method directly implements the generateTemporaryTableCredentials API endpoint described in the documentation. The documentation states 'Generate temporary table credentials.' which is exactly what this method does.",
    "ground_truth_relationship": "The code implements the documented POST endpoint /temporary-table-credentials by validating the table location and returning AWS temporary credentials for S3 storage or empty credentials for local storage.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies that this method implements the documented API endpoint for generating temporary table credentials, which aligns with the ground truth's description of the endpoint functionality. While the ground truth provides more implementation details about S3 vs local storage, this level of detail isn't necessary for the core relationship to be correct.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createSchema\"></a>\n# **createSchema**\n> SchemaInfo createSchema(CreateSchema)\n\nCreate a schema\n\n    Creates a new schema in the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateSchema** | [**CreateSchema**](../Models/CreateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaRepository.createSchema",
    "predicted_relationship": "The document describes a 'createSchema' operation that creates a new schema in a specified catalog. This directly corresponds to the 'SchemaRepository.createSchema' method, which implements this functionality. The method signature 'public SchemaInfo createSchema(CreateSchema createSchema)' matches the documented operation, including the parameter and return types.",
    "ground_truth_relationship": "The code fully implements the documented API endpoint by validating the schema name, checking for existing schemas, persisting the new schema with its properties in a database transaction, and returning a SchemaInfo object as specified in the documentation's return type.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description accurately captures the core relationship between the code and documentation - that this is a method for creating a new schema in a catalog with matching parameter and return types. While it doesn't mention all implementation details like validation and persistence, these are minor omissions that don't affect the fundamental understanding.",
      "error_type": ""
    }
  },
  {
    "document_text": "<a name=\"createSchema\"></a>\n# **createSchema**\n> SchemaInfo createSchema(CreateSchema)\n\nCreate a schema\n\n    Creates a new schema in the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateSchema** | [**CreateSchema**](../Models/CreateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaService.createSchema",
    "predicted_relationship": "While not explicitly mentioned in the document, the SchemaService.createSchema method is likely the service layer implementation that would handle the HTTP request for creating a schema. It would use the SchemaRepository.createSchema method to perform the actual creation.",
    "ground_truth_relationship": "The code implements the documented REST endpoint by accepting a CreateSchema object via POST request and returning a JSON HTTP response containing the schema created through the SCHEMA_REPOSITORY.",
    "traceability_granularity": "Method",
    "evaluation": {
      "alignment_label": "incorrect",
      "justification": "The predicted description incorrectly speculates about a SchemaService layer that isn't present in the code or documentation, while missing the actual direct relationship between the REST endpoint and SCHEMA_REPOSITORY",
      "error_type": "incorrect_architecture_assumption"
    }
  },
  {
    "document_text": "<a name=\"createSchema\"></a>\n# **createSchema**\n> SchemaInfo createSchema(CreateSchema)\n\nCreate a schema\n\n    Creates a new schema in the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateSchema** | [**CreateSchema**](../Models/CreateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
    "artifact_title": "SchemaInfoDAO",
    "predicted_relationship": "The SchemaInfoDAO is likely used internally by SchemaRepository.createSchema to persist the new schema information. While not explicitly mentioned in the document, it's an essential part of the schema creation process.",
    "ground_truth_relationship": "The SchemaInfoDAO class provides the data persistence layer and conversion methods (from/toSchemaInfo) that enable storing and retrieving the SchemaInfo objects that are returned by the documented createSchema API endpoint.",
    "traceability_granularity": "Class",
    "evaluation": {
      "alignment_label": "correct",
      "justification": "The predicted description correctly identifies SchemaInfoDAO's core role in persisting schema information during schema creation, which aligns with the ground truth's explanation of it serving as the data persistence layer and handling SchemaInfo object conversions.",
      "error_type": ""
    }
  }
]