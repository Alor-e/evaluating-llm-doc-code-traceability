[
  {
    "document": {
      "text": "<a name=\"deleteSchema\"></a>\n# **deleteSchema**\n> oas_any_type_not_mapped deleteSchema(full\\_name, force)\n\nDelete a schema\n\n    Deletes the specified schema from the parent catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
      "location": "api/Apis/SchemasApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "SchemaRepository.deleteSchema",
        "location": "server/src/main/java/io/unitycatalog/server/persist/SchemaRepository.java",
        "content": "public void deleteSchema( Session session, UUID catalogId, String catalogName, String schemaName, boolean force) { SchemaInfoDAO schemaInfo = getSchemaDAO(session, catalogId, schemaName); if (schemaInfo != null) { processChildTables(session, schemaInfo.getId(), catalogName, schemaName, force); processChildVolumes(session, schemaInfo.getId(), catalogName, schemaName, force); processChildFunctions(session, schemaInfo.getId(), catalogName, schemaName, force); session.remove(schemaInfo); PropertyRepository.findProperties(session, schemaInfo.getId(), Constants.SCHEMA) .forEach(session::remove); } else { throw new BaseException(ErrorCode.NOT_FOUND, \"Schema not found: \" + schemaName); } } }",
        "type": "Method",
        "relationship": "The code implements the documented schema deletion endpoint by recursively removing child tables, volumes, and functions before deleting the schema itself, while respecting the 'force' parameter and throwing a NOT_FOUND exception when the schema doesn't exist.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.deleteSchema -> SchemaRepository.deleteSchema"
      },
      {
        "title": "SchemaCli.deleteSchema",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/SchemaCli.java",
        "content": "private static String deleteSchema(SchemasApi schemasApi, JSONObject json) throws ApiException { String schemaFullName = json.getString(CliParams.FULL_NAME.getServerParam()); schemasApi.deleteSchema( schemaFullName, json.has(CliParams.FORCE.getServerParam()) && Boolean.parseBoolean(json.getString(CliParams.FORCE.getServerParam()))); return CliUtils.EMPTY; } }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented deleteSchema endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaCli.deleteSchema"
      },
      {
        "title": "SchemaService.deleteSchema",
        "location": "server/src/main/java/io/unitycatalog/server/service/SchemaService.java",
        "content": "@Delete(\"/{full_name}\") public HttpResponse deleteSchema( @Param(\"full_name\") String fullName, @Param(\"force\") Optional<Boolean> force) { SCHEMA_REPOSITORY.deleteSchema(fullName, force.orElse(false)); return HttpResponse.of(HttpStatus.OK); } }",
        "type": "Method",
        "relationship": "The code implements the documented DELETE endpoint by accepting a required fullName path parameter and optional force parameter, delegating schema deletion to SCHEMA_REPOSITORY, and returning an HTTP 200 OK response.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.deleteSchema"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"listSchemas\"></a>\n# **listSchemas**\n> ListSchemasResponse listSchemas(catalog\\_name, max\\_results, page\\_token)\n\nList schemas\n\n    Gets an array of schemas for a catalog. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Parent catalog for schemas of interest. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of schemas to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n\n### Return type\n\n[**ListSchemasResponse**](../Models/ListSchemasResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
      "location": "api/Apis/SchemasApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "SchemaCli.listSchemas",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/SchemaCli.java",
        "content": "private static String listSchemas(SchemasApi schemasApi, JSONObject json) throws JsonProcessingException, ApiException { String catalogName = json.getString(CliParams.CATALOG_NAME.getServerParam()); int maxResults = 100; if (json.has(CliParams.MAX_RESULTS.getServerParam())) { maxResults = json.getInt(CliParams.MAX_RESULTS.getServerParam()); } return objectWriter.writeValueAsString( schemasApi.listSchemas(catalogName, maxResults, null).getSchemas()); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented listSchemas endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaCli.listSchemas"
      },
      {
        "title": "SchemaService.listSchemas",
        "location": "server/src/main/java/io/unitycatalog/server/service/SchemaService.java",
        "content": "@Get(\"\") public HttpResponse listSchemas( @Param(\"catalog_name\") String catalogName, @Param(\"max_results\") Optional<Integer> maxResults, @Param(\"page_token\") Optional<String> pageToken) { return HttpResponse.ofJson(SCHEMA_REPOSITORY.listSchemas(catalogName, maxResults, pageToken)); }",
        "type": "Method",
        "relationship": "The code implements a GET endpoint that takes a catalog name and optional pagination parameters (max_results and page_token) to retrieve a list of schemas from SCHEMA_REPOSITORY, exactly matching the documented API endpoint's parameters and functionality.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.listSchemas"
      },
      {
        "title": "SchemaRepository.listSchemas",
        "location": "server/src/main/java/io/unitycatalog/server/persist/SchemaRepository.java",
        "content": "public ListSchemasResponse listSchemas( String catalogName, Optional<Integer> maxResults, Optional<String> pageToken) { try (Session session = SESSION_FACTORY.openSession()) { session.setDefaultReadOnly(true); Transaction tx = session.beginTransaction(); // TODO: Implement pagination and filtering if required // For now, returning all schemas without pagination try { UUID catalogId = getCatalogId(session, catalogName); ListSchemasResponse response = listSchemas(session, catalogId, catalogName, maxResults, pageToken); tx.commit(); return response; } catch (Exception e) { tx.rollback(); throw e; } } } public ListSchemasResponse listSchemas( Session session, UUID catalogId, String catalogName, Optional<Integer> maxResults, Optional<String> pageToken) { List<SchemaInfoDAO> schemaInfoDAOList = LISTING_HELPER.listEntity(session, maxResults, pageToken, catalogId); String nextPageToken = LISTING_HELPER.getNextPageToken(schemaInfoDAOList, maxResults); List<SchemaInfo> result = new ArrayList<>(); for (SchemaInfoDAO schemaInfoDAO : schemaInfoDAOList) { SchemaInfo schemaInfo = schemaInfoDAO.toSchemaInfo(); RepositoryUtils.attachProperties( schemaInfo, schemaInfo.getSchemaId(), Constants.SCHEMA, session); addNamespaceData(schemaInfo, catalogName); result.add(schemaInfo); } return new ListSchemasResponse().schemas(result).nextPageToken(nextPageToken); }",
        "type": "Method",
        "relationship": "The code implements the documented listSchemas API endpoint by querying a database session for schemas matching the given catalog ID, converting the results from DAOs to SchemaInfo objects, handling pagination through maxResults and pageToken parameters, and returning a ListSchemasResponse containing the schema list and next page token.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.listSchemas -> SchemaRepository.listSchemas"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"createFunction\"></a>\n# **createFunction**\n> FunctionInfo createFunction(CreateFunctionRequest)\n\nCreate a function. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new function instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateFunctionRequest** | [**CreateFunctionRequest**](../Models/CreateFunctionRequest.md)|  | [optional] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
      "location": "api/Apis/FunctionsApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "FunctionService.createFunction",
        "location": "server/src/main/java/io/unitycatalog/server/service/FunctionService.java",
        "content": "@Post(\"\") public HttpResponse createFunction(CreateFunctionRequest createFunctionRequest) { return HttpResponse.ofJson(FUNCTION_REPOSITORY.createFunction(createFunctionRequest)); }",
        "type": "Method",
        "relationship": "The code implements the documented REST API endpoint by exposing a POST method that accepts a CreateFunctionRequest object, delegates to FUNCTION_REPOSITORY for function creation, and returns the result wrapped in an HTTP JSON response.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionService.createFunction"
      },
      {
        "title": "FunctionCli.createFunction",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/FunctionCli.java",
        "content": "private static String createFunction(FunctionsApi functionsApi, JSONObject json) throws JsonProcessingException, ApiException { CliUtils.resolveFullNameToThreeLevelNamespace(json); FunctionParameterInfos inputParams = CliUtils.parseInputParams(json); CreateFunction createFunction = objectMapper.readValue(json.toString(), CreateFunction.class); createFunction.setInputParams(inputParams); if (createFunction.getIsDeterministic() == null) { createFunction.setIsDeterministic(true); } if (createFunction.getParameterStyle() == null) { createFunction.setParameterStyle(CreateFunction.ParameterStyleEnum.S); } if (createFunction.getFullDataType() == null) { createFunction.setFullDataType(createFunction.getDataType().name()); } if (createFunction.getIsNullCall() == null) { createFunction.setIsNullCall(true); } if (createFunction.getRoutineBody() == null) { createFunction.setRoutineBody(CreateFunction.RoutineBodyEnum.EXTERNAL); } if (createFunction.getRoutineDefinition() == null) { createFunction.setRoutineDefinition(EMPTY); } if (createFunction.getSecurityType() == null) { createFunction.setSecurityType(CreateFunction.SecurityTypeEnum.DEFINER); } if (createFunction.getSpecificName() == null) { createFunction.setSpecificName(createFunction.getName()); } if (createFunction.getSqlDataAccess() == null) { createFunction.setSqlDataAccess(CreateFunction.SqlDataAccessEnum.NO_SQL); } if (createFunction.getExternalLanguage() == null) { createFunction.setExternalLanguage(\"python\"); } return objectWriter.writeValueAsString( functionsApi.createFunction(new CreateFunctionRequest().functionInfo(createFunction))); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented createFunction endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionCli.createFunction"
      },
      {
        "title": "FunctionInfoDAO",
        "location": "server/src/main/java/io/unitycatalog/server/persist/dao/FunctionInfoDAO.java",
        "content": "package io.unitycatalog.server.persist.dao; import io.unitycatalog.server.model.ColumnTypeName; import io.unitycatalog.server.model.FunctionInfo; import jakarta.persistence.*; import java.util.List; import java.util.UUID; import lombok.*; import lombok.experimental.SuperBuilder; import org.hibernate.annotations.SQLRestriction; // Hibernate annotations @Entity @Table(name = \"uc_functions\") // Lombok annotations @Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(callSuper = true) @SuperBuilder public class FunctionInfoDAO extends IdentifiableDAO { @Column(name = \"schema_id\") private UUID schemaId; @Column(name = \"comment\") private String comment; @Column(name = \"created_at\") private Long createdAt; @Column(name = \"updated_at\") private Long updatedAt; @Column(name = \"data_type\") private ColumnTypeName dataType; @Column(name = \"full_data_type\") private String fullDataType; @Column(name = \"external_language\") private String externalLanguage; @Column(name = \"is_deterministic\") private Boolean isDeterministic; @Column(name = \"is_null_call\") private Boolean isNullCall; @Column(name = \"parameter_style\") private FunctionInfo.ParameterStyleEnum parameterStyle; @Column(name = \"routine_body\") private FunctionInfo.RoutineBodyEnum routineBody; @Column(name = \"routine_definition\") private String routineDefinition; @Column(name = \"sql_data_access\") private FunctionInfo.SqlDataAccessEnum sqlDataAccess; @Column(name = \"security_type\") private FunctionInfo.SecurityTypeEnum securityType; @Column(name = \"specific_name\") private String specificName; @OneToMany(mappedBy = \"function\", cascade = CascadeType.ALL, orphanRemoval = true) @SQLRestriction(\"input_or_return = 0\") private List<FunctionParameterInfoDAO> inputParams; @OneToMany(mappedBy = \"function\", cascade = CascadeType.ALL, orphanRemoval = true) @SQLRestriction(\"input_or_return = 1\") private List<FunctionParameterInfoDAO> returnParams; public static FunctionInfoDAO from(FunctionInfo functionInfo) { FunctionInfoDAO functionInfoDAO = FunctionInfoDAO.builder() .id( functionInfo.getFunctionId() != null ? UUID.fromString(functionInfo.getFunctionId()) : null) .name(functionInfo.getName()) .comment(functionInfo.getComment()) .createdAt(functionInfo.getCreatedAt()) .updatedAt(functionInfo.getUpdatedAt()) .dataType(functionInfo.getDataType()) .fullDataType(functionInfo.getFullDataType()) .externalLanguage(functionInfo.getExternalLanguage()) .isDeterministic(functionInfo.getIsDeterministic()) .isNullCall(functionInfo.getIsNullCall()) .parameterStyle(functionInfo.getParameterStyle()) .routineBody(functionInfo.getRoutineBody()) .routineDefinition(functionInfo.getRoutineDefinition()) .sqlDataAccess(functionInfo.getSqlDataAccess()) .securityType(functionInfo.getSecurityType()) .specificName(functionInfo.getSpecificName()) .inputParams( FunctionParameterInfoDAO.from( functionInfo.getInputParams(), FunctionParameterInfoDAO.InputOrReturnEnum.INPUT)) .returnParams( FunctionParameterInfoDAO.from( functionInfo.getReturnParams(), FunctionParameterInfoDAO.InputOrReturnEnum.RETURN)) .build(); for (FunctionParameterInfoDAO inputParam : functionInfoDAO.inputParams) { inputParam.setFunction(functionInfoDAO); } for (FunctionParameterInfoDAO returnParam : functionInfoDAO.returnParams) { returnParam.setFunction(functionInfoDAO); } return functionInfoDAO; } public FunctionInfo toFunctionInfo() { FunctionInfo functionInfo = new FunctionInfo() .functionId(getId().toString()) .name(getName()) .comment(comment) .createdAt(createdAt) .updatedAt(updatedAt) .dataType(dataType) .fullDataType(fullDataType) .externalLanguage(externalLanguage) .isDeterministic(isDeterministic) .isNullCall(isNullCall) .parameterStyle(parameterStyle) .routineBody(routineBody) .routineDefinition(routineDefinition) .sqlDataAccess(sqlDataAccess) .securityType(securityType) .specificName(specificName); if (!inputParams.isEmpty()) { functionInfo.inputParams(FunctionParameterInfoDAO.toFunctionParameterInfos(inputParams)); } if (!returnParams.isEmpty()) { functionInfo.returnParams(FunctionParameterInfoDAO.toFunctionParameterInfos(returnParams)); } return functionInfo; } }",
        "type": "Class",
        "relationship": "The FunctionInfoDAO class provides the database persistence layer and object mapping functionality that enables the createFunction API endpoint to store and retrieve function metadata in the uc_functions table, converting between the API's FunctionInfo model and its database representation.",
        "traceability_granularity": "Class",
        "trace_chain": "FunctionsApi.md -> FunctionInfoDAO"
      },
      {
        "title": "FunctionRepository.createFunction",
        "location": "server/src/main/java/io/unitycatalog/server/persist/FunctionRepository.java",
        "content": "public FunctionInfo createFunction(CreateFunctionRequest createFunctionRequest) { ValidationUtils.validateSqlObjectName(createFunctionRequest.getFunctionInfo().getName()); CreateFunction createFunction = createFunctionRequest.getFunctionInfo(); FunctionInfo functionInfo = new FunctionInfo() .functionId(UUID.randomUUID().toString()) .name(createFunction.getName()) .catalogName(createFunction.getCatalogName()) .schemaName(createFunction.getSchemaName()) .comment(createFunction.getComment()) .properties(createFunction.getProperties()) .createdAt(System.currentTimeMillis()) .dataType(createFunction.getDataType()) .fullDataType(createFunction.getFullDataType()) .inputParams(createFunction.getInputParams()) .returnParams(createFunction.getReturnParams()) .fullName( createFunction.getCatalogName() + \".\" + createFunction.getSchemaName() + \".\" + createFunction.getName()) .externalLanguage(createFunction.getExternalLanguage()) .isDeterministic(createFunction.getIsDeterministic()) .isNullCall(createFunction.getIsNullCall()) .parameterStyle( FunctionInfo.ParameterStyleEnum.valueOf(createFunction.getParameterStyle().name())) .routineBody( FunctionInfo.RoutineBodyEnum.valueOf(createFunction.getRoutineBody().name())) .routineDefinition(createFunction.getRoutineDefinition()) .securityType( FunctionInfo.SecurityTypeEnum.valueOf(createFunction.getSecurityType().name())) .specificName(createFunction.getSpecificName()); if (createFunction.getSqlDataAccess() != null) { functionInfo.setSqlDataAccess( FunctionInfo.SqlDataAccessEnum.valueOf(createFunction.getSqlDataAccess().toString())); } try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { String catalogName = createFunction.getCatalogName(); String schemaName = createFunction.getSchemaName(); SchemaInfoDAO schemaInfo = SCHEMA_REPOSITORY.getSchemaDAO(session, catalogName, schemaName); if (schemaInfo == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Schema not found: \" + schemaName); } if (getFunctionDAO(session, catalogName, schemaName, createFunction.getName()) != null) { throw new BaseException( ErrorCode.ALREADY_EXISTS, \"Function already exists: \" + createFunction.getName()); } FunctionInfoDAO dao = FunctionInfoDAO.from(functionInfo); dao.setSchemaId(schemaInfo.getId()); dao.getInputParams() .forEach( p -> { p.setId(UUID.randomUUID()); p.setFunction(dao); }); dao.getReturnParams() .forEach( p -> { p.setId(UUID.randomUUID()); p.setFunction(dao); }); session.persist(dao); tx.commit(); return functionInfo; } catch (Exception e) { tx.rollback(); throw e; } } }",
        "type": "Method",
        "relationship": "The code implements the documented createFunction API endpoint by validating the input function name, constructing a FunctionInfo object with all required properties, and persisting it in a database transaction while handling schema validation and duplicate function checks.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionService.createFunction -> FunctionRepository.createFunction"
      }
    ]
  },
  {
    "document": {
      "text": "# **createVolume**\n> VolumeInfo createVolume(CreateVolumeRequestContent)\n\nCreate a Volume\n\n    Creates a new volume. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateVolumeRequestContent** | [**CreateVolumeRequestContent**](../Models/CreateVolumeRequestContent.md)|  | |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
      "location": "api/Apis/VolumesApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "VolumeInfoDAO",
        "location": "server/src/main/java/io/unitycatalog/server/persist/dao/VolumeInfoDAO.java",
        "content": "package io.unitycatalog.server.persist.dao; import io.unitycatalog.server.model.VolumeInfo; import io.unitycatalog.server.model.VolumeType; import io.unitycatalog.server.persist.utils.FileUtils; import jakarta.persistence.Column; import jakarta.persistence.Entity; import jakarta.persistence.Table; import java.util.Date; import java.util.UUID; import lombok.*; import lombok.experimental.SuperBuilder; @Entity @Table(name = \"uc_volumes\") // lombok annotations @Getter @Setter @NoArgsConstructor @AllArgsConstructor @SuperBuilder @EqualsAndHashCode(callSuper = true) public class VolumeInfoDAO extends IdentifiableDAO { @Column(name = \"schema_id\") private UUID schemaId; @Column(name = \"comment\") private String comment; @Column(name = \"storage_location\") private String storageLocation; @Column(name = \"created_at\") private Date createdAt; @Column(name = \"updated_at\") private Date updatedAt; @Column(name = \"volume_type\") private String volumeType; public VolumeInfo toVolumeInfo() { return new VolumeInfo() .volumeId(getId().toString()) .name(getName()) .comment(comment) .storageLocation(FileUtils.convertRelativePathToURI(storageLocation)) .createdAt(createdAt.getTime()) .updatedAt(updatedAt.getTime()) .volumeType(VolumeType.valueOf(volumeType)); } public static VolumeInfoDAO from(VolumeInfo volumeInfo) { if (volumeInfo == null) { return null; } return VolumeInfoDAO.builder() .id(UUID.fromString(volumeInfo.getVolumeId())) .name(volumeInfo.getName()) .comment(volumeInfo.getComment()) .storageLocation(volumeInfo.getStorageLocation()) .createdAt( volumeInfo.getCreatedAt() != null ? new Date(volumeInfo.getCreatedAt()) : new Date()) .updatedAt( volumeInfo.getUpdatedAt() != null ? new Date(volumeInfo.getUpdatedAt()) : new Date()) .volumeType(volumeInfo.getVolumeType().getValue()) .build(); } }",
        "type": "Class",
        "relationship": "The VolumeInfoDAO class provides the data persistence layer and mapping functionality for the createVolume API endpoint by defining the database schema and conversion methods between the API's VolumeInfo model and the database representation.",
        "traceability_granularity": "Class",
        "trace_chain": "VolumesApi.md -> VolumeInfoDAO"
      },
      {
        "title": "VolumeService.createVolume",
        "location": "server/src/main/java/io/unitycatalog/server/service/VolumeService.java",
        "content": "@Post(\"\") public HttpResponse createVolume(CreateVolumeRequestContent createVolumeRequest) { // Throw error if catalog/schema does not exist return HttpResponse.ofJson(VOLUME_REPOSITORY.createVolume(createVolumeRequest)); }",
        "type": "Method",
        "relationship": "The code implements the documented API endpoint by accepting a CreateVolumeRequestContent parameter and returning a JSON HTTP response containing the created volume information, matching the documented input/output specifications and HTTP headers.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.createVolume"
      },
      {
        "title": "VolumeCli.createVolume",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/VolumeCli.java",
        "content": "private static String createVolume(VolumesApi volumesApi, JSONObject json) throws JsonProcessingException, ApiException { CliUtils.resolveFullNameToThreeLevelNamespace(json); if (!json.has(CliParams.VOLUME_TYPE.getServerParam())) { json.put(CliParams.VOLUME_TYPE.getServerParam(), VolumeType.EXTERNAL.toString()); } CreateVolumeRequestContent createVolumeRequest; createVolumeRequest = objectMapper.readValue(json.toString(), CreateVolumeRequestContent.class); return objectWriter.writeValueAsString(volumesApi.createVolume(createVolumeRequest)); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented createVolume endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeCli.createVolume"
      },
      {
        "title": "VolumeRepository.createVolume",
        "location": "server/src/main/java/io/unitycatalog/server/persist/VolumeRepository.java",
        "content": "public VolumeInfo createVolume(CreateVolumeRequestContent createVolumeRequest) { ValidationUtils.validateSqlObjectName(createVolumeRequest.getName()); String volumeFullName = createVolumeRequest.getCatalogName() + \".\" + createVolumeRequest.getSchemaName() + \".\" + createVolumeRequest.getName(); VolumeInfo volumeInfo = new VolumeInfo(); volumeInfo.setVolumeId(UUID.randomUUID().toString()); volumeInfo.setCatalogName(createVolumeRequest.getCatalogName()); volumeInfo.setSchemaName(createVolumeRequest.getSchemaName()); volumeInfo.setName(createVolumeRequest.getName()); volumeInfo.setComment(createVolumeRequest.getComment()); volumeInfo.setFullName(volumeFullName); volumeInfo.setCreatedAt(System.currentTimeMillis()); volumeInfo.setVolumeType(createVolumeRequest.getVolumeType()); if (VolumeType.MANAGED.equals(createVolumeRequest.getVolumeType())) { throw new BaseException( ErrorCode.INVALID_ARGUMENT, \"Managed volume creation is not supported\"); } if (createVolumeRequest.getStorageLocation() == null) { throw new BaseException( ErrorCode.INVALID_ARGUMENT, \"Storage location is required for external volume\"); } volumeInfo.setStorageLocation(createVolumeRequest.getStorageLocation()); VolumeInfoDAO volumeInfoDAO = VolumeInfoDAO.from(volumeInfo); try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { SchemaInfoDAO schemaInfoDAO = SCHEMA_REPOSITORY.getSchemaDAO( session, createVolumeRequest.getCatalogName(), createVolumeRequest.getSchemaName()); if (schemaInfoDAO == null) { throw new BaseException( ErrorCode.NOT_FOUND, \"Schema not found: \" + createVolumeRequest.getCatalogName() + \".\" + createVolumeRequest.getSchemaName()); } if (getVolumeDAO( session, createVolumeRequest.getCatalogName(), createVolumeRequest.getSchemaName(), createVolumeRequest.getName()) != null) { throw new BaseException( ErrorCode.ALREADY_EXISTS, \"Volume already exists: \" + volumeFullName); } volumeInfoDAO.setSchemaId(schemaInfoDAO.getId()); session.persist(volumeInfoDAO); tx.commit(); LOGGER.info(\"Added volume: {}\", volumeInfo.getName()); return convertFromDAO( volumeInfoDAO, createVolumeRequest.getCatalogName(), createVolumeRequest.getSchemaName()); } catch (Exception e) { tx.rollback(); throw e; } } }",
        "type": "Method",
        "relationship": "The code implements the documented createVolume operation by validating inputs, creating a VolumeInfo object with a UUID, validating volume type and storage location, and persisting it to the database within a transaction while enforcing schema existence and volume uniqueness constraints.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.createVolume -> VolumeRepository.createVolume"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"getCatalog\"></a>\n# **getCatalog**\n> CatalogInfo getCatalog(name)\n\nGet a catalog\n\n    Gets the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
      "location": "api/Apis/CatalogsApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "CatalogService.getCatalog",
        "location": "server/src/main/java/io/unitycatalog/server/service/CatalogService.java",
        "content": "@Get(\"/{name}\") public HttpResponse getCatalog(@Param(\"name\") String name) { return HttpResponse.ofJson(CATALOG_REPOSITORY.getCatalog(name)); }",
        "type": "Method",
        "relationship": "The code implements the documented REST GET endpoint by accepting a name parameter and returning a JSON response containing catalog information, exactly matching the API specification's path parameter and response format requirements.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.getCatalog"
      },
      {
        "title": "CatalogRepository.getCatalog",
        "location": "server/src/main/java/io/unitycatalog/server/persist/CatalogRepository.java",
        "content": "public CatalogInfoDAO getCatalogDAO(Session session, String name) { Query<CatalogInfoDAO> query = session.createQuery(\"FROM CatalogInfoDAO WHERE name = :value\", CatalogInfoDAO.class); query.setParameter(\"value\", name); query.setMaxResults(1); return query.uniqueResult(); }",
        "type": "Method",
        "relationship": "The code directly implements the documented getCatalog operation by querying the database for a CatalogInfoDAO entity matching the specified name parameter using Hibernate's query language and returning a single result.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.getCatalog -> CatalogRepository.getCatalog"
      },
      {
        "title": "CatalogCli.getCatalog",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/CatalogCli.java",
        "content": "private static String getCatalog(CatalogsApi catalogsApi, JSONObject json) throws JsonProcessingException, ApiException { String catalogName = json.getString(NAME_PARAM); return objectWriter.writeValueAsString(catalogsApi.getCatalog(catalogName)); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented getCatalog endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogCli.getCatalog"
      },
      {
        "title": "CatalogInfoDAO",
        "location": "server/src/main/java/io/unitycatalog/server/persist/dao/CatalogInfoDAO.java",
        "content": "package io.unitycatalog.server.persist.dao; import io.unitycatalog.server.model.CatalogInfo; import jakarta.persistence.*; import java.time.Instant; import java.util.Date; import java.util.UUID; import lombok.*; import lombok.experimental.SuperBuilder; @Entity @Table(name = \"uc_catalogs\") // Lombok @Getter @Setter @AllArgsConstructor @NoArgsConstructor @SuperBuilder @EqualsAndHashCode(callSuper = true) public class CatalogInfoDAO extends IdentifiableDAO { @Column(name = \"comment\") private String comment; @Column(name = \"created_at\") private Date createdAt; @Column(name = \"updated_at\") private Date updatedAt; public static CatalogInfoDAO from(CatalogInfo catalogInfo) { return CatalogInfoDAO.builder() .id(catalogInfo.getId() != null ? UUID.fromString(catalogInfo.getId()) : null) .name(catalogInfo.getName()) .comment(catalogInfo.getComment()) .createdAt( catalogInfo.getCreatedAt() != null ? Date.from(Instant.ofEpochMilli(catalogInfo.getCreatedAt())) : new Date()) .updatedAt( catalogInfo.getUpdatedAt() != null ? Date.from(Instant.ofEpochMilli(catalogInfo.getUpdatedAt())) : null) .build(); } public CatalogInfo toCatalogInfo() { return new CatalogInfo() .id(getId().toString()) .name(getName()) .comment(comment) .createdAt(createdAt.getTime()) .updatedAt(updatedAt != null ? updatedAt.getTime() : null); } }",
        "type": "Class",
        "relationship": "The CatalogInfoDAO class provides the data persistence layer and mapping functionality for the CatalogInfo objects that are returned by the documented getCatalog endpoint through its toCatalogInfo() conversion method.",
        "traceability_granularity": "Class",
        "trace_chain": "CatalogsApi.md -> CatalogInfoDAO"
      }
    ]
  },
  {
    "document": {
      "text": "# FunctionsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createFunction**](FunctionsApi.md#createFunction) | **POST** /functions | Create a function. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteFunction**](FunctionsApi.md#deleteFunction) | **DELETE** /functions/{name} | Delete a function |\n| [**getFunction**](FunctionsApi.md#getFunction) | **GET** /functions/{name} | Get a function |\n| [**listFunctions**](FunctionsApi.md#listFunctions) | **GET** /functions | List functions |",
      "location": "api/Apis/FunctionsApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "FunctionService.deleteFunction",
        "location": "server/src/main/java/io/unitycatalog/server/service/FunctionService.java",
        "content": "@Delete(\"/{name}\") public HttpResponse deleteFunction( @Param(\"name\") String name, @Param(\"force\") Optional<Boolean> force) { FUNCTION_REPOSITORY.deleteFunction(name, force.orElse(false)); return HttpResponse.of(HttpStatus.OK); } }",
        "type": "Method",
        "relationship": "The code implements the documented DELETE /functions/{name} endpoint by providing a method that accepts a function name and optional force parameter, deleting the specified function through the repository and returning an HTTP 200 OK response.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionService.deleteFunction"
      },
      {
        "title": "FunctionCli.listFunctions",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/FunctionCli.java",
        "content": "private static String listFunctions(FunctionsApi functionsApi, JSONObject json) throws JsonProcessingException, ApiException { String catalogName = json.getString(CliParams.CATALOG_NAME.getServerParam()); String schemaName = json.getString(CliParams.SCHEMA_NAME.getServerParam()); int maxResults = 100; if (json.has(CliParams.MAX_RESULTS.getServerParam())) { maxResults = json.getInt(CliParams.MAX_RESULTS.getServerParam()); } return objectWriter.writeValueAsString( functionsApi.listFunctions(catalogName, schemaName, maxResults, null).getFunctions()); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented listFunctions endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionCli.listFunctions"
      },
      {
        "title": "FunctionService.listFunctions",
        "location": "server/src/main/java/io/unitycatalog/server/service/FunctionService.java",
        "content": "@Get(\"\") public HttpResponse listFunctions( @Param(\"catalog_name\") String catalogName, @Param(\"schema_name\") String schemaName, @Param(\"max_results\") Optional<Integer> maxResults, @Param(\"page_token\") Optional<String> pageToken) { return HttpResponse.ofJson( FUNCTION_REPOSITORY.listFunctions(catalogName, schemaName, maxResults, pageToken)); }",
        "type": "Method",
        "relationship": "The code implements the documented GET /functions endpoint by defining a listFunctions method that accepts catalog name, schema name, pagination parameters, and returns an HTTP response containing the list of functions.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionService.listFunctions"
      },
      {
        "title": "FunctionRepository.deleteFunction",
        "location": "server/src/main/java/io/unitycatalog/server/persist/FunctionRepository.java",
        "content": "public void deleteFunction(String name, Boolean force) { try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { String[] parts = name.split(\"\\.\"); if (parts.length != 3) { throw new BaseException(ErrorCode.INVALID_ARGUMENT, \"Invalid function name: \" + name); } String catalogName = parts[0], schemaName = parts[1], functionName = parts[2]; SchemaInfoDAO schemaInfo = SCHEMA_REPOSITORY.getSchemaDAO(session, catalogName, schemaName); if (schemaInfo == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Schema not found: \" + schemaName); } deleteFunction(session, schemaInfo.getId(), functionName); tx.commit(); LOGGER.info(\"Deleted function: {}\", functionName); } catch (Exception e) { tx.rollback(); throw e; } } } public void deleteFunction(Session session, UUID schemaId, String functionName) { FunctionInfoDAO functionInfoDAO = getFunctionDAO(session, schemaId, functionName); if (functionInfoDAO == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Function not found: \" + functionName); } session.remove(functionInfoDAO); } }",
        "type": "Method",
        "relationship": "The FunctionRepository.deleteFunction method implements the DELETE /functions/{name} API endpoint by validating a three-part function name (catalog.schema.function), checking for schema existence, and permanently removing the function from the database within a transaction.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionService.deleteFunction -> FunctionRepository.deleteFunction"
      },
      {
        "title": "FunctionRepository.createFunction",
        "location": "server/src/main/java/io/unitycatalog/server/persist/FunctionRepository.java",
        "content": "public FunctionInfo createFunction(CreateFunctionRequest createFunctionRequest) { ValidationUtils.validateSqlObjectName(createFunctionRequest.getFunctionInfo().getName()); CreateFunction createFunction = createFunctionRequest.getFunctionInfo(); FunctionInfo functionInfo = new FunctionInfo() .functionId(UUID.randomUUID().toString()) .name(createFunction.getName()) .catalogName(createFunction.getCatalogName()) .schemaName(createFunction.getSchemaName()) .comment(createFunction.getComment()) .properties(createFunction.getProperties()) .createdAt(System.currentTimeMillis()) .dataType(createFunction.getDataType()) .fullDataType(createFunction.getFullDataType()) .inputParams(createFunction.getInputParams()) .returnParams(createFunction.getReturnParams()) .fullName( createFunction.getCatalogName() + \".\" + createFunction.getSchemaName() + \".\" + createFunction.getName()) .externalLanguage(createFunction.getExternalLanguage()) .isDeterministic(createFunction.getIsDeterministic()) .isNullCall(createFunction.getIsNullCall()) .parameterStyle( FunctionInfo.ParameterStyleEnum.valueOf(createFunction.getParameterStyle().name())) .routineBody( FunctionInfo.RoutineBodyEnum.valueOf(createFunction.getRoutineBody().name())) .routineDefinition(createFunction.getRoutineDefinition()) .securityType( FunctionInfo.SecurityTypeEnum.valueOf(createFunction.getSecurityType().name())) .specificName(createFunction.getSpecificName()); if (createFunction.getSqlDataAccess() != null) { functionInfo.setSqlDataAccess( FunctionInfo.SqlDataAccessEnum.valueOf(createFunction.getSqlDataAccess().toString())); } try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { String catalogName = createFunction.getCatalogName(); String schemaName = createFunction.getSchemaName(); SchemaInfoDAO schemaInfo = SCHEMA_REPOSITORY.getSchemaDAO(session, catalogName, schemaName); if (schemaInfo == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Schema not found: \" + schemaName); } if (getFunctionDAO(session, catalogName, schemaName, createFunction.getName()) != null) { throw new BaseException( ErrorCode.ALREADY_EXISTS, \"Function already exists: \" + createFunction.getName()); } FunctionInfoDAO dao = FunctionInfoDAO.from(functionInfo); dao.setSchemaId(schemaInfo.getId()); dao.getInputParams() .forEach( p -> { p.setId(UUID.randomUUID()); p.setFunction(dao); }); dao.getReturnParams() .forEach( p -> { p.setId(UUID.randomUUID()); p.setFunction(dao); }); session.persist(dao); tx.commit(); return functionInfo; } catch (Exception e) { tx.rollback(); throw e; } } }",
        "type": "Method",
        "relationship": "This code implements the experimental POST /functions endpoint by creating a new function with extensive metadata including UUID, name, catalog, schema, and parameters, while validating uniqueness and schema existence in the database.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionService.createFunction -> FunctionRepository.createFunction"
      },
      {
        "title": "FunctionRepository.getFunction",
        "location": "server/src/main/java/io/unitycatalog/server/persist/FunctionRepository.java",
        "content": "public FunctionInfo getFunction(String name) { FunctionInfo functionInfo = null; try (Session session = SESSION_FACTORY.openSession()) { session.setDefaultReadOnly(true); Transaction tx = session.beginTransaction(); try { String[] parts = name.split(\"\\.\"); if (parts.length != 3) { throw new BaseException(ErrorCode.INVALID_ARGUMENT, \"Invalid function name: \" + name); } String catalogName = parts[0], schemaName = parts[1], functionName = parts[2]; FunctionInfoDAO functionInfoDAO = getFunctionDAO(session, catalogName, schemaName, functionName); if (functionInfoDAO == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Function not found: \" + name); } functionInfo = functionInfoDAO.toFunctionInfo(); addNamespaceInfo(functionInfo, catalogName, schemaName); tx.commit(); } catch (Exception e) { tx.rollback(); throw e; } } catch (Exception e) { LOGGER.error(\"Error getting function\", e); return null; } return functionInfo; }",
        "type": "Method",
        "relationship": "The FunctionRepository.getFunction method implements the backend logic for the GET /functions/{name} API endpoint by retrieving a function's details from the database based on its fully qualified name split into catalog, schema, and function components.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionService.getFunction -> FunctionRepository.getFunction"
      },
      {
        "title": "FunctionCli.getFunction",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/FunctionCli.java",
        "content": "private static String getFunction(FunctionsApi functionsApi, JSONObject json) throws JsonProcessingException, ApiException { String functionFullName = json.getString(CliParams.FULL_NAME.getServerParam()); return objectWriter.writeValueAsString(functionsApi.getFunction(functionFullName)); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented getFunction endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionCli.getFunction"
      },
      {
        "title": "FunctionCli.deleteFunction",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/FunctionCli.java",
        "content": "private static String deleteFunction(FunctionsApi functionsApi, JSONObject json) throws ApiException { String functionFullName = json.getString(CliParams.FULL_NAME.getServerParam()); functionsApi.deleteFunction(functionFullName); return EMPTY; } }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented deleteFunction endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionCli.deleteFunction"
      },
      {
        "title": "FunctionCli.createFunction",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/FunctionCli.java",
        "content": "private static String createFunction(FunctionsApi functionsApi, JSONObject json) throws JsonProcessingException, ApiException { CliUtils.resolveFullNameToThreeLevelNamespace(json); FunctionParameterInfos inputParams = CliUtils.parseInputParams(json); CreateFunction createFunction = objectMapper.readValue(json.toString(), CreateFunction.class); createFunction.setInputParams(inputParams); if (createFunction.getIsDeterministic() == null) { createFunction.setIsDeterministic(true); } if (createFunction.getParameterStyle() == null) { createFunction.setParameterStyle(CreateFunction.ParameterStyleEnum.S); } if (createFunction.getFullDataType() == null) { createFunction.setFullDataType(createFunction.getDataType().name()); } if (createFunction.getIsNullCall() == null) { createFunction.setIsNullCall(true); } if (createFunction.getRoutineBody() == null) { createFunction.setRoutineBody(CreateFunction.RoutineBodyEnum.EXTERNAL); } if (createFunction.getRoutineDefinition() == null) { createFunction.setRoutineDefinition(EMPTY); } if (createFunction.getSecurityType() == null) { createFunction.setSecurityType(CreateFunction.SecurityTypeEnum.DEFINER); } if (createFunction.getSpecificName() == null) { createFunction.setSpecificName(createFunction.getName()); } if (createFunction.getSqlDataAccess() == null) { createFunction.setSqlDataAccess(CreateFunction.SqlDataAccessEnum.NO_SQL); } if (createFunction.getExternalLanguage() == null) { createFunction.setExternalLanguage(\"python\"); } return objectWriter.writeValueAsString( functionsApi.createFunction(new CreateFunctionRequest().functionInfo(createFunction))); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented createFunction endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionCli.createFunction"
      },
      {
        "title": "FunctionRepository.listFunctions",
        "location": "server/src/main/java/io/unitycatalog/server/persist/FunctionRepository.java",
        "content": "public ListFunctionsResponse listFunctions( String catalogName, String schemaName, Optional<Integer> maxResults, Optional<String> pageToken) { try (Session session = SESSION_FACTORY.openSession()) { session.setDefaultReadOnly(true); Transaction tx = session.beginTransaction(); try { UUID schemaId = getSchemaId(session, catalogName, schemaName); ListFunctionsResponse response = listFunctions(session, schemaId, catalogName, schemaName, maxResults, pageToken); tx.commit(); return response; } catch (Exception e) { tx.rollback(); throw e; } } } public ListFunctionsResponse listFunctions( Session session, UUID schemaId, String catalogName, String schemaName, Optional<Integer> maxResults, Optional<String> pageToken) { List<FunctionInfoDAO> functionInfoDAOList = LISTING_HELPER.listEntity(session, maxResults, pageToken, schemaId); String nextPageToken = LISTING_HELPER.getNextPageToken(functionInfoDAOList, maxResults); List<FunctionInfo> result = new ArrayList<>(); for (FunctionInfoDAO functionInfoDAO : functionInfoDAOList) { FunctionInfo functionInfo = functionInfoDAO.toFunctionInfo(); RepositoryUtils.attachProperties( functionInfo, functionInfo.getFunctionId(), Constants.FUNCTION, session); addNamespaceData(functionInfo, catalogName, schemaName); result.add(functionInfo); } return new ListFunctionsResponse().functions(result).nextPageToken(nextPageToken); }",
        "type": "Method",
        "relationship": "The FunctionRepository.listFunctions code implements the backend logic for the GET /functions API endpoint, handling pagination through maxResults and pageToken parameters while retrieving function metadata from a database session and transforming it into the API response format.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionService.listFunctions -> FunctionRepository.listFunctions"
      },
      {
        "title": "FunctionService.createFunction",
        "location": "server/src/main/java/io/unitycatalog/server/service/FunctionService.java",
        "content": "@Post(\"\") public HttpResponse createFunction(CreateFunctionRequest createFunctionRequest) { return HttpResponse.ofJson(FUNCTION_REPOSITORY.createFunction(createFunctionRequest)); }",
        "type": "Method",
        "relationship": "The code implements the experimental POST /functions endpoint documented in the API table by defining a createFunction method that accepts a CreateFunctionRequest and returns an HTTP response containing the newly created function data from the repository.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionService.createFunction"
      },
      {
        "title": "FunctionService.getFunction",
        "location": "server/src/main/java/io/unitycatalog/server/service/FunctionService.java",
        "content": "@Get(\"/{name}\") public HttpResponse getFunction(@Param(\"name\") String name) { return HttpResponse.ofJson(FUNCTION_REPOSITORY.getFunction(name)); }",
        "type": "Method",
        "relationship": "The code implements the documented GET /functions/{name} endpoint by creating a controller method that accepts a name parameter and returns a JSON response containing the function details from the repository.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionService.getFunction"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"listFunctions\"></a>\n# **listFunctions**\n> ListFunctionsResponse listFunctions(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList functions\n\n    List functions within the specified parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for functions of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of functions. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of functions to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query. | [optional] [default to null] |\n\n### Return type\n\n[**ListFunctionsResponse**](../Models/ListFunctionsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
      "location": "api/Apis/FunctionsApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "FunctionService.listFunctions",
        "location": "server/src/main/java/io/unitycatalog/server/service/FunctionService.java",
        "content": "@Get(\"\") public HttpResponse listFunctions( @Param(\"catalog_name\") String catalogName, @Param(\"schema_name\") String schemaName, @Param(\"max_results\") Optional<Integer> maxResults, @Param(\"page_token\") Optional<String> pageToken) { return HttpResponse.ofJson( FUNCTION_REPOSITORY.listFunctions(catalogName, schemaName, maxResults, pageToken)); }",
        "type": "Method",
        "relationship": "The code implements a REST GET endpoint that takes the exact parameters specified in the documentation (catalog_name, schema_name, optional max_results, and optional page_token) and delegates the actual function listing to a repository layer, returning the results as a JSON HTTP response.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionService.listFunctions"
      },
      {
        "title": "FunctionCli.listFunctions",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/FunctionCli.java",
        "content": "private static String listFunctions(FunctionsApi functionsApi, JSONObject json) throws JsonProcessingException, ApiException { String catalogName = json.getString(CliParams.CATALOG_NAME.getServerParam()); String schemaName = json.getString(CliParams.SCHEMA_NAME.getServerParam()); int maxResults = 100; if (json.has(CliParams.MAX_RESULTS.getServerParam())) { maxResults = json.getInt(CliParams.MAX_RESULTS.getServerParam()); } return objectWriter.writeValueAsString( functionsApi.listFunctions(catalogName, schemaName, maxResults, null).getFunctions()); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented listFunctions endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionCli.listFunctions"
      },
      {
        "title": "FunctionRepository.listFunctions",
        "location": "server/src/main/java/io/unitycatalog/server/persist/FunctionRepository.java",
        "content": "public ListFunctionsResponse listFunctions( String catalogName, String schemaName, Optional<Integer> maxResults, Optional<String> pageToken) { try (Session session = SESSION_FACTORY.openSession()) { session.setDefaultReadOnly(true); Transaction tx = session.beginTransaction(); try { UUID schemaId = getSchemaId(session, catalogName, schemaName); ListFunctionsResponse response = listFunctions(session, schemaId, catalogName, schemaName, maxResults, pageToken); tx.commit(); return response; } catch (Exception e) { tx.rollback(); throw e; } } } public ListFunctionsResponse listFunctions( Session session, UUID schemaId, String catalogName, String schemaName, Optional<Integer> maxResults, Optional<String> pageToken) { List<FunctionInfoDAO> functionInfoDAOList = LISTING_HELPER.listEntity(session, maxResults, pageToken, schemaId); String nextPageToken = LISTING_HELPER.getNextPageToken(functionInfoDAOList, maxResults); List<FunctionInfo> result = new ArrayList<>(); for (FunctionInfoDAO functionInfoDAO : functionInfoDAOList) { FunctionInfo functionInfo = functionInfoDAO.toFunctionInfo(); RepositoryUtils.attachProperties( functionInfo, functionInfo.getFunctionId(), Constants.FUNCTION, session); addNamespaceData(functionInfo, catalogName, schemaName); result.add(functionInfo); } return new ListFunctionsResponse().functions(result).nextPageToken(nextPageToken); }",
        "type": "Method",
        "relationship": "The code implements the documented behavior by retrieving function records from a database within a read-only transaction, transforming FunctionInfoDAO objects to FunctionInfo objects with attached properties, and returning them in a ListFunctionsResponse with pagination support through maxResults and pageToken parameters.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionService.listFunctions -> FunctionRepository.listFunctions"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"getFunction\"></a>\n# **getFunction**\n> FunctionInfo getFunction(name)\n\nGet a function\n\n    Gets a function from within a parent catalog and schema.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**FunctionInfo**](../Models/FunctionInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
      "location": "api/Apis/FunctionsApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "FunctionService.getFunction",
        "location": "server/src/main/java/io/unitycatalog/server/service/FunctionService.java",
        "content": "@Get(\"/{name}\") public HttpResponse getFunction(@Param(\"name\") String name) { return HttpResponse.ofJson(FUNCTION_REPOSITORY.getFunction(name)); }",
        "type": "Method",
        "relationship": "The code implements a REST GET endpoint that accepts a fully-qualified function name as a path parameter and returns a JSON response containing the function details, directly mapping to the documented API endpoint specification and its expected FunctionInfo return type.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionService.getFunction"
      },
      {
        "title": "FunctionInfoDAO",
        "location": "server/src/main/java/io/unitycatalog/server/persist/dao/FunctionInfoDAO.java",
        "content": "package io.unitycatalog.server.persist.dao; import io.unitycatalog.server.model.ColumnTypeName; import io.unitycatalog.server.model.FunctionInfo; import jakarta.persistence.*; import java.util.List; import java.util.UUID; import lombok.*; import lombok.experimental.SuperBuilder; import org.hibernate.annotations.SQLRestriction; // Hibernate annotations @Entity @Table(name = \"uc_functions\") // Lombok annotations @Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(callSuper = true) @SuperBuilder public class FunctionInfoDAO extends IdentifiableDAO { @Column(name = \"schema_id\") private UUID schemaId; @Column(name = \"comment\") private String comment; @Column(name = \"created_at\") private Long createdAt; @Column(name = \"updated_at\") private Long updatedAt; @Column(name = \"data_type\") private ColumnTypeName dataType; @Column(name = \"full_data_type\") private String fullDataType; @Column(name = \"external_language\") private String externalLanguage; @Column(name = \"is_deterministic\") private Boolean isDeterministic; @Column(name = \"is_null_call\") private Boolean isNullCall; @Column(name = \"parameter_style\") private FunctionInfo.ParameterStyleEnum parameterStyle; @Column(name = \"routine_body\") private FunctionInfo.RoutineBodyEnum routineBody; @Column(name = \"routine_definition\") private String routineDefinition; @Column(name = \"sql_data_access\") private FunctionInfo.SqlDataAccessEnum sqlDataAccess; @Column(name = \"security_type\") private FunctionInfo.SecurityTypeEnum securityType; @Column(name = \"specific_name\") private String specificName; @OneToMany(mappedBy = \"function\", cascade = CascadeType.ALL, orphanRemoval = true) @SQLRestriction(\"input_or_return = 0\") private List<FunctionParameterInfoDAO> inputParams; @OneToMany(mappedBy = \"function\", cascade = CascadeType.ALL, orphanRemoval = true) @SQLRestriction(\"input_or_return = 1\") private List<FunctionParameterInfoDAO> returnParams; public static FunctionInfoDAO from(FunctionInfo functionInfo) { FunctionInfoDAO functionInfoDAO = FunctionInfoDAO.builder() .id( functionInfo.getFunctionId() != null ? UUID.fromString(functionInfo.getFunctionId()) : null) .name(functionInfo.getName()) .comment(functionInfo.getComment()) .createdAt(functionInfo.getCreatedAt()) .updatedAt(functionInfo.getUpdatedAt()) .dataType(functionInfo.getDataType()) .fullDataType(functionInfo.getFullDataType()) .externalLanguage(functionInfo.getExternalLanguage()) .isDeterministic(functionInfo.getIsDeterministic()) .isNullCall(functionInfo.getIsNullCall()) .parameterStyle(functionInfo.getParameterStyle()) .routineBody(functionInfo.getRoutineBody()) .routineDefinition(functionInfo.getRoutineDefinition()) .sqlDataAccess(functionInfo.getSqlDataAccess()) .securityType(functionInfo.getSecurityType()) .specificName(functionInfo.getSpecificName()) .inputParams( FunctionParameterInfoDAO.from( functionInfo.getInputParams(), FunctionParameterInfoDAO.InputOrReturnEnum.INPUT)) .returnParams( FunctionParameterInfoDAO.from( functionInfo.getReturnParams(), FunctionParameterInfoDAO.InputOrReturnEnum.RETURN)) .build(); for (FunctionParameterInfoDAO inputParam : functionInfoDAO.inputParams) { inputParam.setFunction(functionInfoDAO); } for (FunctionParameterInfoDAO returnParam : functionInfoDAO.returnParams) { returnParam.setFunction(functionInfoDAO); } return functionInfoDAO; } public FunctionInfo toFunctionInfo() { FunctionInfo functionInfo = new FunctionInfo() .functionId(getId().toString()) .name(getName()) .comment(comment) .createdAt(createdAt) .updatedAt(updatedAt) .dataType(dataType) .fullDataType(fullDataType) .externalLanguage(externalLanguage) .isDeterministic(isDeterministic) .isNullCall(isNullCall) .parameterStyle(parameterStyle) .routineBody(routineBody) .routineDefinition(routineDefinition) .sqlDataAccess(sqlDataAccess) .securityType(securityType) .specificName(specificName); if (!inputParams.isEmpty()) { functionInfo.inputParams(FunctionParameterInfoDAO.toFunctionParameterInfos(inputParams)); } if (!returnParams.isEmpty()) { functionInfo.returnParams(FunctionParameterInfoDAO.toFunctionParameterInfos(returnParams)); } return functionInfo; } }",
        "type": "Class",
        "relationship": "The FunctionInfoDAO class provides the data persistence layer that enables the documented getFunction endpoint by mapping database records to FunctionInfo objects through JPA annotations and conversion methods toFunctionInfo() and from().",
        "traceability_granularity": "Class",
        "trace_chain": "FunctionsApi.md -> FunctionInfoDAO"
      },
      {
        "title": "FunctionCli.getFunction",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/FunctionCli.java",
        "content": "private static String getFunction(FunctionsApi functionsApi, JSONObject json) throws JsonProcessingException, ApiException { String functionFullName = json.getString(CliParams.FULL_NAME.getServerParam()); return objectWriter.writeValueAsString(functionsApi.getFunction(functionFullName)); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented getFunction endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionCli.getFunction"
      },
      {
        "title": "FunctionRepository.getFunction",
        "location": "server/src/main/java/io/unitycatalog/server/persist/FunctionRepository.java",
        "content": "public FunctionInfo getFunction(String name) { FunctionInfo functionInfo = null; try (Session session = SESSION_FACTORY.openSession()) { session.setDefaultReadOnly(true); Transaction tx = session.beginTransaction(); try { String[] parts = name.split(\"\\.\"); if (parts.length != 3) { throw new BaseException(ErrorCode.INVALID_ARGUMENT, \"Invalid function name: \" + name); } String catalogName = parts[0], schemaName = parts[1], functionName = parts[2]; FunctionInfoDAO functionInfoDAO = getFunctionDAO(session, catalogName, schemaName, functionName); if (functionInfoDAO == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Function not found: \" + name); } functionInfo = functionInfoDAO.toFunctionInfo(); addNamespaceInfo(functionInfo, catalogName, schemaName); tx.commit(); } catch (Exception e) { tx.rollback(); throw e; } } catch (Exception e) { LOGGER.error(\"Error getting function\", e); return null; } return functionInfo; }",
        "type": "Method",
        "relationship": "The code implements the documented function retrieval by parsing a fully-qualified three-part function name (catalog.schema.function), querying a database session for the function details, and returning a FunctionInfo object as specified in the documentation.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionService.getFunction -> FunctionRepository.getFunction"
      }
    ]
  },
  {
    "document": {
      "text": "# TablesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createTable**](TablesApi.md#createTable) | **POST** /tables | Create a table. WARNING: This API is experimental and will change in future versions.  |\n| [**deleteTable**](TablesApi.md#deleteTable) | **DELETE** /tables/{full_name} | Delete a table |\n| [**getTable**](TablesApi.md#getTable) | **GET** /tables/{full_name} | Get a table |\n| [**listTables**](TablesApi.md#listTables) | **GET** /tables | List tables |",
      "location": "api/Apis/TablesApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "TableCli.deleteTable",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/TableCli.java",
        "content": "private static String deleteTable(TablesApi tablesApi, JSONObject json) throws ApiException { tablesApi.deleteTable(json.getString(CliParams.FULL_NAME.getServerParam())); return EMPTY; }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented deleteTable endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableCli.deleteTable"
      },
      {
        "title": "TableService.createTable",
        "location": "server/src/main/java/io/unitycatalog/server/service/TableService.java",
        "content": "@Post(\"\") public HttpResponse createTable(CreateTable createTable) { assert createTable != null; TableInfo createTableResponse = TABLE_REPOSITORY.createTable(createTable); return HttpResponse.ofJson(createTableResponse); }",
        "type": "Method",
        "relationship": "The createTable code method implements the POST /tables API endpoint documented in TablesApi by accepting a CreateTable request object, delegating to TABLE_REPOSITORY for table creation, and returning the response as JSON.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableService.createTable"
      },
      {
        "title": "TableRepository.getTable",
        "location": "server/src/main/java/io/unitycatalog/server/persist/TableRepository.java",
        "content": "public TableInfo getTable(String fullName) { LOGGER.debug(\"Getting table: \" + fullName); TableInfo tableInfo = null; try (Session session = SESSION_FACTORY.openSession()) { session.setDefaultReadOnly(true); Transaction tx = session.beginTransaction(); try { String[] parts = fullName.split(\"\\.\"); if (parts.length != 3) { throw new BaseException(ErrorCode.INVALID_ARGUMENT, \"Invalid table name: \" + fullName); } String catalogName = parts[0]; String schemaName = parts[1]; String tableName = parts[2]; TableInfoDAO tableInfoDAO = findTable(session, catalogName, schemaName, tableName); if (tableInfoDAO == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Table not found: \" + fullName); } tableInfo = tableInfoDAO.toTableInfo(true); tableInfo.setCatalogName(catalogName); tableInfo.setSchemaName(schemaName); RepositoryUtils.attachProperties( tableInfo, tableInfo.getTableId(), Constants.TABLE, session); tx.commit(); return tableInfo; } catch (Exception e) { if (tx != null && tx.getStatus().canRollback()) { tx.rollback(); } throw e; } } }",
        "type": "Method",
        "relationship": "The TableRepository.getTable method implements the backend database logic for the GET /tables/{full_name} API endpoint, retrieving a table's details from the database by parsing the full_name parameter into catalog, schema and table components and returning a TableInfo object with attached properties.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableService.getTable -> TableRepository.getTable"
      },
      {
        "title": "TableService.deleteTable",
        "location": "server/src/main/java/io/unitycatalog/server/service/TableService.java",
        "content": "@Delete(\"/{full_name}\") public HttpResponse deleteTable(@Param(\"full_name\") String fullName) { TABLE_REPOSITORY.deleteTable(fullName); return HttpResponse.of(HttpStatus.OK); } }",
        "type": "Method",
        "relationship": "The code implements the documented DELETE /tables/{full_name} endpoint by creating a method annotated with @Delete that takes a full_name parameter, deletes the corresponding table through the repository, and returns an HTTP 200 OK response.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableService.deleteTable"
      },
      {
        "title": "TableRepository.deleteTable",
        "location": "server/src/main/java/io/unitycatalog/server/persist/TableRepository.java",
        "content": "public void deleteTable(Session session, UUID schemaId, String tableName) { TableInfoDAO tableInfoDAO = findBySchemaIdAndName(session, schemaId, tableName); if (tableInfoDAO == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Table not found: \" + tableName); } if (TableType.MANAGED.getValue().equals(tableInfoDAO.getType())) { try { FileUtils.deleteDirectory(tableInfoDAO.getUrl()); } catch (Throwable e) { LOGGER.error(\"Error deleting table directory: {}\", tableInfoDAO.getUrl(), e); } } PropertyRepository.findProperties(session, tableInfoDAO.getId(), Constants.TABLE) .forEach(session::remove); session.remove(tableInfoDAO); } }",
        "type": "Method",
        "relationship": "The deleteTable method implements the DELETE /tables/{full_name} API endpoint's backend logic by removing the table's metadata from the session, cleaning up associated properties, and deleting the physical directory for managed tables.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableService.deleteTable -> TableRepository.deleteTable"
      },
      {
        "title": "TableRepository.listTables",
        "location": "server/src/main/java/io/unitycatalog/server/persist/TableRepository.java",
        "content": "public ListTablesResponse listTables( String catalogName, String schemaName, Optional<Integer> maxResults, Optional<String> pageToken, Boolean omitProperties, Boolean omitColumns) { try (Session session = SESSION_FACTORY.openSession()) { session.setDefaultReadOnly(true); Transaction tx = session.beginTransaction(); try { UUID schemaId = getSchemaId(session, catalogName, schemaName); ListTablesResponse response = listTables( session, schemaId, catalogName, schemaName, maxResults, pageToken, omitProperties, omitColumns); tx.commit(); return response; } catch (Exception e) { if (tx != null && tx.getStatus().canRollback()) { tx.rollback(); } throw e; } } } public ListTablesResponse listTables( Session session, UUID schemaId, String catalogName, String schemaName, Optional<Integer> maxResults, Optional<String> pageToken, Boolean omitProperties, Boolean omitColumns) { List<TableInfoDAO> tableInfoDAOList = LISTING_HELPER.listEntity(session, maxResults, pageToken, schemaId); String nextPageToken = LISTING_HELPER.getNextPageToken(tableInfoDAOList, maxResults); List<TableInfo> result = new ArrayList<>(); for (TableInfoDAO tableInfoDAO : tableInfoDAOList) { TableInfo tableInfo = tableInfoDAO.toTableInfo(!omitColumns); if (!omitProperties) { RepositoryUtils.attachProperties( tableInfo, tableInfo.getTableId(), Constants.TABLE, session); } tableInfo.setCatalogName(catalogName); tableInfo.setSchemaName(schemaName); result.add(tableInfo); } return new ListTablesResponse().tables(result).nextPageToken(nextPageToken); }",
        "type": "Method",
        "relationship": "The TableRepository.listTables code implements the GET /tables REST API endpoint by querying tables from a database session, applying pagination through maxResults and pageToken parameters, and returning a ListTablesResponse containing table information with optional properties and columns.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableService.listTables -> TableRepository.listTables"
      },
      {
        "title": "TableRepository.createTable",
        "location": "server/src/main/java/io/unitycatalog/server/persist/TableRepository.java",
        "content": "public TableInfo createTable(CreateTable createTable) { ValidationUtils.validateSqlObjectName(createTable.getName()); List<ColumnInfo> columnInfos = createTable.getColumns().stream() .map(c -> c.typeText(c.getTypeText().toLowerCase(Locale.ROOT))) .collect(Collectors.toList()); TableInfo tableInfo = new TableInfo() .tableId(UUID.randomUUID().toString()) .name(createTable.getName()) .catalogName(createTable.getCatalogName()) .schemaName(createTable.getSchemaName()) .tableType(createTable.getTableType()) .dataSourceFormat(createTable.getDataSourceFormat()) .columns(columnInfos) .storageLocation(FileUtils.convertRelativePathToURI(createTable.getStorageLocation())) .comment(createTable.getComment()) .properties(createTable.getProperties()) .createdAt(System.currentTimeMillis()); String fullName = getTableFullName(tableInfo); LOGGER.debug(\"Creating table: \" + fullName); Transaction tx; try (Session session = SESSION_FACTORY.openSession()) { String catalogName = tableInfo.getCatalogName(); String schemaName = tableInfo.getSchemaName(); UUID schemaId = getSchemaId(session, catalogName, schemaName); tx = session.beginTransaction(); try { // Check if table already exists TableInfoDAO existingTable = findBySchemaIdAndName(session, schemaId, tableInfo.getName()); if (existingTable != null) { throw new BaseException(ErrorCode.ALREADY_EXISTS, \"Table already exists: \" + fullName); } if (TableType.MANAGED.equals(tableInfo.getTableType())) { throw new BaseException( ErrorCode.INVALID_ARGUMENT, \"MANAGED table creation is not supported yet.\"); } // assuming external table if (tableInfo.getStorageLocation() == null) { throw new BaseException( ErrorCode.INVALID_ARGUMENT, \"Storage location is required for external table\"); } TableInfoDAO tableInfoDAO = TableInfoDAO.from(tableInfo); tableInfoDAO.setSchemaId(schemaId); // create columns tableInfoDAO .getColumns() .forEach( c -> { c.setId(UUID.randomUUID()); c.setTable(tableInfoDAO); }); // create properties PropertyDAO.from(tableInfo.getProperties(), tableInfoDAO.getId(), Constants.TABLE) .forEach(session::persist); session.persist(tableInfoDAO); tx.commit(); } catch (RuntimeException e) { if (tx != null && tx.getStatus().canRollback()) { tx.rollback(); } throw e; } } catch (RuntimeException e) { if (e instanceof BaseException) { throw e; } throw new BaseException( ErrorCode.INTERNAL, \"Error creating table: \" + fullName + \". \" + e.getMessage(), e); } return tableInfo; }",
        "type": "Method",
        "relationship": "The TableRepository.createTable method implements the backend logic for the experimental POST /tables API endpoint, handling table creation with validations for SQL object names, schema existence, and storage location requirements while preventing creation of managed tables.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableService.createTable -> TableRepository.createTable"
      },
      {
        "title": "TableCli.createTable",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/TableCli.java",
        "content": "private static String createTable(TablesApi apiClient, JSONObject json) throws JsonProcessingException, ApiException { CliUtils.resolveFullNameToThreeLevelNamespace(json); try { json.putOnce(CliParams.TABLE_TYPE.getServerParam(), TableType.EXTERNAL.name()); } catch (JSONException e) { // ignore (table type already set) } try { json.putOnce(CliParams.DATA_SOURCE_FORMAT.getServerParam(), DataSourceFormat.DELTA.name()); } catch (JSONException e) { // ignore (data source format already set) } String format = json.getString(CliParams.DATA_SOURCE_FORMAT.getServerParam()); // Set fields in json object for seamless deserialization List<ColumnInfo> columnInfoList = CliUtils.parseColumns(json.getString(CliParams.COLUMNS.getServerParam())); CreateTable createTable = new CreateTable() .name(json.getString(CliParams.NAME.getServerParam())) .catalogName(json.getString(CliParams.CATALOG_NAME.getServerParam())) .schemaName(json.getString(CliParams.SCHEMA_NAME.getServerParam())) .columns(columnInfoList) .properties(CliUtils.extractProperties(objectMapper, json)) .tableType( TableType.valueOf( json.getString(CliParams.TABLE_TYPE.getServerParam()).toUpperCase())) .dataSourceFormat(DataSourceFormat.valueOf(format.toUpperCase())); if (createTable.getTableType() == TableType.EXTERNAL) { createTable.storageLocation(json.getString(CliParams.STORAGE_LOCATION.getServerParam())); handleTableStorageLocation(createTable.getStorageLocation(), columnInfoList); } TableInfo tableInfo = apiClient.createTable(createTable); return objectWriter.writeValueAsString(tableInfo); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented createTable endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableCli.createTable"
      },
      {
        "title": "TableCli.listTables",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/TableCli.java",
        "content": "private static String listTables(TablesApi tablesApi, JSONObject json) throws JsonProcessingException, ApiException { int maxResults = 100; if (json.has(CliParams.MAX_RESULTS.getServerParam())) { maxResults = json.getInt(CliParams.MAX_RESULTS.getServerParam()); } return objectWriter.writeValueAsString( tablesApi .listTables( json.getString(CliParams.CATALOG_NAME.getServerParam()), json.getString(CliParams.SCHEMA_NAME.getServerParam()), maxResults, null) .getTables()); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented listTables endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableCli.listTables"
      },
      {
        "title": "TableService.getTable",
        "location": "server/src/main/java/io/unitycatalog/server/service/TableService.java",
        "content": "Get(\"/{full_name}\") public HttpResponse getTable(@Param(\"full_name\") String fullName) { assert fullName != null; TableInfo tableInfo = TABLE_REPOSITORY.getTable(fullName); return HttpResponse.ofJson(tableInfo); }",
        "type": "Method",
        "relationship": "The code implements the documented GET /tables/{full_name} endpoint by creating a method that retrieves a TableInfo object based on the full_name path parameter and returns it as a JSON HTTP response.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableService.getTable"
      },
      {
        "title": "TableService.listTables",
        "location": "server/src/main/java/io/unitycatalog/server/service/TableService.java",
        "content": "@Get(\"\") public HttpResponse listTables( @Param(\"catalog_name\") String catalogName, @Param(\"schema_name\") String schemaName, @Param(\"max_results\") Optional<Integer> maxResults, @Param(\"page_token\") Optional<String> pageToken, @Param(\"omit_properties\") Optional<Boolean> omitProperties, @Param(\"omit_columns\") Optional<Boolean> omitColumns) { return HttpResponse.ofJson( TABLE_REPOSITORY.listTables( catalogName, schemaName, maxResults, pageToken, omitProperties.orElse(false), omitColumns.orElse(false))); }",
        "type": "Method",
        "relationship": "The document is an API endpoint summary table that lists the methods available and their description under the TablesApi. Each code is related to one of the methods.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableService.listTables"
      },
      {
        "title": "TableCli.getTable",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/TableCli.java",
        "content": "private static String getTable(TablesApi tablesApi, JSONObject json) throws JsonProcessingException, ApiException { String fullName = json.getString(CliParams.FULL_NAME.val()); return objectWriter.writeValueAsString(tablesApi.getTable(fullName)); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented getTable endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableCli.getTable"
      }
    ]
  },
  {
    "document": {
      "text": "# **updateVolume**\n> VolumeInfo updateVolume(name, UpdateVolumeRequestContent)\n\nUpdate a Volume\n\n    Updates the specified volume under the specified parent catalog and schema.  Currently only the name or the comment of the volume could be updated. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n| **UpdateVolumeRequestContent** | [**UpdateVolumeRequestContent**](../Models/UpdateVolumeRequestContent.md)|  | [optional] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
      "location": "api/Apis/VolumesApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "VolumeService.updateVolume",
        "location": "server/src/main/java/io/unitycatalog/server/service/VolumeService.java",
        "content": "@Patch(\"/{full_name}\") public HttpResponse updateVolume( @Param(\"full_name\") String fullName, UpdateVolumeRequestContent updateVolumeRequest) { return HttpResponse.ofJson(VOLUME_REPOSITORY.updateVolume(fullName, updateVolumeRequest)); }",
        "type": "Method",
        "relationship": "The code implements a PATCH endpoint that takes a fully qualified volume name and UpdateVolumeRequestContent object as specified in the documentation, delegating the actual update operation to VOLUME_REPOSITORY and wrapping the returned VolumeInfo in an HTTP response.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.updateVolume"
      },
      {
        "title": "VolumeCli.updateVolume",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/VolumeCli.java",
        "content": "private static String updateVolume(VolumesApi apiClient, JSONObject json) throws JsonProcessingException, ApiException { String volumeFullName = json.getString(CliParams.FULL_NAME.getServerParam()); json.remove(CliParams.FULL_NAME.getServerParam()); if (json.length() == 0) { List<CliParams> optionalParams = CliUtils.cliOptions.get(CliUtils.VOLUME).get(CliUtils.UPDATE).getOptionalParams(); String errorMessage = \"No parameters to update, please provide one of:\"; for (CliParams param : optionalParams) { errorMessage += \"\n --\" + param.val(); } throw new CliException(errorMessage); } UpdateVolumeRequestContent updateVolumeRequest = objectMapper.readValue(json.toString(), UpdateVolumeRequestContent.class); return objectWriter.writeValueAsString( apiClient.updateVolume(volumeFullName, updateVolumeRequest)); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented updateVolume endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeCli.updateVolume"
      },
      {
        "title": "VolumeRepository.updateVolume",
        "location": "server/src/main/java/io/unitycatalog/server/persist/VolumeRepository.java",
        "content": "public VolumeInfo updateVolume(String name, UpdateVolumeRequestContent updateVolumeRequest) { if (updateVolumeRequest.getNewName() != null) { ValidationUtils.validateSqlObjectName(updateVolumeRequest.getNewName()); } String[] namespace = name.split(\"\\.\"); String catalog = namespace[0], schema = namespace[1], volume = namespace[2]; try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { VolumeInfoDAO volumeInfo = getVolumeDAO(session, catalog, schema, volume); if (volumeInfo == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Volume not found: \" + name); } if (updateVolumeRequest.getNewName() != null) { VolumeInfoDAO existingVolume = getVolumeDAO(session, catalog, schema, updateVolumeRequest.getNewName()); if (existingVolume != null) { throw new BaseException( ErrorCode.ALREADY_EXISTS, \"Volume already exists: \" + updateVolumeRequest.getNewName()); } } if (updateVolumeRequest.getNewName() == null && updateVolumeRequest.getComment() == null) { tx.rollback(); return convertFromDAO(volumeInfo, catalog, schema); } if (updateVolumeRequest.getNewName() != null) { volumeInfo.setName(updateVolumeRequest.getNewName()); } if (updateVolumeRequest.getComment() != null) { volumeInfo.setComment(updateVolumeRequest.getComment()); } volumeInfo.setUpdatedAt(new Date()); session.merge(volumeInfo); tx.commit(); LOGGER.info(\"Updated volume: {}\", volumeInfo.getName()); return convertFromDAO(volumeInfo, catalog, schema); } catch (Exception e) { tx.rollback(); throw e; } } }",
        "type": "Method",
        "relationship": "The code implements the documented volume update functionality by validating the new name if provided, handling the three-level namespace split, and using database transactions to modify either the volume's name or comment while preventing duplicate names and handling non-existent volumes as specified in the documentation.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.updateVolume -> VolumeRepository.updateVolume"
      },
      {
        "title": "VolumeInfoDAO",
        "location": "server/src/main/java/io/unitycatalog/server/persist/dao/VolumeInfoDAO.java",
        "content": "package io.unitycatalog.server.persist.dao; import io.unitycatalog.server.model.VolumeInfo; import io.unitycatalog.server.model.VolumeType; import io.unitycatalog.server.persist.utils.FileUtils; import jakarta.persistence.Column; import jakarta.persistence.Entity; import jakarta.persistence.Table; import java.util.Date; import java.util.UUID; import lombok.*; import lombok.experimental.SuperBuilder; @Entity @Table(name = \"uc_volumes\") // lombok annotations @Getter @Setter @NoArgsConstructor @AllArgsConstructor @SuperBuilder @EqualsAndHashCode(callSuper = true) public class VolumeInfoDAO extends IdentifiableDAO { @Column(name = \"schema_id\") private UUID schemaId; @Column(name = \"comment\") private String comment; @Column(name = \"storage_location\") private String storageLocation; @Column(name = \"created_at\") private Date createdAt; @Column(name = \"updated_at\") private Date updatedAt; @Column(name = \"volume_type\") private String volumeType; public VolumeInfo toVolumeInfo() { return new VolumeInfo() .volumeId(getId().toString()) .name(getName()) .comment(comment) .storageLocation(FileUtils.convertRelativePathToURI(storageLocation)) .createdAt(createdAt.getTime()) .updatedAt(updatedAt.getTime()) .volumeType(VolumeType.valueOf(volumeType)); } public static VolumeInfoDAO from(VolumeInfo volumeInfo) { if (volumeInfo == null) { return null; } return VolumeInfoDAO.builder() .id(UUID.fromString(volumeInfo.getVolumeId())) .name(volumeInfo.getName()) .comment(volumeInfo.getComment()) .storageLocation(volumeInfo.getStorageLocation()) .createdAt( volumeInfo.getCreatedAt() != null ? new Date(volumeInfo.getCreatedAt()) : new Date()) .updatedAt( volumeInfo.getUpdatedAt() != null ? new Date(volumeInfo.getUpdatedAt()) : new Date()) .volumeType(volumeInfo.getVolumeType().getValue()) .build(); } }",
        "type": "Class",
        "relationship": "The VolumeInfoDAO class implements the data persistence layer for volumes, with fields and conversion methods that match the VolumeInfo structure referenced in the updateVolume API documentation, particularly supporting the comment and name fields that are marked as updatable in the documentation.",
        "traceability_granularity": "Class",
        "trace_chain": "VolumesApi.md -> VolumeInfoDAO"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"deleteTable\"></a>\n# **deleteTable**\n> oas_any_type_not_mapped deleteTable(full\\_name)\n\nDelete a table\n\n    Deletes a table from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
      "location": "api/Apis/TablesApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "TableCli.deleteTable",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/TableCli.java",
        "content": "private static String deleteTable(TablesApi tablesApi, JSONObject json) throws ApiException { tablesApi.deleteTable(json.getString(CliParams.FULL_NAME.getServerParam())); return EMPTY; }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented deleteTable endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableCli.deleteTable"
      },
      {
        "title": "TableRepository.deleteTable",
        "location": "server/src/main/java/io/unitycatalog/server/persist/TableRepository.java",
        "content": "public void deleteTable(Session session, UUID schemaId, String tableName) { TableInfoDAO tableInfoDAO = findBySchemaIdAndName(session, schemaId, tableName); if (tableInfoDAO == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Table not found: \" + tableName); } if (TableType.MANAGED.getValue().equals(tableInfoDAO.getType())) { try { FileUtils.deleteDirectory(tableInfoDAO.getUrl()); } catch (Throwable e) { LOGGER.error(\"Error deleting table directory: {}\", tableInfoDAO.getUrl(), e); } } PropertyRepository.findProperties(session, tableInfoDAO.getId(), Constants.TABLE) .forEach(session::remove); session.remove(tableInfoDAO); } }",
        "type": "Method",
        "relationship": "The code implements the documented table deletion operation by removing the table's database entry, deleting its physical files (for managed tables), and cleaning up associated properties, while the documentation describes the API endpoint that exposes this functionality with a 'full_name' parameter.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableService.deleteTable -> TableRepository.deleteTable"
      },
      {
        "title": "TableService.deleteTable",
        "location": "server/src/main/java/io/unitycatalog/server/service/TableService.java",
        "content": "@Delete(\"/{full_name}\") public HttpResponse deleteTable(@Param(\"full_name\") String fullName) { TABLE_REPOSITORY.deleteTable(fullName); return HttpResponse.of(HttpStatus.OK); } }",
        "type": "Method",
        "relationship": "The code implements a REST DELETE endpoint that matches the documented API specification by accepting a full_name parameter, invoking TABLE_REPOSITORY.deleteTable(), and returning a 200 OK response with no content body.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableService.deleteTable"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"getTable\"></a>\n# **getTable**\n> TableInfo getTable(full\\_name)\n\nGet a table\n\n    Gets a table for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the table. | [default to null] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
      "location": "api/Apis/TablesApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "TableInfoDAO",
        "location": "server/src/main/java/io/unitycatalog/server/persist/dao/TableInfoDAO.java",
        "content": "package io.unitycatalog.server.persist.dao; import io.unitycatalog.server.model.DataSourceFormat; import io.unitycatalog.server.model.TableInfo; import io.unitycatalog.server.model.TableType; import io.unitycatalog.server.persist.utils.FileUtils; import jakarta.persistence.*; import java.util.Date; import java.util.List; import java.util.UUID; import lombok.*; import lombok.experimental.SuperBuilder; // Hibernate annotations @Entity @Table( name = \"uc_tables\", indexes = { @Index(name = \"idx_name\", columnList = \"name\"), }) // Lombok annotations @Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(callSuper = true) @SuperBuilder public class TableInfoDAO extends IdentifiableDAO { @Column(name = \"schema_id\") private UUID schemaId; @Column(name = \"type\") private String type; @Column(name = \"created_at\") private Date createdAt; @Column(name = \"updated_at\") private Date updatedAt; @Column(name = \"data_source_format\") private String dataSourceFormat; @Column(name = \"comment\", length = 65535) private String comment; @Column(name = \"url\", length = 2048) private String url; @Column(name = \"column_count\") private Integer columnCount; @OneToMany( mappedBy = \"table\", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY) private List<ColumnInfoDAO> columns; @Column(name = \"uniform_iceberg_metadata_location\", length = 65535) private String uniformIcebergMetadataLocation; public static TableInfoDAO from(TableInfo tableInfo) { return TableInfoDAO.builder() .id(UUID.fromString(tableInfo.getTableId())) .name(tableInfo.getName()) .comment(tableInfo.getComment()) .createdAt( tableInfo.getCreatedAt() != null ? new Date(tableInfo.getCreatedAt()) : new Date()) .updatedAt(tableInfo.getUpdatedAt() != null ? new Date(tableInfo.getUpdatedAt()) : null) .columnCount(tableInfo.getColumns() != null ? tableInfo.getColumns().size() : 0) .url(tableInfo.getStorageLocation() != null ? tableInfo.getStorageLocation() : null) .type(tableInfo.getTableType().toString()) .dataSourceFormat(tableInfo.getDataSourceFormat().toString()) .url(tableInfo.getStorageLocation()) .columns(ColumnInfoDAO.fromList(tableInfo.getColumns())) .build(); } public TableInfo toTableInfo(boolean fetchColumns) { TableInfo tableInfo = new TableInfo() .tableId(getId().toString()) .name(getName()) .tableType(TableType.valueOf(type)) .dataSourceFormat(DataSourceFormat.valueOf(dataSourceFormat)) .storageLocation(FileUtils.convertRelativePathToURI(url)) .comment(comment) .createdAt(createdAt != null ? createdAt.getTime() : null) .updatedAt(updatedAt != null ? updatedAt.getTime() : null); if (fetchColumns) { tableInfo.columns(ColumnInfoDAO.toList(columns)); } return tableInfo; } }",
        "type": "Class",
        "relationship": "The TableInfoDAO class provides the data persistence layer and model conversion methods that enable the documented getTable API endpoint to retrieve and return table information in the expected TableInfo format.",
        "traceability_granularity": "Class",
        "trace_chain": "TablesApi.md -> TableInfoDAO"
      },
      {
        "title": "TableRepository.getTable",
        "location": "server/src/main/java/io/unitycatalog/server/persist/TableRepository.java",
        "content": "public TableInfo getTable(String fullName) { LOGGER.debug(\"Getting table: \" + fullName); TableInfo tableInfo = null; try (Session session = SESSION_FACTORY.openSession()) { session.setDefaultReadOnly(true); Transaction tx = session.beginTransaction(); try { String[] parts = fullName.split(\"\\.\"); if (parts.length != 3) { throw new BaseException(ErrorCode.INVALID_ARGUMENT, \"Invalid table name: \" + fullName); } String catalogName = parts[0]; String schemaName = parts[1]; String tableName = parts[2]; TableInfoDAO tableInfoDAO = findTable(session, catalogName, schemaName, tableName); if (tableInfoDAO == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Table not found: \" + fullName); } tableInfo = tableInfoDAO.toTableInfo(true); tableInfo.setCatalogName(catalogName); tableInfo.setSchemaName(schemaName); RepositoryUtils.attachProperties( tableInfo, tableInfo.getTableId(), Constants.TABLE, session); tx.commit(); return tableInfo; } catch (Exception e) { if (tx != null && tx.getStatus().canRollback()) { tx.rollback(); } throw e; } } }",
        "type": "Method",
        "relationship": "The code implements the documented getTable operation by parsing a fully qualified table name into catalog, schema, and table components, retrieving the table information from a database session, and returning a TableInfo object with attached properties, exactly matching the documented input parameter and return type specifications.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableService.getTable -> TableRepository.getTable"
      },
      {
        "title": "TableCli.getTable",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/TableCli.java",
        "content": "private static String getTable(TablesApi tablesApi, JSONObject json) throws JsonProcessingException, ApiException { String fullName = json.getString(CliParams.FULL_NAME.val()); return objectWriter.writeValueAsString(tablesApi.getTable(fullName)); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented getTable endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableCli.getTable"
      },
      {
        "title": "TableService.getTable",
        "location": "server/src/main/java/io/unitycatalog/server/service/TableService.java",
        "content": "Get(\"/{full_name}\") public HttpResponse getTable(@Param(\"full_name\") String fullName) { assert fullName != null; TableInfo tableInfo = TABLE_REPOSITORY.getTable(fullName); return HttpResponse.ofJson(tableInfo); }",
        "type": "Method",
        "relationship": "The code implements a REST endpoint annotated with @Get that takes a full_name parameter, validates it's not null, retrieves table information via TABLE_REPOSITORY, and returns it as JSON - matching the documented API endpoint behavior, parameter requirements, and TableInfo return type.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableService.getTable"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"createSchema\"></a>\n# **createSchema**\n> SchemaInfo createSchema(CreateSchema)\n\nCreate a schema\n\n    Creates a new schema in the specified catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateSchema** | [**CreateSchema**](../Models/CreateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
      "location": "api/Apis/SchemasApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "SchemaService.createSchema",
        "location": "server/src/main/java/io/unitycatalog/server/service/SchemaService.java",
        "content": "@Post(\"\") public HttpResponse createSchema(CreateSchema createSchema) { return HttpResponse.ofJson(SCHEMA_REPOSITORY.createSchema(createSchema)); }",
        "type": "Method",
        "relationship": "The code implements the documented REST endpoint by accepting a CreateSchema object via POST request and returning a JSON HTTP response containing the schema created through the SCHEMA_REPOSITORY.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.createSchema"
      },
      {
        "title": "SchemaInfoDAO",
        "location": "server/src/main/java/io/unitycatalog/server/persist/dao/SchemaInfoDAO.java",
        "content": "package io.unitycatalog.server.persist.dao; import io.unitycatalog.server.model.SchemaInfo; import jakarta.persistence.*; import java.time.Instant; import java.util.Date; import java.util.UUID; import lombok.*; import lombok.experimental.SuperBuilder; @Entity @Table(name = \"uc_schemas\") // Lombok @Getter @Setter @SuperBuilder @AllArgsConstructor @NoArgsConstructor @EqualsAndHashCode(callSuper = true) public class SchemaInfoDAO extends IdentifiableDAO { @Column(name = \"catalog_id\") private UUID catalogId; @Column(name = \"comment\") private String comment; @Column(name = \"created_at\") private Date createdAt; @Column(name = \"updated_at\") private Date updatedAt; public static SchemaInfoDAO from(SchemaInfo schemaInfo) { return SchemaInfoDAO.builder() .id(schemaInfo.getSchemaId() != null ? UUID.fromString(schemaInfo.getSchemaId()) : null) .name(schemaInfo.getName()) .comment(schemaInfo.getComment()) .createdAt( schemaInfo.getCreatedAt() != null ? Date.from(Instant.ofEpochMilli(schemaInfo.getCreatedAt())) : new Date()) .updatedAt( schemaInfo.getUpdatedAt() != null ? Date.from(Instant.ofEpochMilli(schemaInfo.getUpdatedAt())) : null) .build(); } public SchemaInfo toSchemaInfo() { return new SchemaInfo() .schemaId(getId().toString()) .name(getName()) .comment(getComment()) .createdAt(getCreatedAt().getTime()) .updatedAt(getUpdatedAt() != null ? getUpdatedAt().getTime() : null); } }",
        "type": "Class",
        "relationship": "The SchemaInfoDAO class provides the data persistence layer and conversion methods (from/toSchemaInfo) that enable storing and retrieving the SchemaInfo objects that are returned by the documented createSchema API endpoint.",
        "traceability_granularity": "Class",
        "trace_chain": "SchemasApi.md -> SchemaInfoDAO"
      },
      {
        "title": "SchemaCli.createSchema",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/SchemaCli.java",
        "content": "private static String createSchema(SchemasApi schemasApi, JSONObject json) throws JsonProcessingException, ApiException { CreateSchema createSchema = new CreateSchema() .name(json.getString(CliParams.NAME.getServerParam())) .catalogName(json.getString(CliParams.CATALOG_NAME.getServerParam())) .comment(json.optString(CliParams.COMMENT.getServerParam(), null)) .properties(CliUtils.extractProperties(objectMapper, json)); SchemaInfo schemaInfo = schemasApi.createSchema(createSchema); return objectWriter.writeValueAsString(schemaInfo); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented createSchema endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaCli.createSchema"
      },
      {
        "title": "SchemaRepository.createSchema",
        "location": "server/src/main/java/io/unitycatalog/server/persist/SchemaRepository.java",
        "content": "public SchemaInfo createSchema(CreateSchema createSchema) { ValidationUtils.validateSqlObjectName(createSchema.getName()); try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { if (getSchemaDAO(session, createSchema.getCatalogName(), createSchema.getName()) != null) { throw new BaseException( ErrorCode.ALREADY_EXISTS, \"Schema already exists: \" + createSchema.getName()); } CatalogInfoDAO catalogDAO = CATALOG_REPOSITORY.getCatalogDAO(session, createSchema.getCatalogName()); SchemaInfo schemaInfo = new SchemaInfo() .schemaId(UUID.randomUUID().toString()) .name(createSchema.getName()) .catalogName(createSchema.getCatalogName()) .comment(createSchema.getComment()) .createdAt(System.currentTimeMillis()) .properties(createSchema.getProperties()); SchemaInfoDAO schemaInfoDAO = SchemaInfoDAO.from(schemaInfo); schemaInfoDAO.setCatalogId(catalogDAO.getId()); PropertyDAO.from(schemaInfo.getProperties(), schemaInfoDAO.getId(), Constants.SCHEMA) .forEach(session::persist); session.persist(schemaInfoDAO); tx.commit(); addNamespaceData(schemaInfo, createSchema.getCatalogName()); return schemaInfo; } catch (Exception e) { tx.rollback(); throw e; } } }",
        "type": "Method",
        "relationship": "The code fully implements the documented API endpoint by validating the schema name, checking for existing schemas, persisting the new schema with its properties in a database transaction, and returning a SchemaInfo object as specified in the documentation's return type.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.createSchema -> SchemaRepository.createSchema"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"deleteFunction\"></a>\n# **deleteFunction**\n> oas_any_type_not_mapped deleteFunction(name)\n\nDelete a function\n\n    Deletes the function that matches the supplied name.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
      "location": "api/Apis/FunctionsApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "FunctionCli.deleteFunction",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/FunctionCli.java",
        "content": "private static String deleteFunction(FunctionsApi functionsApi, JSONObject json) throws ApiException { String functionFullName = json.getString(CliParams.FULL_NAME.getServerParam()); functionsApi.deleteFunction(functionFullName); return EMPTY; } }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented deleteFunction endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionCli.deleteFunction"
      },
      {
        "title": "FunctionService.deleteFunction",
        "location": "server/src/main/java/io/unitycatalog/server/service/FunctionService.java",
        "content": "@Delete(\"/{name}\") public HttpResponse deleteFunction( @Param(\"name\") String name, @Param(\"force\") Optional<Boolean> force) { FUNCTION_REPOSITORY.deleteFunction(name, force.orElse(false)); return HttpResponse.of(HttpStatus.OK); } }",
        "type": "Method",
        "relationship": "The code implements the documented DELETE endpoint by accepting a name parameter and an optional force parameter (not mentioned in docs), calling FUNCTION_REPOSITORY.deleteFunction(), and returning an HTTP 200 OK response as specified in the OpenAPI documentation.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionService.deleteFunction"
      },
      {
        "title": "FunctionRepository.deleteFunction",
        "location": "server/src/main/java/io/unitycatalog/server/persist/FunctionRepository.java",
        "content": "public void deleteFunction(String name, Boolean force) { try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { String[] parts = name.split(\"\\.\"); if (parts.length != 3) { throw new BaseException(ErrorCode.INVALID_ARGUMENT, \"Invalid function name: \" + name); } String catalogName = parts[0], schemaName = parts[1], functionName = parts[2]; SchemaInfoDAO schemaInfo = SCHEMA_REPOSITORY.getSchemaDAO(session, catalogName, schemaName); if (schemaInfo == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Schema not found: \" + schemaName); } deleteFunction(session, schemaInfo.getId(), functionName); tx.commit(); LOGGER.info(\"Deleted function: {}\", functionName); } catch (Exception e) { tx.rollback(); throw e; } } } public void deleteFunction(Session session, UUID schemaId, String functionName) { FunctionInfoDAO functionInfoDAO = getFunctionDAO(session, schemaId, functionName); if (functionInfoDAO == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Function not found: \" + functionName); } session.remove(functionInfoDAO); } }",
        "type": "Method",
        "relationship": "The code implements the documented deleteFunction API endpoint by validating and parsing a fully-qualified function name (catalog.schema.function), managing a database transaction to delete the corresponding FunctionInfoDAO record, and throwing appropriate exceptions for invalid names or missing functions.",
        "traceability_granularity": "Method",
        "trace_chain": "FunctionsApi.md -> FunctionService.deleteFunction -> FunctionRepository.deleteFunction"
      }
    ]
  },
  {
    "document": {
      "text": "# SchemasApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createSchema**](SchemasApi.md#createSchema) | **POST** /schemas | Create a schema |\n| [**deleteSchema**](SchemasApi.md#deleteSchema) | **DELETE** /schemas/{full_name} | Delete a schema |\n| [**getSchema**](SchemasApi.md#getSchema) | **GET** /schemas/{full_name} | Get a schema |\n| [**listSchemas**](SchemasApi.md#listSchemas) | **GET** /schemas | List schemas |\n| [**updateSchema**](SchemasApi.md#updateSchema) | **PATCH** /schemas/{full_name} | Update a schema |",
      "location": "api/Apis/SchemasApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "SchemaCli.deleteSchema",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/SchemaCli.java",
        "content": "private static String deleteSchema(SchemasApi schemasApi, JSONObject json) throws ApiException { String schemaFullName = json.getString(CliParams.FULL_NAME.getServerParam()); schemasApi.deleteSchema( schemaFullName, json.has(CliParams.FORCE.getServerParam()) && Boolean.parseBoolean(json.getString(CliParams.FORCE.getServerParam()))); return CliUtils.EMPTY; } }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented deleteSchema endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaCli.deleteSchema"
      },
      {
        "title": "SchemaRepository.deleteSchema",
        "location": "server/src/main/java/io/unitycatalog/server/persist/SchemaRepository.java",
        "content": "public void deleteSchema( Session session, UUID catalogId, String catalogName, String schemaName, boolean force) { SchemaInfoDAO schemaInfo = getSchemaDAO(session, catalogId, schemaName); if (schemaInfo != null) { processChildTables(session, schemaInfo.getId(), catalogName, schemaName, force); processChildVolumes(session, schemaInfo.getId(), catalogName, schemaName, force); processChildFunctions(session, schemaInfo.getId(), catalogName, schemaName, force); session.remove(schemaInfo); PropertyRepository.findProperties(session, schemaInfo.getId(), Constants.SCHEMA) .forEach(session::remove); } else { throw new BaseException(ErrorCode.NOT_FOUND, \"Schema not found: \" + schemaName); } } }",
        "type": "Method",
        "relationship": "The SchemaRepository.deleteSchema method implements the DELETE /schemas/{full_name} API endpoint by handling schema deletion logic, including processing child tables, volumes, and functions, and removing associated properties from the database session.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.deleteSchema -> SchemaRepository.deleteSchema"
      },
      {
        "title": "SchemaCli.updateSchema",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/SchemaCli.java",
        "content": "private static String updateSchema(SchemasApi schemasApi, JSONObject json) throws JsonProcessingException, ApiException { String schemaFullName = json.getString(CliParams.FULL_NAME.getServerParam()); json.remove(CliParams.FULL_NAME.getServerParam()); if (json.length() == 0) { List<CliParams> optionalParams = CliUtils.cliOptions.get(CliUtils.SCHEMA).get(CliUtils.UPDATE).getOptionalParams(); String errorMessage = \"No parameters to update, please provide one of:\"; for (CliParams param : optionalParams) { errorMessage += \"\n --\" + param.val(); } throw new CliException(errorMessage); } UpdateSchema updateSchema = new UpdateSchema() .newName(json.optString(CliParams.NEW_NAME.getServerParam(), null)) .comment(json.optString(CliParams.COMMENT.getServerParam(), null)) .properties(CliUtils.extractProperties(objectMapper, json)); SchemaInfo schemaInfo = schemasApi.updateSchema(schemaFullName, updateSchema); return objectWriter.writeValueAsString(schemaInfo); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented updateSchema endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaCli.updateSchema"
      },
      {
        "title": "SchemaService.deleteSchema",
        "location": "server/src/main/java/io/unitycatalog/server/service/SchemaService.java",
        "content": "@Delete(\"/{full_name}\") public HttpResponse deleteSchema( @Param(\"full_name\") String fullName, @Param(\"force\") Optional<Boolean> force) { SCHEMA_REPOSITORY.deleteSchema(fullName, force.orElse(false)); return HttpResponse.of(HttpStatus.OK); } }",
        "type": "Method",
        "relationship": "The code implements the documented DELETE /schemas/{full_name} endpoint by providing a method that accepts a schema's full name and an optional force parameter, deletes the specified schema from the repository, and returns an HTTP 200 OK response.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.deleteSchema"
      },
      {
        "title": "SchemaRepository.listSchemas",
        "location": "server/src/main/java/io/unitycatalog/server/persist/SchemaRepository.java",
        "content": "public ListSchemasResponse listSchemas( String catalogName, Optional<Integer> maxResults, Optional<String> pageToken) { try (Session session = SESSION_FACTORY.openSession()) { session.setDefaultReadOnly(true); Transaction tx = session.beginTransaction(); // TODO: Implement pagination and filtering if required // For now, returning all schemas without pagination try { UUID catalogId = getCatalogId(session, catalogName); ListSchemasResponse response = listSchemas(session, catalogId, catalogName, maxResults, pageToken); tx.commit(); return response; } catch (Exception e) { tx.rollback(); throw e; } } } public ListSchemasResponse listSchemas( Session session, UUID catalogId, String catalogName, Optional<Integer> maxResults, Optional<String> pageToken) { List<SchemaInfoDAO> schemaInfoDAOList = LISTING_HELPER.listEntity(session, maxResults, pageToken, catalogId); String nextPageToken = LISTING_HELPER.getNextPageToken(schemaInfoDAOList, maxResults); List<SchemaInfo> result = new ArrayList<>(); for (SchemaInfoDAO schemaInfoDAO : schemaInfoDAOList) { SchemaInfo schemaInfo = schemaInfoDAO.toSchemaInfo(); RepositoryUtils.attachProperties( schemaInfo, schemaInfo.getSchemaId(), Constants.SCHEMA, session); addNamespaceData(schemaInfo, catalogName); result.add(schemaInfo); } return new ListSchemasResponse().schemas(result).nextPageToken(nextPageToken); }",
        "type": "Method",
        "relationship": "The code implements the GET /schemas endpoint by retrieving schemas from a database session, supporting pagination through maxResults and pageToken parameters, and returning a ListSchemasResponse containing schema information and a next page token.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.listSchemas -> SchemaRepository.listSchemas"
      },
      {
        "title": "SchemaService.updateSchema",
        "location": "server/src/main/java/io/unitycatalog/server/service/SchemaService.java",
        "content": "@Patch(\"/{full_name}\") public HttpResponse updateSchema(@Param(\"full_name\") String fullName, UpdateSchema updateSchema) { return HttpResponse.ofJson(SCHEMA_REPOSITORY.updateSchema(fullName, updateSchema)); }",
        "type": "Method",
        "relationship": "The code implements the updateSchema API endpoint documented in the table by creating a PATCH handler at '/schemas/{full_name}' that accepts a schema name and update payload, passing them to the schema repository for processing.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.updateSchema"
      },
      {
        "title": "SchemaCli.listSchemas",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/SchemaCli.java",
        "content": "private static String listSchemas(SchemasApi schemasApi, JSONObject json) throws JsonProcessingException, ApiException { String catalogName = json.getString(CliParams.CATALOG_NAME.getServerParam()); int maxResults = 100; if (json.has(CliParams.MAX_RESULTS.getServerParam())) { maxResults = json.getInt(CliParams.MAX_RESULTS.getServerParam()); } return objectWriter.writeValueAsString( schemasApi.listSchemas(catalogName, maxResults, null).getSchemas()); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented listSchemas endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaCli.listSchemas"
      },
      {
        "title": "SchemaService.getSchema",
        "location": "server/src/main/java/io/unitycatalog/server/service/SchemaService.java",
        "content": "@Get(\"/{full_name}\") public HttpResponse getSchema(@Param(\"full_name\") String fullName) { return HttpResponse.ofJson(SCHEMA_REPOSITORY.getSchema(fullName)); }",
        "type": "Method",
        "relationship": "The code implements the GET /schemas/{full_name} endpoint documented in the API table by defining a method that retrieves a schema using the full_name path parameter and returns it as a JSON HTTP response.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.getSchema"
      },
      {
        "title": "SchemaCli.getSchema",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/SchemaCli.java",
        "content": "private static String getSchema(SchemasApi schemasApi, JSONObject json) throws JsonProcessingException, ApiException { String schemaFullName = json.getString(CliParams.FULL_NAME.getServerParam()); return objectWriter.writeValueAsString(schemasApi.getSchema(schemaFullName)); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented getSchema endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaCli.getSchema"
      },
      {
        "title": "SchemaRepository.updateSchema",
        "location": "server/src/main/java/io/unitycatalog/server/persist/SchemaRepository.java",
        "content": "public SchemaInfo updateSchema(String fullName, UpdateSchema updateSchema) { if (updateSchema.getNewName() != null) { ValidationUtils.validateSqlObjectName(updateSchema.getNewName()); } try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { SchemaInfoDAO schemaInfoDAO = getSchemaDAO(session, fullName); if (schemaInfoDAO == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Schema not found: \" + fullName); } if (updateSchema.getNewName() != null) { if (getSchemaDAO(session, fullName.split(\"\\.\")[0], updateSchema.getNewName()) != null) { throw new BaseException( ErrorCode.ALREADY_EXISTS, \"Schema already exists: \" + updateSchema.getNewName()); } } if (updateSchema.getComment() == null && updateSchema.getNewName() == null && (updateSchema.getProperties() == null || updateSchema.getProperties().isEmpty())) { tx.rollback(); return convertFromDAO(session, schemaInfoDAO, fullName); } // Update the schema with new values if (updateSchema.getComment() != null) { schemaInfoDAO.setComment(updateSchema.getComment()); } if (updateSchema.getNewName() != null) { schemaInfoDAO.setName(updateSchema.getNewName()); } if (updateSchema.getProperties() != null && !updateSchema.getProperties().isEmpty()) { PropertyRepository.findProperties(session, schemaInfoDAO.getId(), Constants.SCHEMA) .forEach(session::remove); session.flush(); PropertyDAO.from(updateSchema.getProperties(), schemaInfoDAO.getId(), Constants.SCHEMA) .forEach(session::persist); } schemaInfoDAO.setUpdatedAt(new Date()); session.merge(schemaInfoDAO); tx.commit(); return convertFromDAO(session, schemaInfoDAO, fullName); } catch (Exception e) { tx.rollback(); throw e; } } }",
        "type": "Method",
        "relationship": "The SchemaRepository.updateSchema method implements the PATCH /schemas/{full_name} API endpoint by handling the validation, modification, and persistence of schema updates including name changes, comments, and properties within a database transaction.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.updateSchema -> SchemaRepository.updateSchema"
      },
      {
        "title": "SchemaRepository.createSchema",
        "location": "server/src/main/java/io/unitycatalog/server/persist/SchemaRepository.java",
        "content": "public SchemaInfo createSchema(CreateSchema createSchema) { ValidationUtils.validateSqlObjectName(createSchema.getName()); try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { if (getSchemaDAO(session, createSchema.getCatalogName(), createSchema.getName()) != null) { throw new BaseException( ErrorCode.ALREADY_EXISTS, \"Schema already exists: \" + createSchema.getName()); } CatalogInfoDAO catalogDAO = CATALOG_REPOSITORY.getCatalogDAO(session, createSchema.getCatalogName()); SchemaInfo schemaInfo = new SchemaInfo() .schemaId(UUID.randomUUID().toString()) .name(createSchema.getName()) .catalogName(createSchema.getCatalogName()) .comment(createSchema.getComment()) .createdAt(System.currentTimeMillis()) .properties(createSchema.getProperties()); SchemaInfoDAO schemaInfoDAO = SchemaInfoDAO.from(schemaInfo); schemaInfoDAO.setCatalogId(catalogDAO.getId()); PropertyDAO.from(schemaInfo.getProperties(), schemaInfoDAO.getId(), Constants.SCHEMA) .forEach(session::persist); session.persist(schemaInfoDAO); tx.commit(); addNamespaceData(schemaInfo, createSchema.getCatalogName()); return schemaInfo; } catch (Exception e) { tx.rollback(); throw e; } } }",
        "type": "Method",
        "relationship": "The SchemaRepository.createSchema method implements the backend logic for the POST /schemas endpoint by validating the schema name, checking for duplicates, creating a new SchemaInfo object with a UUID, persisting it to the database within a transaction, and returning the created schema details.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.createSchema -> SchemaRepository.createSchema"
      },
      {
        "title": "SchemaCli.createSchema",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/SchemaCli.java",
        "content": "private static String createSchema(SchemasApi schemasApi, JSONObject json) throws JsonProcessingException, ApiException { CreateSchema createSchema = new CreateSchema() .name(json.getString(CliParams.NAME.getServerParam())) .catalogName(json.getString(CliParams.CATALOG_NAME.getServerParam())) .comment(json.optString(CliParams.COMMENT.getServerParam(), null)) .properties(CliUtils.extractProperties(objectMapper, json)); SchemaInfo schemaInfo = schemasApi.createSchema(createSchema); return objectWriter.writeValueAsString(schemaInfo); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented createSchema endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaCli.createSchema"
      },
      {
        "title": "SchemaRepository.getSchema",
        "location": "server/src/main/java/io/unitycatalog/server/persist/SchemaRepository.java",
        "content": "public SchemaInfo getSchema(String fullName) { try (Session session = SESSION_FACTORY.openSession()) { session.setDefaultReadOnly(true); Transaction tx = session.beginTransaction(); SchemaInfoDAO schemaInfoDAO; try { schemaInfoDAO = getSchemaDAO(session, fullName); if (schemaInfoDAO == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Schema not found: \" + fullName); } tx.commit(); SchemaInfo schemaInfo = convertFromDAO(session, schemaInfoDAO, fullName); return RepositoryUtils.attachProperties( schemaInfo, schemaInfo.getSchemaId(), Constants.SCHEMA, session); } catch (Exception e) { tx.rollback(); throw e; } } }",
        "type": "Method",
        "relationship": "The SchemaRepository.getSchema method implements the GET /schemas/{full_name} API endpoint by retrieving schema information from a database, converting it from DAO format, and attaching properties while managing database transactions.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.getSchema -> SchemaRepository.getSchema"
      },
      {
        "title": "SchemaService.listSchemas",
        "location": "server/src/main/java/io/unitycatalog/server/service/SchemaService.java",
        "content": "@Get(\"\") public HttpResponse listSchemas( @Param(\"catalog_name\") String catalogName, @Param(\"max_results\") Optional<Integer> maxResults, @Param(\"page_token\") Optional<String> pageToken) { return HttpResponse.ofJson(SCHEMA_REPOSITORY.listSchemas(catalogName, maxResults, pageToken)); }",
        "type": "Method",
        "relationship": "The listSchemas method implements the '/schemas' GET endpoint documented in the API table by accepting catalog_name, max_results, and page_token parameters and returning schema listings as a JSON HTTP response.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.listSchemas"
      },
      {
        "title": "SchemaService.createSchema",
        "location": "server/src/main/java/io/unitycatalog/server/service/SchemaService.java",
        "content": "@Post(\"\") public HttpResponse createSchema(CreateSchema createSchema) { return HttpResponse.ofJson(SCHEMA_REPOSITORY.createSchema(createSchema)); }",
        "type": "Method",
        "relationship": "The code implements the documented POST /schemas API endpoint by defining a createSchema method that accepts a CreateSchema object and returns a JSON HTTP response containing the newly created schema from the repository.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.createSchema"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"createCatalog\"></a>\n# **createCatalog**\n> CatalogInfo createCatalog(CreateCatalog)\n\nCreate a catalog\n\n    Creates a new catalog instance. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateCatalog** | [**CreateCatalog**](../Models/CreateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
      "location": "api/Apis/CatalogsApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "CatalogCli.createCatalog",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/CatalogCli.java",
        "content": "private static String createCatalog(CatalogsApi catalogsApi, JSONObject json) throws JsonProcessingException, ApiException { CreateCatalog createCatalog = new CreateCatalog() .name(json.getString(CliParams.NAME.getServerParam())) .comment(json.optString(CliParams.COMMENT.getServerParam(), null)) .properties(CliUtils.extractProperties(objectMapper, json)); CatalogInfo catalogInfo = catalogsApi.createCatalog(createCatalog); return objectWriter.writeValueAsString(catalogInfo); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented createCatalog endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogCli.createCatalog"
      },
      {
        "title": "CatalogRepository.addCatalog",
        "location": "server/src/main/java/io/unitycatalog/server/persist/CatalogRepository.java",
        "content": "public CatalogInfo addCatalog(CreateCatalog createCatalog) { ValidationUtils.validateSqlObjectName(createCatalog.getName()); CatalogInfo catalogInfo = new CatalogInfo() .id(java.util.UUID.randomUUID().toString()) .comment(createCatalog.getComment()) .name(createCatalog.getName()) .createdAt(System.currentTimeMillis()) .properties(createCatalog.getProperties()); try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { if (getCatalogDAO(session, createCatalog.getName()) != null) { throw new BaseException( ErrorCode.ALREADY_EXISTS, \"Catalog already exists: \" + createCatalog.getName()); } CatalogInfoDAO catalogInfoDAO = CatalogInfoDAO.from(catalogInfo); PropertyDAO.from(catalogInfo.getProperties(), catalogInfoDAO.getId(), Constants.CATALOG) .forEach(session::persist); session.persist(catalogInfoDAO); tx.commit(); LOGGER.info(\"Added catalog: {}\", catalogInfo.getName()); return catalogInfo; } catch (Exception e) { tx.rollback(); throw e; } } }",
        "type": "Method",
        "relationship": "The addCatalog implementation validates SQL object names, creates a CatalogInfo instance with a UUID and properties, and persists it to the database in a transaction, fulfilling the documented createCatalog API endpoint's purpose of creating a new catalog instance.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.createCatalog -> CatalogRepository.addCatalog"
      },
      {
        "title": "CatalogService.createCatalog",
        "location": "server/src/main/java/io/unitycatalog/server/service/CatalogService.java",
        "content": "@Post(\"\") public HttpResponse createCatalog(CreateCatalog createCatalog) { return HttpResponse.ofJson(CATALOG_REPOSITORY.addCatalog(createCatalog)); }",
        "type": "Method",
        "relationship": "The code implements the documented API endpoint by accepting a CreateCatalog object via POST, persisting it through CATALOG_REPOSITORY, and returning a JSON response matching the documented CatalogInfo return type.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.createCatalog"
      },
      {
        "title": "CatalogInfoDAO",
        "location": "server/src/main/java/io/unitycatalog/server/persist/dao/CatalogInfoDAO.java",
        "content": "package io.unitycatalog.server.persist.dao; import io.unitycatalog.server.model.CatalogInfo; import jakarta.persistence.*; import java.time.Instant; import java.util.Date; import java.util.UUID; import lombok.*; import lombok.experimental.SuperBuilder; @Entity @Table(name = \"uc_catalogs\") // Lombok @Getter @Setter @AllArgsConstructor @NoArgsConstructor @SuperBuilder @EqualsAndHashCode(callSuper = true) public class CatalogInfoDAO extends IdentifiableDAO { @Column(name = \"comment\") private String comment; @Column(name = \"created_at\") private Date createdAt; @Column(name = \"updated_at\") private Date updatedAt; public static CatalogInfoDAO from(CatalogInfo catalogInfo) { return CatalogInfoDAO.builder() .id(catalogInfo.getId() != null ? UUID.fromString(catalogInfo.getId()) : null) .name(catalogInfo.getName()) .comment(catalogInfo.getComment()) .createdAt( catalogInfo.getCreatedAt() != null ? Date.from(Instant.ofEpochMilli(catalogInfo.getCreatedAt())) : new Date()) .updatedAt( catalogInfo.getUpdatedAt() != null ? Date.from(Instant.ofEpochMilli(catalogInfo.getUpdatedAt())) : null) .build(); } public CatalogInfo toCatalogInfo() { return new CatalogInfo() .id(getId().toString()) .name(getName()) .comment(comment) .createdAt(createdAt.getTime()) .updatedAt(updatedAt != null ? updatedAt.getTime() : null); } }",
        "type": "Class",
        "relationship": "The CatalogInfoDAO class provides the data persistence layer and mapping functionality for the CatalogInfo objects that are returned by the documented createCatalog API endpoint, with methods to convert between the DAO and API model representations.",
        "traceability_granularity": "Class",
        "trace_chain": "CatalogsApi.md -> CatalogInfoDAO"
      }
    ]
  },
  {
    "document": {
      "text": "# **deleteVolume**\n> oas_any_type_not_mapped deleteVolume(name)\n\nDelete a Volume\n\n    Deletes a volume from the specified parent catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
      "location": "api/Apis/VolumesApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "VolumeRepository.deleteVolume",
        "location": "server/src/main/java/io/unitycatalog/server/persist/VolumeRepository.java",
        "content": "public void deleteVolume(String name) { try (Session session = SESSION_FACTORY.openSession()) { String[] namespace = name.split(\"\\.\"); if (namespace.length != 3) { throw new BaseException(ErrorCode.INVALID_ARGUMENT, \"Invalid volume name: \" + name); } String catalog = namespace[0], schema = namespace[1], volume = namespace[2]; Transaction tx = session.beginTransaction(); try { SchemaInfoDAO schemaInfo = SCHEMA_REPOSITORY.getSchemaDAO(session, catalog, schema); if (schemaInfo == null) { throw new BaseException( ErrorCode.NOT_FOUND, \"Schema not found: \" + catalog + \".\" + schema); } deleteVolume(session, schemaInfo.getId(), volume); tx.commit(); } catch (Exception e) { tx.rollback(); throw e; } } } public void deleteVolume(Session session, UUID schemaId, String volumeName) { VolumeInfoDAO volumeInfoDAO = getVolumeDAO(session, schemaId, volumeName); if (volumeInfoDAO == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Volume not found: \" + volumeName); } if (VolumeType.MANAGED.getValue().equals(volumeInfoDAO.getVolumeType())) { try { FileUtils.deleteDirectory(volumeInfoDAO.getStorageLocation()); } catch (Exception e) { LOGGER.error(\"Error deleting volume directory\", e); } } session.remove(volumeInfoDAO); LOGGER.info(\"Deleted volume: {}\", volumeInfoDAO.getName()); } }",
        "type": "Method",
        "relationship": "The code implements a documented Volume deletion operation by validating a three-part volume name, managing database transactions to remove the volume record, and cleaning up storage directories for managed volumes.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.deleteVolume -> VolumeRepository.deleteVolume"
      },
      {
        "title": "VolumeService.deleteVolume",
        "location": "server/src/main/java/io/unitycatalog/server/service/VolumeService.java",
        "content": "@Delete(\"/{full_name}\") public HttpResponse deleteVolume(@Param(\"full_name\") String fullName) { VOLUME_REPOSITORY.deleteVolume(fullName); return HttpResponse.of(HttpStatus.OK); } }",
        "type": "Method",
        "relationship": "The code directly implements the documented DELETE endpoint by accepting a fully qualified volume name parameter, delegating the deletion to VOLUME_REPOSITORY, and returning an HTTP 200 OK response as specified in the OpenAPI documentation.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.deleteVolume"
      },
      {
        "title": "VolumeCli.deleteVolume",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/VolumeCli.java",
        "content": "private static String deleteVolume(VolumesApi volumesApi, JSONObject json) throws ApiException { String volumeFullName = json.getString(CliParams.FULL_NAME.getServerParam()); volumesApi.deleteVolume(volumeFullName); return CliUtils.EMPTY; } }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented deleteVolume endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeCli.deleteVolume"
      }
    ]
  },
  {
    "document": {
      "text": "# VolumesApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createVolume**](VolumesApi.md#createVolume) | **POST** /volumes | Create a Volume |\n| [**deleteVolume**](VolumesApi.md#deleteVolume) | **DELETE** /volumes/{name} | Delete a Volume |\n| [**getVolume**](VolumesApi.md#getVolume) | **GET** /volumes/{name} | Get a Volume |\n| [**listVolumes**](VolumesApi.md#listVolumes) | **GET** /volumes | List Volumes |\n| [**updateVolume**](VolumesApi.md#updateVolume) | **PATCH** /volumes/{name} | Update a Volume |",
      "location": "api/Apis/VolumesApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "VolumeService.getVolume",
        "location": "server/src/main/java/io/unitycatalog/server/service/VolumeService.java",
        "content": "@Get(\"/{full_name}\") public HttpResponse getVolume( @Param(\"full_name\") String fullName, @Param(\"include_browse\") Optional<Boolean> includeBrowse) { return HttpResponse.ofJson(VOLUME_REPOSITORY.getVolume(fullName)); }",
        "type": "Method",
        "relationship": "The code implements the documented GET /volumes/{name} endpoint by providing a method that retrieves volume information based on a full name parameter and returns it as a JSON HTTP response.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.getVolume"
      },
      {
        "title": "VolumeCli.deleteVolume",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/VolumeCli.java",
        "content": "private static String deleteVolume(VolumesApi volumesApi, JSONObject json) throws ApiException { String volumeFullName = json.getString(CliParams.FULL_NAME.getServerParam()); volumesApi.deleteVolume(volumeFullName); return CliUtils.EMPTY; } }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented deleteVolume endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeCli.deleteVolume"
      },
      {
        "title": "VolumeService.createVolume",
        "location": "server/src/main/java/io/unitycatalog/server/service/VolumeService.java",
        "content": "@Post(\"\") public HttpResponse createVolume(CreateVolumeRequestContent createVolumeRequest) { // Throw error if catalog/schema does not exist return HttpResponse.ofJson(VOLUME_REPOSITORY.createVolume(createVolumeRequest)); }",
        "type": "Method",
        "relationship": "The code implements the POST /volumes endpoint documented in the API table by defining a method that accepts a CreateVolumeRequestContent object and delegates to VOLUME_REPOSITORY to create a new volume, returning the result as a JSON HTTP response.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.createVolume"
      },
      {
        "title": "VolumeRepository.deleteVolume",
        "location": "server/src/main/java/io/unitycatalog/server/persist/VolumeRepository.java",
        "content": "public void deleteVolume(String name) { try (Session session = SESSION_FACTORY.openSession()) { String[] namespace = name.split(\"\\.\"); if (namespace.length != 3) { throw new BaseException(ErrorCode.INVALID_ARGUMENT, \"Invalid volume name: \" + name); } String catalog = namespace[0], schema = namespace[1], volume = namespace[2]; Transaction tx = session.beginTransaction(); try { SchemaInfoDAO schemaInfo = SCHEMA_REPOSITORY.getSchemaDAO(session, catalog, schema); if (schemaInfo == null) { throw new BaseException( ErrorCode.NOT_FOUND, \"Schema not found: \" + catalog + \".\" + schema); } deleteVolume(session, schemaInfo.getId(), volume); tx.commit(); } catch (Exception e) { tx.rollback(); throw e; } } } public void deleteVolume(Session session, UUID schemaId, String volumeName) { VolumeInfoDAO volumeInfoDAO = getVolumeDAO(session, schemaId, volumeName); if (volumeInfoDAO == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Volume not found: \" + volumeName); } if (VolumeType.MANAGED.getValue().equals(volumeInfoDAO.getVolumeType())) { try { FileUtils.deleteDirectory(volumeInfoDAO.getStorageLocation()); } catch (Exception e) { LOGGER.error(\"Error deleting volume directory\", e); } } session.remove(volumeInfoDAO); LOGGER.info(\"Deleted volume: {}\", volumeInfoDAO.getName()); } }",
        "type": "Method",
        "relationship": "The deleteVolume method in VolumeRepository implements the DELETE /volumes/{name} API endpoint by parsing the three-part volume name (catalog.schema.volume), validating the schema exists, and removing both the volume's metadata from the database and its storage directory if it's a managed volume.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.deleteVolume -> VolumeRepository.deleteVolume"
      },
      {
        "title": "VolumeService.updateVolume",
        "location": "server/src/main/java/io/unitycatalog/server/service/VolumeService.java",
        "content": "@Patch(\"/{full_name}\") public HttpResponse updateVolume( @Param(\"full_name\") String fullName, UpdateVolumeRequestContent updateVolumeRequest) { return HttpResponse.ofJson(VOLUME_REPOSITORY.updateVolume(fullName, updateVolumeRequest)); }",
        "type": "Method",
        "relationship": "The code implements the documented PATCH /volumes/{name} API endpoint by defining an updateVolume method that accepts a volume name and update request content, returning the updated volume data as a JSON HTTP response.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.updateVolume"
      },
      {
        "title": "VolumeCli.getVolume",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/VolumeCli.java",
        "content": "private static String getVolume(VolumesApi volumesApi, JSONObject json) throws JsonProcessingException, ApiException { String volumeFullName = json.getString(CliParams.FULL_NAME.getServerParam()); return objectWriter.writeValueAsString(volumesApi.getVolume(volumeFullName)); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented getVolume endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeCli.getVolume"
      },
      {
        "title": "VolumeCli.updateVolume",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/VolumeCli.java",
        "content": "private static String updateVolume(VolumesApi apiClient, JSONObject json) throws JsonProcessingException, ApiException { String volumeFullName = json.getString(CliParams.FULL_NAME.getServerParam()); json.remove(CliParams.FULL_NAME.getServerParam()); if (json.length() == 0) { List<CliParams> optionalParams = CliUtils.cliOptions.get(CliUtils.VOLUME).get(CliUtils.UPDATE).getOptionalParams(); String errorMessage = \"No parameters to update, please provide one of:\"; for (CliParams param : optionalParams) { errorMessage += \"\n --\" + param.val(); } throw new CliException(errorMessage); } UpdateVolumeRequestContent updateVolumeRequest = objectMapper.readValue(json.toString(), UpdateVolumeRequestContent.class); return objectWriter.writeValueAsString( apiClient.updateVolume(volumeFullName, updateVolumeRequest)); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented updateVolume endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeCli.updateVolume"
      },
      {
        "title": "VolumeRepository.updateVolume",
        "location": "server/src/main/java/io/unitycatalog/server/persist/VolumeRepository.java",
        "content": "public VolumeInfo updateVolume(String name, UpdateVolumeRequestContent updateVolumeRequest) { if (updateVolumeRequest.getNewName() != null) { ValidationUtils.validateSqlObjectName(updateVolumeRequest.getNewName()); } String[] namespace = name.split(\"\\.\"); String catalog = namespace[0], schema = namespace[1], volume = namespace[2]; try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { VolumeInfoDAO volumeInfo = getVolumeDAO(session, catalog, schema, volume); if (volumeInfo == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Volume not found: \" + name); } if (updateVolumeRequest.getNewName() != null) { VolumeInfoDAO existingVolume = getVolumeDAO(session, catalog, schema, updateVolumeRequest.getNewName()); if (existingVolume != null) { throw new BaseException( ErrorCode.ALREADY_EXISTS, \"Volume already exists: \" + updateVolumeRequest.getNewName()); } } if (updateVolumeRequest.getNewName() == null && updateVolumeRequest.getComment() == null) { tx.rollback(); return convertFromDAO(volumeInfo, catalog, schema); } if (updateVolumeRequest.getNewName() != null) { volumeInfo.setName(updateVolumeRequest.getNewName()); } if (updateVolumeRequest.getComment() != null) { volumeInfo.setComment(updateVolumeRequest.getComment()); } volumeInfo.setUpdatedAt(new Date()); session.merge(volumeInfo); tx.commit(); LOGGER.info(\"Updated volume: {}\", volumeInfo.getName()); return convertFromDAO(volumeInfo, catalog, schema); } catch (Exception e) { tx.rollback(); throw e; } } }",
        "type": "Method",
        "relationship": "The VolumeRepository.updateVolume method implements the PATCH /volumes/{name} API endpoint by validating input parameters, managing database transactions, and performing volume updates including name and comment changes while handling potential conflicts and exceptions.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.updateVolume -> VolumeRepository.updateVolume"
      },
      {
        "title": "VolumeService.listVolumes",
        "location": "server/src/main/java/io/unitycatalog/server/service/VolumeService.java",
        "content": "@Get(\"\") public HttpResponse listVolumes( @Param(\"catalog_name\") String catalogName, @Param(\"schema_name\") String schemaName, @Param(\"max_results\") Optional<Integer> maxResults, @Param(\"page_token\") Optional<String> pageToken, @Param(\"include_browse\") Optional<Boolean> includeBrowse) { return HttpResponse.ofJson( VOLUME_REPOSITORY.listVolumes( catalogName, schemaName, maxResults, pageToken, includeBrowse)); }",
        "type": "Method",
        "relationship": "The code implements the 'listVolumes' API endpoint documented in the table by defining a GET handler that accepts query parameters for catalog_name, schema_name, pagination controls, and browse options, returning the results as JSON.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.listVolumes"
      },
      {
        "title": "VolumeRepository.listVolumes",
        "location": "server/src/main/java/io/unitycatalog/server/persist/VolumeRepository.java",
        "content": "public ListVolumesResponseContent listVolumes( String catalogName, String schemaName, Optional<Integer> maxResults, Optional<String> pageToken, Optional<Boolean> includeBrowse) { try (Session session = SESSION_FACTORY.openSession()) { session.setDefaultReadOnly(true); Transaction tx = session.beginTransaction(); try { SchemaInfoDAO schemaInfo = SCHEMA_REPOSITORY.getSchemaDAO(session, catalogName, schemaName); if (schemaInfo == null) { throw new BaseException( ErrorCode.NOT_FOUND, \"Schema not found: \" + catalogName + \".\" + schemaName); } ListVolumesResponseContent responseContent = listVolumes( session, schemaInfo.getId(), catalogName, schemaName, maxResults, pageToken); tx.commit(); return responseContent; } catch (Exception e) { tx.rollback(); throw e; } } } public ListVolumesResponseContent listVolumes( Session session, UUID schemaId, String catalogName, String schemaName, Optional<Integer> maxResults, Optional<String> pageToken) { ListVolumesResponseContent responseContent = new ListVolumesResponseContent(); String queryString = \"from VolumeInfoDAO v where v.schemaId = :schemaId\"; Query<VolumeInfoDAO> query = session.createQuery(queryString, VolumeInfoDAO.class); query.setParameter(\"schemaId\", schemaId); maxResults.ifPresent(query::setMaxResults); if (pageToken.isPresent()) { // Perform pagination logic here if needed // Example: query.setFirstResult(startIndex); } responseContent.setVolumes( query.list().stream() .map(x -> convertFromDAO(x, catalogName, schemaName)) .collect(Collectors.toList())); return responseContent; }",
        "type": "Method",
        "relationship": "The listVolumes method implements the GET /volumes API endpoint by querying the database for volumes within a specified schema, supporting pagination through maxResults and pageToken parameters, and returning the results as a ListVolumesResponseContent object.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.listVolumes -> VolumeRepository.listVolumes"
      },
      {
        "title": "VolumeRepository.getVolume",
        "location": "server/src/main/java/io/unitycatalog/server/persist/VolumeRepository.java",
        "content": "public VolumeInfo getVolume(String fullName) { try (Session session = SESSION_FACTORY.openSession()) { String[] namespace = fullName.split(\"\\.\"); if (namespace.length != 3) { throw new BaseException(ErrorCode.INVALID_ARGUMENT, \"Invalid volume name: \" + fullName); } String catalogName = namespace[0]; String schemaName = namespace[1]; String volumeName = namespace[2]; return convertFromDAO( getVolumeDAO(session, catalogName, schemaName, volumeName), catalogName, schemaName); } catch (Exception e) { LOGGER.error(\"Error getting volume\", e); return null; } }",
        "type": "Method",
        "relationship": "The VolumeRepository.getVolume method implements the GET /volumes/{name} endpoint by parsing a three-part volume name (catalog.schema.volume), retrieving the volume data from a database session, and returning a VolumeInfo object that represents the requested volume.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.getVolume -> VolumeRepository.getVolume"
      },
      {
        "title": "VolumeService.deleteVolume",
        "location": "server/src/main/java/io/unitycatalog/server/service/VolumeService.java",
        "content": "@Delete(\"/{full_name}\") public HttpResponse deleteVolume(@Param(\"full_name\") String fullName) { VOLUME_REPOSITORY.deleteVolume(fullName); return HttpResponse.of(HttpStatus.OK); } }",
        "type": "Method",
        "relationship": "The code implements the documented DELETE /volumes/{name} endpoint by accepting a volume's full name as a path parameter, delegating the deletion to VOLUME_REPOSITORY, and returning an HTTP 200 OK response.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.deleteVolume"
      },
      {
        "title": "VolumeCli.createVolume",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/VolumeCli.java",
        "content": "private static String createVolume(VolumesApi volumesApi, JSONObject json) throws JsonProcessingException, ApiException { CliUtils.resolveFullNameToThreeLevelNamespace(json); if (!json.has(CliParams.VOLUME_TYPE.getServerParam())) { json.put(CliParams.VOLUME_TYPE.getServerParam(), VolumeType.EXTERNAL.toString()); } CreateVolumeRequestContent createVolumeRequest; createVolumeRequest = objectMapper.readValue(json.toString(), CreateVolumeRequestContent.class); return objectWriter.writeValueAsString(volumesApi.createVolume(createVolumeRequest)); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented createVolume endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeCli.createVolume"
      },
      {
        "title": "VolumeRepository.createVolume",
        "location": "server/src/main/java/io/unitycatalog/server/persist/VolumeRepository.java",
        "content": "public VolumeInfo createVolume(CreateVolumeRequestContent createVolumeRequest) { ValidationUtils.validateSqlObjectName(createVolumeRequest.getName()); String volumeFullName = createVolumeRequest.getCatalogName() + \".\" + createVolumeRequest.getSchemaName() + \".\" + createVolumeRequest.getName(); VolumeInfo volumeInfo = new VolumeInfo(); volumeInfo.setVolumeId(UUID.randomUUID().toString()); volumeInfo.setCatalogName(createVolumeRequest.getCatalogName()); volumeInfo.setSchemaName(createVolumeRequest.getSchemaName()); volumeInfo.setName(createVolumeRequest.getName()); volumeInfo.setComment(createVolumeRequest.getComment()); volumeInfo.setFullName(volumeFullName); volumeInfo.setCreatedAt(System.currentTimeMillis()); volumeInfo.setVolumeType(createVolumeRequest.getVolumeType()); if (VolumeType.MANAGED.equals(createVolumeRequest.getVolumeType())) { throw new BaseException( ErrorCode.INVALID_ARGUMENT, \"Managed volume creation is not supported\"); } if (createVolumeRequest.getStorageLocation() == null) { throw new BaseException( ErrorCode.INVALID_ARGUMENT, \"Storage location is required for external volume\"); } volumeInfo.setStorageLocation(createVolumeRequest.getStorageLocation()); VolumeInfoDAO volumeInfoDAO = VolumeInfoDAO.from(volumeInfo); try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { SchemaInfoDAO schemaInfoDAO = SCHEMA_REPOSITORY.getSchemaDAO( session, createVolumeRequest.getCatalogName(), createVolumeRequest.getSchemaName()); if (schemaInfoDAO == null) { throw new BaseException( ErrorCode.NOT_FOUND, \"Schema not found: \" + createVolumeRequest.getCatalogName() + \".\" + createVolumeRequest.getSchemaName()); } if (getVolumeDAO( session, createVolumeRequest.getCatalogName(), createVolumeRequest.getSchemaName(), createVolumeRequest.getName()) != null) { throw new BaseException( ErrorCode.ALREADY_EXISTS, \"Volume already exists: \" + volumeFullName); } volumeInfoDAO.setSchemaId(schemaInfoDAO.getId()); session.persist(volumeInfoDAO); tx.commit(); LOGGER.info(\"Added volume: {}\", volumeInfo.getName()); return convertFromDAO( volumeInfoDAO, createVolumeRequest.getCatalogName(), createVolumeRequest.getSchemaName()); } catch (Exception e) { tx.rollback(); throw e; } } }",
        "type": "Method",
        "relationship": "The VolumeRepository.createVolume method implements the POST /volumes API endpoint by validating the request, creating a new volume record with generated UUID and metadata, and persisting it to the database while enforcing schema existence and volume uniqueness constraints.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.createVolume -> VolumeRepository.createVolume"
      },
      {
        "title": "VolumeCli.listVolumes",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/VolumeCli.java",
        "content": "private static String listVolumes(VolumesApi volumesApi, JSONObject json) throws JsonProcessingException, ApiException { String catalogName = json.getString(CliParams.CATALOG_NAME.getServerParam()); String schemaName = json.getString(CliParams.SCHEMA_NAME.getServerParam()); int maxResults = 100; if (json.has(CliParams.MAX_RESULTS.getServerParam())) { maxResults = json.getInt(CliParams.MAX_RESULTS.getServerParam()); } return objectWriter.writeValueAsString( volumesApi.listVolumes(catalogName, schemaName, maxResults, null).getVolumes()); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented listVolumes endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeCli.listVolumes"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"updateSchema\"></a>\n# **updateSchema**\n> SchemaInfo updateSchema(full\\_name, UpdateSchema)\n\nUpdate a schema\n\n    Updates the specified schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n| **UpdateSchema** | [**UpdateSchema**](../Models/UpdateSchema.md)|  | [optional] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
      "location": "api/Apis/SchemasApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "SchemaService.updateSchema",
        "location": "server/src/main/java/io/unitycatalog/server/service/SchemaService.java",
        "content": "@Patch(\"/{full_name}\") public HttpResponse updateSchema(@Param(\"full_name\") String fullName, UpdateSchema updateSchema) { return HttpResponse.ofJson(SCHEMA_REPOSITORY.updateSchema(fullName, updateSchema)); }",
        "type": "Method",
        "relationship": "The code implements a PATCH endpoint that directly matches the documented API endpoint, accepting a fullName path parameter and UpdateSchema body parameter, and returning a JSON response through HttpResponse.ofJson from the schema repository.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.updateSchema"
      },
      {
        "title": "SchemaInfoDAO",
        "location": "server/src/main/java/io/unitycatalog/server/persist/dao/SchemaInfoDAO.java",
        "content": "package io.unitycatalog.server.persist.dao; import io.unitycatalog.server.model.SchemaInfo; import jakarta.persistence.*; import java.time.Instant; import java.util.Date; import java.util.UUID; import lombok.*; import lombok.experimental.SuperBuilder; @Entity @Table(name = \"uc_schemas\") // Lombok @Getter @Setter @SuperBuilder @AllArgsConstructor @NoArgsConstructor @EqualsAndHashCode(callSuper = true) public class SchemaInfoDAO extends IdentifiableDAO { @Column(name = \"catalog_id\") private UUID catalogId; @Column(name = \"comment\") private String comment; @Column(name = \"created_at\") private Date createdAt; @Column(name = \"updated_at\") private Date updatedAt; public static SchemaInfoDAO from(SchemaInfo schemaInfo) { return SchemaInfoDAO.builder() .id(schemaInfo.getSchemaId() != null ? UUID.fromString(schemaInfo.getSchemaId()) : null) .name(schemaInfo.getName()) .comment(schemaInfo.getComment()) .createdAt( schemaInfo.getCreatedAt() != null ? Date.from(Instant.ofEpochMilli(schemaInfo.getCreatedAt())) : new Date()) .updatedAt( schemaInfo.getUpdatedAt() != null ? Date.from(Instant.ofEpochMilli(schemaInfo.getUpdatedAt())) : null) .build(); } public SchemaInfo toSchemaInfo() { return new SchemaInfo() .schemaId(getId().toString()) .name(getName()) .comment(getComment()) .createdAt(getCreatedAt().getTime()) .updatedAt(getUpdatedAt() != null ? getUpdatedAt().getTime() : null); } }",
        "type": "Class",
        "relationship": "The SchemaInfoDAO class provides the data persistence layer and object mapping functionality needed to support the updateSchema API endpoint by managing schema metadata in the database and converting between SchemaInfo API objects and database entities.",
        "traceability_granularity": "Class",
        "trace_chain": "SchemasApi.md -> SchemaInfoDAO"
      },
      {
        "title": "SchemaRepository.updateSchema",
        "location": "server/src/main/java/io/unitycatalog/server/persist/SchemaRepository.java",
        "content": "public SchemaInfo updateSchema(String fullName, UpdateSchema updateSchema) { if (updateSchema.getNewName() != null) { ValidationUtils.validateSqlObjectName(updateSchema.getNewName()); } try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { SchemaInfoDAO schemaInfoDAO = getSchemaDAO(session, fullName); if (schemaInfoDAO == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Schema not found: \" + fullName); } if (updateSchema.getNewName() != null) { if (getSchemaDAO(session, fullName.split(\"\\.\")[0], updateSchema.getNewName()) != null) { throw new BaseException( ErrorCode.ALREADY_EXISTS, \"Schema already exists: \" + updateSchema.getNewName()); } } if (updateSchema.getComment() == null && updateSchema.getNewName() == null && (updateSchema.getProperties() == null || updateSchema.getProperties().isEmpty())) { tx.rollback(); return convertFromDAO(session, schemaInfoDAO, fullName); } // Update the schema with new values if (updateSchema.getComment() != null) { schemaInfoDAO.setComment(updateSchema.getComment()); } if (updateSchema.getNewName() != null) { schemaInfoDAO.setName(updateSchema.getNewName()); } if (updateSchema.getProperties() != null && !updateSchema.getProperties().isEmpty()) { PropertyRepository.findProperties(session, schemaInfoDAO.getId(), Constants.SCHEMA) .forEach(session::remove); session.flush(); PropertyDAO.from(updateSchema.getProperties(), schemaInfoDAO.getId(), Constants.SCHEMA) .forEach(session::persist); } schemaInfoDAO.setUpdatedAt(new Date()); session.merge(schemaInfoDAO); tx.commit(); return convertFromDAO(session, schemaInfoDAO, fullName); } catch (Exception e) { tx.rollback(); throw e; } } }",
        "type": "Method",
        "relationship": "The code implements the documented schema update endpoint by validating the new schema name, managing database transactions to update the schema's name, comment, and properties, and handling errors according to the API specification's parameters and return type.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.updateSchema -> SchemaRepository.updateSchema"
      },
      {
        "title": "SchemaCli.updateSchema",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/SchemaCli.java",
        "content": "private static String updateSchema(SchemasApi schemasApi, JSONObject json) throws JsonProcessingException, ApiException { String schemaFullName = json.getString(CliParams.FULL_NAME.getServerParam()); json.remove(CliParams.FULL_NAME.getServerParam()); if (json.length() == 0) { List<CliParams> optionalParams = CliUtils.cliOptions.get(CliUtils.SCHEMA).get(CliUtils.UPDATE).getOptionalParams(); String errorMessage = \"No parameters to update, please provide one of:\"; for (CliParams param : optionalParams) { errorMessage += \"\n --\" + param.val(); } throw new CliException(errorMessage); } UpdateSchema updateSchema = new UpdateSchema() .newName(json.optString(CliParams.NEW_NAME.getServerParam(), null)) .comment(json.optString(CliParams.COMMENT.getServerParam(), null)) .properties(CliUtils.extractProperties(objectMapper, json)); SchemaInfo schemaInfo = schemasApi.updateSchema(schemaFullName, updateSchema); return objectWriter.writeValueAsString(schemaInfo); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented updateSchema endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaCli.updateSchema"
      }
    ]
  },
  {
    "document": {
      "text": "# CatalogsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**createCatalog**](CatalogsApi.md#createCatalog) | **POST** /catalogs | Create a catalog |\n| [**deleteCatalog**](CatalogsApi.md#deleteCatalog) | **DELETE** /catalogs/{name} | Delete a catalog |\n| [**getCatalog**](CatalogsApi.md#getCatalog) | **GET** /catalogs/{name} | Get a catalog |\n| [**listCatalogs**](CatalogsApi.md#listCatalogs) | **GET** /catalogs | List catalogs |\n| [**updateCatalog**](CatalogsApi.md#updateCatalog) | **PATCH** /catalogs/{name} | Update a catalog |",
      "location": "api/Apis/CatalogsApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "CatalogCli.updateCatalog",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/CatalogCli.java",
        "content": "private static String updateCatalog(CatalogsApi catalogsApi, JSONObject json) throws JsonProcessingException, ApiException { String catalogName = json.getString(NAME_PARAM); json.remove(NAME_PARAM); if (json.length() == 0) { List<CliParams> optionalParams = CliUtils.cliOptions.get(CliUtils.CATALOG).get(CliUtils.UPDATE).getOptionalParams(); String errorMessage = \"No parameters to update, please provide one of:\"; for (CliParams param : optionalParams) { errorMessage += \"\n --\" + param.val(); } throw new CliException(errorMessage); } UpdateCatalog updateCatalog = new UpdateCatalog() .newName(json.optString(CliParams.NEW_NAME.getServerParam(), null)) .comment(json.optString(CliParams.COMMENT.getServerParam(), null)) .properties(CliUtils.extractProperties(objectMapper, json)); CatalogInfo catalogInfo = catalogsApi.updateCatalog(catalogName, updateCatalog); return objectWriter.writeValueAsString(catalogInfo); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented updateCatalog endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogCli.updateCatalog"
      },
      {
        "title": "CatalogRepository.addCatalog",
        "location": "server/src/main/java/io/unitycatalog/server/persist/CatalogRepository.java",
        "content": "public CatalogInfo addCatalog(CreateCatalog createCatalog) { ValidationUtils.validateSqlObjectName(createCatalog.getName()); CatalogInfo catalogInfo = new CatalogInfo() .id(java.util.UUID.randomUUID().toString()) .comment(createCatalog.getComment()) .name(createCatalog.getName()) .createdAt(System.currentTimeMillis()) .properties(createCatalog.getProperties()); try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { if (getCatalogDAO(session, createCatalog.getName()) != null) { throw new BaseException( ErrorCode.ALREADY_EXISTS, \"Catalog already exists: \" + createCatalog.getName()); } CatalogInfoDAO catalogInfoDAO = CatalogInfoDAO.from(catalogInfo); PropertyDAO.from(catalogInfo.getProperties(), catalogInfoDAO.getId(), Constants.CATALOG) .forEach(session::persist); session.persist(catalogInfoDAO); tx.commit(); LOGGER.info(\"Added catalog: {}\", catalogInfo.getName()); return catalogInfo; } catch (Exception e) { tx.rollback(); throw e; } } }",
        "type": "Method",
        "relationship": "The CatalogRepository.addCatalog method implements the backend persistence logic for the POST /catalogs API endpoint, handling the creation of a new catalog with validation, transaction management, and database persistence of the catalog metadata and its properties.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.createCatalog -> CatalogRepository.addCatalog"
      },
      {
        "title": "CatalogService.getCatalog",
        "location": "server/src/main/java/io/unitycatalog/server/service/CatalogService.java",
        "content": "@Get(\"/{name}\") public HttpResponse getCatalog(@Param(\"name\") String name) { return HttpResponse.ofJson(CATALOG_REPOSITORY.getCatalog(name)); }",
        "type": "Method",
        "relationship": "The code implements the documented GET /catalogs/{name} endpoint by creating a method annotated with @Get that takes a name parameter and returns a catalog object as JSON via the repository layer.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.getCatalog"
      },
      {
        "title": "CatalogRepository.getCatalog",
        "location": "server/src/main/java/io/unitycatalog/server/persist/CatalogRepository.java",
        "content": "public CatalogInfoDAO getCatalogDAO(Session session, String name) { Query<CatalogInfoDAO> query = session.createQuery(\"FROM CatalogInfoDAO WHERE name = :value\", CatalogInfoDAO.class); query.setParameter(\"value\", name); query.setMaxResults(1); return query.uniqueResult(); }",
        "type": "Method",
        "relationship": "The getCatalogDAO method implements the database query layer for the GET /catalogs/{name} API endpoint by retrieving a single CatalogInfoDAO record matching the specified catalog name from the database session.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.getCatalog -> CatalogRepository.getCatalog"
      },
      {
        "title": "CatalogRepository.listCatalogs",
        "location": "server/src/main/java/io/unitycatalog/server/persist/CatalogRepository.java",
        "content": "public ListCatalogsResponse listCatalogs( Optional<Integer> maxResults, Optional<String> pageToken) { try (Session session = SESSION_FACTORY.openSession()) { session.setDefaultReadOnly(true); Transaction tx = session.beginTransaction(); try { ListCatalogsResponse response = listCatalogs(session, maxResults, pageToken); tx.commit(); return response; } catch (Exception e) { tx.rollback(); throw e; } } } public ListCatalogsResponse listCatalogs( Session session, Optional<Integer> maxResults, Optional<String> pageToken) { List<CatalogInfoDAO> catalogInfoDAOList = LISTING_HELPER.listEntity(session, maxResults, pageToken, null); String nextPageToken = LISTING_HELPER.getNextPageToken(catalogInfoDAOList, maxResults); List<CatalogInfo> result = new ArrayList<>(); for (CatalogInfoDAO catalogInfoDAO : catalogInfoDAOList) { CatalogInfo catalogInfo = catalogInfoDAO.toCatalogInfo(); RepositoryUtils.attachProperties( catalogInfo, catalogInfo.getId(), Constants.CATALOG, session); result.add(catalogInfo); } return new ListCatalogsResponse().catalogs(result).nextPageToken(nextPageToken); }",
        "type": "Method",
        "relationship": "The CatalogRepository.listCatalogs method implements the GET /catalogs endpoint by providing paginated retrieval of catalog information from the database, with support for maxResults and pageToken parameters.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.listCatalogs -> CatalogRepository.listCatalogs"
      },
      {
        "title": "CatalogService.deleteCatalog",
        "location": "server/src/main/java/io/unitycatalog/server/service/CatalogService.java",
        "content": "@Delete(\"/{name}\") public HttpResponse deleteCatalog( @Param(\"name\") String name, @Param(\"force\") Optional<Boolean> force) { CATALOG_REPOSITORY.deleteCatalog(name, force.orElse(false)); return HttpResponse.of(HttpStatus.OK); } }",
        "type": "Method",
        "relationship": "Rep handler method that accepts a catalog name parameter and an optional force parameter, and returns a 200 OK response after delegating the deletion to a repository.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.deleteCatalog"
      },
      {
        "title": "CatalogService.createCatalog",
        "location": "server/src/main/java/io/unitycatalog/server/service/CatalogService.java",
        "content": "@Post(\"\") public HttpResponse createCatalog(CreateCatalog createCatalog) { return HttpResponse.ofJson(CATALOG_REPOSITORY.addCatalog(createCatalog)); }",
        "type": "Method",
        "relationship": "The code implements the documented POST /catalogs endpoint through a @Post-annotated method that accepts a CreateCatalog object and returns a JSON response from the catalog repository's add operation.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.createCatalog"
      },
      {
        "title": "CatalogService.updateCatalog",
        "location": "server/src/main/java/io/unitycatalog/server/service/CatalogService.java",
        "content": "@Patch(\"/{name}\") public HttpResponse updateCatalog(@Param(\"name\") String name, UpdateCatalog updateCatalog) { return HttpResponse.ofJson(CATALOG_REPOSITORY.updateCatalog(name, updateCatalog)); }",
        "type": "Method",
        "relationship": "The code implements the documented PATCH /catalogs/{name} endpoint by providing a method that accepts a catalog name parameter and update payload, returning the updated catalog as JSON via HttpResponse.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.updateCatalog"
      },
      {
        "title": "CatalogCli.listCatalogs",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/CatalogCli.java",
        "content": "private static String listCatalogs(CatalogsApi catalogsApi, JSONObject json) throws JsonProcessingException, ApiException { int maxResults = 100; if (json.has(CliParams.MAX_RESULTS.getServerParam())) { maxResults = json.getInt(CliParams.MAX_RESULTS.getServerParam()); } return objectWriter.writeValueAsString( catalogsApi.listCatalogs(null, maxResults).getCatalogs()); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented listCatalogs endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogCli.listCatalogs"
      },
      {
        "title": "CatalogCli.deleteCatalog",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/CatalogCli.java",
        "content": "private static String deleteCatalog(CatalogsApi catalogsApi, JSONObject json) throws ApiException { String catalogName = json.getString(NAME_PARAM); catalogsApi.deleteCatalog( catalogName, json.has(CliParams.FORCE.getServerParam()) && Boolean.parseBoolean(json.getString(CliParams.FORCE.getServerParam()))); return CliUtils.EMPTY_JSON; } }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented deleteCatalog endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogCli.deleteCatalog"
      },
      {
        "title": "CatalogRepository.updateCatalog",
        "location": "server/src/main/java/io/unitycatalog/server/persist/CatalogRepository.java",
        "content": "public CatalogInfo updateCatalog(String name, UpdateCatalog updateCatalog) { if (updateCatalog.getNewName() != null) { ValidationUtils.validateSqlObjectName(updateCatalog.getNewName()); } // can make this just update once we have an identifier that is not the name try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { CatalogInfoDAO catalogInfoDAO = getCatalogDAO(session, name); if (catalogInfoDAO == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Catalog not found: \" + name); } if (updateCatalog.getNewName() == null && updateCatalog.getComment() == null && (updateCatalog.getProperties() == null || updateCatalog.getProperties().isEmpty())) { tx.rollback(); CatalogInfo catalogInfo = catalogInfoDAO.toCatalogInfo(); return RepositoryUtils.attachProperties( catalogInfo, catalogInfo.getId(), Constants.CATALOG, session); } if (updateCatalog.getNewName() != null && getCatalogDAO(session, updateCatalog.getNewName()) != null) { throw new BaseException( ErrorCode.ALREADY_EXISTS, \"Catalog already exists: \" + updateCatalog.getNewName()); } if (updateCatalog.getNewName() != null) { catalogInfoDAO.setName(updateCatalog.getNewName()); } if (updateCatalog.getComment() != null) { catalogInfoDAO.setComment(updateCatalog.getComment()); } if (updateCatalog.getProperties() != null && !updateCatalog.getProperties().isEmpty()) { PropertyRepository.findProperties(session, catalogInfoDAO.getId(), Constants.CATALOG) .forEach(session::remove); session.flush(); PropertyDAO.from(updateCatalog.getProperties(), catalogInfoDAO.getId(), Constants.CATALOG) .forEach(session::persist); } catalogInfoDAO.setUpdatedAt(new Date()); session.merge(catalogInfoDAO); tx.commit(); CatalogInfo catalogInfo = catalogInfoDAO.toCatalogInfo(); return RepositoryUtils.attachProperties( catalogInfo, catalogInfo.getId(), Constants.CATALOG, session); } catch (Exception e) { tx.rollback(); throw e; } } }",
        "type": "Method",
        "relationship": "The CatalogRepository.updateCatalog method implements the PATCH /catalogs/{name} endpoint by handling catalog updates including name changes, comments, and properties while managing database transactions and validation.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.updateCatalog -> CatalogRepository.updateCatalog"
      },
      {
        "title": "CatalogRepository.deleteCatalog",
        "location": "server/src/main/java/io/unitycatalog/server/persist/CatalogRepository.java",
        "content": "public void deleteCatalog(String name, boolean force) { try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { CatalogInfoDAO catalogInfo = getCatalogDAO(session, name); if (catalogInfo != null) { // Check if there are any schemas in the catalog List<SchemaInfo> schemas = SCHEMA_REPOSITORY .listSchemas( session, catalogInfo.getId(), catalogInfo.getName(), Optional.of(1), Optional.empty()) .getSchemas(); if (schemas != null && !schemas.isEmpty()) { if (!force) { throw new BaseException( ErrorCode.FAILED_PRECONDITION, \"Cannot delete catalog with schemas: \" + name); } String nextToken = null; do { ListSchemasResponse listSchemasResponse = SCHEMA_REPOSITORY.listSchemas( session, catalogInfo.getId(), catalogInfo.getName(), Optional.empty(), Optional.ofNullable(nextToken)); for (SchemaInfo schemaInfo : listSchemasResponse.getSchemas()) { SCHEMA_REPOSITORY.deleteSchema( session, catalogInfo.getId(), catalogInfo.getName(), schemaInfo.getName(), true); } nextToken = listSchemasResponse.getNextPageToken(); } while (nextToken != null); } PropertyRepository.findProperties(session, catalogInfo.getId(), Constants.CATALOG) .forEach(session::remove); session.remove(catalogInfo); tx.commit(); LOGGER.info(\"Deleted catalog: {}\", catalogInfo.getName()); } else { throw new BaseException(ErrorCode.NOT_FOUND, \"Catalog not found: \" + name); } } catch (Exception e) { tx.rollback(); throw e; } } } }",
        "type": "Method",
        "relationship": "The deleteCatalog method implements the DELETE /catalogs/{name} API endpoint by handling catalog deletion with schema cleanup, supporting forced deletion via a boolean parameter, and providing appropriate error responses for non-existent catalogs or catalogs with schemas.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.deleteCatalog -> CatalogRepository.deleteCatalog"
      },
      {
        "title": "CatalogCli.getCatalog",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/CatalogCli.java",
        "content": "private static String getCatalog(CatalogsApi catalogsApi, JSONObject json) throws JsonProcessingException, ApiException { String catalogName = json.getString(NAME_PARAM); return objectWriter.writeValueAsString(catalogsApi.getCatalog(catalogName)); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented getCatalog endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogCli.getCatalog"
      },
      {
        "title": "CatalogService.listCatalogs",
        "location": "server/src/main/java/io/unitycatalog/server/service/CatalogService.java",
        "content": "@Get(\"\") public HttpResponse listCatalogs( @Param(\"max_results\") Optional<Integer> maxResults, @Param(\"page_token\") Optional<String> pageToken) { return HttpResponse.ofJson(CATALOG_REPOSITORY.listCatalogs(maxResults, pageToken)); }",
        "type": "Method",
        "relationship": "The listCatalogs code implements the documented GET /catalogs endpoint by accepting optional pagination parameters (max_results and page_token) and returning a JSON response of catalogs from the repository.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.listCatalogs"
      },
      {
        "title": "CatalogCli.createCatalog",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/CatalogCli.java",
        "content": "private static String createCatalog(CatalogsApi catalogsApi, JSONObject json) throws JsonProcessingException, ApiException { CreateCatalog createCatalog = new CreateCatalog() .name(json.getString(CliParams.NAME.getServerParam())) .comment(json.optString(CliParams.COMMENT.getServerParam(), null)) .properties(CliUtils.extractProperties(objectMapper, json)); CatalogInfo catalogInfo = catalogsApi.createCatalog(createCatalog); return objectWriter.writeValueAsString(catalogInfo); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented createCatalog endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogCli.createCatalog"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"updateCatalog\"></a>\n# **updateCatalog**\n> CatalogInfo updateCatalog(name, UpdateCatalog)\n\nUpdate a catalog\n\n    Updates the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **UpdateCatalog** | [**UpdateCatalog**](../Models/UpdateCatalog.md)|  | [optional] |\n\n### Return type\n\n[**CatalogInfo**](../Models/CatalogInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
      "location": "api/Apis/CatalogsApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "CatalogService.updateCatalog",
        "location": "server/src/main/java/io/unitycatalog/server/service/CatalogService.java",
        "content": "@Patch(\"/{name}\") public HttpResponse updateCatalog(@Param(\"name\") String name, UpdateCatalog updateCatalog) { return HttpResponse.ofJson(CATALOG_REPOSITORY.updateCatalog(name, updateCatalog)); }",
        "type": "Method",
        "relationship": "The code implements a PATCH endpoint that matches the documented API specifications by accepting a catalog name and UpdateCatalog object as parameters, invoking the repository layer, and returning a JSON HTTP response containing the updated CatalogInfo.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.updateCatalog"
      },
      {
        "title": "CatalogInfoDAO",
        "location": "server/src/main/java/io/unitycatalog/server/persist/dao/CatalogInfoDAO.java",
        "content": "package io.unitycatalog.server.persist.dao; import io.unitycatalog.server.model.CatalogInfo; import jakarta.persistence.*; import java.time.Instant; import java.util.Date; import java.util.UUID; import lombok.*; import lombok.experimental.SuperBuilder; @Entity @Table(name = \"uc_catalogs\") // Lombok @Getter @Setter @AllArgsConstructor @NoArgsConstructor @SuperBuilder @EqualsAndHashCode(callSuper = true) public class CatalogInfoDAO extends IdentifiableDAO { @Column(name = \"comment\") private String comment; @Column(name = \"created_at\") private Date createdAt; @Column(name = \"updated_at\") private Date updatedAt; public static CatalogInfoDAO from(CatalogInfo catalogInfo) { return CatalogInfoDAO.builder() .id(catalogInfo.getId() != null ? UUID.fromString(catalogInfo.getId()) : null) .name(catalogInfo.getName()) .comment(catalogInfo.getComment()) .createdAt( catalogInfo.getCreatedAt() != null ? Date.from(Instant.ofEpochMilli(catalogInfo.getCreatedAt())) : new Date()) .updatedAt( catalogInfo.getUpdatedAt() != null ? Date.from(Instant.ofEpochMilli(catalogInfo.getUpdatedAt())) : null) .build(); } public CatalogInfo toCatalogInfo() { return new CatalogInfo() .id(getId().toString()) .name(getName()) .comment(comment) .createdAt(createdAt.getTime()) .updatedAt(updatedAt != null ? updatedAt.getTime() : null); } }",
        "type": "Class",
        "relationship": "The CatalogInfoDAO class supports the updateCatalog endpoint by providing the data persistence layer and mapping functions (from/toCatalogInfo) that convert between the API's CatalogInfo model and the database entity representation.",
        "traceability_granularity": "Class",
        "trace_chain": "CatalogsApi.md -> CatalogInfoDAO"
      },
      {
        "title": "CatalogRepository.updateCatalog",
        "location": "server/src/main/java/io/unitycatalog/server/persist/CatalogRepository.java",
        "content": "public CatalogInfo updateCatalog(String name, UpdateCatalog updateCatalog) { if (updateCatalog.getNewName() != null) { ValidationUtils.validateSqlObjectName(updateCatalog.getNewName()); } // can make this just update once we have an identifier that is not the name try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { CatalogInfoDAO catalogInfoDAO = getCatalogDAO(session, name); if (catalogInfoDAO == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Catalog not found: \" + name); } if (updateCatalog.getNewName() == null && updateCatalog.getComment() == null && (updateCatalog.getProperties() == null || updateCatalog.getProperties().isEmpty())) { tx.rollback(); CatalogInfo catalogInfo = catalogInfoDAO.toCatalogInfo(); return RepositoryUtils.attachProperties( catalogInfo, catalogInfo.getId(), Constants.CATALOG, session); } if (updateCatalog.getNewName() != null && getCatalogDAO(session, updateCatalog.getNewName()) != null) { throw new BaseException( ErrorCode.ALREADY_EXISTS, \"Catalog already exists: \" + updateCatalog.getNewName()); } if (updateCatalog.getNewName() != null) { catalogInfoDAO.setName(updateCatalog.getNewName()); } if (updateCatalog.getComment() != null) { catalogInfoDAO.setComment(updateCatalog.getComment()); } if (updateCatalog.getProperties() != null && !updateCatalog.getProperties().isEmpty()) { PropertyRepository.findProperties(session, catalogInfoDAO.getId(), Constants.CATALOG) .forEach(session::remove); session.flush(); PropertyDAO.from(updateCatalog.getProperties(), catalogInfoDAO.getId(), Constants.CATALOG) .forEach(session::persist); } catalogInfoDAO.setUpdatedAt(new Date()); session.merge(catalogInfoDAO); tx.commit(); CatalogInfo catalogInfo = catalogInfoDAO.toCatalogInfo(); return RepositoryUtils.attachProperties( catalogInfo, catalogInfo.getId(), Constants.CATALOG, session); } catch (Exception e) { tx.rollback(); throw e; } } }",
        "type": "Method",
        "relationship": "The code implements the documented API endpoint by validating the new catalog name, managing a database transaction to update the catalog's properties, name, and comment in a CatalogInfoDAO object, and handling error cases like NOT_FOUND and ALREADY_EXISTS as specified in the documentation's parameters and return type.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.updateCatalog -> CatalogRepository.updateCatalog"
      },
      {
        "title": "CatalogCli.updateCatalog",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/CatalogCli.java",
        "content": "private static String updateCatalog(CatalogsApi catalogsApi, JSONObject json) throws JsonProcessingException, ApiException { String catalogName = json.getString(NAME_PARAM); json.remove(NAME_PARAM); if (json.length() == 0) { List<CliParams> optionalParams = CliUtils.cliOptions.get(CliUtils.CATALOG).get(CliUtils.UPDATE).getOptionalParams(); String errorMessage = \"No parameters to update, please provide one of:\"; for (CliParams param : optionalParams) { errorMessage += \"\n --\" + param.val(); } throw new CliException(errorMessage); } UpdateCatalog updateCatalog = new UpdateCatalog() .newName(json.optString(CliParams.NEW_NAME.getServerParam(), null)) .comment(json.optString(CliParams.COMMENT.getServerParam(), null)) .properties(CliUtils.extractProperties(objectMapper, json)); CatalogInfo catalogInfo = catalogsApi.updateCatalog(catalogName, updateCatalog); return objectWriter.writeValueAsString(catalogInfo); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented updateCatalog endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogCli.updateCatalog"
      }
    ]
  },
  {
    "document": {
      "text": "# TemporaryVolumeCredentialsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**generateTemporaryVolumeCredentials**](TemporaryVolumeCredentialsApi.md#generateTemporaryVolumeCredentials) | **POST** /temporary-volume-credentials | Generate temporary volume credentials. |",
      "location": "api/Apis/TemporaryVolumeCredentialsApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "TemporaryVolumeCredentialsService.generateTemporaryVolumeCredentials",
        "location": "server/src/main/java/io/unitycatalog/server/service/TemporaryVolumeCredentialsService.java",
        "content": "@Post(\"\") public HttpResponse generateTemporaryVolumeCredentials( GenerateTemporaryVolumeCredential generateTemporaryVolumeCredential) { String volumeId = generateTemporaryVolumeCredential.getVolumeId(); if (volumeId.isEmpty()) { throw new BaseException(ErrorCode.INVALID_ARGUMENT, \"Volume ID is required.\"); } VolumeInfo volumeInfo = VOLUME_REPOSITORY.getVolumeById(volumeId); String volumePath = volumeInfo.getStorageLocation(); if (volumePath == null || volumePath.isEmpty()) { throw new BaseException(ErrorCode.FAILED_PRECONDITION, \"Volume storage location not found.\"); } if (volumePath.startsWith(\"s3://\")) { return HttpResponse.ofJson( new GenerateTemporaryVolumeCredentialResponse() .awsTempCredentials(TemporaryCredentialUtils.findS3BucketConfig(volumePath))); } else { // return empty credentials for local file system return HttpResponse.ofJson(new GenerateTemporaryVolumeCredential()); } } }",
        "type": "Method",
        "relationship": "The code implements the documented POST endpoint '/temporary-volume-credentials' by handling volume credential generation requests, validating the volume ID, and returning temporary AWS credentials for S3 volumes or empty credentials for local filesystems.",
        "traceability_granularity": "Method",
        "trace_chain": "TemporaryVolumeCredentialsApi.md -> TemporaryVolumeCredentialsService.generateTemporaryVolumeCredentials"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"generateTemporaryTableCredentials\"></a>\n# **generateTemporaryTableCredentials**\n> GenerateTemporaryTableCredentialResponse generateTemporaryTableCredentials(GenerateTemporaryTableCredential)\n\nGenerate temporary table credentials.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **GenerateTemporaryTableCredential** | [**GenerateTemporaryTableCredential**](../Models/GenerateTemporaryTableCredential.md)|  | [optional] |\n\n### Return type\n\n[**GenerateTemporaryTableCredentialResponse**](../Models/GenerateTemporaryTableCredentialResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json\n",
      "location": "api/Apis/TemporaryTableCredentialsApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "TemporaryTableCredentialsService.generateTemporaryTableCredentials",
        "location": "server/src/main/java/io/unitycatalog/server/service/TemporaryTableCredentialsService.java",
        "content": "@Post(\"\") public HttpResponse generateTemporaryTableCredential( GenerateTemporaryTableCredential generateTemporaryTableCredential) { String tableId = generateTemporaryTableCredential.getTableId(); // Check if table exists String tableStorageLocation = \"\"; TableInfo tableInfo = TABLE_REPOSITORY.getTableById(tableId); tableStorageLocation = tableInfo.getStorageLocation(); // Generate temporary credentials if (tableStorageLocation == null || tableStorageLocation.isEmpty()) { throw new BaseException(ErrorCode.FAILED_PRECONDITION, \"Table storage location not found.\"); } if (tableStorageLocation.startsWith(\"s3://\")) { return HttpResponse.ofJson( new GenerateTemporaryTableCredentialResponse() .awsTempCredentials( TemporaryCredentialUtils.findS3BucketConfig(tableStorageLocation))); } else { // return empty credentials for local file system return HttpResponse.ofJson(new GenerateTemporaryTableCredentialResponse()); } } }",
        "type": "Method",
        "relationship": "The code implements the documented API endpoint by checking if a table exists at a storage location, then either generating AWS S3 temporary credentials or returning empty credentials for local filesystems, matching the documented GenerateTemporaryTableCredentialResponse return type.",
        "traceability_granularity": "Method",
        "trace_chain": "TemporaryTableCredentialsApi.md -> TemporaryTableCredentialsService.generateTemporaryTableCredentials"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"generateTemporaryVolumeCredentials\"></a>\n# **generateTemporaryVolumeCredentials**\n> GenerateTemporaryVolumeCredentialResponse generateTemporaryVolumeCredentials(GenerateTemporaryVolumeCredential)\n\nGenerate temporary volume credentials.\n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **GenerateTemporaryVolumeCredential** | [**GenerateTemporaryVolumeCredential**](../Models/GenerateTemporaryVolumeCredential.md)|  | [optional] |\n\n### Return type\n\n[**GenerateTemporaryVolumeCredentialResponse**](../Models/GenerateTemporaryVolumeCredentialResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json\n",
      "location": "api/Apis/TemporaryVolumeCredentialsApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "TemporaryVolumeCredentialsService.generateTemporaryVolumeCredentials",
        "location": "server/src/main/java/io/unitycatalog/server/service/TemporaryVolumeCredentialsService.java",
        "content": "@Post(\"\") public HttpResponse generateTemporaryVolumeCredentials( GenerateTemporaryVolumeCredential generateTemporaryVolumeCredential) { String volumeId = generateTemporaryVolumeCredential.getVolumeId(); if (volumeId.isEmpty()) { throw new BaseException(ErrorCode.INVALID_ARGUMENT, \"Volume ID is required.\"); } VolumeInfo volumeInfo = VOLUME_REPOSITORY.getVolumeById(volumeId); String volumePath = volumeInfo.getStorageLocation(); if (volumePath == null || volumePath.isEmpty()) { throw new BaseException(ErrorCode.FAILED_PRECONDITION, \"Volume storage location not found.\"); } if (volumePath.startsWith(\"s3://\")) { return HttpResponse.ofJson( new GenerateTemporaryVolumeCredentialResponse() .awsTempCredentials(TemporaryCredentialUtils.findS3BucketConfig(volumePath))); } else { // return empty credentials for local file system return HttpResponse.ofJson(new GenerateTemporaryVolumeCredential()); } } }",
        "type": "Method",
        "relationship": "The code implements the documented API endpoint by validating the volume ID, retrieving storage location information, and returning temporary AWS S3 credentials for S3 volumes or empty credentials for local storage, while matching the specified request/response types and HTTP POST behavior.",
        "traceability_granularity": "Method",
        "trace_chain": "TemporaryVolumeCredentialsApi.md -> TemporaryVolumeCredentialsService.generateTemporaryVolumeCredentials"
      }
    ]
  },
  {
    "document": {
      "text": "# **listVolumes**\n> ListVolumesResponseContent listVolumes(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList Volumes\n\n    Gets an array of available volumes under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| The identifier of the catalog | [default to null] |\n| **schema\\_name** | **String**| The identifier of the schema | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of volumes to return (page length).  If not set, the page length is set to a server configured value. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  Note: this parameter controls only the maximum number of volumes to return. The actual number of volumes returned in a page may be smaller than this value, including 0, even if there are more pages.   | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token returned by a previous request. It must be included in the request to retrieve the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListVolumesResponseContent**](../Models/ListVolumesResponseContent.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
      "location": "api/Apis/VolumesApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "VolumeRepository.listVolumes",
        "location": "server/src/main/java/io/unitycatalog/server/persist/VolumeRepository.java",
        "content": "public ListVolumesResponseContent listVolumes( String catalogName, String schemaName, Optional<Integer> maxResults, Optional<String> pageToken, Optional<Boolean> includeBrowse) { try (Session session = SESSION_FACTORY.openSession()) { session.setDefaultReadOnly(true); Transaction tx = session.beginTransaction(); try { SchemaInfoDAO schemaInfo = SCHEMA_REPOSITORY.getSchemaDAO(session, catalogName, schemaName); if (schemaInfo == null) { throw new BaseException( ErrorCode.NOT_FOUND, \"Schema not found: \" + catalogName + \".\" + schemaName); } ListVolumesResponseContent responseContent = listVolumes( session, schemaInfo.getId(), catalogName, schemaName, maxResults, pageToken); tx.commit(); return responseContent; } catch (Exception e) { tx.rollback(); throw e; } } } public ListVolumesResponseContent listVolumes( Session session, UUID schemaId, String catalogName, String schemaName, Optional<Integer> maxResults, Optional<String> pageToken) { ListVolumesResponseContent responseContent = new ListVolumesResponseContent(); String queryString = \"from VolumeInfoDAO v where v.schemaId = :schemaId\"; Query<VolumeInfoDAO> query = session.createQuery(queryString, VolumeInfoDAO.class); query.setParameter(\"schemaId\", schemaId); maxResults.ifPresent(query::setMaxResults); if (pageToken.isPresent()) { // Perform pagination logic here if needed // Example: query.setFirstResult(startIndex); } responseContent.setVolumes( query.list().stream() .map(x -> convertFromDAO(x, catalogName, schemaName)) .collect(Collectors.toList())); return responseContent; }",
        "type": "Method",
        "relationship": "The code implements the documented listVolumes API by querying volumes from a database using Hibernate, enforcing the documented parameters (catalog_name, schema_name, max_results, page_token) and returning a ListVolumesResponseContent object containing the filtered volume list.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.listVolumes -> VolumeRepository.listVolumes"
      },
      {
        "title": "VolumeCli.listVolumes",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/VolumeCli.java",
        "content": "private static String listVolumes(VolumesApi volumesApi, JSONObject json) throws JsonProcessingException, ApiException { String catalogName = json.getString(CliParams.CATALOG_NAME.getServerParam()); String schemaName = json.getString(CliParams.SCHEMA_NAME.getServerParam()); int maxResults = 100; if (json.has(CliParams.MAX_RESULTS.getServerParam())) { maxResults = json.getInt(CliParams.MAX_RESULTS.getServerParam()); } return objectWriter.writeValueAsString( volumesApi.listVolumes(catalogName, schemaName, maxResults, null).getVolumes()); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented listVolumes endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeCli.listVolumes"
      },
      {
        "title": "VolumeService.listVolumes",
        "location": "server/src/main/java/io/unitycatalog/server/service/VolumeService.java",
        "content": "@Get(\"\") public HttpResponse listVolumes( @Param(\"catalog_name\") String catalogName, @Param(\"schema_name\") String schemaName, @Param(\"max_results\") Optional<Integer> maxResults, @Param(\"page_token\") Optional<String> pageToken, @Param(\"include_browse\") Optional<Boolean> includeBrowse) { return HttpResponse.ofJson( VOLUME_REPOSITORY.listVolumes( catalogName, schemaName, maxResults, pageToken, includeBrowse)); }",
        "type": "Method",
        "relationship": "The code implements the documented listVolumes API endpoint as a GET HTTP method that accepts the specified catalog_name, schema_name, max_results, and page_token parameters, though it includes an additional undocumented include_browse parameter, and returns a JSON response from the volume repository.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.listVolumes"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"listCatalogs\"></a>\n# **listCatalogs**\n> ListCatalogsResponse listCatalogs(page\\_token, max\\_results)\n\nList catalogs\n\n    Lists the available catalogs. There is no guarantee of a specific ordering of the elements in the list. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **page\\_token** | **String**| Opaque pagination token to go to next page based on previous query.  | [optional] [default to null] |\n| **max\\_results** | **Integer**| Maximum number of catalogs to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n\n### Return type\n\n[**ListCatalogsResponse**](../Models/ListCatalogsResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
      "location": "api/Apis/CatalogsApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "CatalogRepository.listCatalogs",
        "location": "server/src/main/java/io/unitycatalog/server/persist/CatalogRepository.java",
        "content": "public ListCatalogsResponse listCatalogs( Optional<Integer> maxResults, Optional<String> pageToken) { try (Session session = SESSION_FACTORY.openSession()) { session.setDefaultReadOnly(true); Transaction tx = session.beginTransaction(); try { ListCatalogsResponse response = listCatalogs(session, maxResults, pageToken); tx.commit(); return response; } catch (Exception e) { tx.rollback(); throw e; } } } public ListCatalogsResponse listCatalogs( Session session, Optional<Integer> maxResults, Optional<String> pageToken) { List<CatalogInfoDAO> catalogInfoDAOList = LISTING_HELPER.listEntity(session, maxResults, pageToken, null); String nextPageToken = LISTING_HELPER.getNextPageToken(catalogInfoDAOList, maxResults); List<CatalogInfo> result = new ArrayList<>(); for (CatalogInfoDAO catalogInfoDAO : catalogInfoDAOList) { CatalogInfo catalogInfo = catalogInfoDAO.toCatalogInfo(); RepositoryUtils.attachProperties( catalogInfo, catalogInfo.getId(), Constants.CATALOG, session); result.add(catalogInfo); } return new ListCatalogsResponse().catalogs(result).nextPageToken(nextPageToken); }",
        "type": "Method",
        "relationship": "The code implements the documented listCatalogs endpoint by using database transactions and pagination logic to retrieve catalog records from storage, transform them into CatalogInfo objects with attached properties, and return them in a ListCatalogsResponse with the next page token.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.listCatalogs -> CatalogRepository.listCatalogs"
      },
      {
        "title": "CatalogCli.listCatalogs",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/CatalogCli.java",
        "content": "private static String listCatalogs(CatalogsApi catalogsApi, JSONObject json) throws JsonProcessingException, ApiException { int maxResults = 100; if (json.has(CliParams.MAX_RESULTS.getServerParam())) { maxResults = json.getInt(CliParams.MAX_RESULTS.getServerParam()); } return objectWriter.writeValueAsString( catalogsApi.listCatalogs(null, maxResults).getCatalogs()); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented listCatalogs endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogCli.listCatalogs"
      },
      {
        "title": "CatalogService.listCatalogs",
        "location": "server/src/main/java/io/unitycatalog/server/service/CatalogService.java",
        "content": "@Get(\"\") public HttpResponse listCatalogs( @Param(\"max_results\") Optional<Integer> maxResults, @Param(\"page_token\") Optional<String> pageToken) { return HttpResponse.ofJson(CATALOG_REPOSITORY.listCatalogs(maxResults, pageToken)); }",
        "type": "Method",
        "relationship": "The code implements the documented REST endpoint by accepting optional maxResults and pageToken parameters, making a repository call, and returning a JSON response containing the list of catalogs in the format specified by ListCatalogsResponse.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.listCatalogs"
      }
    ]
  },
  {
    "document": {
      "text": "# TemporaryTableCredentialsApi\n\nAll URIs are relative to *http://localhost:8080/api/2.1/unity-catalog*\n\n| Method | HTTP request | Description |\n|------------- | ------------- | -------------|\n| [**generateTemporaryTableCredentials**](TemporaryTableCredentialsApi.md#generateTemporaryTableCredentials) | **POST** /temporary-table-credentials | Generate temporary table credentials. |",
      "location": "api/Apis/TemporaryTableCredentialsApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "TemporaryTableCredentialsService.generateTemporaryTableCredentials",
        "location": "server/src/main/java/io/unitycatalog/server/service/TemporaryTableCredentialsService.java",
        "content": "@Post(\"\") public HttpResponse generateTemporaryTableCredential( GenerateTemporaryTableCredential generateTemporaryTableCredential) { String tableId = generateTemporaryTableCredential.getTableId(); // Check if table exists String tableStorageLocation = \"\"; TableInfo tableInfo = TABLE_REPOSITORY.getTableById(tableId); tableStorageLocation = tableInfo.getStorageLocation(); // Generate temporary credentials if (tableStorageLocation == null || tableStorageLocation.isEmpty()) { throw new BaseException(ErrorCode.FAILED_PRECONDITION, \"Table storage location not found.\"); } if (tableStorageLocation.startsWith(\"s3://\")) { return HttpResponse.ofJson( new GenerateTemporaryTableCredentialResponse() .awsTempCredentials( TemporaryCredentialUtils.findS3BucketConfig(tableStorageLocation))); } else { // return empty credentials for local file system return HttpResponse.ofJson(new GenerateTemporaryTableCredentialResponse()); } } }",
        "type": "Method",
        "relationship": "The code implements the documented POST endpoint /temporary-table-credentials by validating the table location and returning AWS temporary credentials for S3 storage or empty credentials for local storage.",
        "traceability_granularity": "Method",
        "trace_chain": "TemporaryTableCredentialsApi.md -> TemporaryTableCredentialsService.generateTemporaryTableCredentials"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"listTables\"></a>\n# **listTables**\n> ListTablesResponse listTables(catalog\\_name, schema\\_name, max\\_results, page\\_token)\n\nList tables\n\n    Gets the list of all available tables under the parent catalog and schema. There is no guarantee of a specific ordering of the elements in the array. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **catalog\\_name** | **String**| Name of parent catalog for tables of interest. | [default to null] |\n| **schema\\_name** | **String**| Parent schema of tables. | [default to null] |\n| **max\\_results** | **Integer**| Maximum number of tables to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value; - when set to a value less than 0, an invalid parameter error is returned;  | [optional] [default to null] |\n| **page\\_token** | **String**| Opaque token to send for the next page of results (pagination). | [optional] [default to null] |\n\n### Return type\n\n[**ListTablesResponse**](../Models/ListTablesResponse.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
      "location": "api/Apis/TablesApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "TableRepository.listTables",
        "location": "server/src/main/java/io/unitycatalog/server/persist/TableRepository.java",
        "content": "public ListTablesResponse listTables( String catalogName, String schemaName, Optional<Integer> maxResults, Optional<String> pageToken, Boolean omitProperties, Boolean omitColumns) { try (Session session = SESSION_FACTORY.openSession()) { session.setDefaultReadOnly(true); Transaction tx = session.beginTransaction(); try { UUID schemaId = getSchemaId(session, catalogName, schemaName); ListTablesResponse response = listTables( session, schemaId, catalogName, schemaName, maxResults, pageToken, omitProperties, omitColumns); tx.commit(); return response; } catch (Exception e) { if (tx != null && tx.getStatus().canRollback()) { tx.rollback(); } throw e; } } } public ListTablesResponse listTables( Session session, UUID schemaId, String catalogName, String schemaName, Optional<Integer> maxResults, Optional<String> pageToken, Boolean omitProperties, Boolean omitColumns) { List<TableInfoDAO> tableInfoDAOList = LISTING_HELPER.listEntity(session, maxResults, pageToken, schemaId); String nextPageToken = LISTING_HELPER.getNextPageToken(tableInfoDAOList, maxResults); List<TableInfo> result = new ArrayList<>(); for (TableInfoDAO tableInfoDAO : tableInfoDAOList) { TableInfo tableInfo = tableInfoDAO.toTableInfo(!omitColumns); if (!omitProperties) { RepositoryUtils.attachProperties( tableInfo, tableInfo.getTableId(), Constants.TABLE, session); } tableInfo.setCatalogName(catalogName); tableInfo.setSchemaName(schemaName); result.add(tableInfo); } return new ListTablesResponse().tables(result).nextPageToken(nextPageToken); }",
        "type": "Method",
        "relationship": "The code implements the documented listTables endpoint by querying a database session for table records matching the given catalog and schema names, handling pagination through maxResults and pageToken parameters, and returning a ListTablesResponse object containing the table list and next page token.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableService.listTables -> TableRepository.listTables"
      },
      {
        "title": "TableService.listTables",
        "location": "server/src/main/java/io/unitycatalog/server/service/TableService.java",
        "content": "@Get(\"\") public HttpResponse listTables( @Param(\"catalog_name\") String catalogName, @Param(\"schema_name\") String schemaName, @Param(\"max_results\") Optional<Integer> maxResults, @Param(\"page_token\") Optional<String> pageToken, @Param(\"omit_properties\") Optional<Boolean> omitProperties, @Param(\"omit_columns\") Optional<Boolean> omitColumns) { return HttpResponse.ofJson( TABLE_REPOSITORY.listTables( catalogName, schemaName, maxResults, pageToken, omitProperties.orElse(false), omitColumns.orElse(false))); }",
        "type": "Method",
        "relationship": "The code implements the documented API endpoint by accepting the same catalog_name, schema_name, max_results, and page_token parameters, while also including two additional optional parameters (omit_properties and omit_columns) that are not mentioned in the documentation, then delegates the actual table listing to TABLE_REPOSITORY and returns the result as a JSON HTTP response.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableService.listTables"
      },
      {
        "title": "TableCli.listTables",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/TableCli.java",
        "content": "private static String listTables(TablesApi tablesApi, JSONObject json) throws JsonProcessingException, ApiException { int maxResults = 100; if (json.has(CliParams.MAX_RESULTS.getServerParam())) { maxResults = json.getInt(CliParams.MAX_RESULTS.getServerParam()); } return objectWriter.writeValueAsString( tablesApi .listTables( json.getString(CliParams.CATALOG_NAME.getServerParam()), json.getString(CliParams.SCHEMA_NAME.getServerParam()), maxResults, null) .getTables()); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented listTables endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableCli.listTables"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"deleteCatalog\"></a>\n# **deleteCatalog**\n> oas_any_type_not_mapped deleteCatalog(name, force)\n\nDelete a catalog\n\n    Deletes the catalog that matches the supplied name. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The name of the catalog. | [default to null] |\n| **force** | **Boolean**| Force deletion even if the catalog is not empty. | [optional] [default to null] |\n\n### Return type\n\n[**oas_any_type_not_mapped**](../Models/AnyType.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
      "location": "api/Apis/CatalogsApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "CatalogService.deleteCatalog",
        "location": "server/src/main/java/io/unitycatalog/server/service/CatalogService.java",
        "content": "@Delete(\"/{name}\") public HttpResponse deleteCatalog( @Param(\"name\") String name, @Param(\"force\") Optional<Boolean> force) { CATALOG_REPOSITORY.deleteCatalog(name, force.orElse(false)); return HttpResponse.of(HttpStatus.OK); } }",
        "type": "Method",
        "relationship": "The code implements a DELETE endpoint that directly mirrors the documented API behavior by accepting a required 'name' parameter and optional 'force' parameter, invoking the catalog repository's deletion logic, and returning an HTTP 200 OK response.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.deleteCatalog"
      },
      {
        "title": "CatalogRepository.deleteCatalog",
        "location": "server/src/main/java/io/unitycatalog/server/persist/CatalogRepository.java",
        "content": "public void deleteCatalog(String name, boolean force) { try (Session session = SESSION_FACTORY.openSession()) { Transaction tx = session.beginTransaction(); try { CatalogInfoDAO catalogInfo = getCatalogDAO(session, name); if (catalogInfo != null) { // Check if there are any schemas in the catalog List<SchemaInfo> schemas = SCHEMA_REPOSITORY .listSchemas( session, catalogInfo.getId(), catalogInfo.getName(), Optional.of(1), Optional.empty()) .getSchemas(); if (schemas != null && !schemas.isEmpty()) { if (!force) { throw new BaseException( ErrorCode.FAILED_PRECONDITION, \"Cannot delete catalog with schemas: \" + name); } String nextToken = null; do { ListSchemasResponse listSchemasResponse = SCHEMA_REPOSITORY.listSchemas( session, catalogInfo.getId(), catalogInfo.getName(), Optional.empty(), Optional.ofNullable(nextToken)); for (SchemaInfo schemaInfo : listSchemasResponse.getSchemas()) { SCHEMA_REPOSITORY.deleteSchema( session, catalogInfo.getId(), catalogInfo.getName(), schemaInfo.getName(), true); } nextToken = listSchemasResponse.getNextPageToken(); } while (nextToken != null); } PropertyRepository.findProperties(session, catalogInfo.getId(), Constants.CATALOG) .forEach(session::remove); session.remove(catalogInfo); tx.commit(); LOGGER.info(\"Deleted catalog: {}\", catalogInfo.getName()); } else { throw new BaseException(ErrorCode.NOT_FOUND, \"Catalog not found: \" + name); } } catch (Exception e) { tx.rollback(); throw e; } } } }",
        "type": "Method",
        "relationship": "The code implements the documented deleteCatalog operation by handling catalog deletion with optional force removal of schemas, throwing appropriate exceptions if the catalog is not found (ErrorCode.NOT_FOUND) or contains schemas without force flag (ErrorCode.FAILED_PRECONDITION), and managing the transaction across catalog, schema, and property deletions.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogService.deleteCatalog -> CatalogRepository.deleteCatalog"
      },
      {
        "title": "CatalogCli.deleteCatalog",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/CatalogCli.java",
        "content": "private static String deleteCatalog(CatalogsApi catalogsApi, JSONObject json) throws ApiException { String catalogName = json.getString(NAME_PARAM); catalogsApi.deleteCatalog( catalogName, json.has(CliParams.FORCE.getServerParam()) && Boolean.parseBoolean(json.getString(CliParams.FORCE.getServerParam()))); return CliUtils.EMPTY_JSON; } }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented deleteCatalog endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "CatalogsApi.md -> CatalogCli.deleteCatalog"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"createTable\"></a>\n# **createTable**\n> TableInfo createTable(CreateTable)\n\nCreate a table. WARNING: This API is experimental and will change in future versions. \n\n    Creates a new table instance. WARNING: This API is experimental and will change in future versions. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **CreateTable** | [**CreateTable**](../Models/CreateTable.md)|  | [optional] |\n\n### Return type\n\n[**TableInfo**](../Models/TableInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: application/json\n- **Accept**: application/json",
      "location": "api/Apis/TablesApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "TableInfoDAO",
        "location": "server/src/main/java/io/unitycatalog/server/persist/dao/TableInfoDAO.java",
        "content": "package io.unitycatalog.server.persist.dao; import io.unitycatalog.server.model.DataSourceFormat; import io.unitycatalog.server.model.TableInfo; import io.unitycatalog.server.model.TableType; import io.unitycatalog.server.persist.utils.FileUtils; import jakarta.persistence.*; import java.util.Date; import java.util.List; import java.util.UUID; import lombok.*; import lombok.experimental.SuperBuilder; // Hibernate annotations @Entity @Table( name = \"uc_tables\", indexes = { @Index(name = \"idx_name\", columnList = \"name\"), }) // Lombok annotations @Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(callSuper = true) @SuperBuilder public class TableInfoDAO extends IdentifiableDAO { @Column(name = \"schema_id\") private UUID schemaId; @Column(name = \"type\") private String type; @Column(name = \"created_at\") private Date createdAt; @Column(name = \"updated_at\") private Date updatedAt; @Column(name = \"data_source_format\") private String dataSourceFormat; @Column(name = \"comment\", length = 65535) private String comment; @Column(name = \"url\", length = 2048) private String url; @Column(name = \"column_count\") private Integer columnCount; @OneToMany( mappedBy = \"table\", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY) private List<ColumnInfoDAO> columns; @Column(name = \"uniform_iceberg_metadata_location\", length = 65535) private String uniformIcebergMetadataLocation; public static TableInfoDAO from(TableInfo tableInfo) { return TableInfoDAO.builder() .id(UUID.fromString(tableInfo.getTableId())) .name(tableInfo.getName()) .comment(tableInfo.getComment()) .createdAt( tableInfo.getCreatedAt() != null ? new Date(tableInfo.getCreatedAt()) : new Date()) .updatedAt(tableInfo.getUpdatedAt() != null ? new Date(tableInfo.getUpdatedAt()) : null) .columnCount(tableInfo.getColumns() != null ? tableInfo.getColumns().size() : 0) .url(tableInfo.getStorageLocation() != null ? tableInfo.getStorageLocation() : null) .type(tableInfo.getTableType().toString()) .dataSourceFormat(tableInfo.getDataSourceFormat().toString()) .url(tableInfo.getStorageLocation()) .columns(ColumnInfoDAO.fromList(tableInfo.getColumns())) .build(); } public TableInfo toTableInfo(boolean fetchColumns) { TableInfo tableInfo = new TableInfo() .tableId(getId().toString()) .name(getName()) .tableType(TableType.valueOf(type)) .dataSourceFormat(DataSourceFormat.valueOf(dataSourceFormat)) .storageLocation(FileUtils.convertRelativePathToURI(url)) .comment(comment) .createdAt(createdAt != null ? createdAt.getTime() : null) .updatedAt(updatedAt != null ? updatedAt.getTime() : null); if (fetchColumns) { tableInfo.columns(ColumnInfoDAO.toList(columns)); } return tableInfo; } }",
        "type": "Class",
        "relationship": "The TableInfoDAO class provides the persistence layer mapping and conversion logic for the TableInfo objects returned by the documented createTable API endpoint, handling the storage and retrieval of table metadata in the 'uc_tables' database table.",
        "traceability_granularity": "Class",
        "trace_chain": "TablesApi.md -> TableInfoDAO"
      },
      {
        "title": "TableCli.createTable",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/TableCli.java",
        "content": "private static String createTable(TablesApi apiClient, JSONObject json) throws JsonProcessingException, ApiException { CliUtils.resolveFullNameToThreeLevelNamespace(json); try { json.putOnce(CliParams.TABLE_TYPE.getServerParam(), TableType.EXTERNAL.name()); } catch (JSONException e) { // ignore (table type already set) } try { json.putOnce(CliParams.DATA_SOURCE_FORMAT.getServerParam(), DataSourceFormat.DELTA.name()); } catch (JSONException e) { // ignore (data source format already set) } String format = json.getString(CliParams.DATA_SOURCE_FORMAT.getServerParam()); // Set fields in json object for seamless deserialization List<ColumnInfo> columnInfoList = CliUtils.parseColumns(json.getString(CliParams.COLUMNS.getServerParam())); CreateTable createTable = new CreateTable() .name(json.getString(CliParams.NAME.getServerParam())) .catalogName(json.getString(CliParams.CATALOG_NAME.getServerParam())) .schemaName(json.getString(CliParams.SCHEMA_NAME.getServerParam())) .columns(columnInfoList) .properties(CliUtils.extractProperties(objectMapper, json)) .tableType( TableType.valueOf( json.getString(CliParams.TABLE_TYPE.getServerParam()).toUpperCase())) .dataSourceFormat(DataSourceFormat.valueOf(format.toUpperCase())); if (createTable.getTableType() == TableType.EXTERNAL) { createTable.storageLocation(json.getString(CliParams.STORAGE_LOCATION.getServerParam())); handleTableStorageLocation(createTable.getStorageLocation(), columnInfoList); } TableInfo tableInfo = apiClient.createTable(createTable); return objectWriter.writeValueAsString(tableInfo); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented createTable endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableCli.createTable"
      },
      {
        "title": "TableService.createTable",
        "location": "server/src/main/java/io/unitycatalog/server/service/TableService.java",
        "content": "@Post(\"\") public HttpResponse createTable(CreateTable createTable) { assert createTable != null; TableInfo createTableResponse = TABLE_REPOSITORY.createTable(createTable); return HttpResponse.ofJson(createTableResponse); }",
        "type": "Method",
        "relationship": "The code implements the documented POST endpoint by accepting a CreateTable request object, validating it's not null, delegating to the TABLE_REPOSITORY to create the table, and returning a TableInfo response wrapped in an HTTP JSON response, matching the documented input/output types and content types.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableService.createTable"
      },
      {
        "title": "TableRepository.createTable",
        "location": "server/src/main/java/io/unitycatalog/server/persist/TableRepository.java",
        "content": "public TableInfo createTable(CreateTable createTable) { ValidationUtils.validateSqlObjectName(createTable.getName()); List<ColumnInfo> columnInfos = createTable.getColumns().stream() .map(c -> c.typeText(c.getTypeText().toLowerCase(Locale.ROOT))) .collect(Collectors.toList()); TableInfo tableInfo = new TableInfo() .tableId(UUID.randomUUID().toString()) .name(createTable.getName()) .catalogName(createTable.getCatalogName()) .schemaName(createTable.getSchemaName()) .tableType(createTable.getTableType()) .dataSourceFormat(createTable.getDataSourceFormat()) .columns(columnInfos) .storageLocation(FileUtils.convertRelativePathToURI(createTable.getStorageLocation())) .comment(createTable.getComment()) .properties(createTable.getProperties()) .createdAt(System.currentTimeMillis()); String fullName = getTableFullName(tableInfo); LOGGER.debug(\"Creating table: \" + fullName); Transaction tx; try (Session session = SESSION_FACTORY.openSession()) { String catalogName = tableInfo.getCatalogName(); String schemaName = tableInfo.getSchemaName(); UUID schemaId = getSchemaId(session, catalogName, schemaName); tx = session.beginTransaction(); try { // Check if table already exists TableInfoDAO existingTable = findBySchemaIdAndName(session, schemaId, tableInfo.getName()); if (existingTable != null) { throw new BaseException(ErrorCode.ALREADY_EXISTS, \"Table already exists: \" + fullName); } if (TableType.MANAGED.equals(tableInfo.getTableType())) { throw new BaseException( ErrorCode.INVALID_ARGUMENT, \"MANAGED table creation is not supported yet.\"); } // assuming external table if (tableInfo.getStorageLocation() == null) { throw new BaseException( ErrorCode.INVALID_ARGUMENT, \"Storage location is required for external table\"); } TableInfoDAO tableInfoDAO = TableInfoDAO.from(tableInfo); tableInfoDAO.setSchemaId(schemaId); // create columns tableInfoDAO .getColumns() .forEach( c -> { c.setId(UUID.randomUUID()); c.setTable(tableInfoDAO); }); // create properties PropertyDAO.from(tableInfo.getProperties(), tableInfoDAO.getId(), Constants.TABLE) .forEach(session::persist); session.persist(tableInfoDAO); tx.commit(); } catch (RuntimeException e) { if (tx != null && tx.getStatus().canRollback()) { tx.rollback(); } throw e; } } catch (RuntimeException e) { if (e instanceof BaseException) { throw e; } throw new BaseException( ErrorCode.INTERNAL, \"Error creating table: \" + fullName + \". \" + e.getMessage(), e); } return tableInfo; }",
        "type": "Method",
        "relationship": "The code implements the documented createTable API by validating the table name, creating a new TableInfo object with the specified properties, checking for existing tables, rejecting MANAGED table types, requiring storage locations for external tables, and persisting the table data in a database transaction while handling errors as specified in the API documentation.",
        "traceability_granularity": "Method",
        "trace_chain": "TablesApi.md -> TableService.createTable -> TableRepository.createTable"
      }
    ]
  },
  {
    "document": {
      "text": "# **getVolume**\n> VolumeInfo getVolume(name)\n\nGet a Volume\n\n    Gets a volume for a specific catalog and schema. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **name** | **String**| The three-level (fully qualified) name of the volume | [default to null] |\n\n### Return type\n\n[**VolumeInfo**](../Models/VolumeInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
      "location": "api/Apis/VolumesApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "VolumeService.getVolume",
        "location": "server/src/main/java/io/unitycatalog/server/service/VolumeService.java",
        "content": "@Get(\"/{full_name}\") public HttpResponse getVolume( @Param(\"full_name\") String fullName, @Param(\"include_browse\") Optional<Boolean> includeBrowse) { return HttpResponse.ofJson(VOLUME_REPOSITORY.getVolume(fullName)); }",
        "type": "Method",
        "relationship": "The code implements the documented GET endpoint by accepting a required 'full_name' path parameter and an optional 'include_browse' query parameter, returning a JSON response containing volume information from the repository, though the documentation doesn't mention the optional parameter.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.getVolume"
      },
      {
        "title": "VolumeRepository.getVolume",
        "location": "server/src/main/java/io/unitycatalog/server/persist/VolumeRepository.java",
        "content": "public VolumeInfo getVolume(String fullName) { try (Session session = SESSION_FACTORY.openSession()) { String[] namespace = fullName.split(\"\\.\"); if (namespace.length != 3) { throw new BaseException(ErrorCode.INVALID_ARGUMENT, \"Invalid volume name: \" + fullName); } String catalogName = namespace[0]; String schemaName = namespace[1]; String volumeName = namespace[2]; return convertFromDAO( getVolumeDAO(session, catalogName, schemaName, volumeName), catalogName, schemaName); } catch (Exception e) { LOGGER.error(\"Error getting volume\", e); return null; } }",
        "type": "Method",
        "relationship": "The code implements the documented getVolume operation by splitting a three-level name parameter into catalog, schema, and volume components, validating the format, and returning a VolumeInfo object retrieved from the database through a DAO pattern.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeService.getVolume -> VolumeRepository.getVolume"
      },
      {
        "title": "VolumeInfoDAO",
        "location": "server/src/main/java/io/unitycatalog/server/persist/dao/VolumeInfoDAO.java",
        "content": "package io.unitycatalog.server.persist.dao; import io.unitycatalog.server.model.VolumeInfo; import io.unitycatalog.server.model.VolumeType; import io.unitycatalog.server.persist.utils.FileUtils; import jakarta.persistence.Column; import jakarta.persistence.Entity; import jakarta.persistence.Table; import java.util.Date; import java.util.UUID; import lombok.*; import lombok.experimental.SuperBuilder; @Entity @Table(name = \"uc_volumes\") // lombok annotations @Getter @Setter @NoArgsConstructor @AllArgsConstructor @SuperBuilder @EqualsAndHashCode(callSuper = true) public class VolumeInfoDAO extends IdentifiableDAO { @Column(name = \"schema_id\") private UUID schemaId; @Column(name = \"comment\") private String comment; @Column(name = \"storage_location\") private String storageLocation; @Column(name = \"created_at\") private Date createdAt; @Column(name = \"updated_at\") private Date updatedAt; @Column(name = \"volume_type\") private String volumeType; public VolumeInfo toVolumeInfo() { return new VolumeInfo() .volumeId(getId().toString()) .name(getName()) .comment(comment) .storageLocation(FileUtils.convertRelativePathToURI(storageLocation)) .createdAt(createdAt.getTime()) .updatedAt(updatedAt.getTime()) .volumeType(VolumeType.valueOf(volumeType)); } public static VolumeInfoDAO from(VolumeInfo volumeInfo) { if (volumeInfo == null) { return null; } return VolumeInfoDAO.builder() .id(UUID.fromString(volumeInfo.getVolumeId())) .name(volumeInfo.getName()) .comment(volumeInfo.getComment()) .storageLocation(volumeInfo.getStorageLocation()) .createdAt( volumeInfo.getCreatedAt() != null ? new Date(volumeInfo.getCreatedAt()) : new Date()) .updatedAt( volumeInfo.getUpdatedAt() != null ? new Date(volumeInfo.getUpdatedAt()) : new Date()) .volumeType(volumeInfo.getVolumeType().getValue()) .build(); } }",
        "type": "Class",
        "relationship": "The VolumeInfoDAO class provides the data persistence layer and model conversion methods (toVolumeInfo/from) needed to support the documented getVolume API endpoint by mapping between the database representation and the VolumeInfo response type.",
        "traceability_granularity": "Class",
        "trace_chain": "VolumesApi.md -> VolumeInfoDAO"
      },
      {
        "title": "VolumeCli.getVolume",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/VolumeCli.java",
        "content": "private static String getVolume(VolumesApi volumesApi, JSONObject json) throws JsonProcessingException, ApiException { String volumeFullName = json.getString(CliParams.FULL_NAME.getServerParam()); return objectWriter.writeValueAsString(volumesApi.getVolume(volumeFullName)); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented getVolume endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "VolumesApi.md -> VolumeCli.getVolume"
      }
    ]
  },
  {
    "document": {
      "text": "<a name=\"getSchema\"></a>\n# **getSchema**\n> SchemaInfo getSchema(full\\_name)\n\nGet a schema\n\n    Gets the specified schema for a catalog. \n\n### Parameters\n\n|Name | Type | Description  | Notes |\n|------------- | ------------- | ------------- | -------------|\n| **full\\_name** | **String**| Full name of the schema. | [default to null] |\n\n### Return type\n\n[**SchemaInfo**](../Models/SchemaInfo.md)\n\n### Authorization\n\nNo authorization required\n\n### HTTP request headers\n\n- **Content-Type**: Not defined\n- **Accept**: application/json",
      "location": "api/Apis/SchemasApi.md",
      "type": ""
    },
    "artifacts": [
      {
        "title": "SchemaCli.getSchema",
        "location": "examples/cli/src/main/java/io/unitycatalog/cli/SchemaCli.java",
        "content": "private static String getSchema(SchemasApi schemasApi, JSONObject json) throws JsonProcessingException, ApiException { String schemaFullName = json.getString(CliParams.FULL_NAME.getServerParam()); return objectWriter.writeValueAsString(schemasApi.getSchema(schemaFullName)); }",
        "type": "Method",
        "relationship": "The code implements a CLI wrapper for the documented getSchema endpoint.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaCli.getSchema"
      },
      {
        "title": "SchemaInfoDAO",
        "location": "server/src/main/java/io/unitycatalog/server/persist/dao/SchemaInfoDAO.java",
        "content": "package io.unitycatalog.server.persist.dao; import io.unitycatalog.server.model.SchemaInfo; import jakarta.persistence.*; import java.time.Instant; import java.util.Date; import java.util.UUID; import lombok.*; import lombok.experimental.SuperBuilder; @Entity @Table(name = \"uc_schemas\") // Lombok @Getter @Setter @SuperBuilder @AllArgsConstructor @NoArgsConstructor @EqualsAndHashCode(callSuper = true) public class SchemaInfoDAO extends IdentifiableDAO { @Column(name = \"catalog_id\") private UUID catalogId; @Column(name = \"comment\") private String comment; @Column(name = \"created_at\") private Date createdAt; @Column(name = \"updated_at\") private Date updatedAt; public static SchemaInfoDAO from(SchemaInfo schemaInfo) { return SchemaInfoDAO.builder() .id(schemaInfo.getSchemaId() != null ? UUID.fromString(schemaInfo.getSchemaId()) : null) .name(schemaInfo.getName()) .comment(schemaInfo.getComment()) .createdAt( schemaInfo.getCreatedAt() != null ? Date.from(Instant.ofEpochMilli(schemaInfo.getCreatedAt())) : new Date()) .updatedAt( schemaInfo.getUpdatedAt() != null ? Date.from(Instant.ofEpochMilli(schemaInfo.getUpdatedAt())) : null) .build(); } public SchemaInfo toSchemaInfo() { return new SchemaInfo() .schemaId(getId().toString()) .name(getName()) .comment(getComment()) .createdAt(getCreatedAt().getTime()) .updatedAt(getUpdatedAt() != null ? getUpdatedAt().getTime() : null); } }",
        "type": "Class",
        "relationship": "The SchemaInfoDAO class provides the data persistence and transformation layer for the SchemaInfo object that is returned by the documented getSchema endpoint, handling the mapping between database records and the API response model.",
        "traceability_granularity": "Class",
        "trace_chain": "SchemasApi.md -> SchemaInfoDAO"
      },
      {
        "title": "SchemaService.getSchema",
        "location": "server/src/main/java/io/unitycatalog/server/service/SchemaService.java",
        "content": "@Get(\"/{full_name}\") public HttpResponse getSchema(@Param(\"full_name\") String fullName) { return HttpResponse.ofJson(SCHEMA_REPOSITORY.getSchema(fullName)); }",
        "type": "Method",
        "relationship": "The code implements the documented GET endpoint with path parameter 'full_name' by returning a JSON HTTP response containing schema information retrieved from SCHEMA_REPOSITORY.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.getSchema"
      },
      {
        "title": "SchemaRepository.getSchema",
        "location": "server/src/main/java/io/unitycatalog/server/persist/SchemaRepository.java",
        "content": "public SchemaInfo getSchema(String fullName) { try (Session session = SESSION_FACTORY.openSession()) { session.setDefaultReadOnly(true); Transaction tx = session.beginTransaction(); SchemaInfoDAO schemaInfoDAO; try { schemaInfoDAO = getSchemaDAO(session, fullName); if (schemaInfoDAO == null) { throw new BaseException(ErrorCode.NOT_FOUND, \"Schema not found: \" + fullName); } tx.commit(); SchemaInfo schemaInfo = convertFromDAO(session, schemaInfoDAO, fullName); return RepositoryUtils.attachProperties( schemaInfo, schemaInfo.getSchemaId(), Constants.SCHEMA, session); } catch (Exception e) { tx.rollback(); throw e; } } }",
        "type": "Method",
        "relationship": "The code implements the documented getSchema operation by retrieving a schema from a database session, converting it from DAO format to SchemaInfo, and attaching properties, while handling the specified error case for when the schema is not found.",
        "traceability_granularity": "Method",
        "trace_chain": "SchemasApi.md -> SchemaService.getSchema -> SchemaRepository.getSchema"
      }
    ]
  }
]